<!DOCTYPE html>
<meta charset="ascii">
<link rel="icon" href="img/favicon.ico">
<link href="ecmarkup.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="ecmarkup.js"></script>
<style>
  /* custom styles */
  @media print {
    /* for the PDF */
    body.oldtoc {
      font-size: 80%;
    }
    .oldtoc var {
      color: #197124;
    }
  }
  #metadata-block {
    margin: 4em 0;
    padding: 10px;
    border: 1px solid #ee8421;
  }

  #metadata-block h1 {
    font-size: 1.5em;
    margin-top: 0;
  }
  #metadata-block > ul {
    list-style-type: none;
    margin: 0; padding: 0;
  }
  #ecma-logo {
    width: 500px;
  }
  .unicode-property-table {
    table-layout: fixed;
    width: 100%;
    font-size: 80%;
  }
  .unicode-property-table ul {
    padding-left: 0;
    list-style: none;
  }
</style>
<script>
  if (location.hostname === 'tc39.github.io' && location.protocol !== 'https:') {
    location.protocol = 'https:';
  }
</script>
<pre class=metadata>
  title: ECMAScript&reg; 2020 Language&nbsp;Specification
  shortname: ECMA-262
  status: draft
  location: https://tc39.github.io/ecma262/
</pre>
<p><img src="img/ecma-logo.svg" id=ecma-logo></p>
<div id=metadata-block>
  <h1>Contributing to this Specification</h1>
  <p>This specification is developed on GitHub with the help of the ECMAScript community. There are a number of ways to contribute to the development of this specification:</p>
  <ul>
    <li>GitHub Repository: <a href="https://github.com/tc39/ecma262">https://github.com/tc39/ecma262</a></li>
    <li>Issues: <a href="https://github.com/tc39/ecma262/issues">All Issues</a>, <a href="https://github.com/tc39/ecma262/issues/new">File a New Issue</a></li>
    <li>Pull Requests: <a href="https://github.com/tc39/ecma262/pulls">All Pull Requests</a>, <a href="https://github.com/tc39/ecma262/pulls/new">Create a New Pull Request</a></li>
    <li>Test Suite: <a href="https://github.com/tc39/test262">Test262</a></li>
    <li>Editors:
      <ul>
        <li><a href="mailto:brian.terlson at microsoft dot com">Brian Terlson</a> (<a href="https://twitter.com/bterlson">@bterlson</a>)</li>
        <li><a href="mailto:bradley.meck at gmail dot com">Bradley Farias</a> (<a href="https://twitter.com/bradleymeck">@bradleymeck</a>)</li>
        <li><a href="mailto:ljharb at gmail dot com">Jordan Harband</a> (<a href="https://twitter.com/ljharb">@ljharb</a>)</li>
      </ul>
    </li>
    <li>
      <p>Community:</p>
      <ul>
        <li>Discourse: <a href="https://es.discourse.group">https://es.discourse.group</a></li>
        <li>IRC: <a href="ircs://irc.freenode.net:6667">#tc39</a> on <a href="https://freenode.net/kb/answer/chat">freenode</a></li>
        <li>Mailing List Archives: <a href="https://esdiscuss.org">https://esdiscuss.org/</a></li>
      </ul>
    </li>
  </ul>
  <p>Refer to the <emu-xref href="#sec-colophon">colophon</emu-xref> for more information on how this document is created.</p>
</div>
<emu-intro id="sec-intro">
  <h1>Introduction</h1>
  <p>This Ecma Standard defines the ECMAScript 2020 Language. It is the tenth edition of the ECMAScript Language Specification. Since publication of the first edition in 1997, ECMAScript has grown to be one of the world's most widely used general-purpose programming languages. It is best known as the language embedded in web browsers but has also been widely adopted for server and embedded applications.</p>
  <p>ECMAScript is based on several originating technologies, the most well-known being JavaScript (Netscape) and JScript (Microsoft). The language was invented by Brendan Eich at Netscape and first appeared in that company's Navigator 2.0 browser. It has appeared in all subsequent browsers from Netscape and in all browsers from Microsoft starting with Internet Explorer 3.0.</p>
  <p>The development of the ECMAScript Language Specification started in November 1996. The first edition of this Ecma Standard was adopted by the Ecma General Assembly of June 1997.</p>
  <p>That Ecma Standard was submitted to ISO/IEC JTC 1 for adoption under the fast-track procedure, and approved as international standard ISO/IEC 16262, in April 1998. The Ecma General Assembly of June 1998 approved the second edition of ECMA-262 to keep it fully aligned with ISO/IEC 16262. Changes between the first and the second edition are editorial in nature.</p>
  <p>The third edition of the Standard introduced powerful regular expressions, better string handling, new control statements, try/catch exception handling, tighter definition of errors, formatting for numeric output and minor changes in anticipation of future language growth. The third edition of the ECMAScript standard was adopted by the Ecma General Assembly of December 1999 and published as ISO/IEC 16262:2002 in June 2002.</p>
  <p>After publication of the third edition, ECMAScript achieved massive adoption in conjunction with the World Wide Web where it has become the programming language that is supported by essentially all web browsers. Significant work was done to develop a fourth edition of ECMAScript. However, that work was not completed and not published as the fourth edition of ECMAScript but some of it was incorporated into the development of the sixth edition.</p>
  <p>The fifth edition of ECMAScript (published as ECMA-262 5<sup>th</sup> edition) codified de facto interpretations of the language specification that have become common among browser implementations and added support for new features that had emerged since the publication of the third edition. Such features include accessor properties, reflective creation and inspection of objects, program control of property attributes, additional array manipulation functions, support for the JSON object encoding format, and a strict mode that provides enhanced error checking and program security. The fifth edition was adopted by the Ecma General Assembly of December 2009.</p>
  <p>The fifth edition was submitted to ISO/IEC JTC 1 for adoption under the fast-track procedure, and approved as international standard ISO/IEC 16262:2011. Edition 5.1 of the ECMAScript Standard incorporated minor corrections and is the same text as ISO/IEC 16262:2011. The 5.1 Edition was adopted by the Ecma General Assembly of June 2011.</p>
  <p>Focused development of the sixth edition started in 2009, as the fifth edition was being prepared for publication. However, this was preceded by significant experimentation and language enhancement design efforts dating to the publication of the third edition in 1999. In a very real sense, the completion of the sixth edition is the culmination of a fifteen year effort. The goals for this edition included providing better support for large applications, library creation, and for use of ECMAScript as a compilation target for other languages. Some of its major enhancements included modules, class declarations, lexical block scoping, iterators and generators, promises for asynchronous programming, destructuring patterns, and proper tail calls. The ECMAScript library of built-ins was expanded to support additional data abstractions including maps, sets, and arrays of binary numeric values as well as additional support for Unicode supplemental characters in strings and regular expressions. The built-ins were also made extensible via subclassing. The sixth edition provides the foundation for regular, incremental language and library enhancements. The sixth edition was adopted by the General Assembly of June 2015.</p>
  <p>ECMAScript 2016 was the first ECMAScript edition released under Ecma TC39's new yearly release cadence and open development process. A plain-text source document was built from the ECMAScript 2015 source document to serve as the base for further development entirely on GitHub. Over the year of this standard's development, hundreds of pull requests and issues were filed representing thousands of bug fixes, editorial fixes and other improvements. Additionally, numerous software tools were developed to aid in this effort including Ecmarkup, Ecmarkdown, and Grammarkdown. ES2016 also included support for a new exponentiation operator and adds a new method to Array.prototype called `includes`.</p>
  <p>ECMAScript 2017 introduced Async Functions, Shared Memory, and Atomics along with smaller language and library enhancements, bug fixes, and editorial updates. Async functions improve the asynchronous programming experience by providing syntax for promise-returning functions. Shared Memory and Atomics introduce a new memory model that allows multi-agent programs to communicate using atomic operations that ensure a well-defined execution order even on parallel CPUs. This specification also includes new static methods on Object: `Object.values`, `Object.entries`, and `Object.getOwnPropertyDescriptors`.</p>
  <p>ECMAScript 2018 introduced support for asynchronous iteration via the AsyncIterator protocol and async generators. It also included four new regular expression features: the dotAll flag, named capture groups, Unicode property escapes, and look-behind assertions. Lastly it included rest parameter and spread operator support for object properties.</p>
  <p>This specification, the 10<sup>th</sup> edition, introduces a few new built-in functions: `flat` and `flatMap` on `Array.prototype` for flattening arrays, `Object.fromEntries` for directly turning the return value of `Object.entries` into a new Object, and `trimStart` and `trimEnd` on `String.prototype` as better-named alternatives to the widely implemented but non-standard `String.prototype.trimLeft` and `trimRight` built-ins. In addition, this specification includes a few minor updates to syntax and semantics. Updated syntax includes optional catch binding parameters and allowing U+2028 (LINE SEPARATOR) and U+2029 (PARAGRAPH SEPARATOR) in string literals to align with JSON. Other updates include requiring that `Array.prototype.sort` be a stable sort, requiring that JSON.stringify return well-formed UTF-8 regardless of input, and clarifying `Function.prototype.toString` by requiring that it either return the corresponding original source text or a standard placeholder.</p>
  <p>Dozens of individuals representing many organizations have made very significant contributions within Ecma TC39 to the development of this edition and to the prior editions. In addition, a vibrant community has emerged supporting TC39's ECMAScript efforts. This community has reviewed numerous drafts, filed thousands of bug reports, performed implementation experiments, contributed test suites, and educated the world-wide developer community about ECMAScript. Unfortunately, it is impossible to identify and acknowledge every person and organization who has contributed to this effort.</p>
  <p>
    Allen Wirfs-Brock<br>
    ECMA-262, Project Editor, 6<sup>th</sup> Edition
  </p>
  <p>
    Brian Terlson<br>
    ECMA-262, Project Editor, 7<sup>th</sup> through 10<sup>th</sup> Editions
  </p>
</emu-intro>

<emu-clause id="sec-scope">
  <h1>Scope</h1>
  <p>This Standard defines the ECMAScript 2020 general-purpose programming language.</p>
</emu-clause>

<emu-clause id="sec-conformance">
  <h1>Conformance</h1>
  <p>A conforming implementation of ECMAScript must provide and support all the types, values, objects, properties, functions, and program syntax and semantics described in this specification.</p>
  <p>A conforming implementation of ECMAScript must interpret source text input in conformance with the latest version of the Unicode Standard and ISO/IEC 10646.</p>
  <p>A conforming implementation of ECMAScript that provides an application programming interface (API) that supports programs that need to adapt to the linguistic and cultural conventions used by different human languages and countries must implement the interface defined by the most recent edition of ECMA-402 that is compatible with this specification.</p>
  <p>A conforming implementation of ECMAScript may provide additional types, values, objects, properties, and functions beyond those described in this specification. In particular, a conforming implementation of ECMAScript may provide properties not described in this specification, and values for those properties, for objects that are described in this specification.</p>
  <p>A conforming implementation of ECMAScript may support program and regular expression syntax not described in this specification. In particular, a conforming implementation of ECMAScript may support program syntax that makes use of the &ldquo;future reserved words&rdquo; listed in subclause <emu-xref href="#sec-future-reserved-words"></emu-xref> of this specification.</p>
  <p>A conforming implementation of ECMAScript must not implement any extension that is listed as a Forbidden Extension in subclause <emu-xref href="#sec-forbidden-extensions"></emu-xref>.</p>
</emu-clause>

<emu-clause id="sec-normative-references">
  <h1>Normative References</h1>
  <p>The following referenced documents are indispensable for the application of this document. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies.</p>
  <p>ISO/IEC 10646 <i>Information Technology &ndash; Universal Multiple-Octet Coded Character Set (UCS) plus Amendment 1:2005, Amendment 2:2006, Amendment 3:2008, and Amendment 4:2008</i>, plus additional amendments and corrigenda, or successor</p>
  <p>ECMA-402, <i>ECMAScript 2015 Internationalization API Specification</i>.
    <br>
    <a href="https://ecma-international.org/publications/standards/Ecma-402.htm">https://ecma-international.org/publications/standards/Ecma-402.htm</a></p>
  <p>ECMA-404, <i>The JSON Data Interchange Format</i>.
    <br>
    <a href="https://ecma-international.org/publications/standards/Ecma-404.htm">https://ecma-international.org/publications/standards/Ecma-404.htm</a></p>
</emu-clause>

<emu-clause id="sec-overview">
  <h1>Overview</h1>
  <p>This section contains a non-normative overview of the ECMAScript language.</p>
  <p>ECMAScript is an object-oriented programming language for performing computations and manipulating computational objects within a host environment. ECMAScript as defined here is not intended to be computationally self-sufficient; indeed, there are no provisions in this specification for input of external data or output of computed results. Instead, it is expected that the computational environment of an ECMAScript program will provide not only the objects and other facilities described in this specification but also certain environment-specific objects, whose description and behaviour are beyond the scope of this specification except to indicate that they may provide certain properties that can be accessed and certain functions that can be called from an ECMAScript program.</p>
  <p>ECMAScript was originally designed to be used as a scripting language, but has become widely used as a general-purpose programming language. A <em>scripting language</em> is a programming language that is used to manipulate, customize, and automate the facilities of an existing system. In such systems, useful functionality is already available through a user interface, and the scripting language is a mechanism for exposing that functionality to program control. In this way, the existing system is said to provide a host environment of objects and facilities, which completes the capabilities of the scripting language. A scripting language is intended for use by both professional and non-professional programmers.</p>
  <p>ECMAScript was originally designed to be a <em>Web scripting language</em>, providing a mechanism to enliven Web pages in browsers and to perform server computation as part of a Web-based client-server architecture. ECMAScript is now used to provide core scripting capabilities for a variety of host environments. Therefore the core language is specified in this document apart from any particular host environment.</p>
  <p>ECMAScript usage has moved beyond simple scripting and it is now used for the full spectrum of programming tasks in many different environments and scales. As the usage of ECMAScript has expanded, so have the features and facilities it provides. ECMAScript is now a fully featured general-purpose programming language.</p>
  <p>Some of the facilities of ECMAScript are similar to those used in other programming languages; in particular C, Java&trade;, Self, and Scheme as described in:</p>
  <p>ISO/IEC 9899:1996, <i>Programming Languages &ndash; C</i>.</p>
  <p>Gosling, James, Bill Joy and Guy Steele. <i>The Java<sup>&trade;</sup> Language Specification</i>. Addison Wesley Publishing Co., 1996.</p>
  <p>Ungar, David, and Smith, Randall B. Self: The Power of Simplicity. <i>OOPSLA '87 Conference Proceedings</i>, pp. 227-241, Orlando, FL, October 1987.</p>
  <p><i>IEEE Standard for the Scheme Programming Language</i>. IEEE Std 1178-1990.</p>

  <emu-clause id="sec-web-scripting">
    <h1>Web Scripting</h1>
    <p>A web browser provides an ECMAScript host environment for client-side computation including, for instance, objects that represent windows, menus, pop-ups, dialog boxes, text areas, anchors, frames, history, cookies, and input/output. Further, the host environment provides a means to attach scripting code to events such as change of focus, page and image loading, unloading, error and abort, selection, form submission, and mouse actions. Scripting code appears within the HTML and the displayed page is a combination of user interface elements and fixed and computed text and images. The scripting code is reactive to user interaction, and there is no need for a main program.</p>
    <p>A web server provides a different host environment for server-side computation including objects representing requests, clients, and files; and mechanisms to lock and share data. By using browser-side and server-side scripting together, it is possible to distribute computation between the client and server while providing a customized user interface for a Web-based application.</p>
    <p>Each Web browser and server that supports ECMAScript supplies its own host environment, completing the ECMAScript execution environment.</p>
  </emu-clause>

  <emu-clause id="sec-ecmascript-overview">
    <h1>ECMAScript Overview</h1>
    <p>The following is an informal overview of ECMAScript&mdash;not all parts of the language are described. This overview is not part of the standard proper.</p>
    <p>ECMAScript is object-based: basic language and host facilities are provided by objects, and an ECMAScript program is a cluster of communicating objects. In ECMAScript, an <em>object</em> is a collection of zero or more <em>properties</em> each with <em>attributes</em> that determine how each property can be used&mdash;for example, when the Writable attribute for a property is set to *false*, any attempt by executed ECMAScript code to assign a different value to the property fails. Properties are containers that hold other objects, <em>primitive values</em>, or <em>functions</em>. A primitive value is a member of one of the following built-in types: <b>Undefined</b>, <b>Null</b>, <b>Boolean</b>, <b>Number</b>, <b>String</b>, and <b>Symbol;</b> an object is a member of the built-in type <b>Object</b>; and a function is a callable object. A function that is associated with an object via a property is called a <em>method</em>.</p>
    <p>ECMAScript defines a collection of <em>built-in objects</em> that round out the definition of ECMAScript entities. These built-in objects include the global object; objects that are fundamental to the runtime semantics of the language including `Object`, `Function`, `Boolean`, `Symbol`, and various `Error` objects; objects that represent and manipulate numeric values including `Math`, `Number`, and `Date`; the text processing objects `String` and `RegExp`; objects that are indexed collections of values including `Array` and nine different kinds of Typed Arrays whose elements all have a specific numeric data representation; keyed collections including `Map` and `Set` objects; objects supporting structured data including the `JSON` object, `ArrayBuffer`, `SharedArrayBuffer`, and `DataView`; objects supporting control abstractions including generator functions and `Promise` objects; and reflection objects including `Proxy` and `Reflect`.</p>
    <p>ECMAScript also defines a set of built-in <em>operators</em>. ECMAScript operators include various unary operations, multiplicative operators, additive operators, bitwise shift operators, relational operators, equality operators, binary bitwise operators, binary logical operators, assignment operators, and the comma operator.</p>
    <p>Large ECMAScript programs are supported by <em>modules</em> which allow a program to be divided into multiple sequences of statements and declarations. Each module explicitly identifies declarations it uses that need to be provided by other modules and which of its declarations are available for use by other modules.</p>
    <p>ECMAScript syntax intentionally resembles Java syntax. ECMAScript syntax is relaxed to enable it to serve as an easy-to-use scripting language. For example, a variable is not required to have its type declared nor are types associated with properties, and defined functions are not required to have their declarations appear textually before calls to them.</p>

    <emu-clause id="sec-objects">
      <h1>Objects</h1>
      <p>Even though ECMAScript includes syntax for class definitions, ECMAScript objects are not fundamentally class-based such as those in C++, Smalltalk, or Java. Instead objects may be created in various ways including via a literal notation or via <em>constructors</em> which create objects and then execute code that initializes all or part of them by assigning initial values to their properties. Each constructor is a function that has a property named `"prototype"` that is used to implement <em>prototype-based inheritance</em> and <em>shared properties</em>. Objects are created by using constructors in <b>new</b> expressions; for example, `new Date(2009, 11)` creates a new Date object. Invoking a constructor without using <b>new</b> has consequences that depend on the constructor. For example, `Date()` produces a string representation of the current date and time rather than an object.</p>
      <p>Every object created by a constructor has an implicit reference (called the object's <em>prototype</em>) to the value of its constructor's `"prototype"` property. Furthermore, a prototype may have a non-null implicit reference to its prototype, and so on; this is called the <em>prototype chain</em>. When a reference is made to a property in an object, that reference is to the property of that name in the first object in the prototype chain that contains a property of that name. In other words, first the object mentioned directly is examined for such a property; if that object contains the named property, that is the property to which the reference refers; if that object does not contain the named property, the prototype for that object is examined next; and so on.</p>
      <emu-figure id="figure-1" caption="Object/Prototype Relationships">
        <object data="img/figure-1.svg" height="354" type="image/svg+xml" width="719"> <img alt="An image of lots of boxes and arrows." height="354" src="img/figure-1.png" width="719"> </object>
      </emu-figure>
      <p>In a class-based object-oriented language, in general, state is carried by instances, methods are carried by classes, and inheritance is only of structure and behaviour. In ECMAScript, the state and methods are carried by objects, while structure, behaviour, and state are all inherited.</p>
      <p>All objects that do not directly contain a particular property that their prototype contains share that property and its value. Figure 1 illustrates this:</p>
      <p><b>CF</b> is a constructor (and also an object). Five objects have been created by using `new` expressions: <b>cf<sub>1</sub></b>, <b>cf<sub>2</sub></b>, <b>cf<sub>3</sub></b>, <b>cf<sub>4</sub></b>, and <b>cf<sub>5</sub></b>. Each of these objects contains properties named `q1` and `q2`. The dashed lines represent the implicit prototype relationship; so, for example, <b>cf<sub>3</sub></b>'s prototype is <b>CF<sub>p</sub></b>. The constructor, <b>CF</b>, has two properties itself, named `P1` and `P2`, which are not visible to <b>CF<sub>p</sub></b>, <b>cf<sub>1</sub></b>, <b>cf<sub>2</sub></b>, <b>cf<sub>3</sub></b>, <b>cf<sub>4</sub></b>, or <b>cf<sub>5</sub></b>. The property named `CFP1` in <b>CF<sub>p</sub></b> is shared by <b>cf<sub>1</sub></b>, <b>cf<sub>2</sub></b>, <b>cf<sub>3</sub></b>, <b>cf<sub>4</sub></b>, and <b>cf<sub>5</sub></b> (but not by <b>CF</b>), as are any properties found in <b>CF<sub>p</sub></b>'s implicit prototype chain that are not named `q1`, `q2`, or `CFP1`. Notice that there is no implicit prototype link between <b>CF</b> and <b>CF<sub>p</sub></b>.</p>
      <p>Unlike most class-based object languages, properties can be added to objects dynamically by assigning values to them. That is, constructors are not required to name or assign values to all or any of the constructed object's properties. In the above diagram, one could add a new shared property for <b>cf<sub>1</sub></b>, <b>cf<sub>2</sub></b>, <b>cf<sub>3</sub></b>, <b>cf<sub>4</sub></b>, and <b>cf<sub>5</sub></b> by assigning a new value to the property in <b>CF<sub>p</sub></b>.</p>
      <p>Although ECMAScript objects are not inherently class-based, it is often convenient to define class-like abstractions based upon a common pattern of constructor functions, prototype objects, and methods. The ECMAScript built-in objects themselves follow such a class-like pattern. Beginning with ECMAScript 2015, the ECMAScript language includes syntactic class definitions that permit programmers to concisely define objects that conform to the same class-like abstraction pattern used by the built-in objects.</p>
    </emu-clause>

    <emu-clause id="sec-strict-variant-of-ecmascript">
      <h1>The Strict Variant of ECMAScript</h1>
      <p>The ECMAScript Language recognizes the possibility that some users of the language may wish to restrict their usage of some features available in the language. They might do so in the interests of security, to avoid what they consider to be error-prone features, to get enhanced error checking, or for other reasons of their choosing. In support of this possibility, ECMAScript defines a strict variant of the language. The strict variant of the language excludes some specific syntactic and semantic features of the regular ECMAScript language and modifies the detailed semantics of some features. The strict variant also specifies additional error conditions that must be reported by throwing error exceptions in situations that are not specified as errors by the non-strict form of the language.</p>
      <p>The strict variant of ECMAScript is commonly referred to as the <em>strict mode</em> of the language. Strict mode selection and use of the strict mode syntax and semantics of ECMAScript is explicitly made at the level of individual ECMAScript source text units. Because strict mode is selected at the level of a syntactic source text unit, strict mode only imposes restrictions that have local effect within such a source text unit. Strict mode does not restrict or modify any aspect of the ECMAScript semantics that must operate consistently across multiple source text units. A complete ECMAScript program may be composed of both strict mode and non-strict mode ECMAScript source text units. In this case, strict mode only applies when actually executing code that is defined within a strict mode source text unit.</p>
      <p>In order to conform to this specification, an ECMAScript implementation must implement both the full unrestricted ECMAScript language and the strict variant of the ECMAScript language as defined by this specification. In addition, an implementation must support the combination of unrestricted and strict mode source text units into a single composite program.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-terms-and-definitions">
    <h1>Terms and Definitions</h1>
    <p>For the purposes of this document, the following terms and definitions apply.</p>

    <emu-clause id="sec-type">
      <h1>type</h1>
      <p>set of data values as defined in clause <emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref> of this specification</p>
    </emu-clause>

    <emu-clause id="sec-primitive-value">
      <h1>primitive value</h1>
      <p>member of one of the types Undefined, Null, Boolean, Number, Symbol, or String as defined in clause <emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref></p>
      <emu-note>
        <p>A primitive value is a datum that is represented directly at the lowest level of the language implementation.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-object">
      <h1>object</h1>
      <p>member of the type Object</p>
      <emu-note>
        <p>An object is a collection of properties and has a single prototype object. The prototype may be the null value.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-constructor">
      <h1>constructor</h1>
      <p>function object that creates and initializes objects</p>
      <emu-note>
        <p>The value of a constructor's `prototype` property is a prototype object that is used to implement inheritance and shared properties.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-prototype">
      <h1>prototype</h1>
      <p>object that provides shared properties for other objects</p>
      <emu-note>
        <p>When a constructor creates an object, that object implicitly references the constructor's `prototype` property for the purpose of resolving property references. The constructor's `prototype` property can be referenced by the program expression <code><var>constructor</var>.prototype</code>, and properties added to an object's prototype are shared, through inheritance, by all objects sharing the prototype. Alternatively, a new object may be created with an explicitly specified prototype by using the `Object.create` built-in function.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-ordinary-object">
      <h1>ordinary object</h1>
      <p>object that has the default behaviour for the essential internal methods that must be supported by all objects</p>
    </emu-clause>

    <emu-clause id="sec-exotic-object">
      <h1>exotic object</h1>
      <p>object that does not have the default behaviour for one or more of the essential internal methods</p>
      <emu-note>
        <p>Any object that is not an ordinary object is an exotic object.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-standard-object">
      <h1>standard object</h1>
      <p>object whose semantics are defined by this specification</p>
    </emu-clause>

    <emu-clause id="sec-built-in-object">
      <h1>built-in object</h1>
      <p>object specified and supplied by an ECMAScript implementation</p>
      <emu-note>
        <p>Standard built-in objects are defined in this specification. An ECMAScript implementation may specify and supply additional kinds of built-in objects. A <em>built-in constructor</em> is a built-in object that is also a constructor.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-undefined-value">
      <h1>undefined value</h1>
      <p>primitive value used when a variable has not been assigned a value</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-undefined-type">
      <h1>Undefined type</h1>
      <p>type whose sole value is the *undefined* value</p>
    </emu-clause>

    <emu-clause id="sec-null-value">
      <h1>null value</h1>
      <p>primitive value that represents the intentional absence of any object value</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-null-type">
      <h1>Null type</h1>
      <p>type whose sole value is the *null* value</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-boolean-value">
      <h1>Boolean value</h1>
      <p>member of the Boolean type</p>
      <emu-note>
        <p>There are only two Boolean values, *true* and *false*.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-boolean-type">
      <h1>Boolean type</h1>
      <p>type consisting of the primitive values *true* and *false*</p>
    </emu-clause>

    <emu-clause id="sec-boolean-object">
      <h1>Boolean object</h1>
      <p>member of the Object type that is an instance of the standard built-in `Boolean` constructor</p>
      <emu-note>
        <p>A Boolean object is created by using the `Boolean` constructor in a `new` expression, supplying a Boolean value as an argument. The resulting object has an internal slot whose value is the Boolean value. A Boolean object can be coerced to a Boolean value.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-string-value">
      <h1>String value</h1>
      <p>primitive value that is a finite ordered sequence of zero or more 16-bit unsigned integer values</p>
      <emu-note>
        <p>A String value is a member of the String type. Each integer value in the sequence usually represents a single 16-bit unit of UTF-16 text. However, ECMAScript does not place any restrictions or requirements on the values except that they must be 16-bit unsigned integers.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-string-type">
      <h1>String type</h1>
      <p>set of all possible String values</p>
    </emu-clause>

    <emu-clause id="sec-string-object">
      <h1>String object</h1>
      <p>member of the Object type that is an instance of the standard built-in `String` constructor</p>
      <emu-note>
        <p>A String object is created by using the `String` constructor in a `new` expression, supplying a String value as an argument. The resulting object has an internal slot whose value is the String value. A String object can be coerced to a String value by calling the `String` constructor as a function (<emu-xref href="#sec-string-constructor-string-value"></emu-xref>).</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-number-value">
      <h1>Number value</h1>
      <p>primitive value corresponding to a double-precision 64-bit binary format IEEE 754-2008 value</p>
      <emu-note>
        <p>A Number value is a member of the Number type and is a direct representation of a number.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-number-type">
      <h1>Number type</h1>
      <p>set of all possible Number values including the special &ldquo;Not-a-Number&rdquo; (NaN) value, positive infinity, and negative infinity</p>
    </emu-clause>

    <emu-clause id="sec-number-object">
      <h1>Number object</h1>
      <p>member of the Object type that is an instance of the standard built-in `Number` constructor</p>
      <emu-note>
        <p>A Number object is created by using the `Number` constructor in a `new` expression, supplying a number value as an argument. The resulting object has an internal slot whose value is the number value. A Number object can be coerced to a number value by calling the `Number` constructor as a function (<emu-xref href="#sec-number-constructor-number-value"></emu-xref>).</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-infinity">
      <h1>Infinity</h1>
      <p>number value that is the positive infinite number value</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-nan">
      <h1>NaN</h1>
      <p>number value that is an IEEE 754-2008 &ldquo;Not-a-Number&rdquo; value</p>
    </emu-clause>

    <emu-clause id="sec-symbol-value">
      <h1>Symbol value</h1>
      <p>primitive value that represents a unique, non-String Object property key</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-symbol-type">
      <h1>Symbol type</h1>
      <p>set of all possible Symbol values</p>
    </emu-clause>

    <emu-clause id="sec-symbol-object">
      <h1>Symbol object</h1>
      <p>member of the Object type that is an instance of the standard built-in `Symbol` constructor</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-function">
      <h1>function</h1>
      <p>member of the Object type that may be invoked as a subroutine</p>
      <emu-note>
        <p>In addition to its properties, a function contains executable code and state that determine how it behaves when invoked. A function's code may or may not be written in ECMAScript.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-built-in-function">
      <h1>built-in function</h1>
      <p>built-in object that is a function</p>
      <emu-note>
        <p>Examples of built-in functions include `parseInt` and `Math.exp`. An implementation may provide implementation-dependent built-in functions that are not described in this specification.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-property">
      <h1>property</h1>
      <p>part of an object that associates a key (either a String value or a Symbol value) and a value</p>
      <emu-note>
        <p>Depending upon the form of the property the value may be represented either directly as a data value (a primitive value, an object, or a function object) or indirectly by a pair of accessor functions.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-method">
      <h1>method</h1>
      <p>function that is the value of a property</p>
      <emu-note>
        <p>When a function is called as a method of an object, the object is passed to the function as its *this* value.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-built-in-method">
      <h1>built-in method</h1>
      <p>method that is a built-in function</p>
      <emu-note>
        <p>Standard built-in methods are defined in this specification, and an ECMAScript implementation may specify and provide other additional built-in methods.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-attribute">
      <h1>attribute</h1>
      <p>internal value that defines some characteristic of a property</p>
    </emu-clause>

    <emu-clause id="sec-own-property">
      <h1>own property</h1>
      <p>property that is directly contained by its object</p>
    </emu-clause>

    <emu-clause id="sec-inherited-property">
      <h1>inherited property</h1>
      <p>property of an object that is not an own property but is a property (either own or inherited) of the object's prototype</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-organization-of-this-specification">
    <h1>Organization of This Specification</h1>
    <p>The remainder of this specification is organized as follows:</p>
    <p>Clause 5 defines the notational conventions used throughout the specification.</p>
    <p>Clauses 6-9 define the execution environment within which ECMAScript programs operate.</p>
    <p>Clauses 10-16 define the actual ECMAScript programming language including its syntactic encoding and the execution semantics of all language features.</p>
    <p>Clauses 17-26 define the ECMAScript standard library. They include the definitions of all of the standard objects that are available for use by ECMAScript programs as they execute.</p>
    <p>Clause 27 describes the memory consistency model of accesses on SharedArrayBuffer-backed memory and methods of the Atomics object.</p>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-notational-conventions">
  <h1>Notational Conventions</h1>

  <emu-clause id="sec-syntactic-and-lexical-grammars">
    <h1>Syntactic and Lexical Grammars</h1>

    <emu-clause id="sec-context-free-grammars">
      <h1>Context-Free Grammars</h1>
      <p>A <em>context-free grammar</em> consists of a number of <em>productions</em>. Each production has an abstract symbol called a <em>nonterminal</em> as its <em>left-hand side</em>, and a sequence of zero or more nonterminal and <em>terminal</em> symbols as its <em>right-hand side</em>. For each grammar, the terminal symbols are drawn from a specified alphabet.</p>
      <p>A <dfn>chain production</dfn> is a production that has exactly one nonterminal symbol on its right-hand side along with zero or more terminal symbols.</p>
      <p>Starting from a sentence consisting of a single distinguished nonterminal, called the <dfn>goal symbol</dfn>, a given context-free grammar specifies a <em>language</em>, namely, the (perhaps infinite) set of possible sequences of terminal symbols that can result from repeatedly replacing any nonterminal in the sequence with a right-hand side of a production for which the nonterminal is the left-hand side.</p>
    </emu-clause>

    <emu-clause id="sec-lexical-and-regexp-grammars">
      <h1>The Lexical and RegExp Grammars</h1>
      <p>A <em>lexical grammar</em> for ECMAScript is given in clause <emu-xref href="#sec-ecmascript-language-lexical-grammar"></emu-xref>. This grammar has as its terminal symbols Unicode code points that conform to the rules for |SourceCharacter| defined in <emu-xref href="#sec-source-text"></emu-xref>. It defines a set of productions, starting from the goal symbol |InputElementDiv|, |InputElementTemplateTail|, or |InputElementRegExp|, or |InputElementRegExpOrTemplateTail|, that describe how sequences of such code points are translated into a sequence of input elements.</p>
      <p>Input elements other than white space and comments form the terminal symbols for the syntactic grammar for ECMAScript and are called ECMAScript <em>tokens</em>. These tokens are the reserved words, identifiers, literals, and punctuators of the ECMAScript language. Moreover, line terminators, although not considered to be tokens, also become part of the stream of input elements and guide the process of automatic semicolon insertion (<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>). Simple white space and single-line comments are discarded and do not appear in the stream of input elements for the syntactic grammar. A |MultiLineComment| (that is, a comment of the form `/*`&hellip;`*/` regardless of whether it spans more than one line) is likewise simply discarded if it contains no line terminator; but if a |MultiLineComment| contains one or more line terminators, then it is replaced by a single line terminator, which becomes part of the stream of input elements for the syntactic grammar.</p>
      <p>A <em>RegExp grammar</em> for ECMAScript is given in <emu-xref href="#sec-patterns"></emu-xref>. This grammar also has as its terminal symbols the code points as defined by |SourceCharacter|. It defines a set of productions, starting from the goal symbol |Pattern|, that describe how sequences of code points are translated into regular expression patterns.</p>
      <p>Productions of the lexical and RegExp grammars are distinguished by having two colons &ldquo;<b>::</b>&rdquo; as separating punctuation. The lexical and RegExp grammars share some productions.</p>
    </emu-clause>

    <emu-clause id="sec-numeric-string-grammar">
      <h1>The Numeric String Grammar</h1>
      <p>Another grammar is used for translating Strings into numeric values. This grammar is similar to the part of the lexical grammar having to do with numeric literals and has as its terminal symbols |SourceCharacter|. This grammar appears in <emu-xref href="#sec-tonumber-applied-to-the-string-type"></emu-xref>.</p>
      <p>Productions of the numeric string grammar are distinguished by having three colons &ldquo;<b>:::</b>&rdquo; as punctuation.</p>
    </emu-clause>

    <emu-clause id="sec-syntactic-grammar">
      <h1>The Syntactic Grammar</h1>
      <p>The <em>syntactic grammar</em> for ECMAScript is given in clauses 11, 12, 13, 14, and 15. This grammar has ECMAScript tokens defined by the lexical grammar as its terminal symbols (<emu-xref href="#sec-lexical-and-regexp-grammars"></emu-xref>). It defines a set of productions, starting from two alternative goal symbols |Script| and |Module|, that describe how sequences of tokens form syntactically correct independent components of ECMAScript programs.</p>
      <p>When a stream of code points is to be parsed as an ECMAScript |Script| or |Module|, it is first converted to a stream of input elements by repeated application of the lexical grammar; this stream of input elements is then parsed by a single application of the syntactic grammar. The input stream is syntactically in error if the tokens in the stream of input elements cannot be parsed as a single instance of the goal nonterminal (|Script| or |Module|), with no tokens left over.</p>
      <p>When a parse is successful, it constructs a <em>parse tree</em>, a rooted tree structure in which each node is a <dfn>Parse Node</dfn>. Each Parse Node is an <em>instance</em> of a symbol in the grammar; it represents a span of the source text that can be derived from that symbol. The root node of the parse tree, representing the whole of the source text, is an instance of the parse's goal symbol. When a Parse Node is an instance of a nonterminal, it is also an instance of some production that has that nonterminal as its left-hand side. Moreover, it has zero or more <em>children</em>, one for each symbol on the production's right-hand side: each child is a Parse Node that is an instance of the corresponding symbol.</p>
      <p>New Parse Nodes are instantiated for each invocation of the parser and never reused between parses even of identical source text. Parse Nodes are considered <dfn>the same Parse Node</dfn> if and only if they represent the same span of source text, are instances of the same grammar symbol, and resulted from the same parser invocation.</p>
      <emu-note>
        <p>Parsing the same String multiple times will lead to different Parse Nodes, e.g., as occurs in:</p>
        <pre><code class="javascript">eval(str); eval(str);</code></pre>
      </emu-note>
      <emu-note>Parse Nodes are specification artefacts, and implementations are not required to use an analogous data structure.</emu-note>
      <p>Productions of the syntactic grammar are distinguished by having just one colon &ldquo;<b>:</b>&rdquo; as punctuation.</p>
      <p>The syntactic grammar as presented in clauses 12, 13, 14 and 15 is not a complete account of which token sequences are accepted as a correct ECMAScript |Script| or |Module|. Certain additional token sequences are also accepted, namely, those that would be described by the grammar if only semicolons were added to the sequence in certain places (such as before line terminator characters). Furthermore, certain token sequences that are described by the grammar are not considered acceptable if a line terminator character appears in certain &ldquo;awkward&rdquo; places.</p>
      <p>In certain cases, in order to avoid ambiguities, the syntactic grammar uses generalized productions that permit token sequences that do not form a valid ECMAScript |Script| or |Module|. For example, this technique is used for object literals and object destructuring patterns. In such cases a more restrictive <em>supplemental grammar</em> is provided that further restricts the acceptable token sequences. Typically, an early error rule will then define an error condition if "_P_ is not <dfn>covering</dfn> an _N_", where _P_ is a Parse Node (an instance of the generalized production) and _N_ is a nonterminal from the supplemental grammar. Here, the sequence of tokens originally matched by _P_ is parsed again using _N_ as the goal symbol. (If _N_ takes grammatical parameters, then they are set to the same values used when _P_ was originally parsed.) An error occurs if the sequence of tokens cannot be parsed as a single instance of _N_, with no tokens left over. Subsequently, algorithms access the result of the parse using a phrase of the form "the _N_ that is <dfn>covered</dfn> by _P_". This will always be a Parse Node (an instance of _N_, unique for a given _P_), since any parsing failure would have been detected by an early error rule.</p>
    </emu-clause>

    <emu-clause id="sec-grammar-notation" namespace=grammar-notation>
      <h1>Grammar Notation</h1>
      <p>Terminal symbols of the lexical, RegExp, and numeric string grammars are shown in `fixed width` font, both in the productions of the grammars and throughout this specification whenever the text directly refers to such a terminal symbol. These are to appear in a script exactly as written. All terminal symbol code points specified in this way are to be understood as the appropriate Unicode code points from the Basic Latin range, as opposed to any similar-looking code points from other Unicode ranges.</p>
      <p>Nonterminal symbols are shown in <i>italic</i> type. The definition of a nonterminal (also called a &ldquo;production&rdquo;) is introduced by the name of the nonterminal being defined followed by one or more colons. (The number of colons indicates to which grammar the production belongs.) One or more alternative right-hand sides for the nonterminal then follow on succeeding lines. For example, the syntactic definition:</p>
      <emu-grammar type="example">
        WhileStatement :
          `while` `(` Expression `)` Statement
      </emu-grammar>
      <p>states that the nonterminal |WhileStatement| represents the token `while`, followed by a left parenthesis token, followed by an |Expression|, followed by a right parenthesis token, followed by a |Statement|. The occurrences of |Expression| and |Statement| are themselves nonterminals. As another example, the syntactic definition:</p>
      <emu-grammar type="example">
        ArgumentList :
          AssignmentExpression
          ArgumentList `,` AssignmentExpression
      </emu-grammar>
      <p>states that an |ArgumentList| may represent either a single |AssignmentExpression| or an |ArgumentList|, followed by a comma, followed by an |AssignmentExpression|. This definition of |ArgumentList| is recursive, that is, it is defined in terms of itself. The result is that an |ArgumentList| may contain any positive number of arguments, separated by commas, where each argument expression is an |AssignmentExpression|. Such recursive definitions of nonterminals are common.</p>
      <p>The subscripted suffix &ldquo;<sub>opt</sub>&rdquo;, which may appear after a terminal or nonterminal, indicates an optional symbol. The alternative containing the optional symbol actually specifies two right-hand sides, one that omits the optional element and one that includes it. This means that:</p>
      <emu-grammar type="example">
        VariableDeclaration :
          BindingIdentifier Initializer?
      </emu-grammar>
      <p>is a convenient abbreviation for:</p>
      <emu-grammar type="example">
        VariableDeclaration :
          BindingIdentifier
          BindingIdentifier Initializer
      </emu-grammar>
      <p>and that:</p>
      <emu-grammar type="example">
        IterationStatement :
          `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
      </emu-grammar>
      <p>is a convenient abbreviation for:</p>
      <emu-grammar type="example">
        IterationStatement :
          `for` `(` LexicalDeclaration `;` Expression? `)` Statement
          `for` `(` LexicalDeclaration Expression `;` Expression? `)` Statement
      </emu-grammar>
      <p>which in turn is an abbreviation for:</p>
      <emu-grammar type="example">
        IterationStatement :
          `for` `(` LexicalDeclaration `;` `)` Statement
          `for` `(` LexicalDeclaration `;` Expression `)` Statement
          `for` `(` LexicalDeclaration Expression `;` `)` Statement
          `for` `(` LexicalDeclaration Expression `;` Expression `)` Statement
      </emu-grammar>
      <p>so, in this example, the nonterminal |IterationStatement| actually has four alternative right-hand sides.</p>
      <p>A production may be parameterized by a subscripted annotation of the form &ldquo;<sub>[parameters]</sub>&rdquo;, which may appear as a suffix to the nonterminal symbol defined by the production. &ldquo;<sub>parameters</sub>&rdquo; may be either a single name or a comma separated list of names. A parameterized production is shorthand for a set of productions defining all combinations of the parameter names, preceded by an underscore, appended to the parameterized nonterminal symbol. This means that:</p>
      <emu-grammar type="example">
        StatementList[Return] :
          ReturnStatement
          ExpressionStatement
      </emu-grammar>
      <p>is a convenient abbreviation for:</p>
      <emu-grammar type="example">
        StatementList :
          ReturnStatement
          ExpressionStatement

        StatementList_Return :
          ReturnStatement
          ExpressionStatement
      </emu-grammar>
      <p>and that:</p>
      <emu-grammar type="example">
        StatementList[Return, In] :
          ReturnStatement
          ExpressionStatement
      </emu-grammar>
      <p>is an abbreviation for:</p>
      <emu-grammar type="example">
        StatementList :
          ReturnStatement
          ExpressionStatement

        StatementList_Return :
          ReturnStatement
          ExpressionStatement

        StatementList_In :
          ReturnStatement
          ExpressionStatement

        StatementList_Return_In :
          ReturnStatement
          ExpressionStatement
      </emu-grammar>
      <p>Multiple parameters produce a combinatory number of productions, not all of which are necessarily referenced in a complete grammar.</p>
      <p>References to nonterminals on the right-hand side of a production can also be parameterized. For example:</p>
      <emu-grammar type="example">
        StatementList :
          ReturnStatement
          ExpressionStatement[+In]
      </emu-grammar>
      <p>is equivalent to saying:</p>
      <emu-grammar type="example">
        StatementList :
          ReturnStatement
          ExpressionStatement_In
      </emu-grammar>
      <p>and:</p>
      <emu-grammar type="example">
        StatementList :
          ReturnStatement
          ExpressionStatement[~In]
      </emu-grammar>
      <p>is equivalent to:</p>
      <emu-grammar type="example">
        StatementList :
          ReturnStatement
          ExpressionStatement
      </emu-grammar>
      <p>A nonterminal reference may have both a parameter list and an &ldquo;<sub>opt</sub>&rdquo; suffix. For example:</p>
      <emu-grammar type="example">
        VariableDeclaration :
          BindingIdentifier Initializer[+In]?
      </emu-grammar>
      <p>is an abbreviation for:</p>
      <emu-grammar type="example">
        VariableDeclaration :
          BindingIdentifier
          BindingIdentifier Initializer_In
      </emu-grammar>
      <p>Prefixing a parameter name with &ldquo;<sub>?</sub>&rdquo; on a right-hand side nonterminal reference makes that parameter value dependent upon the occurrence of the parameter name on the reference to the current production's left-hand side symbol. For example:</p>
      <emu-grammar type="example">
        VariableDeclaration[In] :
          BindingIdentifier Initializer[?In]
      </emu-grammar>
      <p>is an abbreviation for:</p>
      <emu-grammar type="example">
        VariableDeclaration :
          BindingIdentifier Initializer

        VariableDeclaration_In :
          BindingIdentifier Initializer_In
      </emu-grammar>
      <p>If a right-hand side alternative is prefixed with &ldquo;[+parameter]&rdquo; that alternative is only available if the named parameter was used in referencing the production's nonterminal symbol. If a right-hand side alternative is prefixed with &ldquo;[\~parameter]&rdquo; that alternative is only available if the named parameter was <em>not</em> used in referencing the production's nonterminal symbol. This means that:</p>
      <emu-grammar type="example">
        StatementList[Return] :
          [+Return] ReturnStatement
          ExpressionStatement
      </emu-grammar>
      <p>is an abbreviation for:</p>
      <emu-grammar type="example">
        StatementList :
          ExpressionStatement

        StatementList_Return :
          ReturnStatement
          ExpressionStatement
      </emu-grammar>
      <p>and that:</p>
      <emu-grammar type="example">
        StatementList[Return] :
          [~Return] ReturnStatement
          ExpressionStatement
      </emu-grammar>
      <p>is an abbreviation for:</p>
      <emu-grammar type="example">
        StatementList :
          ReturnStatement
          ExpressionStatement

        StatementList_Return :
          ExpressionStatement
      </emu-grammar>
      <p>When the words &ldquo;<b>one of</b>&rdquo; follow the colon(s) in a grammar definition, they signify that each of the terminal symbols on the following line or lines is an alternative definition. For example, the lexical grammar for ECMAScript contains the production:</p>
      <emu-grammar type="example">
        NonZeroDigit :: one of
          `1` `2` `3` `4` `5` `6` `7` `8` `9`
      </emu-grammar>
      <p>which is merely a convenient abbreviation for:</p>
      <emu-grammar type="example">
        NonZeroDigit ::
          `1`
          `2`
          `3`
          `4`
          `5`
          `6`
          `7`
          `8`
          `9`
      </emu-grammar>
      <p>If the phrase &ldquo;[empty]&rdquo; appears as the right-hand side of a production, it indicates that the production's right-hand side contains no terminals or nonterminals.</p>
      <p>If the phrase &ldquo;[lookahead &notin; _set_]&rdquo; appears in the right-hand side of a production, it indicates that the production may not be used if the immediately following input token sequence is a member of the given _set_. The _set_ can be written as a comma separated list of one or two element terminal sequences enclosed in curly brackets. For convenience, the set can also be written as a nonterminal, in which case it represents the set of all terminals to which that nonterminal could expand. If the _set_ consists of a single terminal the phrase &ldquo;[lookahead &ne; _terminal_]&rdquo; may be used.</p>
      <p>For example, given the definitions:</p>
      <emu-grammar type="example">
        DecimalDigit :: one of
          `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`

        DecimalDigits ::
          DecimalDigit
          DecimalDigits DecimalDigit
      </emu-grammar>
      <p>the definition:</p>
      <emu-grammar type="example">
        LookaheadExample ::
          `n` [lookahead &lt;! {`1`, `3`, `5`, `7`, `9`}] DecimalDigits
          DecimalDigit [lookahead &lt;! DecimalDigit]
      </emu-grammar>
      <p>matches either the letter `n` followed by one or more decimal digits the first of which is even, or a decimal digit not followed by another decimal digit.</p>
      <p>Similarly, if the phrase &ldquo;[lookahead &isin; _set_]&rdquo; appears in the right-hand side of a production, it indicates that the production may only be used if the immediately following input token sequence is a member of the given _set_. If the _set_ consists of a single terminal the phrase &ldquo;[lookahead = _terminal_]&rdquo; may be used.</p>
      <p>If the phrase &ldquo;[no |LineTerminator| here]&rdquo; appears in the right-hand side of a production of the syntactic grammar, it indicates that the production is <em>a restricted production</em>: it may not be used if a |LineTerminator| occurs in the input stream at the indicated position. For example, the production:</p>
      <emu-grammar type="example">
        ThrowStatement :
          `throw` [no LineTerminator here] Expression `;`
      </emu-grammar>
      <p>indicates that the production may not be used if a |LineTerminator| occurs in the script between the `throw` token and the |Expression|.</p>
      <p>Unless the presence of a |LineTerminator| is forbidden by a restricted production, any number of occurrences of |LineTerminator| may appear between any two consecutive tokens in the stream of input elements without affecting the syntactic acceptability of the script.</p>
      <p>When an alternative in a production of the lexical grammar or the numeric string grammar appears to be a multi-code point token, it represents the sequence of code points that would make up such a token.</p>
      <p>The right-hand side of a production may specify that certain expansions are not permitted by using the phrase &ldquo;<b>but not</b>&rdquo; and then indicating the expansions to be excluded. For example, the production:</p>
      <emu-grammar type="example">
        Identifier ::
          IdentifierName but not ReservedWord
      </emu-grammar>
      <p>means that the nonterminal |Identifier| may be replaced by any sequence of code points that could replace |IdentifierName| provided that the same sequence of code points could not replace |ReservedWord|.</p>
      <p>Finally, a few nonterminal symbols are described by a descriptive phrase in sans-serif type in cases where it would be impractical to list all the alternatives:</p>
      <emu-grammar type="example">
        SourceCharacter ::
          &gt; any Unicode code point
      </emu-grammar>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-algorithm-conventions">
    <h1>Algorithm Conventions</h1>
    <p>The specification often uses a numbered list to specify steps in an algorithm. These algorithms are used to precisely specify the required semantics of ECMAScript language constructs. The algorithms are not intended to imply the use of any specific implementation technique. In practice, there may be more efficient algorithms available to implement a given feature.</p>
    <p>Algorithms may be explicitly parameterized, in which case the names and usage of the parameters must be provided as part of the algorithm's definition.</p>
    <p>Algorithm steps may be subdivided into sequential substeps. Substeps are indented and may themselves be further divided into indented substeps. Outline numbering conventions are used to identify substeps with the first level of substeps labelled with lower case alphabetic characters and the second level of substeps labelled with lower case roman numerals. If more than three levels are required these rules repeat with the fourth level using numeric labels. For example:</p>
    <emu-alg>
      1. Top-level step
        1. Substep.
        1. Substep.
          1. Subsubstep.
            1. Subsubsubstep
              1. Subsubsubsubstep
                1. Subsubsubsubsubstep
    </emu-alg>
    <p>A step or substep may be written as an &ldquo;if&rdquo; predicate that conditions its substeps. In this case, the substeps are only applied if the predicate is true. If a step or substep begins with the word &ldquo;else&rdquo;, it is a predicate that is the negation of the preceding &ldquo;if&rdquo; predicate step at the same level.</p>
    <p>A step may specify the iterative application of its substeps.</p>
    <p>A step that begins with &ldquo;<dfn id="assert">Assert</dfn>:&rdquo; asserts an invariant condition of its algorithm. Such assertions are used to make explicit algorithmic invariants that would otherwise be implicit. Such assertions add no additional semantic requirements and hence need not be checked by an implementation. They are used simply to clarify algorithms.</p>
    <p>Algorithm steps may declare named aliases for any value using the form &ldquo;Let _x_ be _someValue_&rdquo;. These aliases are reference-like in that both _x_ and _someValue_ refer to the same underlying data and modifications to either are visible to both. Algorithm steps that want to avoid this reference-like behaviour should explicitly make a copy of the right-hand side: &ldquo;Let _x_ be a copy of _someValue_&rdquo; creates a shallow copy of _someValue_.</p>
    <p>Once declared, an alias may be referenced in any subsequent steps and must not be referenced from steps prior to the alias's declaration. Aliases may be modified using the form &ldquo;Set _x_ to _someOtherValue_&rdquo;.</p>

    <emu-clause id=sec-algorithm-conventions-abstract-operations>
      <h1>Abstract Operations</h1>
      <p>In order to facilitate their use in multiple parts of this specification, some algorithms, called <dfn>abstract operations</dfn>, are named and written in parameterized functional form so that they may be referenced by name from within other algorithms. Abstract operations are typically referenced using a functional application style such as OperationName(_arg1_, _arg2_). Some abstract operations are treated as polymorphically dispatched methods of class-like specification abstractions. Such method-like abstract operations are typically referenced using a method application style such as _someValue_.OperationName(_arg1_, _arg2_).</p>
    </emu-clause>

    <emu-clause id=sec-algorithm-conventions-syntax-directed-operations namespace=algorithm-conventions>
      <h1>Syntax-Directed Operations</h1>
      <p>A <dfn>syntax-directed operation</dfn> is a named operation whose definition consists of algorithms, each of which is associated with one or more productions from one of the ECMAScript grammars. A production that has multiple alternative definitions will typically have a distinct algorithm for each alternative. When an algorithm is associated with a grammar production, it may reference the terminal and nonterminal symbols of the production alternative as if they were parameters of the algorithm. When used in this manner, nonterminal symbols refer to the actual alternative definition that is matched when parsing the source text. The <dfn>source text matched by</dfn> a grammar production is the portion of the source text that starts at the beginning of the first terminal that participated in the match and ends at the end of the last terminal that participated in the match.</p>
      <p>When an algorithm is associated with a production alternative, the alternative is typically shown without any &ldquo;[ ]&rdquo; grammar annotations. Such annotations should only affect the syntactic recognition of the alternative and have no effect on the associated semantics for the alternative.</p>
      <p>Syntax-directed operations are invoked with a parse node and, optionally, other parameters by using the conventions on steps 1, 3, and 4 in the following algorithm:</p>
      <emu-alg>
        1. Let _status_ be the result of performing SyntaxDirectedOperation of |SomeNonTerminal|.
        2. Let _someParseNode_ be the parse of some source text.
        2. Perform SyntaxDirectedOperation of _someParseNode_.
        2. Perform SyntaxDirectedOperation of _someParseNode_ passing `"value"` as the argument.
      </emu-alg>
      <p>Unless explicitly specified otherwise, all chain productions have an implicit definition for every operation that might be applied to that production's left-hand side nonterminal. The implicit definition simply reapplies the same operation with the same parameters, if any, to the chain production's sole right-hand side nonterminal and then returns the result. For example, assume that some algorithm has a step of the form: &ldquo;Return the result of evaluating |Block|&rdquo; and that there is a production:</p>
      <emu-grammar type="example">
        Block :
          `{` StatementList `}`
      </emu-grammar>
      <p>but the Evaluation operation does not associate an algorithm with that production. In that case, the Evaluation operation implicitly includes an association of the form:</p>
      <p><b>Runtime Semantics: Evaluation</b></p>
      <emu-grammar type="example">Block : `{` StatementList `}`</emu-grammar>
      <emu-alg>
        1. Return the result of evaluating |StatementList|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics">
      <h1>Runtime Semantics</h1>
      <p>Algorithms which specify semantics that must be called at runtime are called <dfn>runtime semantics</dfn>. Runtime semantics are defined by abstract operations or syntax-directed operations. Such algorithms always return a completion record.</p>
      <emu-clause id="sec-implicit-completion-values">
        <h1>Implicit Completion Values</h1>
        <p>The algorithms of this specification often implicitly return Completion Records whose [[Type]] is ~normal~. Unless it is otherwise obvious from the context, an algorithm statement that returns a value that is not a Completion Record, such as:</p>
        <emu-alg>
          1. Return `"Infinity"`.
        </emu-alg>
        <p>means the same thing as:</p>
        <emu-alg>
          1. Return NormalCompletion(`"Infinity"`).
        </emu-alg>
        <p>However, if the value expression of a &ldquo;return&rdquo; statement is a Completion Record construction literal, the resulting Completion Record is returned. If the value expression is a call to an abstract operation, the &ldquo;return&rdquo; statement simply returns the Completion Record produced by the abstract operation.</p>
        <p>The abstract operation Completion(_completionRecord_) is used to emphasize that a previously computed Completion Record is being returned. The Completion abstract operation takes a single argument, _completionRecord_, and performs the following steps:</p>
        <emu-alg>
          1. Assert: _completionRecord_ is a Completion Record.
          1. Return _completionRecord_ as the Completion Record of this abstract operation.
        </emu-alg>
        <p>A &ldquo;return&rdquo; statement without a value in an algorithm step means the same thing as:</p>
        <emu-alg>
          1. Return NormalCompletion(*undefined*).
        </emu-alg>
        <p>Any reference to a Completion Record value that is in a context that does not explicitly require a complete Completion Record value is equivalent to an explicit reference to the [[Value]] field of the Completion Record value unless the Completion Record is an abrupt completion.</p>
      </emu-clause>

      <emu-clause id="sec-throw-an-exception">
        <h1>Throw an Exception</h1>
        <p>Algorithms steps that say to throw an exception, such as</p>
        <emu-alg>
          1. Throw a *TypeError* exception.
        </emu-alg>
        <p>mean the same things as:</p>
        <emu-alg>
          1. Return ThrowCompletion(a newly created *TypeError* object).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-returnifabrupt" aoid="ReturnIfAbrupt">
        <h1>ReturnIfAbrupt</h1>
        <p>Algorithms steps that say or are otherwise equivalent to:</p>
        <emu-alg>
          1. ReturnIfAbrupt(_argument_).
        </emu-alg>
        <p>mean the same thing as:</p>
        <emu-alg>
          1. If _argument_ is an abrupt completion, return _argument_.
          1. Else if _argument_ is a Completion Record, set _argument_ to _argument_.[[Value]].
        </emu-alg>
        <p>Algorithms steps that say or are otherwise equivalent to:</p>
        <emu-alg>
          1. ReturnIfAbrupt(AbstractOperation()).
        </emu-alg>
        <p>mean the same thing as:</p>
        <emu-alg>
          1. Let _hygienicTemp_ be AbstractOperation().
          1. If _hygienicTemp_ is an abrupt completion, return _hygienicTemp_.
          1. Else if _hygienicTemp_ is a Completion Record, set _hygienicTemp_ to _hygienicTemp_.[[Value]].
        </emu-alg>
        <p>Where _hygienicTemp_ is ephemeral and visible only in the steps pertaining to ReturnIfAbrupt.</p>
        <p>Algorithms steps that say or are otherwise equivalent to:</p>
        <emu-alg>
          1. Let _result_ be AbstractOperation(ReturnIfAbrupt(_argument_)).
        </emu-alg>
        <p>mean the same thing as:</p>
        <emu-alg>
          1. If _argument_ is an abrupt completion, return _argument_.
          1. If _argument_ is a Completion Record, set _argument_ to _argument_.[[Value]].
          1. Let _result_ be AbstractOperation(_argument_).
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-returnifabrupt-shorthands">
        <h1>ReturnIfAbrupt Shorthands</h1>
        <p>Invocations of abstract operations and syntax-directed operations that are prefixed by `?` indicate that ReturnIfAbrupt should be applied to the resulting Completion Record. For example, the step:</p>
        <emu-alg>
          1. ? OperationName().
        </emu-alg>
        <p>is equivalent to the following step:</p>
        <emu-alg>
          1. ReturnIfAbrupt(OperationName()).
        </emu-alg>
        <p>Similarly, for method application style, the step:</p>
        <emu-alg>
          1. ? _someValue_.OperationName().
        </emu-alg>
        <p>is equivalent to:</p>
        <emu-alg>
          1. ReturnIfAbrupt(_someValue_.OperationName()).
        </emu-alg>
        <p>Similarly, prefix `!` is used to indicate that the following invocation of an abstract or syntax-directed operation will never return an abrupt completion and that the resulting Completion Record's [[Value]] field should be used in place of the return value of the operation. For example, the step:</p>
        <emu-alg>
          1. Let _val_ be ! OperationName().
        </emu-alg>
        <p>is equivalent to the following steps:</p>
        <emu-alg>
          1. Let _val_ be OperationName().
          1. Assert: _val_ is never an abrupt completion.
          1. If _val_ is a Completion Record, set _val_ to _val_.[[Value]].
        </emu-alg>
        <p>Syntax-directed operations for runtime semantics make use of this shorthand by placing `!` or `?` before the invocation of the operation:</p>
        <emu-alg>
          1. Perform ! SyntaxDirectedOperation of |NonTerminal|.
        </emu-alg>
      </emu-clause>
    </emu-clause>
    <emu-clause id="sec-static-semantic-rules">
      <h1>Static Semantics</h1>
      <p>Context-free grammars are not sufficiently powerful to express all the rules that define whether a stream of input elements form a valid ECMAScript |Script| or |Module| that may be evaluated. In some situations additional rules are needed that may be expressed using either ECMAScript algorithm conventions or prose requirements. Such rules are always associated with a production of a grammar and are called the <dfn>static semantics</dfn> of the production.</p>
      <p>Static Semantic Rules have names and typically are defined using an algorithm. Named Static Semantic Rules are associated with grammar productions and a production that has multiple alternative definitions will typically have for each alternative a distinct algorithm for each applicable named static semantic rule.</p>
      <p>Unless otherwise specified every grammar production alternative in this specification implicitly has a definition for a static semantic rule named Contains which takes an argument named _symbol_ whose value is a terminal or nonterminal of the grammar that includes the associated production. The default definition of Contains is:</p>
      <emu-alg>
        1. For each child node _child_ of this Parse Node, do
          1. If _child_ is an instance of _symbol_, return *true*.
          1. If _child_ is an instance of a nonterminal, then
            1. Let _contained_ be the result of _child_ Contains _symbol_.
            1. If _contained_ is *true*, return *true*.
        1. Return *false*.
      </emu-alg>
      <p>The above definition is explicitly over-ridden for specific productions.</p>
      <p>A special kind of static semantic rule is an <dfn id="early-error-rule">Early Error Rule</dfn>. Early error rules define early error conditions (see clause <emu-xref href="#sec-error-handling-and-language-extensions"></emu-xref>) that are associated with specific grammar productions. Evaluation of most early error rules are not explicitly invoked within the algorithms of this specification. A conforming implementation must, prior to the first evaluation of a |Script| or |Module|, validate all of the early error rules of the productions used to parse that |Script| or |Module|. If any of the early error rules are violated the |Script| or |Module| is invalid and cannot be evaluated.</p>
    </emu-clause>
    <emu-clause id=sec-mathematical-operations>
      <h1>Mathematical Operations</h1>
      <p>Mathematical operations such as addition, subtraction, negation, multiplication, division, and the mathematical functions defined later in this clause should always be understood as computing exact mathematical results on mathematical real numbers, which unless otherwise noted do not include infinities and do not include a negative zero that is distinguished from positive zero. Algorithms in this standard that model floating-point arithmetic include explicit steps, where necessary, to handle infinities and signed zero and to perform rounding. If a mathematical operation or function is applied to a floating-point number, it should be understood as being applied to the exact mathematical value represented by that floating-point number; such a floating-point number must be finite, and if it is *+0* or *-0* then the corresponding mathematical value is simply 0.</p>
      <p>The mathematical function <emu-eqn id="eqn-abs" aoid="abs">abs(_x_)</emu-eqn> produces the absolute value of _x_, which is <emu-eqn>-_x_</emu-eqn> if _x_ is negative (less than zero) and otherwise is _x_ itself.</p>
      <p>The mathematical function <emu-eqn id="eqn-min" aoid="min">min(_x1_, _x2_, ..., _xN_)</emu-eqn> produces the mathematically smallest of <emu-eqn>_x1_</emu-eqn> through <emu-eqn>_xN_</emu-eqn>. The mathematical function <emu-eqn id="eqn-max" aoid="max">max(_x1_, _x2_, ..., _xN_)</emu-eqn> produces the mathematically largest of <emu-eqn>_x1_</emu-eqn> through <emu-eqn>_xN_</emu-eqn>. The domain and range of these mathematical functions include *+&infin;* and *-&infin;*.</p>
      <p>The notation &ldquo;<emu-eqn id="eqn-modulo" aoid="modulo">_x_ modulo _y_</emu-eqn>&rdquo; (_y_ must be finite and nonzero) computes a value _k_ of the same sign as _y_ (or zero) such that <emu-eqn>abs(_k_) &lt; abs(_y_) and _x_ - _k_ = _q_ &times; _y_</emu-eqn> for some integer _q_.</p>
      <p>The mathematical function <emu-eqn id="eqn-floor" aoid="floor">floor(_x_)</emu-eqn> produces the largest integer (closest to positive infinity) that is not larger than _x_.</p>
      <emu-note>
        <p><emu-eqn>floor(_x_) = _x_ - (_x_ modulo 1)</emu-eqn>.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-data-types-and-values" aoid="Type">
  <h1>ECMAScript Data Types and Values</h1>
  <p>Algorithms within this specification manipulate values each of which has an associated type. The possible value types are exactly those defined in this clause. Types are further subclassified into ECMAScript language types and specification types.</p>
  <p>Within this specification, the notation &ldquo;Type(_x_)&rdquo; is used as shorthand for &ldquo;the <dfn id="type">type</dfn> of _x_&rdquo; where &ldquo;type&rdquo; refers to the ECMAScript language and specification types defined in this clause. When the term &ldquo;empty&rdquo; is used as if it was naming a value, it is equivalent to saying &ldquo;no value of any type&rdquo;.</p>

  <emu-clause id="sec-ecmascript-language-types">
    <h1>ECMAScript Language Types</h1>
    <p>An <dfn>ECMAScript language type</dfn> corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Symbol, Number, and Object. An <dfn>ECMAScript language value</dfn> is a value that is characterized by an ECMAScript language type.</p>

    <emu-clause id="sec-ecmascript-language-types-undefined-type">
      <h1>The Undefined Type</h1>
      <p>The Undefined type has exactly one value, called *undefined*. Any variable that has not been assigned a value has the value *undefined*.</p>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-null-type">
      <h1>The Null Type</h1>
      <p>The Null type has exactly one value, called *null*.</p>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-boolean-type">
      <h1>The Boolean Type</h1>
      <p>The Boolean type represents a logical entity having two values, called *true* and *false*.</p>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-string-type">
      <h1>The String Type</h1>
      <p>The String type is the set of all ordered sequences of zero or more 16-bit unsigned integer values (&ldquo;elements&rdquo;) up to a maximum length of 2<sup>53</sup> - 1 elements. The String type is generally used to represent textual data in a running ECMAScript program, in which case each element in the String is treated as a UTF-16 code unit value. Each element is regarded as occupying a position within the sequence. These positions are indexed with nonnegative integers. The first element (if any) is at index 0, the next element (if any) at index 1, and so on. The length of a String is the number of elements (i.e., 16-bit values) within it. The empty String has length zero and therefore contains no elements.</p>
      <p>ECMAScript operations that do not interpret String contents apply no further semantics. Operations that do interpret String values treat each element as a single UTF-16 code unit. However, ECMAScript does not restrict the value of or relationships between these code units, so operations that further interpret String contents as sequences of Unicode code points encoded in UTF-16 must account for ill-formed subsequences. Such operations apply special treatment to every code unit with a numeric value in the inclusive range 0xD800 to 0xDBFF (defined by the Unicode Standard as a <dfn id="leading-surrogate">leading surrogate</dfn>, or more formally as a <dfn id="high-surrogate-code-unit">high-surrogate code unit</dfn>) and every code unit with a numeric value in the inclusive range 0xDC00 to 0xDFFF (defined as a <dfn id="trailing-surrogate">trailing surrogate</dfn>, or more formally as a <dfn id="low-surrogate-code-unit">low-surrogate code unit</dfn>) using the following rules:</p>
      <ul>
        <li>
          A code unit that is not a <emu-xref href="#leading-surrogate"></emu-xref> and not a <emu-xref href="#trailing-surrogate"></emu-xref> is interpreted as a code point with the same value.
        </li>
        <li>
          A sequence of two code units, where the first code unit _c1_ is a <emu-xref href="#leading-surrogate"></emu-xref> and the second code unit _c2_ a <emu-xref href="#trailing-surrogate"></emu-xref>, is a <dfn id="surrogate-pair">surrogate pair</dfn> and is interpreted as a code point with the value (_c1_ - 0xD800) &times; 0x400 + (_c2_ - 0xDC00) + 0x10000. (See <emu-xref href="#sec-utf16decode"></emu-xref>)
        </li>
        <li>
          A code unit that is a <emu-xref href="#leading-surrogate"></emu-xref> or <emu-xref href="#trailing-surrogate"></emu-xref>, but is not part of a <emu-xref href="#surrogate-pair"></emu-xref>, is interpreted as a code point with the same value.
        </li>
      </ul>
      <p>The function `String.prototype.normalize` (see <emu-xref href="#sec-string.prototype.normalize"></emu-xref>) can be used to explicitly normalize a String value. `String.prototype.localeCompare` (see <emu-xref href="#sec-string.prototype.localecompare"></emu-xref>) internally normalizes String values, but no other operations implicitly normalize the strings upon which they operate. Only operations that are explicitly specified to be language or locale sensitive produce language-sensitive results.</p>
      <emu-note>
        <p>The rationale behind this design was to keep the implementation of Strings as simple and high-performing as possible. If ECMAScript source text is in Normalized Form C, string literals are guaranteed to also be normalized, as long as they do not contain any Unicode escape sequences.</p>
      </emu-note>
      <p>In this specification, the phrase "the <dfn>string-concatenation</dfn> of _A_, _B_, ..." (where each argument is a String value, a code unit, or a sequence of code units) denotes the String value whose sequence of code units is the concatenation of the code units (in order) of each of the arguments (in order).</p>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-symbol-type">
      <h1>The Symbol Type</h1>
      <p>The Symbol type is the set of all non-String values that may be used as the key of an Object property (<emu-xref href="#sec-object-type"></emu-xref>).</p>
      <p>Each possible Symbol value is unique and immutable.</p>
      <p>Each Symbol value immutably holds an associated value called [[Description]] that is either *undefined* or a String value.</p>

      <emu-clause id="sec-well-known-symbols">
        <h1>Well-Known Symbols</h1>
        <p>Well-known symbols are built-in Symbol values that are explicitly referenced by algorithms of this specification. They are typically used as the keys of properties whose values serve as extension points of a specification algorithm. Unless otherwise specified, well-known symbols values are shared by all realms (<emu-xref href="#sec-code-realms"></emu-xref>).</p>
        <p>Within this specification a well-known symbol is referred to by using a notation of the form @@name, where &ldquo;name&rdquo; is one of the values listed in <emu-xref href="#table-1"></emu-xref>.</p>
        <emu-table id="table-1" caption="Well-known Symbols">
          <table>
            <tbody>
            <tr>
              <th>
                Specification Name
              </th>
              <th>
                [[Description]]
              </th>
              <th>
                Value and Purpose
              </th>
            </tr>
            <tr>
              <td>
                @@asyncIterator
              </td>
              <td>
                `"Symbol.asyncIterator"`
              </td>
              <td>
                A method that returns the default AsyncIterator for an object. Called by the semantics of the `for`-`await`-`of` statement.
              </td>
            </tr>
            <tr>
              <td>
                @@hasInstance
              </td>
              <td>
                `"Symbol.hasInstance"`
              </td>
              <td>
                A method that determines if a constructor object recognizes an object as one of the constructor's instances. Called by the semantics of the `instanceof` operator.
              </td>
            </tr>
            <tr>
              <td>
                @@isConcatSpreadable
              </td>
              <td>
                `"Symbol.isConcatSpreadable"`
              </td>
              <td>
                A Boolean valued property that if true indicates that an object should be flattened to its array elements by <emu-xref href="#sec-array.prototype.concat">`Array.prototype.concat`</emu-xref>.
              </td>
            </tr>
            <tr>
              <td>
                @@iterator
              </td>
              <td>
                `"Symbol.iterator"`
              </td>
              <td>
                A method that returns the default Iterator for an object. Called by the semantics of the for-of statement.
              </td>
            </tr>
            <tr>
              <td>
                @@match
              </td>
              <td>
                `"Symbol.match"`
              </td>
              <td>
                A regular expression method that matches the regular expression against a string. Called by the <emu-xref href="#sec-string.prototype.match">`String.prototype.match`</emu-xref> method.
              </td>
            </tr>
            <tr>
              <td>
                @@matchAll
              </td>
              <td>
                `"Symbol.matchAll"`
              </td>
              <td>
                A regular expression method that returns an iterator, that yields matches of the regular expression against a string. Called by the <emu-xhref="#sec-string.prototype.matchall">`String.prototype.matchAll`</emu-xref> method.
              </td>
            </tr>
            <tr>
              <td>
                @@replace
              </td>
              <td>
                `"Symbol.replace"`
              </td>
              <td>
                A regular expression method that replaces matched substrings of a string. Called by the <emu-xref href="#sec-string.prototype.replace">`String.prototype.replace`</emu-xref> method.
              </td>
            </tr>
            <tr>
              <td>
                @@search
              </td>
              <td>
                `"Symbol.search"`
              </td>
              <td>
                A regular expression method that returns the index within a string that matches the regular expression. Called by the <emu-xref href="#sec-string.prototype.search">`String.prototype.search`</emu-xref> method.
              </td>
            </tr>
            <tr>
              <td>
                @@species
              </td>
              <td>
                `"Symbol.species"`
              </td>
              <td>
                A function valued property that is the constructor function that is used to create derived objects.
              </td>
            </tr>
            <tr>
              <td>
                @@split
              </td>
              <td>
                `"Symbol.split"`
              </td>
              <td>
                A regular expression method that splits a string at the indices that match the regular expression. Called by the <emu-xref href="#sec-string.prototype.split">`String.prototype.split`</emu-xref> method.
              </td>
            </tr>
            <tr>
              <td>
                @@toPrimitive
              </td>
              <td>
                `"Symbol.toPrimitive"`
              </td>
              <td>
                A method that converts an object to a corresponding primitive value. Called by the ToPrimitive abstract operation.
              </td>
            </tr>
            <tr>
              <td>
                @@toStringTag
              </td>
              <td>
                `"Symbol.toStringTag"`
              </td>
              <td>
                A String valued property that is used in the creation of the default string description of an object. Accessed by the built-in method <emu-xref href="#sec-object.prototype.tostring">`Object.prototype.toString`</emu-xref>.
              </td>
            </tr>
            <tr>
              <td>
                @@unscopables
              </td>
              <td>
                `"Symbol.unscopables"`
              </td>
              <td>
                An object valued property whose own and inherited property names are property names that are excluded from the `with` environment bindings of the associated object.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-number-type">
      <h1>The Number Type</h1>
      <p>The Number type has exactly 18437736874454810627 (that is, <emu-eqn>2<sup>64</sup> - 2<sup>53</sup> + 3</emu-eqn>) values, representing the double-precision 64-bit binary format IEEE 754-2008 values as specified in the IEEE Standard for Floating-Point Arithmetic, except that the 9007199254740990 (that is, <emu-eqn>2<sup>53</sup> - 2</emu-eqn>) distinct &ldquo;Not-a-Number&rdquo; values of the IEEE Standard are represented in ECMAScript as a single special *NaN* value. (Note that the *NaN* value is produced by the program expression `NaN`.) In some implementations, external code might be able to detect a difference between various Not-a-Number values, but such behaviour is implementation-dependent; to ECMAScript code, all *NaN* values are indistinguishable from each other.</p>
      <emu-note>
        <p>The bit pattern that might be observed in an ArrayBuffer (see <emu-xref href="#sec-arraybuffer-objects"></emu-xref>) or a SharedArrayBuffer (see <emu-xref href="#sec-sharedarraybuffer-objects"></emu-xref>) after a Number value has been stored into it is not necessarily the same as the internal representation of that Number value used by the ECMAScript implementation.</p>
      </emu-note>
      <p>There are two other special values, called *positive Infinity* and *negative Infinity*. For brevity, these values are also referred to for expository purposes by the symbols *+&infin;* and *-&infin;*, respectively. (Note that these two infinite Number values are produced by the program expressions `+Infinity` (or simply `Infinity`) and `-Infinity`.)</p>
      <p>The other 18437736874454810624 (that is, <emu-eqn>2<sup>64</sup> - 2<sup>53</sup></emu-eqn>) values are called the finite numbers. Half of these are positive numbers and half are negative numbers; for every finite positive Number value there is a corresponding negative value having the same magnitude.</p>
      <p>Note that there is both a *positive zero* and a *negative zero*. For brevity, these values are also referred to for expository purposes by the symbols *+0* and *-0*, respectively. (Note that these two different zero Number values are produced by the program expressions `+0` (or simply `0`) and `-0`.)</p>
      <p>The 18437736874454810622 (that is, <emu-eqn>2<sup>64</sup> - 2<sup>53</sup> - 2</emu-eqn>) finite nonzero values are of two kinds:</p>
      <p>18428729675200069632 (that is, <emu-eqn>2<sup>64</sup> - 2<sup>54</sup></emu-eqn>) of them are normalized, having the form</p>
      <div class="math-display">
        _s_ &times; _m_ &times; 2<sup>_e_</sup>
      </div>
      <p>where _s_ is +1 or -1, _m_ is a positive integer less than 2<sup>53</sup> but not less than 2<sup>52</sup>, and _e_ is an integer ranging from -1074 to 971, inclusive.</p>
      <p>The remaining 9007199254740990 (that is, <emu-eqn>2<sup>53</sup> - 2</emu-eqn>) values are denormalized, having the form</p>
      <div class="math-display">
        _s_ &times; _m_ &times; 2<sup>_e_</sup>
      </div>
      <p>where _s_ is +1 or -1, _m_ is a positive integer less than 2<sup>52</sup>, and _e_ is -1074.</p>
      <p>Note that all the positive and negative integers whose magnitude is no greater than 2<sup>53</sup> are representable in the Number type (indeed, the integer 0 has two representations, *+0* and *-0*).</p>
      <p>A finite number has an <em>odd significand</em> if it is nonzero and the integer _m_ used to express it (in one of the two forms shown above) is odd. Otherwise, it has an <em>even significand</em>.</p>
      <p>In this specification, the phrase &ldquo;the Number value for _x_&rdquo; where _x_ represents an exact real mathematical quantity (which might even be an irrational number such as &pi;) means a Number value chosen in the following manner. Consider the set of all finite values of the Number type, with *-0* removed and with two additional values added to it that are not representable in the Number type, namely 2<sup>1024</sup> (which is <emu-eqn>+1 &times; 2<sup>53</sup> &times; 2<sup>971</sup></emu-eqn>) and <emu-eqn>-2<sup>1024</sup></emu-eqn> (which is <emu-eqn>-1 &times; 2<sup>53</sup> &times; 2<sup>971</sup></emu-eqn>). Choose the member of this set that is closest in value to _x_. If two values of the set are equally close, then the one with an even significand is chosen; for this purpose, the two extra values 2<sup>1024</sup> and <emu-eqn>-2<sup>1024</sup></emu-eqn> are considered to have even significands. Finally, if 2<sup>1024</sup> was chosen, replace it with *+&infin;*; if <emu-eqn>-2<sup>1024</sup></emu-eqn> was chosen, replace it with *-&infin;*; if *+0* was chosen, replace it with *-0* if and only if _x_ is less than zero; any other chosen value is used unchanged. The result is the Number value for _x_. (This procedure corresponds exactly to the behaviour of the IEEE 754-2008 roundTiesToEven mode.)</p>
      <p>Some ECMAScript operators deal only with integers in specific ranges such as <emu-eqn>-2<sup>31</sup></emu-eqn> through <emu-eqn>2<sup>31</sup> - 1</emu-eqn>, inclusive, or in the range 0 through <emu-eqn>2<sup>16</sup> - 1</emu-eqn>, inclusive. These operators accept any value of the Number type but first convert each such value to an integer value in the expected range. See the descriptions of the numeric conversion operations in <emu-xref href="#sec-type-conversion"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-object-type">
      <h1>The Object Type</h1>
      <p>An Object is logically a collection of properties. Each property is either a data property, or an accessor property:</p>
      <ul>
        <li>
          A <dfn>data property</dfn> associates a key value with an ECMAScript language value and a set of Boolean attributes.
        </li>
        <li>
          An <dfn>accessor property</dfn> associates a key value with one or two accessor functions, and a set of Boolean attributes. The accessor functions are used to store or retrieve an ECMAScript language value that is associated with the property.
        </li>
      </ul>
      <p>Properties are identified using key values. A property key value is either an ECMAScript String value or a Symbol value. All String and Symbol values, including the empty string, are valid as property keys. A <dfn id="property-name">property name</dfn> is a property key that is a String value.</p>
      <p>An <dfn id="integer-index">integer index</dfn> is a String-valued property key that is a canonical numeric String (see <emu-xref href="#sec-canonicalnumericindexstring"></emu-xref>) and whose numeric value is either *+0* or a positive integer &le; 2<sup>53</sup> - 1. An <dfn id="array-index">array index</dfn> is an integer index whose numeric value _i_ is in the range <emu-eqn>+0 &le; _i_ &lt; 2<sup>32</sup> - 1</emu-eqn>.</p>
      <p>Property keys are used to access properties and their values. There are two kinds of access for properties: <em>get</em> and <em>set</em>, corresponding to value retrieval and assignment, respectively. The properties accessible via get and set access includes both <em>own properties</em> that are a direct part of an object and <em>inherited properties</em> which are provided by another associated object via a property inheritance relationship. Inherited properties may be either own or inherited properties of the associated object. Each own property of an object must each have a key value that is distinct from the key values of the other own properties of that object.</p>
      <p>All objects are logically collections of properties, but there are multiple forms of objects that differ in their semantics for accessing and manipulating their properties. <dfn id="ordinary-objects">Ordinary objects</dfn> are the most common form of objects and have the default object semantics. An <dfn id="exotic-object">exotic object</dfn> is any form of object whose property semantics differ in any way from the default semantics.</p>

      <emu-clause id="sec-property-attributes">
        <h1>Property Attributes</h1>
        <p>Attributes are used in this specification to define and explain the state of Object properties. A data property associates a key value with the attributes listed in <emu-xref href="#table-2"></emu-xref>.</p>
        <emu-table id="table-2" caption="Attributes of a Data Property">
          <table>
            <tbody>
            <tr>
              <th>
                Attribute Name
              </th>
              <th>
                Value Domain
              </th>
              <th>
                Description
              </th>
            </tr>
            <tr>
              <td>
                [[Value]]
              </td>
              <td>
                Any ECMAScript language type
              </td>
              <td>
                The value retrieved by a get access of the property.
              </td>
            </tr>
            <tr>
              <td>
                [[Writable]]
              </td>
              <td>
                Boolean
              </td>
              <td>
                If *false*, attempts by ECMAScript code to change the property's [[Value]] attribute using [[Set]] will not succeed.
              </td>
            </tr>
            <tr>
              <td>
                [[Enumerable]]
              </td>
              <td>
                Boolean
              </td>
              <td>
                If *true*, the property will be enumerated by a for-in enumeration (see <emu-xref href="#sec-for-in-and-for-of-statements"></emu-xref>). Otherwise, the property is said to be non-enumerable.
              </td>
            </tr>
            <tr>
              <td>
                [[Configurable]]
              </td>
              <td>
                Boolean
              </td>
              <td>
                If *false*, attempts to delete the property, change the property to be an accessor property, or change its attributes (other than [[Value]], or changing [[Writable]] to *false*) will fail.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
        <p>An accessor property associates a key value with the attributes listed in <emu-xref href="#table-3"></emu-xref>.</p>
        <emu-table id="table-3" caption="Attributes of an Accessor Property">
          <table>
            <tbody>
            <tr>
              <th>
                Attribute Name
              </th>
              <th>
                Value Domain
              </th>
              <th>
                Description
              </th>
            </tr>
            <tr>
              <td>
                [[Get]]
              </td>
              <td>
                Object | Undefined
              </td>
              <td>
                If the value is an Object it must be a function object. The function's [[Call]] internal method (<emu-xref href="#table-6"></emu-xref>) is called with an empty arguments list to retrieve the property value each time a get access of the property is performed.
              </td>
            </tr>
            <tr>
              <td>
                [[Set]]
              </td>
              <td>
                Object | Undefined
              </td>
              <td>
                If the value is an Object it must be a function object. The function's [[Call]] internal method (<emu-xref href="#table-6"></emu-xref>) is called with an arguments list containing the assigned value as its sole argument each time a set access of the property is performed. The effect of a property's [[Set]] internal method may, but is not required to, have an effect on the value returned by subsequent calls to the property's [[Get]] internal method.
              </td>
            </tr>
            <tr>
              <td>
                [[Enumerable]]
              </td>
              <td>
                Boolean
              </td>
              <td>
                If *true*, the property is to be enumerated by a for-in enumeration (see <emu-xref href="#sec-for-in-and-for-of-statements"></emu-xref>). Otherwise, the property is said to be non-enumerable.
              </td>
            </tr>
            <tr>
              <td>
                [[Configurable]]
              </td>
              <td>
                Boolean
              </td>
              <td>
                If *false*, attempts to delete the property, change the property to be a data property, or change its attributes will fail.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
        <p>If the initial values of a property's attributes are not explicitly specified by this specification, the default value defined in <emu-xref href="#table-4"></emu-xref> is used.</p>
        <emu-table id="table-4" caption="Default Attribute Values">
          <table>
            <tbody>
            <tr>
              <th>
                Attribute Name
              </th>
              <th>
                Default Value
              </th>
            </tr>
            <tr>
              <td>
                [[Value]]
              </td>
              <td>
                *undefined*
              </td>
            </tr>
            <tr>
              <td>
                [[Get]]
              </td>
              <td>
                *undefined*
              </td>
            </tr>
            <tr>
              <td>
                [[Set]]
              </td>
              <td>
                *undefined*
              </td>
            </tr>
            <tr>
              <td>
                [[Writable]]
              </td>
              <td>
                *false*
              </td>
            </tr>
            <tr>
              <td>
                [[Enumerable]]
              </td>
              <td>
                *false*
              </td>
            </tr>
            <tr>
              <td>
                [[Configurable]]
              </td>
              <td>
                *false*
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-object-internal-methods-and-internal-slots">
        <h1>Object Internal Methods and Internal Slots</h1>
        <p>The actual semantics of objects, in ECMAScript, are specified via algorithms called <em>internal methods</em>. Each object in an ECMAScript engine is associated with a set of internal methods that defines its runtime behaviour. These internal methods are not part of the ECMAScript language. They are defined by this specification purely for expository purposes. However, each object within an implementation of ECMAScript must behave as specified by the internal methods associated with it. The exact manner in which this is accomplished is determined by the implementation.</p>
        <p>Internal method names are polymorphic. This means that different object values may perform different algorithms when a common internal method name is invoked upon them. That actual object upon which an internal method is invoked is the &ldquo;target&rdquo; of the invocation. If, at runtime, the implementation of an algorithm attempts to use an internal method of an object that the object does not support, a *TypeError* exception is thrown.</p>
        <p>Internal slots correspond to internal state that is associated with objects and used by various ECMAScript specification algorithms. Internal slots are not object properties and they are not inherited. Depending upon the specific internal slot specification, such state may consist of values of any ECMAScript language type or of specific ECMAScript specification type values. Unless explicitly specified otherwise, internal slots are allocated as part of the process of creating an object and may not be dynamically added to an object. Unless specified otherwise, the initial value of an internal slot is the value *undefined*. Various algorithms within this specification create objects that have internal slots. However, the ECMAScript language provides no direct way to associate internal slots with an object.</p>
        <p>Internal methods and internal slots are identified within this specification using names enclosed in double square brackets [[ ]].</p>
        <p><emu-xref href="#table-5"></emu-xref> summarizes the <em>essential internal methods</em> used by this specification that are applicable to all objects created or manipulated by ECMAScript code. Every object must have algorithms for all of the essential internal methods. However, all objects do not necessarily use the same algorithms for those methods.</p>
        <p>The &ldquo;Signature&rdquo; column of <emu-xref href="#table-5"></emu-xref> and other similar tables describes the invocation pattern for each internal method. The invocation pattern always includes a parenthesized list of descriptive parameter names. If a parameter name is the same as an ECMAScript type name then the name describes the required type of the parameter value. If an internal method explicitly returns a value, its parameter list is followed by the symbol &ldquo;&rarr;&rdquo; and the type name of the returned value. The type names used in signatures refer to the types defined in clause <emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref> augmented by the following additional names. &ldquo;<em>any</em>&rdquo; means the value may be any ECMAScript language type. An internal method implicitly returns a Completion Record. In addition to its parameters, an internal method always has access to the object that is the target of the method invocation.</p>
        <emu-table id="table-5" caption="Essential Internal Methods">
          <table>
            <tbody>
            <tr>
              <th>
                Internal Method
              </th>
              <th>
                Signature
              </th>
              <th>
                Description
              </th>
            </tr>
            <tr>
              <td>
                [[GetPrototypeOf]]
              </td>
              <td>
                ( ) <b>&rarr;</b> Object | Null
              </td>
              <td>
                Determine the object that provides inherited properties for this object. A *null* value indicates that there are no inherited properties.
              </td>
            </tr>
            <tr>
              <td>
                [[SetPrototypeOf]]
              </td>
              <td>
                (Object | Null) <b>&rarr;</b> Boolean
              </td>
              <td>
                Associate this object with another object that provides inherited properties. Passing *null* indicates that there are no inherited properties. Returns *true* indicating that the operation was completed successfully or *false* indicating that the operation was not successful.
              </td>
            </tr>
            <tr>
              <td>
                [[IsExtensible]]
              </td>
              <td>
                ( ) <b>&rarr;</b> Boolean
              </td>
              <td>
                Determine whether it is permitted to add additional properties to this object.
              </td>
            </tr>
            <tr>
              <td>
                [[PreventExtensions]]
              </td>
              <td>
                ( ) <b>&rarr;</b> Boolean
              </td>
              <td>
                Control whether new properties may be added to this object. Returns *true* if the operation was successful or *false* if the operation was unsuccessful.
              </td>
            </tr>
            <tr>
              <td>
                [[GetOwnProperty]]
              </td>
              <td>
                (_propertyKey_) <b>&rarr;</b> Undefined | Property Descriptor
              </td>
              <td>
                Return a Property Descriptor for the own property of this object whose key is _propertyKey_, or *undefined* if no such property exists.
              </td>
            </tr>
            <tr>
              <td>
                [[DefineOwnProperty]]
              </td>
              <td>
                (_propertyKey_, _PropertyDescriptor_) <b>&rarr;</b> Boolean
              </td>
              <td>
                Create or alter the own property, whose key is _propertyKey_, to have the state described by _PropertyDescriptor_. Return *true* if that property was successfully created/updated or *false* if the property could not be created or updated.
              </td>
            </tr>
            <tr>
              <td>
                [[HasProperty]]
              </td>
              <td>
                (_propertyKey_) <b>&rarr;</b> Boolean
              </td>
              <td>
                Return a Boolean value indicating whether this object already has either an own or inherited property whose key is _propertyKey_.
              </td>
            </tr>
            <tr>
              <td>
                [[Get]]
              </td>
              <td>
                (_propertyKey_, _Receiver_) <b>&rarr;</b> <em>any</em>
              </td>
              <td>
                Return the value of the property whose key is _propertyKey_ from this object. If any ECMAScript code must be executed to retrieve the property value, _Receiver_ is used as the *this* value when evaluating the code.
              </td>
            </tr>
            <tr>
              <td>
                [[Set]]
              </td>
              <td>
                (_propertyKey_, _value_, _Receiver_) <b>&rarr;</b> Boolean
              </td>
              <td>
                Set the value of the property whose key is _propertyKey_ to _value_. If any ECMAScript code must be executed to set the property value, _Receiver_ is used as the *this* value when evaluating the code. Returns *true* if the property value was set or *false* if it could not be set.
              </td>
            </tr>
            <tr>
              <td>
                [[Delete]]
              </td>
              <td>
                (_propertyKey_) <b>&rarr;</b> Boolean
              </td>
              <td>
                Remove the own property whose key is _propertyKey_ from this object. Return *false* if the property was not deleted and is still present. Return *true* if the property was deleted or is not present.
              </td>
            </tr>
            <tr>
              <td>
                [[OwnPropertyKeys]]
              </td>
              <td>
                ( ) <b>&rarr;</b> List of propertyKey
              </td>
              <td>
                Return a List whose elements are all of the own property keys for the object.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
        <p><emu-xref href="#table-6"></emu-xref> summarizes additional essential internal methods that are supported by objects that may be called as functions. A <dfn id="function-object">function object</dfn> is an object that supports the [[Call]] internal method. A <dfn id="constructor">constructor</dfn> is an object that supports the [[Construct]] internal method. Every object that supports [[Construct]] must support [[Call]]; that is, every constructor must be a function object. Therefore, a constructor may also be referred to as a <em>constructor function</em> or <em>constructor function object</em>.</p>
        <emu-table id="table-6" caption="Additional Essential Internal Methods of Function Objects">
          <table>
            <tbody>
            <tr>
              <th>
                Internal Method
              </th>
              <th>
                Signature
              </th>
              <th>
                Description
              </th>
            </tr>
            <tr>
              <td>
                [[Call]]
              </td>
              <td>
                (<em>any</em>, a List of <em>any</em>) <b>&rarr;</b> <em>any</em>
              </td>
              <td>
                Executes code associated with this object. Invoked via a function call expression. The arguments to the internal method are a *this* value and a list containing the arguments passed to the function by a call expression. Objects that implement this internal method are <em>callable</em>.
              </td>
            </tr>
            <tr>
              <td>
                [[Construct]]
              </td>
              <td>
                (a List of <em>any</em>, Object) <b>&rarr;</b> Object
              </td>
              <td>
                Creates an object. Invoked via the `new` or `super` operators. The first argument to the internal method is a list containing the arguments of the operator. The second argument is the object to which the `new` operator was initially applied. Objects that implement this internal method are called <em>constructors</em>. A function object is not necessarily a constructor and such non-constructor function objects do not have a [[Construct]] internal method.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
        <p>The semantics of the essential internal methods for ordinary objects and standard exotic objects are specified in clause <emu-xref href="#sec-ordinary-and-exotic-objects-behaviours"></emu-xref>. If any specified use of an internal method of an exotic object is not supported by an implementation, that usage must throw a *TypeError* exception when attempted.</p>
      </emu-clause>

      <emu-clause id="sec-invariants-of-the-essential-internal-methods">
        <h1>Invariants of the Essential Internal Methods</h1>
        <p>The Internal Methods of Objects of an ECMAScript engine must conform to the list of invariants specified below. Ordinary ECMAScript Objects as well as all standard exotic objects in this specification maintain these invariants. ECMAScript Proxy objects maintain these invariants by means of runtime checks on the result of traps invoked on the [[ProxyHandler]] object.</p>
        <p>Any implementation provided exotic objects must also maintain these invariants for those objects. Violation of these invariants may cause ECMAScript code to have unpredictable behaviour and create security issues. However, violation of these invariants must never compromise the memory safety of an implementation.</p>
        <p>An implementation must not allow these invariants to be circumvented in any manner such as by providing alternative interfaces that implement the functionality of the essential internal methods without enforcing their invariants.</p>
        <h2>Definitions:</h2>
        <ul>
          <li>
            The <em>target</em> of an internal method is the object upon which the internal method is called.
          </li>
          <li>
            A target is <em>non-extensible</em> if it has been observed to return *false* from its [[IsExtensible]] internal method, or *true* from its [[PreventExtensions]] internal method.
          </li>
          <li>
            A <em>non-existent</em> property is a property that does not exist as an own property on a non-extensible target.
          </li>
          <li>
            All references to <em>SameValue</em> are according to the definition of the SameValue algorithm.
          </li>
        </ul>
        <h2>[[GetPrototypeOf]] ( )</h2>
        <ul>
          <li>
            The Type of the return value must be either Object or Null.
          </li>
          <li>
            If target is non-extensible, and [[GetPrototypeOf]] returns a value _V_, then any future calls to [[GetPrototypeOf]] should return the SameValue as _V_.
          </li>
        </ul>
        <emu-note>
          <p>An object's prototype chain should have finite length (that is, starting from any object, recursively applying the [[GetPrototypeOf]] internal method to its result should eventually lead to the value *null*). However, this requirement is not enforceable as an object level invariant if the prototype chain includes any exotic objects that do not use the ordinary object definition of [[GetPrototypeOf]]. Such a circular prototype chain may result in infinite loops when accessing object properties.</p>
        </emu-note>
        <h2>[[SetPrototypeOf]] ( _V_ )</h2>
        <ul>
          <li>
            The Type of the return value must be Boolean.
          </li>
          <li>
            If target is non-extensible, [[SetPrototypeOf]] must return *false*, unless _V_ is the SameValue as the target's observed [[GetPrototypeOf]] value.
          </li>
        </ul>
        <h2>[[IsExtensible]] ( )</h2>
        <ul>
          <li>
            The Type of the return value must be Boolean.
          </li>
          <li>
            If [[IsExtensible]] returns *false*, all future calls to [[IsExtensible]] on the target must return *false*.
          </li>
        </ul>
        <h2>[[PreventExtensions]] ( )</h2>
        <ul>
          <li>
            The Type of the return value must be Boolean.
          </li>
          <li>
            If [[PreventExtensions]] returns *true*, all future calls to [[IsExtensible]] on the target must return *false* and the target is now considered non-extensible.
          </li>
        </ul>
        <h2>[[GetOwnProperty]] ( _P_ )</h2>
        <ul>
          <li>
            The Type of the return value must be either Property Descriptor or Undefined.
          </li>
          <li>
            If the Type of the return value is Property Descriptor, the return value must be a <emu-xref href="#sec-completepropertydescriptor">complete property descriptor</emu-xref>.
          </li>
          <li>
            If _P_ is described as a non-configurable, non-writable own data property, all future calls to [[GetOwnProperty]] ( _P_ ) must return Property Descritor whose [[Value]] is SameValue as _P_'s [[Value]] attribute.
          </li>
          <li>
            If _P_'s attributes other than [[Writable]] may change over time or if the property might be deleted, then _P_'s [[Configurable]] attribute must be *true*.
          </li>
          <li>
            If the [[Writable]] attribute may change from *false* to *true*, then the [[Configurable]] attribute must be *true*.
          </li>
          <li>
            If the target is non-extensible and _P_ is non-existent, then all future calls to [[GetOwnProperty]] (_P_) on the target must describe _P_ as non-existent (i.e. [[GetOwnProperty]] (_P_) must return *undefined*).
          </li>
        </ul>
        <emu-note>
          <p>As a consequence of the third invariant, if a property is described as a data property and it may return different values over time, then either or both of the [[Writable]] and [[Configurable]] attributes must be *true* even if no mechanism to change the value is exposed via the other internal methods.</p>
        </emu-note>
        <h2>[[DefineOwnProperty]] ( _P_, _Desc_ )</h2>
        <ul>
          <li>
            The Type of the return value must be Boolean.
          </li>
          <li>
            [[DefineOwnProperty]] must return *false* if _P_ has previously been observed as a non-configurable own property of the target, unless either:
            <ol>
              <li>
                _P_ is a writable data property. A non-configurable writable data property can be changed into a non-configurable non-writable data property.
              </li>
              <li>
                All attributes of _Desc_ are the SameValue as _P_'s attributes.
              </li>
            </ol>
          </li>
          <li>
            [[DefineOwnProperty]] (_P_, _Desc_) must return *false* if target is non-extensible and _P_ is a non-existent own property. That is, a non-extensible target object cannot be extended with new properties.
          </li>
        </ul>
        <h2>[[HasProperty]] ( _P_ )</h2>
        <ul>
          <li>
            The Type of the return value must be Boolean.
          </li>
          <li>
            If _P_ was previously observed as a non-configurable own data or accessor property of the target, [[HasProperty]] must return *true*.
          </li>
        </ul>
        <h2>[[Get]] ( _P_, _Receiver_ )</h2>
        <ul>
          <li>
            If _P_ was previously observed as a non-configurable, non-writable own data property of the target with value _V_, then [[Get]] must return the SameValue as _V_.
          </li>
          <li>
            If _P_ was previously observed as a non-configurable own accessor property of the target whose [[Get]] attribute is *undefined*, the [[Get]] operation must return *undefined*.
          </li>
        </ul>
        <h2>[[Set]] ( _P_, _V_, _Receiver_ )</h2>
        <ul>
          <li>
            The Type of the return value must be Boolean.
          </li>
          <li>
            If _P_ was previously observed as a non-configurable, non-writable own data property of the target, then [[Set]] must return *false* unless _V_ is the SameValue as _P_'s [[Value]] attribute.
          </li>
          <li>
            If _P_ was previously observed as a non-configurable own accessor property of the target whose [[Set]] attribute is *undefined*, the [[Set]] operation must return *false*.
          </li>
        </ul>
        <h2>[[Delete]] ( _P_ )</h2>
        <ul>
          <li>
            The Type of the return value must be Boolean.
          </li>
          <li>
            If _P_ was previously observed as a non-configurable own data or accessor property of the target, [[Delete]] must return *false*.
          </li>
        </ul>
        <h2>[[OwnPropertyKeys]] ( )</h2>
        <ul>
          <li>
            The return value must be a List.
          </li>
          <li>
            The returned List must not contain any duplicate entries.
          </li>
          <li>
            The Type of each element of the returned List is either String or Symbol.
          </li>
          <li>
            The returned List must contain at least the keys of all non-configurable own properties that have previously been observed.
          </li>
          <li>
            If the object is non-extensible, the returned List must contain only the keys of all own properties of the object that are observable using [[GetOwnProperty]].
          </li>
        </ul>
        <h2>[[Construct]] ( )</h2>
        <ul>
          <li>
            The Type of the return value must be Object.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-well-known-intrinsic-objects">
        <h1>Well-Known Intrinsic Objects</h1>
        <p>Well-known intrinsics are built-in objects that are explicitly referenced by the algorithms of this specification and which usually have realm-specific identities. Unless otherwise specified each intrinsic object actually corresponds to a set of similar objects, one per realm.</p>
        <p>Within this specification a reference such as %name% means the intrinsic object, associated with the current realm, corresponding to the name. Determination of the current realm and its intrinsics is described in <emu-xref href="#sec-execution-contexts"></emu-xref>. The well-known intrinsics are listed in <emu-xref href="#table-7"></emu-xref>.</p>
        <emu-table id="table-7" caption="Well-Known Intrinsic Objects">
          <table>
            <tbody>
            <tr>
              <th>
                Intrinsic Name
              </th>
              <th>
                Global Name
              </th>
              <th>
                ECMAScript Language Association
              </th>
            </tr>
            <tr>
              <td>
                %Array%
              </td>
              <td>
                `Array`
              </td>
              <td>
                The `Array` constructor (<emu-xref href="#sec-array-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ArrayBuffer%
              </td>
              <td>
                `ArrayBuffer`
              </td>
              <td>
                The `ArrayBuffer` constructor (<emu-xref href="#sec-arraybuffer-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ArrayBufferPrototype%
              </td>
              <td>
                `ArrayBuffer.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %ArrayBuffer%.
              </td>
            </tr>
            <tr>
              <td>
                %ArrayIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of Array iterator objects (<emu-xref href="#sec-array-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ArrayPrototype%
              </td>
              <td>
                `Array.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %Array% (<emu-xref href="#sec-properties-of-the-array-prototype-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ArrayProto_entries%
              </td>
              <td>
                `Array.prototype.entries`
              </td>
              <td>
                The initial value of the `entries` data property of %ArrayPrototype% (<emu-xref href="#sec-array.prototype.entries"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ArrayProto_forEach%
              </td>
              <td>
                `Array.prototype.forEach`
              </td>
              <td>
                The initial value of the `forEach` data property of %ArrayPrototype% (<emu-xref href="#sec-array.prototype.foreach"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ArrayProto_keys%
              </td>
              <td>
                `Array.prototype.keys`
              </td>
              <td>
                The initial value of the `keys` data property of %ArrayPrototype% (<emu-xref href="#sec-array.prototype.keys"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ArrayProto_values%
              </td>
              <td>
                `Array.prototype.values`
              </td>
              <td>
                The initial value of the `values` data property of %ArrayPrototype% (<emu-xref href="#sec-array.prototype.values"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncFromSyncIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of async-from-sync iterator objects (<emu-xref href="#sec-async-from-sync-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncFunction%
              </td>
              <td>
              </td>
              <td>
                The constructor of async function objects (<emu-xref href="#sec-async-function-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncFunctionPrototype%
              </td>
              <td>
              </td>
              <td>
                The initial value of the `prototype` data property of %AsyncFunction%
              </td>
            </tr>
            <tr>
              <td>
                %AsyncGenerator%
              </td>
              <td>
              </td>
              <td>
                The initial value of the `prototype` property of %AsyncGeneratorFunction%
              </td>
            </tr>
            <tr>
              <td>
                %AsyncGeneratorFunction%
              </td>
              <td>
              </td>
              <td>
                The constructor of async iterator objects (<emu-xref href="#sec-asyncgeneratorfunction-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncGeneratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The initial value of the `prototype` property of %AsyncGenerator%
              </td>
            </tr>
            <tr>
              <td>
                %AsyncIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                An object that all standard built-in async iterator objects indirectly inherit from
              </td>
            </tr>
            <tr>
              <td>
                %Atomics%
              </td>
              <td>
                `Atomics`
              </td>
              <td>
                The `Atomics` object (<emu-xref href="#sec-atomics-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Boolean%
              </td>
              <td>
                `Boolean`
              </td>
              <td>
                The `Boolean` constructor (<emu-xref href="#sec-boolean-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %BooleanPrototype%
              </td>
              <td>
                `Boolean.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %Boolean% (<emu-xref href="#sec-properties-of-the-boolean-prototype-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %DataView%
              </td>
              <td>
                `DataView`
              </td>
              <td>
                The `DataView` constructor (<emu-xref href="#sec-dataview-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %DataViewPrototype%
              </td>
              <td>
                `DataView.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %DataView%
              </td>
            </tr>
            <tr>
              <td>
                %Date%
              </td>
              <td>
                `Date`
              </td>
              <td>
                The `Date` constructor (<emu-xref href="#sec-date-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %DatePrototype%
              </td>
              <td>
                `Date.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %Date%.
              </td>
            </tr>
            <tr>
              <td>
                %decodeURI%
              </td>
              <td>
                `decodeURI`
              </td>
              <td>
                The `decodeURI` function (<emu-xref href="#sec-decodeuri-encodeduri"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %decodeURIComponent%
              </td>
              <td>
                `decodeURIComponent`
              </td>
              <td>
                The `decodeURIComponent` function (<emu-xref href="#sec-decodeuricomponent-encodeduricomponent"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %encodeURI%
              </td>
              <td>
                `encodeURI`
              </td>
              <td>
                The `encodeURI` function (<emu-xref href="#sec-encodeuri-uri"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %encodeURIComponent%
              </td>
              <td>
                `encodeURIComponent`
              </td>
              <td>
                The `encodeURIComponent` function (<emu-xref href="#sec-encodeuricomponent-uricomponent"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Error%
              </td>
              <td>
                `Error`
              </td>
              <td>
                The `Error` constructor (<emu-xref href="#sec-error-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ErrorPrototype%
              </td>
              <td>
                `Error.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %Error%
              </td>
            </tr>
            <tr>
              <td>
                %eval%
              </td>
              <td>
                `eval`
              </td>
              <td>
                The `eval` function (<emu-xref href="#sec-eval-x"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %EvalError%
              </td>
              <td>
                `EvalError`
              </td>
              <td>
                The `EvalError` constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-evalerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %EvalErrorPrototype%
              </td>
              <td>
                `EvalError.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %EvalError%
              </td>
            </tr>
            <tr>
              <td>
                %Float32Array%
              </td>
              <td>
                `Float32Array`
              </td>
              <td>
                The `Float32Array` constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Float32ArrayPrototype%
              </td>
              <td>
                `Float32Array.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %Float32Array%
              </td>
            </tr>
            <tr>
              <td>
                %Float64Array%
              </td>
              <td>
                `Float64Array`
              </td>
              <td>
                The `Float64Array` constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Float64ArrayPrototype%
              </td>
              <td>
                `Float64Array.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %Float64Array%
              </td>
            </tr>
            <tr>
              <td>
                %Function%
              </td>
              <td>
                `Function`
              </td>
              <td>
                The `Function` constructor (<emu-xref href="#sec-function-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %FunctionPrototype%
              </td>
              <td>
                `Function.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %Function%
              </td>
            </tr>
            <tr>
              <td>
                %Generator%
              </td>
              <td>
              </td>
              <td>
                The initial value of the `prototype` data property of %GeneratorFunction%
              </td>
            </tr>
            <tr>
              <td>
                %GeneratorFunction%
              </td>
              <td>
              </td>
              <td>
                The constructor of generator objects (<emu-xref href="#sec-generatorfunction-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %GeneratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The initial value of the `prototype` data property of %Generator%
              </td>
            </tr>
            <tr>
              <td>
                %Int8Array%
              </td>
              <td>
                `Int8Array`
              </td>
              <td>
                The `Int8Array` constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Int8ArrayPrototype%
              </td>
              <td>
                `Int8Array.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %Int8Array%
              </td>
            </tr>
            <tr>
              <td>
                %Int16Array%
              </td>
              <td>
                `Int16Array`
              </td>
              <td>
                The `Int16Array` constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Int16ArrayPrototype%
              </td>
              <td>
                `Int16Array.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %Int16Array%
              </td>
            </tr>
            <tr>
              <td>
                %Int32Array%
              </td>
              <td>
                `Int32Array`
              </td>
              <td>
                The `Int32Array` constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Int32ArrayPrototype%
              </td>
              <td>
                `Int32Array.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %Int32Array%
              </td>
            </tr>
            <tr>
              <td>
                %isFinite%
              </td>
              <td>
                `isFinite`
              </td>
              <td>
                The `isFinite` function (<emu-xref href="#sec-isfinite-number"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %isNaN%
              </td>
              <td>
                `isNaN`
              </td>
              <td>
                The `isNaN` function (<emu-xref href="#sec-isnan-number"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %IteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                An object that all standard built-in iterator objects indirectly inherit from
              </td>
            </tr>
            <tr>
              <td>
                %JSON%
              </td>
              <td>
                `JSON`
              </td>
              <td>
                The `JSON` object (<emu-xref href="#sec-json-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %JSONParse%
              </td>
              <td>
                `JSON.parse`
              </td>
              <td>
                The initial value of the `parse` data property of %JSON%
              </td>
            </tr>
            <tr>
              <td>
                %JSONStringify%
              </td>
              <td>
                `JSON.stringify`
              </td>
              <td>
                The initial value of the `stringify` data property of %JSON%
              </td>
            </tr>
            <tr>
              <td>
                %Map%
              </td>
              <td>
                `Map`
              </td>
              <td>
                The `Map` constructor (<emu-xref href="#sec-map-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %MapIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of Map iterator objects (<emu-xref href="#sec-map-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %MapPrototype%
              </td>
              <td>
                `Map.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %Map%
              </td>
            </tr>
            <tr>
              <td>
                %Math%
              </td>
              <td>
                `Math`
              </td>
              <td>
                The `Math` object (<emu-xref href="#sec-math-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Number%
              </td>
              <td>
                `Number`
              </td>
              <td>
                The `Number` constructor (<emu-xref href="#sec-number-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %NumberPrototype%
              </td>
              <td>
                `Number.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %Number%
              </td>
            </tr>
            <tr>
              <td>
                %Object%
              </td>
              <td>
                `Object`
              </td>
              <td>
                The `Object` constructor (<emu-xref href="#sec-object-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ObjectPrototype%
              </td>
              <td>
                `Object.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %Object% (<emu-xref href="#sec-properties-of-the-object-prototype-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ObjProto_toString%
              </td>
              <td>
                `Object.prototype.toString`
              </td>
              <td>
                The initial value of the `toString` data property of %ObjectPrototype% (<emu-xref href="#sec-object.prototype.tostring"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ObjProto_valueOf%
              </td>
              <td>
                `Object.prototype.valueOf`
              </td>
              <td>
                The initial value of the `valueOf` data property of %ObjectPrototype% (<emu-xref href="#sec-object.prototype.valueof"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %parseFloat%
              </td>
              <td>
                `parseFloat`
              </td>
              <td>
                The `parseFloat` function (<emu-xref href="#sec-parsefloat-string"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %parseInt%
              </td>
              <td>
                `parseInt`
              </td>
              <td>
                The `parseInt` function (<emu-xref href="#sec-parseint-string-radix"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Promise%
              </td>
              <td>
                `Promise`
              </td>
              <td>
                The `Promise` constructor (<emu-xref href="#sec-promise-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %PromisePrototype%
              </td>
              <td>
                `Promise.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %Promise%
              </td>
            </tr>
            <tr>
              <td>
                %PromiseProto_then%
              </td>
              <td>
                `Promise.prototype.then`
              </td>
              <td>
                The initial value of the `then` data property of %PromisePrototype% (<emu-xref href="#sec-promise.prototype.then"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Promise_all%
              </td>
              <td>
                `Promise.all`
              </td>
              <td>
                The initial value of the `all` data property of %Promise% (<emu-xref href="#sec-promise.all"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Promise_reject%
              </td>
              <td>
                `Promise.reject`
              </td>
              <td>
                The initial value of the `reject` data property of %Promise% (<emu-xref href="#sec-promise.reject"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Promise_resolve%
              </td>
              <td>
                `Promise.resolve`
              </td>
              <td>
                The initial value of the `resolve` data property of %Promise% (<emu-xref href="#sec-promise.resolve"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Proxy%
              </td>
              <td>
                `Proxy`
              </td>
              <td>
                The `Proxy` constructor (<emu-xref href="#sec-proxy-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %RangeError%
              </td>
              <td>
                `RangeError`
              </td>
              <td>
                The `RangeError` constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-rangeerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %RangeErrorPrototype%
              </td>
              <td>
                `RangeError.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %RangeError%
              </td>
            </tr>
            <tr>
              <td>
                %ReferenceError%
              </td>
              <td>
                `ReferenceError`
              </td>
              <td>
                The `ReferenceError` constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-referenceerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ReferenceErrorPrototype%
              </td>
              <td>
                `ReferenceError.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %ReferenceError%
              </td>
            </tr>
            <tr>
              <td>
                %Reflect%
              </td>
              <td>
                `Reflect`
              </td>
              <td>
                The `Reflect` object (<emu-xref href="#sec-reflect-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %RegExp%
              </td>
              <td>
                `RegExp`
              </td>
              <td>
                The `RegExp` constructor (<emu-xref href="#sec-regexp-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %RegExpPrototype%
              </td>
              <td>
                `RegExp.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %RegExp%
              </td>
            </tr>
            <tr>
              <td>
                %Set%
              </td>
              <td>
                `Set`
              </td>
              <td>
                The `Set` constructor (<emu-xref href="#sec-set-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SetIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of Set iterator objects (<emu-xref href="#sec-set-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SetPrototype%
              </td>
              <td>
                `Set.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %Set%
              </td>
            </tr>
            <tr>
              <td>
                %SharedArrayBuffer%
              </td>
              <td>
                `SharedArrayBuffer`
              </td>
              <td>
                The `SharedArrayBuffer` constructor (<emu-xref href="#sec-sharedarraybuffer-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SharedArrayBufferPrototype%
              </td>
              <td>
                `SharedArrayBuffer.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %SharedArrayBuffer%
              </td>
            </tr>
            <tr>
              <td>
                %String%
              </td>
              <td>
                `String`
              </td>
              <td>
                The `String` constructor (<emu-xref href="#sec-string-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %StringIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of String iterator objects (<emu-xref href="#sec-string-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %StringPrototype%
              </td>
              <td>
                `String.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %String%
              </td>
            </tr>
            <tr>
              <td>
                %Symbol%
              </td>
              <td>
                `Symbol`
              </td>
              <td>
                The `Symbol` constructor (<emu-xref href="#sec-symbol-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SymbolPrototype%
              </td>
              <td>
                `Symbol.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %Symbol% (<emu-xref href="#sec-properties-of-the-symbol-prototype-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SyntaxError%
              </td>
              <td>
                `SyntaxError`
              </td>
              <td>
                The `SyntaxError` constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-syntaxerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SyntaxErrorPrototype%
              </td>
              <td>
                `SyntaxError.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %SyntaxError%
              </td>
            </tr>
            <tr>
              <td>
                %ThrowTypeError%
              </td>
              <td>
              </td>
              <td>
                A function object that unconditionally throws a new instance of %TypeError%
              </td>
            </tr>
            <tr>
              <td>
                %TypedArray%
              </td>
              <td>
              </td>
              <td>
                The super class of all typed Array constructors (<emu-xref href="#sec-%typedarray%-intrinsic-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %TypedArrayPrototype%
              </td>
              <td>
              </td>
              <td>
                The initial value of the `prototype` data property of %TypedArray%
              </td>
            </tr>
            <tr>
              <td>
                %TypeError%
              </td>
              <td>
                `TypeError`
              </td>
              <td>
                The `TypeError` constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-typeerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %TypeErrorPrototype%
              </td>
              <td>
                `TypeError.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %TypeError%
              </td>
            </tr>
            <tr>
              <td>
                %Uint8Array%
              </td>
              <td>
                `Uint8Array`
              </td>
              <td>
                The `Uint8Array` constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint8ArrayPrototype%
              </td>
              <td>
                `Uint8Array.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %Uint8Array%
              </td>
            </tr>
            <tr>
              <td>
                %Uint8ClampedArray%
              </td>
              <td>
                `Uint8ClampedArray`
              </td>
              <td>
                The `Uint8ClampedArray` constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint8ClampedArrayPrototype%
              </td>
              <td>
                `Uint8ClampedArray.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %Uint8ClampedArray%
              </td>
            </tr>
            <tr>
              <td>
                %Uint16Array%
              </td>
              <td>
                `Uint16Array`
              </td>
              <td>
                The `Uint16Array` constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint16ArrayPrototype%
              </td>
              <td>
                `Uint16Array.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %Uint16Array%
              </td>
            </tr>
            <tr>
              <td>
                %Uint32Array%
              </td>
              <td>
                `Uint32Array`
              </td>
              <td>
                The `Uint32Array` constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint32ArrayPrototype%
              </td>
              <td>
                `Uint32Array.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %Uint32Array%
              </td>
            </tr>
            <tr>
              <td>
                %URIError%
              </td>
              <td>
                `URIError`
              </td>
              <td>
                The `URIError` constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-urierror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %URIErrorPrototype%
              </td>
              <td>
                `URIError.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %URIError%
              </td>
            </tr>
            <tr>
              <td>
                %WeakMap%
              </td>
              <td>
                `WeakMap`
              </td>
              <td>
                The `WeakMap` constructor (<emu-xref href="#sec-weakmap-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %WeakMapPrototype%
              </td>
              <td>
                `WeakMap.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %WeakMap%
              </td>
            </tr>
            <tr>
              <td>
                %WeakSet%
              </td>
              <td>
                `WeakSet`
              </td>
              <td>
                The `WeakSet` constructor (<emu-xref href="#sec-weakset-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %WeakSetPrototype%
              </td>
              <td>
                `WeakSet.prototype`
              </td>
              <td>
                The initial value of the `prototype` data property of %WeakSet%
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-ecmascript-specification-types">
    <h1>ECMAScript Specification Types</h1>
    <p>A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. The specification types include Reference, List, Completion, Property Descriptor, Lexical Environment, Environment Record, and Data Block. Specification type values are specification artefacts that do not necessarily correspond to any specific entity within an ECMAScript implementation. Specification type values may be used to describe intermediate results of ECMAScript expression evaluation but such values cannot be stored as properties of objects or values of ECMAScript language variables.</p>

    <emu-clause id="sec-list-and-record-specification-type">
      <h1>The List and Record Specification Types</h1>
      <p>The <dfn>List</dfn> type is used to explain the evaluation of argument lists (see <emu-xref href="#sec-argument-lists"></emu-xref>) in `new` expressions, in function calls, and in other algorithms where a simple ordered list of values is needed. Values of the List type are simply ordered sequences of list elements containing the individual values. These sequences may be of any length. The elements of a list may be randomly accessed using 0-origin indices. For notational convenience an array-like syntax can be used to access List elements. For example, _arguments_[2] is shorthand for saying the 3<sup>rd</sup> element of the List _arguments_.</p>
      <p>For notational convenience within this specification, a literal syntax can be used to express a new List value. For example, &laquo; 1, 2 &raquo; defines a List value that has two elements each of which is initialized to a specific value. A new empty List can be expressed as &laquo; &raquo;.</p>
      <p>The <dfn>Record</dfn> type is used to describe data aggregations within the algorithms of this specification. A Record type value consists of one or more named fields. The value of each field is either an ECMAScript value or an abstract value represented by a name associated with the Record type. Field names are always enclosed in double brackets, for example [[Value]].</p>
      <p>For notational convenience within this specification, an object literal-like syntax can be used to express a Record value. For example, { [[Field1]]: 42, [[Field2]]: *false*, [[Field3]]: ~empty~ } defines a Record value that has three fields, each of which is initialized to a specific value. Field name order is not significant. Any fields that are not explicitly listed are considered to be absent.</p>
      <p>In specification text and algorithms, dot notation may be used to refer to a specific field of a Record value. For example, if R is the record shown in the previous paragraph then R.[[Field2]] is shorthand for &ldquo;the field of R named [[Field2]]&rdquo;.</p>
      <p>Schema for commonly used Record field combinations may be named, and that name may be used as a prefix to a literal Record value to identify the specific kind of aggregations that is being described. For example: PropertyDescriptor { [[Value]]: 42, [[Writable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>

    <emu-clause id="sec-set-and-relation-specification-type">
      <h1>The Set and Relation Specification Types</h1>
      <p>The <dfn>Set</dfn> type is used to explain a collection of unordered elements for use in the memory model. Values of the Set type are simple collections of elements, where no element appears more than once. Elements may be added to and removed from Sets. Sets may be unioned, intersected, or subtracted from each other.</p>
      <p>The <dfn>Relation</dfn> type is used to explain constraints on Sets. Values of the Relation type are Sets of ordered pairs of values from its value domain. For example, a Relation on events is a set of ordered pairs of events. For a Relation _R_ and two values _a_ and _b_ in the value domain of _R_, _a_ _R_ _b_ is shorthand for saying the ordered pair (_a_, _b_) is a member of _R_. A Relation is least with respect to some conditions when it is the smallest Relation that satisfies those conditions.</p>
      <p>A <dfn>strict partial order</dfn> is a Relation value _R_ that satisfies the following.</p>
      <ul>
        <li>
          <p>For all _a_, _b_, and _c_ in _R_'s domain:</p>
          <ul>
            <li>It is not the case that _a_ _R_ _a_, and</li>
            <li>If _a_ _R_ _b_ and _b_ _R_ _c_, then _a_ _R_ _c_.</li>
          </ul>
        </li>
      </ul>
      <emu-note>
        <p>The two properties above are called, in order, irreflexivity and transitivity.</p>
      </emu-note>
      <p>A <dfn>strict total order</dfn> is a Relation value _R_ that satisfies the following.</p>
      <ul>
        <li>
          <p>For all _a_, _b_, and _c_ in _R_'s domain:</p>
          <ul>
            <li>_a_ is identical to _b_ or _a_ _R_ _b_ or _b_ _R_ _a_, and</li>
            <li>It is not the case that _a_ _R_ _a_, and</li>
            <li>If _a_ _R_ _b_ and _b_ _R_ _c_, then _a_ _R_ _c_.</li>
          </ul>
        </li>
      </ul>
      <emu-note>
        <p>The three properties above are called, in order, totality, irreflexivity, and transitivity.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-completion-record-specification-type" aoid="Completion">
      <h1>The Completion Record Specification Type</h1>
      <p>The Completion type is a Record used to explain the runtime propagation of values and control flow such as the behaviour of statements (`break`, `continue`, `return` and `throw`) that perform nonlocal transfers of control.</p>
      <p>Values of the Completion type are Record values whose fields are defined as by <emu-xref href="#table-8"></emu-xref>. Such values are referred to as <dfn>Completion Record</dfn>s.</p>
      <emu-table id="table-8" caption="Completion Record Fields">
        <table>
          <tbody>
          <tr>
            <th>
              Field Name
            </th>
            <th>
              Value
            </th>
            <th>
              Meaning
            </th>
          </tr>
          <tr>
            <td>
              [[Type]]
            </td>
            <td>
              One of ~normal~, ~break~, ~continue~, ~return~, or ~throw~
            </td>
            <td>
              The type of completion that occurred.
            </td>
          </tr>
          <tr>
            <td>
              [[Value]]
            </td>
            <td>
              any ECMAScript language value or ~empty~
            </td>
            <td>
              The value that was produced.
            </td>
          </tr>
          <tr>
            <td>
              [[Target]]
            </td>
            <td>
              any ECMAScript string or ~empty~
            </td>
            <td>
              The target label for directed control transfers.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
      <p>The term &ldquo;<dfn>abrupt completion</dfn>&rdquo; refers to any completion with a [[Type]] value other than ~normal~.</p>

      <emu-clause id="await" aoid="Await">
        <h1>Await</h1>

        <p>Algorithm steps that say</p>

        <emu-alg>
          1. Let _completion_ be Await(_value_).
        </emu-alg>

        <p>mean the same thing as:</p>

        <emu-alg>
          1. Let _asyncContext_ be the running execution context.
          1. Let _promise_ be ? PromiseResolve(%Promise%, _value_).
          1. Let _stepsFulfilled_ be the algorithm steps defined in <emu-xref href="#await-fulfilled" title></emu-xref>.
          1. Let _onFulfilled_ be CreateBuiltinFunction(_stepsFulfilled_, &laquo; [[AsyncContext]] &raquo;).
          1. Set _onFulfilled_.[[AsyncContext]] to _asyncContext_.
          1. Let _stepsRejected_ be the algorithm steps defined in <emu-xref href="#await-rejected" title></emu-xref>.
          1. Let _onRejected_ be CreateBuiltinFunction(_stepsRejected_, &laquo; [[AsyncContext]] &raquo;).
          1. Set _onRejected_.[[AsyncContext]] to _asyncContext_.
          1. Perform ! PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_).
          1. Remove _asyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
          1. Set the code evaluation state of _asyncContext_ such that when evaluation is resumed with a Completion _completion_, the following steps of the algorithm that invoked Await will be performed, with _completion_ available.
          1. Return.
          1. NOTE: This returns to the evaluation of the operation that had most previously resumed evaluation of _asyncContext_.
        </emu-alg>

        <p>where all variables in the above steps, with the exception of _completion_, are ephemeral and visible only in the steps pertaining to Await.</p>

        <emu-note>
          <p>Await can be combined with the `?` and `!` prefixes, so that for example</p>

          <emu-alg>
            1. Let _result_ be ? Await(_value_).
          </emu-alg>

          <p>means the same thing as:</p>

          <emu-alg>
            1. Let _result_ be Await(_value_).
            1. ReturnIfAbrupt(_result_).
          </emu-alg>
        </emu-note>

        <emu-clause id="await-fulfilled">
          <h1>Await Fulfilled Functions</h1>

          <p>An Await fulfilled function is an anonymous built-in function that is used as part of the Await specification device to deliver the promise fulfillment value to the caller as a normal completion. Each Await fulfilled function has an [[AsyncContext]] internal slot.</p>

          <p>When an Await fulfilled function is called with argument _value_, the following steps are taken:</p>

          <emu-alg>
            1. Let _F_ be the active function object.
            1. Let _asyncContext_ be _F_.[[AsyncContext]].
            1. Let _prevContext_ be the running execution context.
            1. Suspend _prevContext_.
            1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.
            1. Resume the suspended evaluation of _asyncContext_ using NormalCompletion(_value_) as the result of the operation that suspended it.
            1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.
            1. Return *undefined*.
          </emu-alg>

          <p>The `"length"` property of an Await fulfilled function is 1.</p>
        </emu-clause>

        <emu-clause id="await-rejected">
          <h1>Await Rejected Functions</h1>

          <p>An Await rejected function is an anonymous built-in function that is used as part of the Await specification device to deliver the promise rejection reason to the caller as an abrupt throw completion. Each Await rejected function has an [[AsyncContext]] internal slot.</p>

          <p>When an Await rejected function is called with argument _reason_, the following steps are taken:</p>

          <emu-alg>
            1. Let _F_ be the active function object.
            1. Let _asyncContext_ be _F_.[[AsyncContext]].
            1. Let _prevContext_ be the running execution context.
            1. Suspend _prevContext_.
            1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.
            1. Resume the suspended evaluation of _asyncContext_ using ThrowCompletion(_reason_) as the result of the operation that suspended it.
            1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.
            1. Return *undefined*.
          </emu-alg>

          <p>The `"length"` property of an Await rejected function is 1.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-normalcompletion" aoid="NormalCompletion">
        <h1>NormalCompletion</h1>
        <p>The abstract operation NormalCompletion with a single _argument_, such as:</p>
        <emu-alg>
          1. Return NormalCompletion(_argument_).
        </emu-alg>
        <p>Is a shorthand that is defined as follows:</p>
        <emu-alg>
          1. Return Completion { [[Type]]: ~normal~, [[Value]]: _argument_, [[Target]]: ~empty~ }.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-throwcompletion" aoid="ThrowCompletion">
        <h1>ThrowCompletion</h1>
        <p>The abstract operation ThrowCompletion with a single _argument_, such as:</p>
        <emu-alg>
          1. Return ThrowCompletion(_argument_).
        </emu-alg>
        <p>Is a shorthand that is defined as follows:</p>
        <emu-alg>
          1. Return Completion { [[Type]]: ~throw~, [[Value]]: _argument_, [[Target]]: ~empty~ }.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-updateempty" aoid="UpdateEmpty">
        <h1>UpdateEmpty ( _completionRecord_, _value_ )</h1>
        <p>The abstract operation UpdateEmpty with arguments _completionRecord_ and _value_ performs the following steps:</p>
        <emu-alg>
          1. Assert: If _completionRecord_.[[Type]] is either ~return~ or ~throw~, then _completionRecord_.[[Value]] is not ~empty~.
          1. If _completionRecord_.[[Value]] is not ~empty~, return Completion(_completionRecord_).
          1. Return Completion { [[Type]]: _completionRecord_.[[Type]], [[Value]]: _value_, [[Target]]: _completionRecord_.[[Target]] }.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-reference-specification-type">
      <h1>The Reference Specification Type</h1>
      <emu-note>
        <p>The Reference type is used to explain the behaviour of such operators as `delete`, `typeof`, the assignment operators, the `super` keyword and other language features. For example, the left-hand operand of an assignment is expected to produce a reference.</p>
      </emu-note>
      <p>A <dfn>Reference</dfn> is a resolved name or property binding. A Reference consists of three components, the base value component, the referenced name component, and the Boolean-valued strict reference flag. The base value component is either *undefined*, an Object, a Boolean, a String, a Symbol, a Number, or an Environment Record. A base value component of *undefined* indicates that the Reference could not be resolved to a binding. The referenced name component is a String or Symbol value.</p>
      <p>A <dfn id="super-reference">Super Reference</dfn> is a Reference that is used to represent a name binding that was expressed using the super keyword. A Super Reference has an additional thisValue component, and its base value component will never be an Environment Record.</p>
      <p>The following abstract operations are used in this specification to operate on references:</p>

      <emu-clause id="sec-getbase" aoid="GetBase" oldids="ao-getbase">
        <h1>GetBase ( _V_ )</h1>
        <emu-alg>
          1. Assert: Type(_V_) is Reference.
          1. Return the base value component of _V_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getreferencedname" aoid="GetReferencedName" oldids="ao-getreferencedname">
        <h1>GetReferencedName ( _V_ )</h1>
        <emu-alg>
          1. Assert: Type(_V_) is Reference.
          1. Return the referenced name component of _V_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isstrictreference" aoid="IsStrictReference" oldids="ao-isstrictreference">
        <h1>IsStrictReference ( _V_ )</h1>
        <emu-alg>
          1. Assert: Type(_V_) is Reference.
          1. Return the strict reference flag of _V_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-hasprimitivebase" aoid="HasPrimitiveBase" oldids="ao-hasprimitivebase">
        <h1>HasPrimitiveBase ( _V_ )</h1>
        <emu-alg>
          1. Assert: Type(_V_) is Reference.
          1. If Type(_V_'s base value component) is Boolean, String, Symbol, or Number, return *true*; otherwise return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ispropertyreference" aoid="IsPropertyReference" oldids="ao-ispropertyreference">
        <h1>IsPropertyReference ( _V_ )</h1>
        <emu-alg>
          1. Assert: Type(_V_) is Reference.
          1. If either the base value component of _V_ is an Object or HasPrimitiveBase(_V_) is *true*, return *true*; otherwise return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isunresolvablereference" aoid="IsUnresolvableReference" oldids="ao-isunresolvablereference">
        <h1>IsUnresolvableReference ( _V_ )</h1>
        <emu-alg>
          1. Assert: Type(_V_) is Reference.
          1. If the base value component of _V_ is *undefined*, return *true*; otherwise return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-issuperreference" aoid="IsSuperReference" oldids="ao-issuperreference">
        <h1>IsSuperReference ( _V_ )</h1>
        <emu-alg>
          1. Assert: Type(_V_) is Reference.
          1. If _V_ has a thisValue component, return *true*; otherwise return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getvalue" aoid="GetValue">
        <h1>GetValue ( _V_ )</h1>
        <emu-alg>
          1. ReturnIfAbrupt(_V_).
          1. If Type(_V_) is not Reference, return _V_.
          1. Let _base_ be GetBase(_V_).
          1. If IsUnresolvableReference(_V_) is *true*, throw a *ReferenceError* exception.
          1. If IsPropertyReference(_V_) is *true*, then
            1. If HasPrimitiveBase(_V_) is *true*, then
              1. Assert: In this case, _base_ will never be *undefined* or *null*.
              1. Set _base_ to ! ToObject(_base_).
            1. Return ? _base_.[[Get]](GetReferencedName(_V_), GetThisValue(_V_)).
          1. Else _base_ must be an Environment Record,
            1. Return ? _base_.GetBindingValue(GetReferencedName(_V_), IsStrictReference(_V_)) (see <emu-xref href="#sec-environment-records"></emu-xref>).
        </emu-alg>
        <emu-note>
          <p>The object that may be created in step 5.a.ii is not accessible outside of the above abstract operation and the ordinary object [[Get]] internal method. An implementation might choose to avoid the actual creation of the object.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-putvalue" aoid="PutValue">
        <h1>PutValue ( _V_, _W_ )</h1>
        <emu-alg>
          1. ReturnIfAbrupt(_V_).
          1. ReturnIfAbrupt(_W_).
          1. If Type(_V_) is not Reference, throw a *ReferenceError* exception.
          1. Let _base_ be GetBase(_V_).
          1. If IsUnresolvableReference(_V_) is *true*, then
            1. If IsStrictReference(_V_) is *true*, then
              1. Throw a *ReferenceError* exception.
            1. Let _globalObj_ be GetGlobalObject().
            1. Return ? Set(_globalObj_, GetReferencedName(_V_), _W_, *false*).
          1. Else if IsPropertyReference(_V_) is *true*, then
            1. If HasPrimitiveBase(_V_) is *true*, then
              1. Assert: In this case, _base_ will never be *undefined* or *null*.
              1. Set _base_ to ! ToObject(_base_).
            1. Let _succeeded_ be ? _base_.[[Set]](GetReferencedName(_V_), _W_, GetThisValue(_V_)).
            1. If _succeeded_ is *false* and IsStrictReference(_V_) is *true*, throw a *TypeError* exception.
            1. Return.
          1. Else _base_ must be an Environment Record,
            1. Return ? _base_.SetMutableBinding(GetReferencedName(_V_), _W_, IsStrictReference(_V_)) (see <emu-xref href="#sec-environment-records"></emu-xref>).
        </emu-alg>
        <emu-note>
          <p>The object that may be created in step 6.a.ii is not accessible outside of the above algorithm and the ordinary object [[Set]] internal method. An implementation might choose to avoid the actual creation of that object.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-getthisvalue" aoid="GetThisValue">
        <h1>GetThisValue ( _V_ )</h1>
        <emu-alg>
          1. Assert: IsPropertyReference(_V_) is *true*.
          1. If IsSuperReference(_V_) is *true*, then
            1. Return the value of the thisValue component of the reference _V_.
          1. Return GetBase(_V_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-initializereferencedbinding" aoid="InitializeReferencedBinding">
        <h1>InitializeReferencedBinding ( _V_, _W_ )</h1>
        <emu-alg>
          1. ReturnIfAbrupt(_V_).
          1. ReturnIfAbrupt(_W_).
          1. Assert: Type(_V_) is Reference.
          1. Assert: IsUnresolvableReference(_V_) is *false*.
          1. Let _base_ be GetBase(_V_).
          1. Assert: _base_ is an Environment Record.
          1. Return _base_.InitializeBinding(GetReferencedName(_V_), _W_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-property-descriptor-specification-type">
      <h1>The Property Descriptor Specification Type</h1>
      <p>The <dfn>Property Descriptor</dfn> type is used to explain the manipulation and reification of Object property attributes. Values of the Property Descriptor type are Records. Each field's name is an attribute name and its value is a corresponding attribute value as specified in <emu-xref href="#sec-property-attributes"></emu-xref>. In addition, any field may be present or absent. The schema name used within this specification to tag literal descriptions of Property Descriptor records is &ldquo;PropertyDescriptor&rdquo;.</p>
      <p>Property Descriptor values may be further classified as data Property Descriptors and accessor Property Descriptors based upon the existence or use of certain fields. A data Property Descriptor is one that includes any fields named either [[Value]] or [[Writable]]. An accessor Property Descriptor is one that includes any fields named either [[Get]] or [[Set]]. Any Property Descriptor may have fields named [[Enumerable]] and [[Configurable]]. A Property Descriptor value may not be both a data Property Descriptor and an accessor Property Descriptor; however, it may be neither. A generic Property Descriptor is a Property Descriptor value that is neither a data Property Descriptor nor an accessor Property Descriptor. A fully populated Property Descriptor is one that is either an accessor Property Descriptor or a data Property Descriptor and that has all of the fields that correspond to the property attributes defined in either <emu-xref href="#table-2"></emu-xref> or <emu-xref href="#table-3"></emu-xref>.</p>
      <p>The following abstract operations are used in this specification to operate upon Property Descriptor values:</p>

      <emu-clause id="sec-isaccessordescriptor" aoid="IsAccessorDescriptor">
        <h1>IsAccessorDescriptor ( _Desc_ )</h1>
        <p>When the abstract operation IsAccessorDescriptor is called with Property Descriptor _Desc_, the following steps are taken:</p>
        <emu-alg>
          1. If _Desc_ is *undefined*, return *false*.
          1. If both _Desc_.[[Get]] and _Desc_.[[Set]] are absent, return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isdatadescriptor" aoid="IsDataDescriptor">
        <h1>IsDataDescriptor ( _Desc_ )</h1>
        <p>When the abstract operation IsDataDescriptor is called with Property Descriptor _Desc_, the following steps are taken:</p>
        <emu-alg>
          1. If _Desc_ is *undefined*, return *false*.
          1. If both _Desc_.[[Value]] and _Desc_.[[Writable]] are absent, return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isgenericdescriptor" aoid="IsGenericDescriptor">
        <h1>IsGenericDescriptor ( _Desc_ )</h1>
        <p>When the abstract operation IsGenericDescriptor is called with Property Descriptor _Desc_, the following steps are taken:</p>
        <emu-alg>
          1. If _Desc_ is *undefined*, return *false*.
          1. If IsAccessorDescriptor(_Desc_) and IsDataDescriptor(_Desc_) are both *false*, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-frompropertydescriptor" aoid="FromPropertyDescriptor">
        <h1>FromPropertyDescriptor ( _Desc_ )</h1>
        <p>When the abstract operation FromPropertyDescriptor is called with Property Descriptor _Desc_, the following steps are taken:</p>
        <emu-alg>
          1. If _Desc_ is *undefined*, return *undefined*.
          1. Let _obj_ be ObjectCreate(%ObjectPrototype%).
          1. Assert: _obj_ is an extensible ordinary object with no own properties.
          1. If _Desc_ has a [[Value]] field, then
            1. Perform CreateDataProperty(_obj_, `"value"`, _Desc_.[[Value]]).
          1. If _Desc_ has a [[Writable]] field, then
            1. Perform CreateDataProperty(_obj_, `"writable"`, _Desc_.[[Writable]]).
          1. If _Desc_ has a [[Get]] field, then
            1. Perform CreateDataProperty(_obj_, `"get"`, _Desc_.[[Get]]).
          1. If _Desc_ has a [[Set]] field, then
            1. Perform CreateDataProperty(_obj_, `"set"`, _Desc_.[[Set]]).
          1. If _Desc_ has an [[Enumerable]] field, then
            1. Perform CreateDataProperty(_obj_, `"enumerable"`, _Desc_.[[Enumerable]]).
          1. If _Desc_ has a [[Configurable]] field, then
            1. Perform CreateDataProperty(_obj_, `"configurable"`, _Desc_.[[Configurable]]).
          1. Assert: All of the above CreateDataProperty operations return *true*.
          1. Return _obj_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-topropertydescriptor" aoid="ToPropertyDescriptor">
        <h1>ToPropertyDescriptor ( _Obj_ )</h1>
        <p>When the abstract operation ToPropertyDescriptor is called with object _Obj_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_Obj_) is not Object, throw a *TypeError* exception.
          1. Let _desc_ be a new Property Descriptor that initially has no fields.
          1. Let _hasEnumerable_ be ? HasProperty(_Obj_, `"enumerable"`).
          1. If _hasEnumerable_ is *true*, then
            1. Let _enumerable_ be ToBoolean(? Get(_Obj_, `"enumerable"`)).
            1. Set _desc_.[[Enumerable]] to _enumerable_.
          1. Let _hasConfigurable_ be ? HasProperty(_Obj_, `"configurable"`).
          1. If _hasConfigurable_ is *true*, then
            1. Let _configurable_ be ToBoolean(? Get(_Obj_, `"configurable"`)).
            1. Set _desc_.[[Configurable]] to _configurable_.
          1. Let _hasValue_ be ? HasProperty(_Obj_, `"value"`).
          1. If _hasValue_ is *true*, then
            1. Let _value_ be ? Get(_Obj_, `"value"`).
            1. Set _desc_.[[Value]] to _value_.
          1. Let _hasWritable_ be ? HasProperty(_Obj_, `"writable"`).
          1. If _hasWritable_ is *true*, then
            1. Let _writable_ be ToBoolean(? Get(_Obj_, `"writable"`)).
            1. Set _desc_.[[Writable]] to _writable_.
          1. Let _hasGet_ be ? HasProperty(_Obj_, `"get"`).
          1. If _hasGet_ is *true*, then
            1. Let _getter_ be ? Get(_Obj_, `"get"`).
            1. If IsCallable(_getter_) is *false* and _getter_ is not *undefined*, throw a *TypeError* exception.
            1. Set _desc_.[[Get]] to _getter_.
          1. Let _hasSet_ be ? HasProperty(_Obj_, `"set"`).
          1. If _hasSet_ is *true*, then
            1. Let _setter_ be ? Get(_Obj_, `"set"`).
            1. If IsCallable(_setter_) is *false* and _setter_ is not *undefined*, throw a *TypeError* exception.
            1. Set _desc_.[[Set]] to _setter_.
          1. If _desc_.[[Get]] is present or _desc_.[[Set]] is present, then
            1. If _desc_.[[Value]] is present or _desc_.[[Writable]] is present, throw a *TypeError* exception.
          1. Return _desc_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-completepropertydescriptor" aoid="CompletePropertyDescriptor">
        <h1>CompletePropertyDescriptor ( _Desc_ )</h1>
        <p>When the abstract operation CompletePropertyDescriptor is called with Property Descriptor _Desc_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: _Desc_ is a Property Descriptor.
          1. Let _like_ be Record { [[Value]]: *undefined*, [[Writable]]: *false*, [[Get]]: *undefined*, [[Set]]: *undefined*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.
          1. If IsGenericDescriptor(_Desc_) is *true* or IsDataDescriptor(_Desc_) is *true*, then
            1. If _Desc_ does not have a [[Value]] field, set _Desc_.[[Value]] to _like_.[[Value]].
            1. If _Desc_ does not have a [[Writable]] field, set _Desc_.[[Writable]] to _like_.[[Writable]].
          1. Else,
            1. If _Desc_ does not have a [[Get]] field, set _Desc_.[[Get]] to _like_.[[Get]].
            1. If _Desc_ does not have a [[Set]] field, set _Desc_.[[Set]] to _like_.[[Set]].
          1. If _Desc_ does not have an [[Enumerable]] field, set _Desc_.[[Enumerable]] to _like_.[[Enumerable]].
          1. If _Desc_ does not have a [[Configurable]] field, set _Desc_.[[Configurable]] to _like_.[[Configurable]].
          1. Return _Desc_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-lexical-environment-and-environment-record-specification-types">
      <h1>The Lexical Environment and Environment Record Specification Types</h1>
      <p>The Lexical Environment and Environment Record types are used to explain the behaviour of name resolution in nested functions and blocks. These types and the operations upon them are defined in <emu-xref href="#sec-lexical-environments"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-data-blocks">
      <h1>Data Blocks</h1>
      <p>The <dfn>Data Block</dfn> specification type is used to describe a distinct and mutable sequence of byte-sized (8 bit) numeric values. A Data Block value is created with a fixed number of bytes that each have the initial value 0.</p>
      <p>For notational convenience within this specification, an array-like syntax can be used to access the individual bytes of a Data Block value. This notation presents a Data Block value as a 0-origined integer-indexed sequence of bytes. For example, if _db_ is a 5 byte Data Block value then _db_[2] can be used to access its 3<sup>rd</sup> byte.</p>
      <p>A data block that resides in memory that can be referenced from multiple agents concurrently is designated a <dfn>Shared Data Block</dfn>. A Shared Data Block has an identity (for the purposes of equality testing Shared Data Block values) that is <em>address-free</em>: it is tied not to the virtual addresses the block is mapped to in any process, but to the set of locations in memory that the block represents. Two data blocks are equal only if the sets of the locations they contain are equal; otherwise, they are not equal and the intersection of the sets of locations they contain is empty.  Finally, Shared Data Blocks can be distinguished from Data Blocks.</p>
      <p>The semantics of Shared Data Blocks is defined using Shared Data Block events by the memory model. Abstract operations below introduce Shared Data Block events and act as the interface between evaluation semantics and the event semantics of the memory model. The events form a candidate execution, on which the memory model acts as a filter. Please consult the memory model for full semantics.</p>
      <p>Shared Data Block events are modeled by Records, defined in the memory model.</p>
      <p>The following abstract operations are used in this specification to operate upon Data Block values:</p>

      <emu-clause id="sec-createbytedatablock" aoid="CreateByteDataBlock">
        <h1>CreateByteDataBlock ( _size_ )</h1>
        <p>When the abstract operation CreateByteDataBlock is called with integer argument _size_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: _size_ &ge; 0.
          1. Let _db_ be a new Data Block value consisting of _size_ bytes. If it is impossible to create such a Data Block, throw a *RangeError* exception.
          1. Set all of the bytes of _db_ to 0.
          1. Return _db_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createsharedbytedatablock" aoid="CreateSharedByteDataBlock">
        <h1>CreateSharedByteDataBlock ( _size_ )</h1>
        <p>When the abstract operation CreateSharedByteDataBlock is called with integer argument _size_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: _size_ &ge; 0.
          1. Let _db_ be a new Shared Data Block value consisting of _size_ bytes. If it is impossible to create such a Shared Data Block, throw a *RangeError* exception.
          1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
          1. Let _eventList_ be the [[EventList]] field of the element in _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
          1. Let _zero_ be &laquo; 0 &raquo;.
          1. For each index _i_ of _db_, do
            1. Append WriteSharedMemory { [[Order]]: `"Init"`, [[NoTear]]: *true*, [[Block]]: _db_, [[ByteIndex]]: _i_, [[ElementSize]]: 1, [[Payload]]: _zero_ } to _eventList_.
          1. Return _db_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-copydatablockbytes" aoid="CopyDataBlockBytes">
        <h1>CopyDataBlockBytes ( _toBlock_, _toIndex_, _fromBlock_, _fromIndex_, _count_ )</h1>
        <p>When the abstract operation CopyDataBlockBytes is called, the following steps are taken:</p>
        <emu-alg>
          1. Assert: _fromBlock_ and _toBlock_ are distinct Data Block or Shared Data Block values.
          1. Assert: _fromIndex_, _toIndex_, and _count_ are integer values &ge; 0.
          1. Let _fromSize_ be the number of bytes in _fromBlock_.
          1. Assert: _fromIndex_ + _count_ &le; _fromSize_.
          1. Let _toSize_ be the number of bytes in _toBlock_.
          1. Assert: _toIndex_ + _count_ &le; _toSize_.
          1. Repeat, while _count_ &gt; 0
            1. If _fromBlock_ is a Shared Data Block, then
              1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
              1. Let _eventList_ be the [[EventList]] field of the element in _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
              1. Let _bytes_ be a List of length 1 that contains a nondeterministically chosen byte value.
              1. NOTE: In implementations, _bytes_ is the result of a non-atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
              1. Let _readEvent_ be ReadSharedMemory { [[Order]]: `"Unordered"`, [[NoTear]]: *true*, [[Block]]: _fromBlock_, [[ByteIndex]]: _fromIndex_, [[ElementSize]]: 1 }.
              1. Append _readEvent_ to _eventList_.
              1. Append Chosen Value Record { [[Event]]: _readEvent_, [[ChosenValue]]: _bytes_ } to _execution_.[[ChosenValues]].
              1. If _toBlock_ is a Shared Data Block, then
                1. Append WriteSharedMemory { [[Order]]: `"Unordered"`, [[NoTear]]: *true*, [[Block]]: _toBlock_, [[ByteIndex]]: _toIndex_, [[ElementSize]]: 1, [[Payload]]: _bytes_ } to _eventList_.
              1. Else,
                1. Set _toBlock_[_toIndex_] to _bytes_[0].
            1. Else,
              1. Assert: _toBlock_ is not a Shared Data Block.
              1. Set _toBlock_[_toIndex_] to _fromBlock_[_fromIndex_].
            1. Increment _toIndex_ and _fromIndex_ each by 1.
            1. Decrement _count_ by 1.
          1. Return NormalCompletion(~empty~).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-abstract-operations">
  <h1>Abstract Operations</h1>
  <p>These operations are not a part of the ECMAScript language; they are defined here to solely to aid the specification of the semantics of the ECMAScript language. Other, more specialized abstract operations are defined throughout this specification.</p>

  <emu-clause id="sec-type-conversion">
    <h1>Type Conversion</h1>
    <p>The ECMAScript language implicitly performs automatic type conversion as needed. To clarify the semantics of certain constructs it is useful to define a set of conversion abstract operations. The conversion abstract operations are polymorphic; they can accept a value of any ECMAScript language type. But no other specification types are used with these operations.</p>

    <emu-clause id="sec-toprimitive" aoid="ToPrimitive" oldids="table-9">
      <h1>ToPrimitive ( _input_ [ , _PreferredType_ ] )</h1>
      <p>The abstract operation ToPrimitive takes an _input_ argument and an optional argument _PreferredType_. The abstract operation ToPrimitive converts its _input_ argument to a non-Object type. If an object is capable of converting to more than one primitive type, it may use the optional hint _PreferredType_ to favour that type. Conversion occurs according to the following algorithm:</p>
      <emu-alg>
        1. Assert: _input_ is an ECMAScript language value.
        1. If Type(_input_) is Object, then
          1. If _PreferredType_ is not present, let _hint_ be `"default"`.
          1. Else if _PreferredType_ is hint String, let _hint_ be `"string"`.
          1. Else _PreferredType_ is hint Number, let _hint_ be `"number"`.
          1. Let _exoticToPrim_ be ? GetMethod(_input_, @@toPrimitive).
          1. If _exoticToPrim_ is not *undefined*, then
            1. Let _result_ be ? Call(_exoticToPrim_, _input_, &laquo; _hint_ &raquo;).
            1. If Type(_result_) is not Object, return _result_.
            1. Throw a *TypeError* exception.
          1. If _hint_ is `"default"`, set _hint_ to `"number"`.
          1. Return ? OrdinaryToPrimitive(_input_, _hint_).
        1. Return _input_.
      </emu-alg>
      <emu-note>
        <p>When ToPrimitive is called with no hint, then it generally behaves as if the hint were Number. However, objects may over-ride this behaviour by defining a @@toPrimitive method. Of the objects defined in this specification only Date objects (see <emu-xref href="#sec-date.prototype-@@toprimitive"></emu-xref>) and Symbol objects (see <emu-xref href="#sec-symbol.prototype-@@toprimitive"></emu-xref>) over-ride the default ToPrimitive behaviour. Date objects treat no hint as if the hint were String.</p>
      </emu-note>

      <emu-clause id="sec-ordinarytoprimitive" aoid="OrdinaryToPrimitive">
        <h1>OrdinaryToPrimitive ( _O_, _hint_ )</h1>
        <p>When the abstract operation OrdinaryToPrimitive is called with arguments _O_ and _hint_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: Type(_O_) is Object.
          1. Assert: Type(_hint_) is String and its value is either `"string"` or `"number"`.
          1. If _hint_ is `"string"`, then
            1. Let _methodNames_ be &laquo; `"toString"`, `"valueOf"` &raquo;.
          1. Else,
            1. Let _methodNames_ be &laquo; `"valueOf"`, `"toString"` &raquo;.
          1. For each _name_ in _methodNames_ in List order, do
            1. Let _method_ be ? Get(_O_, _name_).
            1. If IsCallable(_method_) is *true*, then
              1. Let _result_ be ? Call(_method_, _O_).
              1. If Type(_result_) is not Object, return _result_.
          1. Throw a *TypeError* exception.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-toboolean" aoid="ToBoolean">
      <h1>ToBoolean ( _argument_ )</h1>
      <p>The abstract operation ToBoolean converts _argument_ to a value of type Boolean according to <emu-xref href="#table-10"></emu-xref>:</p>
      <emu-table id="table-10" caption="ToBoolean Conversions">
        <table>
          <tbody>
          <tr>
            <th>
              Argument Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              Undefined
            </td>
            <td>
              Return *false*.
            </td>
          </tr>
          <tr>
            <td>
              Null
            </td>
            <td>
              Return *false*.
            </td>
          </tr>
          <tr>
            <td>
              Boolean
            </td>
            <td>
              Return _argument_.
            </td>
          </tr>
          <tr>
            <td>
              Number
            </td>
            <td>
              If _argument_ is *+0*, *-0*, or *NaN*, return *false*; otherwise return *true*.
            </td>
          </tr>
          <tr>
            <td>
              String
            </td>
            <td>
              If _argument_ is the empty String (its length is zero), return *false*; otherwise return *true*.
            </td>
          </tr>
          <tr>
            <td>
              Symbol
            </td>
            <td>
              Return *true*.
            </td>
          </tr>
          <tr>
            <td>
              Object
            </td>
            <td>
              Return *true*.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-tonumber" aoid="ToNumber">
      <h1>ToNumber ( _argument_ )</h1>
      <p>The abstract operation ToNumber converts _argument_ to a value of type Number according to <emu-xref href="#table-11"></emu-xref>:</p>
      <emu-table id="table-11" caption="ToNumber Conversions">
        <table>
          <tbody>
          <tr>
            <th>
              Argument Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              Undefined
            </td>
            <td>
              Return *NaN*.
            </td>
          </tr>
          <tr>
            <td>
              Null
            </td>
            <td>
              Return *+0*.
            </td>
          </tr>
          <tr>
            <td>
              Boolean
            </td>
            <td>
              If _argument_ is *true*, return 1. If _argument_ is *false*, return *+0*.
            </td>
          </tr>
          <tr>
            <td>
              Number
            </td>
            <td>
              Return _argument_ (no conversion).
            </td>
          </tr>
          <tr>
            <td>
              String
            </td>
            <td>
              See grammar and conversion algorithm below.
            </td>
          </tr>
          <tr>
            <td>
              Symbol
            </td>
            <td>
              Throw a *TypeError* exception.
            </td>
          </tr>
          <tr>
            <td>
              Object
            </td>
            <td>
              <p>Apply the following steps:</p>
              <emu-alg>
                1. Let _primValue_ be ? ToPrimitive(_argument_, hint Number).
                1. Return ? ToNumber(_primValue_).
              </emu-alg>
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>

      <emu-clause id="sec-tonumber-applied-to-the-string-type">
        <h1>ToNumber Applied to the String Type</h1>
        <p>ToNumber applied to Strings applies the following grammar to the input String interpreted as a sequence of UTF-16 encoded code points (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>). If the grammar cannot interpret the String as an expansion of |StringNumericLiteral|, then the result of ToNumber is *NaN*.</p>
        <emu-note>
          <p>The terminal symbols of this grammar are all composed of characters in the Unicode Basic Multilingual Plane (BMP). Therefore, the result of ToNumber will be *NaN* if the string contains any <emu-xref href="#leading-surrogate"></emu-xref> or <emu-xref href="#trailing-surrogate"></emu-xref> code units, whether paired or unpaired.</p>
        </emu-note>
        <h2>Syntax</h2>
        <emu-grammar type="definition">
          StringNumericLiteral :::
            StrWhiteSpace?
            StrWhiteSpace? StrNumericLiteral StrWhiteSpace?

          StrWhiteSpace :::
            StrWhiteSpaceChar StrWhiteSpace?

          StrWhiteSpaceChar :::
            WhiteSpace
            LineTerminator

          StrNumericLiteral :::
            StrDecimalLiteral
            BinaryIntegerLiteral
            OctalIntegerLiteral
            HexIntegerLiteral

          StrDecimalLiteral :::
            StrUnsignedDecimalLiteral
            `+` StrUnsignedDecimalLiteral
            `-` StrUnsignedDecimalLiteral

          StrUnsignedDecimalLiteral :::
            `Infinity`
            DecimalDigits `.` DecimalDigits? ExponentPart?
            `.` DecimalDigits ExponentPart?
            DecimalDigits ExponentPart?
        </emu-grammar>
        <p>All grammar symbols not explicitly defined above have the definitions used in the Lexical Grammar for numeric literals (<emu-xref href="#sec-literals-numeric-literals"></emu-xref>)</p>
        <emu-note>
          <p>Some differences should be noted between the syntax of a |StringNumericLiteral| and a |NumericLiteral|:</p>
          <ul>
            <li>
              A |StringNumericLiteral| may include leading and/or trailing white space and/or line terminators.
            </li>
            <li>
              A |StringNumericLiteral| that is decimal may have any number of leading `0` digits.
            </li>
            <li>
              A |StringNumericLiteral| that is decimal may include a `+` or `-` to indicate its sign.
            </li>
            <li>
              A |StringNumericLiteral| that is empty or contains only white space is converted to *+0*.
            </li>
            <li>
              `Infinity` and `-Infinity` are recognized as a |StringNumericLiteral| but not as a |NumericLiteral|.
            </li>
          </ul>
        </emu-note>

        <emu-clause id="sec-runtime-semantics-mv-s">
          <h1>Runtime Semantics: MV</h1>
          <p>The conversion of a String to a Number value is similar overall to the determination of the Number value for a numeric literal (see <emu-xref href="#sec-literals-numeric-literals"></emu-xref>), but some of the details are different, so the process for converting a String numeric literal to a value of Number type is given here. This value is determined in two steps: first, a mathematical value (MV) is derived from the String numeric literal; second, this mathematical value is rounded as described below. The MV on any grammar symbol, not provided below, is the MV for that symbol defined in <emu-xref href="#sec-static-semantics-mv"></emu-xref>.</p>
          <ul>
            <li>
              The MV of <emu-grammar>StringNumericLiteral ::: [empty]</emu-grammar> is 0.
            </li>
            <li>
              The MV of <emu-grammar>StringNumericLiteral ::: StrWhiteSpace</emu-grammar> is 0.
            </li>
            <li>
              The MV of <emu-grammar>StringNumericLiteral ::: StrWhiteSpace? StrNumericLiteral StrWhiteSpace?</emu-grammar> is the MV of |StrNumericLiteral|, no matter whether white space is present or not.
            </li>
            <li>
              The MV of <emu-grammar>StrNumericLiteral ::: StrDecimalLiteral</emu-grammar> is the MV of |StrDecimalLiteral|.
            </li>
            <li>
              The MV of <emu-grammar>StrNumericLiteral ::: BinaryIntegerLiteral</emu-grammar> is the MV of |BinaryIntegerLiteral|.
            </li>
            <li>
              The MV of <emu-grammar>StrNumericLiteral ::: OctalIntegerLiteral</emu-grammar> is the MV of |OctalIntegerLiteral|.
            </li>
            <li>
              The MV of <emu-grammar>StrNumericLiteral ::: HexIntegerLiteral</emu-grammar> is the MV of |HexIntegerLiteral|.
            </li>
            <li>
              The MV of <emu-grammar>StrDecimalLiteral ::: StrUnsignedDecimalLiteral</emu-grammar> is the MV of |StrUnsignedDecimalLiteral|.
            </li>
            <li>
              The MV of <emu-grammar>StrDecimalLiteral ::: `+` StrUnsignedDecimalLiteral</emu-grammar> is the MV of |StrUnsignedDecimalLiteral|.
            </li>
            <li>
              The MV of <emu-grammar>StrDecimalLiteral ::: `-` StrUnsignedDecimalLiteral</emu-grammar> is the negative of the MV of |StrUnsignedDecimalLiteral|. (Note that if the MV of |StrUnsignedDecimalLiteral| is 0, the negative of this MV is also 0. The rounding rule described below handles the conversion of this signless mathematical zero to a floating-point *+0* or *-0* as appropriate.)
            </li>
            <li>
              The MV of <emu-grammar>StrUnsignedDecimalLiteral ::: `Infinity`</emu-grammar> is 10<sup>10000</sup> (a value so large that it will round to *+&infin;*).
            </li>
            <li>
              The MV of <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits `.`</emu-grammar> is the MV of |DecimalDigits|.
            </li>
            <li>
              The MV of <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits `.` DecimalDigits</emu-grammar> is the MV of the first |DecimalDigits| plus (the MV of the second |DecimalDigits| times 10<sup>-_n_</sup>), where _n_ is the number of code points in the second |DecimalDigits|.
            </li>
            <li>
              The MV of <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits `.` ExponentPart</emu-grammar> is the MV of |DecimalDigits| times 10<sup>_e_</sup>, where _e_ is the MV of |ExponentPart|.
            </li>
            <li>
              The MV of <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits `.` DecimalDigits ExponentPart</emu-grammar> is (the MV of the first |DecimalDigits| plus (the MV of the second |DecimalDigits| times 10<sup>-_n_</sup>)) times 10<sup>_e_</sup>, where _n_ is the number of code points in the second |DecimalDigits| and _e_ is the MV of |ExponentPart|.
            </li>
            <li>
              The MV of <emu-grammar>StrUnsignedDecimalLiteral ::: `.` DecimalDigits</emu-grammar> is the MV of |DecimalDigits| times 10<sup>-_n_</sup>, where _n_ is the number of code points in |DecimalDigits|.
            </li>
            <li>
              The MV of <emu-grammar>StrUnsignedDecimalLiteral ::: `.` DecimalDigits ExponentPart</emu-grammar> is the MV of |DecimalDigits| times 10<sup>_e_ - _n_</sup>, where _n_ is the number of code points in |DecimalDigits| and _e_ is the MV of |ExponentPart|.
            </li>
            <li>
              The MV of <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits</emu-grammar> is the MV of |DecimalDigits|.
            </li>
            <li>
              The MV of <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPart</emu-grammar> is the MV of |DecimalDigits| times 10<sup>_e_</sup>, where _e_ is the MV of |ExponentPart|.
            </li>
          </ul>
          <p>Once the exact MV for a String numeric literal has been determined, it is then rounded to a value of the Number type. If the MV is 0, then the rounded value is *+0* unless the first non white space code point in the String numeric literal is `"-"`, in which case the rounded value is *-0*. Otherwise, the rounded value must be the Number value for the MV (in the sense defined in <emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref>), unless the literal includes a |StrUnsignedDecimalLiteral| and the literal has more than 20 significant digits, in which case the Number value may be either the Number value for the MV of a literal produced by replacing each significant digit after the 20th with a 0 digit or the Number value for the MV of a literal produced by replacing each significant digit after the 20th with a 0 digit and then incrementing the literal at the 20th digit position. A digit is significant if it is not part of an |ExponentPart| and</p>
          <ul>
            <li>
              it is not `0`; or
            </li>
            <li>
              there is a nonzero digit to its left and there is a nonzero digit, not in the |ExponentPart|, to its right.
            </li>
          </ul>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-tointeger" aoid="ToInteger">
      <h1>ToInteger ( _argument_ )</h1>
      <p>The abstract operation ToInteger converts _argument_ to an integral numeric value. This abstract operation functions as follows:</p>
      <emu-alg>
        1. Let _number_ be ? ToNumber(_argument_).
        1. If _number_ is *NaN*, return *+0*.
        1. If _number_ is *+0*, *-0*, *+&infin;*, or *-&infin;*, return _number_.
        1. Return the number value that is the same sign as _number_ and whose magnitude is floor(abs(_number_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-toint32" aoid="ToInt32">
      <h1>ToInt32 ( _argument_ )</h1>
      <p>The abstract operation ToInt32 converts _argument_ to one of 2<sup>32</sup> integer values in the range <emu-eqn>-2<sup>31</sup></emu-eqn> through <emu-eqn>2<sup>31</sup> - 1</emu-eqn>, inclusive. This abstract operation functions as follows:</p>
      <emu-alg>
        1. Let _number_ be ? ToNumber(_argument_).
        1. If _number_ is *NaN*, *+0*, *-0*, *+&infin;*, or *-&infin;*, return *+0*.
        1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(_number_)).
        1. Let _int32bit_ be _int_ modulo 2<sup>32</sup>.
        1. If _int32bit_ &ge; 2<sup>31</sup>, return _int32bit_ - 2<sup>32</sup>; otherwise return _int32bit_.
      </emu-alg>
      <emu-note>
        <p>Given the above definition of ToInt32:</p>
        <ul>
          <li>
            The ToInt32 abstract operation is idempotent: if applied to a result that it produced, the second application leaves that value unchanged.
          </li>
          <li>
            ToInt32(ToUint32(_x_)) is equal to ToInt32(_x_) for all values of _x_. (It is to preserve this latter property that *+&infin;* and *-&infin;* are mapped to *+0*.)
          </li>
          <li>
            ToInt32 maps *-0* to *+0*.
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-touint32" aoid="ToUint32">
      <h1>ToUint32 ( _argument_ )</h1>
      <p>The abstract operation ToUint32 converts _argument_ to one of 2<sup>32</sup> integer values in the range 0 through <emu-eqn>2<sup>32</sup> - 1</emu-eqn>, inclusive. This abstract operation functions as follows:</p>
      <emu-alg>
        1. Let _number_ be ? ToNumber(_argument_).
        1. If _number_ is *NaN*, *+0*, *-0*, *+&infin;*, or *-&infin;*, return *+0*.
        1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(_number_)).
        1. Let _int32bit_ be _int_ modulo 2<sup>32</sup>.
        1. Return _int32bit_.
      </emu-alg>
      <emu-note>
        <p>Given the above definition of ToUint32:</p>
        <ul>
          <li>
            Step 5 is the only difference between ToUint32 and ToInt32.
          </li>
          <li>
            The ToUint32 abstract operation is idempotent: if applied to a result that it produced, the second application leaves that value unchanged.
          </li>
          <li>
            ToUint32(ToInt32(_x_)) is equal to ToUint32(_x_) for all values of _x_. (It is to preserve this latter property that *+&infin;* and *-&infin;* are mapped to *+0*.)
          </li>
          <li>
            ToUint32 maps *-0* to *+0*.
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-toint16" aoid="ToInt16">
      <h1>ToInt16 ( _argument_ )</h1>
      <p>The abstract operation ToInt16 converts _argument_ to one of 2<sup>16</sup> integer values in the range -32768 through 32767, inclusive. This abstract operation functions as follows:</p>
      <emu-alg>
        1. Let _number_ be ? ToNumber(_argument_).
        1. If _number_ is *NaN*, *+0*, *-0*, *+&infin;*, or *-&infin;*, return *+0*.
        1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(_number_)).
        1. Let _int16bit_ be _int_ modulo 2<sup>16</sup>.
        1. If _int16bit_ &ge; 2<sup>15</sup>, return _int16bit_ - 2<sup>16</sup>; otherwise return _int16bit_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-touint16" aoid="ToUint16">
      <h1>ToUint16 ( _argument_ )</h1>
      <p>The abstract operation ToUint16 converts _argument_ to one of 2<sup>16</sup> integer values in the range 0 through <emu-eqn>2<sup>16</sup> - 1</emu-eqn>, inclusive. This abstract operation functions as follows:</p>
      <emu-alg>
        1. Let _number_ be ? ToNumber(_argument_).
        1. If _number_ is *NaN*, *+0*, *-0*, *+&infin;*, or *-&infin;*, return *+0*.
        1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(_number_)).
        1. Let _int16bit_ be _int_ modulo 2<sup>16</sup>.
        1. Return _int16bit_.
      </emu-alg>
      <emu-note>
        <p>Given the above definition of ToUint16:</p>
        <ul>
          <li>
            The substitution of 2<sup>16</sup> for 2<sup>32</sup> in step 4 is the only difference between ToUint32 and ToUint16.
          </li>
          <li>
            ToUint16 maps *-0* to *+0*.
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-toint8" aoid="ToInt8">
      <h1>ToInt8 ( _argument_ )</h1>
      <p>The abstract operation ToInt8 converts _argument_ to one of 2<sup>8</sup> integer values in the range -128 through 127, inclusive. This abstract operation functions as follows:</p>
      <emu-alg>
        1. Let _number_ be ? ToNumber(_argument_).
        1. If _number_ is *NaN*, *+0*, *-0*, *+&infin;*, or *-&infin;*, return *+0*.
        1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(_number_)).
        1. Let _int8bit_ be _int_ modulo 2<sup>8</sup>.
        1. If _int8bit_ &ge; 2<sup>7</sup>, return _int8bit_ - 2<sup>8</sup>; otherwise return _int8bit_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-touint8" aoid="ToUint8">
      <h1>ToUint8 ( _argument_ )</h1>
      <p>The abstract operation ToUint8 converts _argument_ to one of 2<sup>8</sup> integer values in the range 0 through 255, inclusive. This abstract operation functions as follows:</p>
      <emu-alg>
        1. Let _number_ be ? ToNumber(_argument_).
        1. If _number_ is *NaN*, *+0*, *-0*, *+&infin;*, or *-&infin;*, return *+0*.
        1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(_number_)).
        1. Let _int8bit_ be _int_ modulo 2<sup>8</sup>.
        1. Return _int8bit_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-touint8clamp" aoid="ToUint8Clamp">
      <h1>ToUint8Clamp ( _argument_ )</h1>
      <p>The abstract operation ToUint8Clamp converts _argument_ to one of 2<sup>8</sup> integer values in the range 0 through 255, inclusive. This abstract operation functions as follows:</p>
      <emu-alg>
        1. Let _number_ be ? ToNumber(_argument_).
        1. If _number_ is *NaN*, return *+0*.
        1. If _number_ &le; 0, return *+0*.
        1. If _number_ &ge; 255, return 255.
        1. Let _f_ be floor(_number_).
        1. If _f_ + 0.5 &lt; _number_, return _f_ + 1.
        1. If _number_ &lt; _f_ + 0.5, return _f_.
        1. If _f_ is odd, return _f_ + 1.
        1. Return _f_.
      </emu-alg>
      <emu-note>
        <p>Unlike the other ECMAScript integer conversion abstract operation, ToUint8Clamp rounds rather than truncates non-integer values and does not convert *+&infin;* to 0. ToUint8Clamp does &ldquo;round half to even&rdquo; tie-breaking. This differs from `Math.round` which does &ldquo;round half up&rdquo; tie-breaking.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-tostring" aoid="ToString">
      <h1>ToString ( _argument_ )</h1>
      <p>The abstract operation ToString converts _argument_ to a value of type String according to <emu-xref href="#table-12"></emu-xref>:</p>
      <emu-table id="table-12" caption="ToString Conversions">
        <table>
          <tbody>
          <tr>
            <th>
              Argument Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              Undefined
            </td>
            <td>
              Return `"undefined"`.
            </td>
          </tr>
          <tr>
            <td>
              Null
            </td>
            <td>
              Return `"null"`.
            </td>
          </tr>
          <tr>
            <td>
              Boolean
            </td>
            <td>
              <p>If _argument_ is *true*, return `"true"`.</p>
              <p>If _argument_ is *false*, return `"false"`.</p>
            </td>
          </tr>
          <tr>
            <td>
              Number
            </td>
            <td>
              Return NumberToString(_argument_).
            </td>
          </tr>
          <tr>
            <td>
              String
            </td>
            <td>
              Return _argument_.
            </td>
          </tr>
          <tr>
            <td>
              Symbol
            </td>
            <td>
              Throw a *TypeError* exception.
            </td>
          </tr>
          <tr>
            <td>
              Object
            </td>
            <td>
              <p>Apply the following steps:</p>
              <emu-alg>
                1. Let _primValue_ be ? ToPrimitive(_argument_, hint String).
                1. Return ? ToString(_primValue_).
              </emu-alg>
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>

      <emu-clause id="sec-tostring-applied-to-the-number-type" aoid="NumberToString">
        <h1>NumberToString ( _m_ )</h1>
        <p>The abstract operation NumberToString converts a Number _m_ to String format as follows:</p>
        <emu-alg>
          1. If _m_ is *NaN*, return the String `"NaN"`.
          1. If _m_ is *+0* or *-0*, return the String `"0"`.
          1. If _m_ is less than zero, return the string-concatenation of `"-"` and ! NumberToString(-_m_).
          1. If _m_ is *+&infin;*, return the String `"Infinity"`.
          1. Otherwise, let _n_, _k_, and _s_ be integers such that _k_ &ge; 1, 10<sup>_k_ - 1</sup> &le; _s_ &lt; 10<sup>_k_</sup>, the Number value for _s_ &times; 10<sup>_n_ - _k_</sup> is _m_, and _k_ is as small as possible. Note that _k_ is the number of digits in the decimal representation of _s_, that _s_ is not divisible by 10, and that the least significant digit of _s_ is not necessarily uniquely determined by these criteria.
          1. If _k_ &le; _n_ &le; 21, return the string-concatenation of:
            * the code units of the _k_ digits of the decimal representation of _s_ (in order, with no leading zeroes)
            * _n_ - _k_ occurrences of the code unit 0x0030 (DIGIT ZERO)
          1. If 0 &lt; _n_ &le; 21, return the string-concatenation of:
            * the code units of the most significant _n_ digits of the decimal representation of _s_
            * the code unit 0x002E (FULL STOP)
            * the code units of the remaining _k_ - _n_ digits of the decimal representation of _s_
          1. If -6 &lt; _n_ &le; 0, return the string-concatenation of:
            * the code unit 0x0030 (DIGIT ZERO)
            * the code unit 0x002E (FULL STOP)
            * -_n_ occurrences of the code unit 0x0030 (DIGIT ZERO)
            * the code units of the _k_ digits of the decimal representation of _s_
          1. Otherwise, if _k_ = 1, return the string-concatenation of:
            * the code unit of the single digit of _s_
            * the code unit 0x0065 (LATIN SMALL LETTER E)
            * the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS) according to whether _n_ - 1 is positive or negative
            * the code units of the decimal representation of the integer abs(_n_ - 1) (with no leading zeroes)
          1. Return the string-concatenation of:
            * the code units of the most significant digit of the decimal representation of _s_
            * the code unit 0x002E (FULL STOP)
            * the code units of the remaining _k_ - 1 digits of the decimal representation of _s_
            * the code unit 0x0065 (LATIN SMALL LETTER E)
            * the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS) according to whether _n_ - 1 is positive or negative
            * the code units of the decimal representation of the integer abs(_n_ - 1) (with no leading zeroes)
        </emu-alg>
        <emu-note>
          <p>The following observations may be useful as guidelines for implementations, but are not part of the normative requirements of this Standard:</p>
          <ul>
            <li>
              If x is any Number value other than *-0*, then ToNumber(ToString(x)) is exactly the same Number value as x.
            </li>
            <li>
              The least significant digit of s is not always uniquely determined by the requirements listed in step 5.
            </li>
          </ul>
        </emu-note>
        <emu-note>
          <p>For implementations that provide more accurate conversions than required by the rules above, it is recommended that the following alternative version of step 5 be used as a guideline:</p>
          <emu-alg>
            5. Otherwise, let _n_, _k_, and _s_ be integers such that _k_ &ge; 1, 10<sup>_k_ - 1</sup> &le; _s_ &lt; 10<sup>_k_</sup>, the Number value for _s_ &times; 10<sup>_n_ - _k_</sup> is _m_, and _k_ is as small as possible. If there are multiple possibilities for _s_, choose the value of _s_ for which _s_ &times; 10<sup>_n_ - _k_</sup> is closest in value to _m_. If there are two such possible values of _s_, choose the one that is even. Note that _k_ is the number of digits in the decimal representation of _s_ and that _s_ is not divisible by 10.
          </emu-alg>
        </emu-note>
        <emu-note>
          <p>Implementers of ECMAScript may find useful the paper and code written by David M. Gay for binary-to-decimal conversion of floating-point numbers:</p>
          <p>Gay, David M. Correctly Rounded Binary-Decimal and Decimal-Binary Conversions. Numerical Analysis, Manuscript 90-10. AT&amp;T Bell Laboratories (Murray Hill, New Jersey). November 30, 1990. Available as
            <br>
            <a href="http://ampl.com/REFS/abstracts.html#rounding">http://ampl.com/REFS/abstracts.html#rounding</a>. Associated code available as
            <br>
            <a href="http://netlib.sandia.gov/fp/dtoa.c">http://netlib.sandia.gov/fp/dtoa.c</a> and as
            <br>
            <a href="http://netlib.sandia.gov/fp/g_fmt.c">http://netlib.sandia.gov/fp/g_fmt.c</a> and may also be found at the various `netlib` mirror sites.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-toobject" aoid="ToObject">
      <h1>ToObject ( _argument_ )</h1>
      <p>The abstract operation ToObject converts _argument_ to a value of type Object according to <emu-xref href="#table-13"></emu-xref>:</p>
      <emu-table id="table-13" caption="ToObject Conversions">
        <table>
          <tbody>
          <tr>
            <th>
              Argument Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              Undefined
            </td>
            <td>
              Throw a *TypeError* exception.
            </td>
          </tr>
          <tr>
            <td>
              Null
            </td>
            <td>
              Throw a *TypeError* exception.
            </td>
          </tr>
          <tr>
            <td>
              Boolean
            </td>
            <td>
              Return a new Boolean object whose [[BooleanData]] internal slot is set to _argument_. See <emu-xref href="#sec-boolean-objects"></emu-xref> for a description of Boolean objects.
            </td>
          </tr>
          <tr>
            <td>
              Number
            </td>
            <td>
              Return a new Number object whose [[NumberData]] internal slot is set to _argument_. See <emu-xref href="#sec-number-objects"></emu-xref> for a description of Number objects.
            </td>
          </tr>
          <tr>
            <td>
              String
            </td>
            <td>
              Return a new String object whose [[StringData]] internal slot is set to _argument_. See <emu-xref href="#sec-string-objects"></emu-xref> for a description of String objects.
            </td>
          </tr>
          <tr>
            <td>
              Symbol
            </td>
            <td>
              Return a new Symbol object whose [[SymbolData]] internal slot is set to _argument_. See <emu-xref href="#sec-symbol-objects"></emu-xref> for a description of Symbol objects.
            </td>
          </tr>
          <tr>
            <td>
              Object
            </td>
            <td>
              Return _argument_.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-topropertykey" aoid="ToPropertyKey">
      <h1>ToPropertyKey ( _argument_ )</h1>
      <p>The abstract operation ToPropertyKey converts _argument_ to a value that can be used as a property key by performing the following steps:</p>
      <emu-alg>
        1. Let _key_ be ? ToPrimitive(_argument_, hint String).
        1. If Type(_key_) is Symbol, then
          1. Return _key_.
        1. Return ! ToString(_key_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tolength" aoid="ToLength">
      <h1>ToLength ( _argument_ )</h1>
      <p>The abstract operation ToLength converts _argument_ to an integer suitable for use as the length of an array-like object. It performs the following steps:</p>
      <emu-alg>
        1. Let _len_ be ? ToInteger(_argument_).
        1. If _len_ &le; *+0*, return *+0*.
        1. Return min(_len_, 2<sup>53</sup> - 1).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-canonicalnumericindexstring" aoid="CanonicalNumericIndexString">
      <h1>CanonicalNumericIndexString ( _argument_ )</h1>
      <p>The abstract operation CanonicalNumericIndexString returns _argument_ converted to a numeric value if it is a String representation of a Number that would be produced by ToString, or the string `"-0"`. Otherwise, it returns *undefined*. This abstract operation functions as follows:</p>
      <emu-alg>
        1. Assert: Type(_argument_) is String.
        1. If _argument_ is `"-0"`, return *-0*.
        1. Let _n_ be ! ToNumber(_argument_).
        1. If SameValue(! ToString(_n_), _argument_) is *false*, return *undefined*.
        1. Return _n_.
      </emu-alg>
      <p>A <em>canonical numeric string</em> is any String value for which the CanonicalNumericIndexString abstract operation does not return *undefined*.</p>
    </emu-clause>

    <emu-clause id="sec-toindex" aoid="ToIndex">
      <h1>ToIndex ( _value_ )</h1>
      <p>The abstract operation ToIndex returns _value_ argument converted to a numeric value if it is a valid integer index value. This abstract operation functions as follows:</p>
      <emu-alg>
        1. If _value_ is *undefined*, then
          1. Let _index_ be 0.
        1. Else,
          1. Let _integerIndex_ be ? ToInteger(_value_).
          1. If _integerIndex_ &lt; 0, throw a *RangeError* exception.
          1. Let _index_ be ! ToLength(_integerIndex_).
          1. If SameValueZero(_integerIndex_, _index_) is *false*, throw a *RangeError* exception.
        1. Return _index_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-testing-and-comparison-operations">
    <h1>Testing and Comparison Operations</h1>

    <emu-clause id="sec-requireobjectcoercible" aoid="RequireObjectCoercible">
      <h1>RequireObjectCoercible ( _argument_ )</h1>
      <p>The abstract operation RequireObjectCoercible throws an error if _argument_ is a value that cannot be converted to an Object using ToObject. It is defined by <emu-xref href="#table-14"></emu-xref>:</p>
      <emu-table id="table-14" caption="RequireObjectCoercible Results">
        <table>
          <tbody>
          <tr>
            <th>
              Argument Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              Undefined
            </td>
            <td>
              Throw a *TypeError* exception.
            </td>
          </tr>
          <tr>
            <td>
              Null
            </td>
            <td>
              Throw a *TypeError* exception.
            </td>
          </tr>
          <tr>
            <td>
              Boolean
            </td>
            <td>
              Return _argument_.
            </td>
          </tr>
          <tr>
            <td>
              Number
            </td>
            <td>
              Return _argument_.
            </td>
          </tr>
          <tr>
            <td>
              String
            </td>
            <td>
              Return _argument_.
            </td>
          </tr>
          <tr>
            <td>
              Symbol
            </td>
            <td>
              Return _argument_.
            </td>
          </tr>
          <tr>
            <td>
              Object
            </td>
            <td>
              Return _argument_.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-isarray" aoid="IsArray">
      <h1>IsArray ( _argument_ )</h1>
      <p>The abstract operation IsArray takes one argument _argument_, and performs the following steps:</p>
      <emu-alg>
        1. If Type(_argument_) is not Object, return *false*.
        1. If _argument_ is an Array exotic object, return *true*.
        1. If _argument_ is a Proxy exotic object, then
          1. If _argument_.[[ProxyHandler]] is *null*, throw a *TypeError* exception.
          1. Let _target_ be _argument_.[[ProxyTarget]].
          1. Return ? IsArray(_target_).
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iscallable" aoid="IsCallable">
      <h1>IsCallable ( _argument_ )</h1>
      <p>The abstract operation IsCallable determines if _argument_, which must be an ECMAScript language value, is a callable function with a [[Call]] internal method.</p>
      <emu-alg>
        1. If Type(_argument_) is not Object, return *false*.
        1. If _argument_ has a [[Call]] internal method, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isconstructor" aoid="IsConstructor">
      <h1>IsConstructor ( _argument_ )</h1>
      <p>The abstract operation IsConstructor determines if _argument_, which must be an ECMAScript language value, is a function object with a [[Construct]] internal method.</p>
      <emu-alg>
        1. If Type(_argument_) is not Object, return *false*.
        1. If _argument_ has a [[Construct]] internal method, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isextensible-o" aoid="IsExtensible">
      <h1>IsExtensible ( _O_ )</h1>
      <p>The abstract operation IsExtensible is used to determine whether additional properties can be added to the object that is _O_. A Boolean value is returned. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. Assert: Type(_O_) is Object.
        1. Return ? _O_.[[IsExtensible]]().
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isinteger" aoid="IsInteger">
      <h1>IsInteger ( _argument_ )</h1>
      <p>The abstract operation IsInteger determines if _argument_ is a finite integer numeric value.</p>
      <emu-alg>
        1. If Type(_argument_) is not Number, return *false*.
        1. If _argument_ is *NaN*, *+&infin;*, or *-&infin;*, return *false*.
        1. If floor(abs(_argument_)) &ne; abs(_argument_), return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-ispropertykey" aoid="IsPropertyKey">
      <h1>IsPropertyKey ( _argument_ )</h1>
      <p>The abstract operation IsPropertyKey determines if _argument_, which must be an ECMAScript language value, is a value that may be used as a property key.</p>
      <emu-alg>
        1. If Type(_argument_) is String, return *true*.
        1. If Type(_argument_) is Symbol, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isregexp" aoid="IsRegExp">
      <h1>IsRegExp ( _argument_ )</h1>
      <p>The abstract operation IsRegExp with argument _argument_ performs the following steps:</p>
      <emu-alg>
        1. If Type(_argument_) is not Object, return *false*.
        1. Let _matcher_ be ? Get(_argument_, @@match).
        1. If _matcher_ is not *undefined*, return ToBoolean(_matcher_).
        1. If _argument_ has a [[RegExpMatcher]] internal slot, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isstringprefix" aoid="IsStringPrefix">
      <h1>IsStringPrefix ( _p_, _q_ )</h1>
      <p>The abstract operation IsStringPrefix determines if String _p_ is a prefix of String _q_.</p>
      <emu-alg>
        1. Assert: Type(_p_) is String.
        1. Assert: Type(_q_) is String.
        1. If _q_ can be the string-concatenation of _p_ and some other String _r_, return *true*. Otherwise, return *false*.
        1. NOTE: Any String is a prefix of itself, because _r_ may be the empty String.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-samevalue" aoid="SameValue">
      <h1>SameValue ( _x_, _y_ )</h1>
      <p>The internal comparison abstract operation SameValue(_x_, _y_), where _x_ and _y_ are ECMAScript language values, produces *true* or *false*. Such a comparison is performed as follows:</p>
      <emu-alg>
        1. If Type(_x_) is different from Type(_y_), return *false*.
        1. If Type(_x_) is Number, then
          1. If _x_ is *NaN* and _y_ is *NaN*, return *true*.
          1. If _x_ is *+0* and _y_ is *-0*, return *false*.
          1. If _x_ is *-0* and _y_ is *+0*, return *false*.
          1. If _x_ is the same Number value as _y_, return *true*.
          1. Return *false*.
        1. Return SameValueNonNumber(_x_, _y_).
      </emu-alg>
      <emu-note>
        <p>This algorithm differs from the Strict Equality Comparison Algorithm in its treatment of signed zeroes and NaNs.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-samevaluezero" aoid="SameValueZero">
      <h1>SameValueZero ( _x_, _y_ )</h1>
      <p>The internal comparison abstract operation SameValueZero(_x_, _y_), where _x_ and _y_ are ECMAScript language values, produces *true* or *false*. Such a comparison is performed as follows:</p>
      <emu-alg>
        1. If Type(_x_) is different from Type(_y_), return *false*.
        1. If Type(_x_) is Number, then
          1. If _x_ is *NaN* and _y_ is *NaN*, return *true*.
          1. If _x_ is *+0* and _y_ is *-0*, return *true*.
          1. If _x_ is *-0* and _y_ is *+0*, return *true*.
          1. If _x_ is the same Number value as _y_, return *true*.
          1. Return *false*.
        1. Return SameValueNonNumber(_x_, _y_).
      </emu-alg>
      <emu-note>
        <p>SameValueZero differs from SameValue only in its treatment of *+0* and *-0*.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-samevaluenonnumber" aoid="SameValueNonNumber">
      <h1>SameValueNonNumber ( _x_, _y_ )</h1>
      <p>The internal comparison abstract operation SameValueNonNumber(_x_, _y_), where neither _x_ nor _y_ are Number values, produces *true* or *false*. Such a comparison is performed as follows:</p>
      <emu-alg>
        1. Assert: Type(_x_) is not Number.
        1. Assert: Type(_x_) is the same as Type(_y_).
        1. If Type(_x_) is Undefined, return *true*.
        1. If Type(_x_) is Null, return *true*.
        1. If Type(_x_) is String, then
          1. If _x_ and _y_ are exactly the same sequence of code units (same length and same code units at corresponding indices), return *true*; otherwise, return *false*.
        1. If Type(_x_) is Boolean, then
          1. If _x_ and _y_ are both *true* or both *false*, return *true*; otherwise, return *false*.
        1. If Type(_x_) is Symbol, then
          1. If _x_ and _y_ are both the same Symbol value, return *true*; otherwise, return *false*.
        1. If _x_ and _y_ are the same Object value, return *true*. Otherwise, return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-abstract-relational-comparison" aoid="Abstract Relational Comparison">
      <h1>Abstract Relational Comparison</h1>
      <p>The comparison _x_ &lt; _y_, where _x_ and _y_ are values, produces *true*, *false*, or *undefined* (which indicates that at least one operand is *NaN*). In addition to _x_ and _y_ the algorithm takes a Boolean flag named _LeftFirst_ as a parameter. The flag is used to control the order in which operations with potentially visible side-effects are performed upon _x_ and _y_. It is necessary because ECMAScript specifies left to right evaluation of expressions. The default value of _LeftFirst_ is *true* and indicates that the _x_ parameter corresponds to an expression that occurs to the left of the _y_ parameter's corresponding expression. If _LeftFirst_ is *false*, the reverse is the case and operations must be performed upon _y_ before _x_. Such a comparison is performed as follows:</p>
      <emu-alg>
        1. If the _LeftFirst_ flag is *true*, then
          1. Let _px_ be ? ToPrimitive(_x_, hint Number).
          1. Let _py_ be ? ToPrimitive(_y_, hint Number).
        1. Else the order of evaluation needs to be reversed to preserve left to right evaluation,
          1. Let _py_ be ? ToPrimitive(_y_, hint Number).
          1. Let _px_ be ? ToPrimitive(_x_, hint Number).
        1. If Type(_px_) is String and Type(_py_) is String, then
          1. If IsStringPrefix(_py_, _px_) is *true*, return *false*.
          1. If IsStringPrefix(_px_, _py_) is *true*, return *true*.
          1. Let _k_ be the smallest nonnegative integer such that the code unit at index _k_ within _px_ is different from the code unit at index _k_ within _py_. (There must be such a _k_, for neither String is a prefix of the other.)
          1. Let _m_ be the integer that is the numeric value of the code unit at index _k_ within _px_.
          1. Let _n_ be the integer that is the numeric value of the code unit at index _k_ within _py_.
          1. If _m_ &lt; _n_, return *true*. Otherwise, return *false*.
        1. Else,
          1. NOTE: Because _px_ and _py_ are primitive values evaluation order is not important.
          1. Let _nx_ be ? ToNumber(_px_).
          1. Let _ny_ be ? ToNumber(_py_).
          1. If _nx_ is *NaN*, return *undefined*.
          1. If _ny_ is *NaN*, return *undefined*.
          1. If _nx_ and _ny_ are the same Number value, return *false*.
          1. If _nx_ is *+0* and _ny_ is *-0*, return *false*.
          1. If _nx_ is *-0* and _ny_ is *+0*, return *false*.
          1. If _nx_ is *+&infin;*, return *false*.
          1. If _ny_ is *+&infin;*, return *true*.
          1. If _ny_ is *-&infin;*, return *false*.
          1. If _nx_ is *-&infin;*, return *true*.
          1. If the mathematical value of _nx_ is less than the mathematical value of _ny_&mdash;note that these mathematical values are both finite and not both zero&mdash;return *true*. Otherwise, return *false*.
      </emu-alg>
      <emu-note>
        <p>Step 3 differs from step 7 in the algorithm for the addition operator `+` (<emu-xref href="#sec-addition-operator-plus"></emu-xref>) by using the logical-and operation instead of the logical-or operation.</p>
      </emu-note>
      <emu-note>
        <p>The comparison of Strings uses a simple lexicographic ordering on sequences of code unit values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore String values that are canonically equal according to the Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalized form. Also, note that for strings containing supplementary characters, lexicographic ordering on sequences of UTF-16 code unit values differs from that on sequences of code point values.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-abstract-equality-comparison" aoid="Abstract Equality Comparison">
      <h1>Abstract Equality Comparison</h1>
      <p>The comparison _x_ == _y_, where _x_ and _y_ are values, produces *true* or *false*. Such a comparison is performed as follows:</p>
      <emu-alg>
        1. If Type(_x_) is the same as Type(_y_), then
          1. Return the result of performing Strict Equality Comparison _x_ === _y_.
        1. If _x_ is *null* and _y_ is *undefined*, return *true*.
        1. If _x_ is *undefined* and _y_ is *null*, return *true*.
        1. If Type(_x_) is Number and Type(_y_) is String, return the result of the comparison _x_ == ! ToNumber(_y_).
        1. If Type(_x_) is String and Type(_y_) is Number, return the result of the comparison ! ToNumber(_x_) == _y_.
        1. If Type(_x_) is Boolean, return the result of the comparison ! ToNumber(_x_) == _y_.
        1. If Type(_y_) is Boolean, return the result of the comparison _x_ == ! ToNumber(_y_).
        1. If Type(_x_) is either String, Number, or Symbol and Type(_y_) is Object, return the result of the comparison _x_ == ToPrimitive(_y_).
        1. If Type(_x_) is Object and Type(_y_) is either String, Number, or Symbol, return the result of the comparison ToPrimitive(_x_) == _y_.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-strict-equality-comparison" aoid="Strict Equality Comparison">
      <h1>Strict Equality Comparison</h1>
      <p>The comparison _x_ === _y_, where _x_ and _y_ are values, produces *true* or *false*. Such a comparison is performed as follows:</p>
      <emu-alg>
        1. If Type(_x_) is different from Type(_y_), return *false*.
        1. If Type(_x_) is Number, then
          1. If _x_ is *NaN*, return *false*.
          1. If _y_ is *NaN*, return *false*.
          1. If _x_ is the same Number value as _y_, return *true*.
          1. If _x_ is *+0* and _y_ is *-0*, return *true*.
          1. If _x_ is *-0* and _y_ is *+0*, return *true*.
          1. Return *false*.
        1. Return SameValueNonNumber(_x_, _y_).
      </emu-alg>
      <emu-note>
        <p>This algorithm differs from the SameValue Algorithm in its treatment of signed zeroes and NaNs.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-operations-on-objects">
    <h1>Operations on Objects</h1>

    <emu-clause id="sec-get-o-p" aoid="Get">
      <h1>Get ( _O_, _P_ )</h1>
      <p>The abstract operation Get is used to retrieve the value of a specific property of an object. The operation is called with arguments _O_ and _P_ where _O_ is the object and _P_ is the property key. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. Assert: Type(_O_) is Object.
        1. Assert: IsPropertyKey(_P_) is *true*.
        1. Return ? _O_.[[Get]](_P_, _O_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getv" aoid="GetV">
      <h1>GetV ( _V_, _P_ )</h1>
      <p>The abstract operation GetV is used to retrieve the value of a specific property of an ECMAScript language value. If the value is not an object, the property lookup is performed using a wrapper object appropriate for the type of the value. The operation is called with arguments _V_ and _P_ where _V_ is the value and _P_ is the property key. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. Assert: IsPropertyKey(_P_) is *true*.
        1. Let _O_ be ? ToObject(_V_).
        1. Return ? _O_.[[Get]](_P_, _V_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-set-o-p-v-throw" aoid="Set">
      <h1>Set ( _O_, _P_, _V_, _Throw_ )</h1>
      <p>The abstract operation Set is used to set the value of a specific property of an object. The operation is called with arguments _O_, _P_, _V_, and _Throw_ where _O_ is the object, _P_ is the property key, _V_ is the new value for the property and _Throw_ is a Boolean flag. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. Assert: Type(_O_) is Object.
        1. Assert: IsPropertyKey(_P_) is *true*.
        1. Assert: Type(_Throw_) is Boolean.
        1. Let _success_ be ? _O_.[[Set]](_P_, _V_, _O_).
        1. If _success_ is *false* and _Throw_ is *true*, throw a *TypeError* exception.
        1. Return _success_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createdataproperty" aoid="CreateDataProperty">
      <h1>CreateDataProperty ( _O_, _P_, _V_ )</h1>
      <p>The abstract operation CreateDataProperty is used to create a new own property of an object. The operation is called with arguments _O_, _P_, and _V_ where _O_ is the object, _P_ is the property key, and _V_ is the value for the property. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. Assert: Type(_O_) is Object.
        1. Assert: IsPropertyKey(_P_) is *true*.
        1. Let _newDesc_ be the PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* }.
        1. Return ? _O_.[[DefineOwnProperty]](_P_, _newDesc_).
      </emu-alg>
      <emu-note>
        <p>This abstract operation creates a property whose attributes are set to the same defaults used for properties created by the ECMAScript language assignment operator. Normally, the property will not already exist. If it does exist and is not configurable or if _O_ is not extensible, [[DefineOwnProperty]] will return *false*.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-createmethodproperty" aoid="CreateMethodProperty">
      <h1>CreateMethodProperty ( _O_, _P_, _V_ )</h1>
      <p>The abstract operation CreateMethodProperty is used to create a new own property of an object. The operation is called with arguments _O_, _P_, and _V_ where _O_ is the object, _P_ is the property key, and _V_ is the value for the property. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. Assert: Type(_O_) is Object.
        1. Assert: IsPropertyKey(_P_) is *true*.
        1. Let _newDesc_ be the PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
        1. Return ? _O_.[[DefineOwnProperty]](_P_, _newDesc_).
      </emu-alg>
      <emu-note>
        <p>This abstract operation creates a property whose attributes are set to the same defaults used for built-in methods and methods defined using class declaration syntax. Normally, the property will not already exist. If it does exist and is not configurable or if _O_ is not extensible, [[DefineOwnProperty]] will return *false*.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-createdatapropertyorthrow" aoid="CreateDataPropertyOrThrow">
      <h1>CreateDataPropertyOrThrow ( _O_, _P_, _V_ )</h1>
      <p>The abstract operation CreateDataPropertyOrThrow is used to create a new own property of an object. It throws a *TypeError* exception if the requested property update cannot be performed. The operation is called with arguments _O_, _P_, and _V_ where _O_ is the object, _P_ is the property key, and _V_ is the value for the property. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. Assert: Type(_O_) is Object.
        1. Assert: IsPropertyKey(_P_) is *true*.
        1. Let _success_ be ? CreateDataProperty(_O_, _P_, _V_).
        1. If _success_ is *false*, throw a *TypeError* exception.
        1. Return _success_.
      </emu-alg>
      <emu-note>
        <p>This abstract operation creates a property whose attributes are set to the same defaults used for properties created by the ECMAScript language assignment operator. Normally, the property will not already exist. If it does exist and is not configurable or if _O_ is not extensible, [[DefineOwnProperty]] will return *false* causing this operation to throw a *TypeError* exception.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-definepropertyorthrow" aoid="DefinePropertyOrThrow">
      <h1>DefinePropertyOrThrow ( _O_, _P_, _desc_ )</h1>
      <p>The abstract operation DefinePropertyOrThrow is used to call the [[DefineOwnProperty]] internal method of an object in a manner that will throw a *TypeError* exception if the requested property update cannot be performed. The operation is called with arguments _O_, _P_, and _desc_ where _O_ is the object, _P_ is the property key, and _desc_ is the Property Descriptor for the property. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. Assert: Type(_O_) is Object.
        1. Assert: IsPropertyKey(_P_) is *true*.
        1. Let _success_ be ? _O_.[[DefineOwnProperty]](_P_, _desc_).
        1. If _success_ is *false*, throw a *TypeError* exception.
        1. Return _success_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-deletepropertyorthrow" aoid="DeletePropertyOrThrow">
      <h1>DeletePropertyOrThrow ( _O_, _P_ )</h1>
      <p>The abstract operation DeletePropertyOrThrow is used to remove a specific own property of an object. It throws an exception if the property is not configurable. The operation is called with arguments _O_ and _P_ where _O_ is the object and _P_ is the property key. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. Assert: Type(_O_) is Object.
        1. Assert: IsPropertyKey(_P_) is *true*.
        1. Let _success_ be ? _O_.[[Delete]](_P_).
        1. If _success_ is *false*, throw a *TypeError* exception.
        1. Return _success_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getmethod" aoid="GetMethod">
      <h1>GetMethod ( _V_, _P_ )</h1>
      <p>The abstract operation GetMethod is used to get the value of a specific property of an ECMAScript language value when the value of the property is expected to be a function. The operation is called with arguments _V_ and _P_ where _V_ is the ECMAScript language value, _P_ is the property key. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. Assert: IsPropertyKey(_P_) is *true*.
        1. Let _func_ be ? GetV(_V_, _P_).
        1. If _func_ is either *undefined* or *null*, return *undefined*.
        1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.
        1. Return _func_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-hasproperty" aoid="HasProperty">
      <h1>HasProperty ( _O_, _P_ )</h1>
      <p>The abstract operation HasProperty is used to determine whether an object has a property with the specified property key. The property may be either an own or inherited. A Boolean value is returned. The operation is called with arguments _O_ and _P_ where _O_ is the object and _P_ is the property key. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. Assert: Type(_O_) is Object.
        1. Assert: IsPropertyKey(_P_) is *true*.
        1. Return ? _O_.[[HasProperty]](_P_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-hasownproperty" aoid="HasOwnProperty">
      <h1>HasOwnProperty ( _O_, _P_ )</h1>
      <p>The abstract operation HasOwnProperty is used to determine whether an object has an own property with the specified property key. A Boolean value is returned. The operation is called with arguments _O_ and _P_ where _O_ is the object and _P_ is the property key. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. Assert: Type(_O_) is Object.
        1. Assert: IsPropertyKey(_P_) is *true*.
        1. Let _desc_ be ? _O_.[[GetOwnProperty]](_P_).
        1. If _desc_ is *undefined*, return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-call" aoid="Call">
      <h1>Call ( _F_, _V_ [ , _argumentsList_ ] )</h1>
      <p>The abstract operation Call is used to call the [[Call]] internal method of a function object. The operation is called with arguments _F_, _V_, and optionally _argumentsList_ where _F_ is the function object, _V_ is an ECMAScript language value that is the *this* value of the [[Call]], and _argumentsList_ is the value passed to the corresponding argument of the internal method. If _argumentsList_ is not present, a new empty List is used as its value. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. If _argumentsList_ is not present, set _argumentsList_ to a new empty List.
        1. If IsCallable(_F_) is *false*, throw a *TypeError* exception.
        1. Return ? _F_.[[Call]](_V_, _argumentsList_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-construct" aoid="Construct">
      <h1>Construct ( _F_ [ , _argumentsList_ [ , _newTarget_ ] ] )</h1>
      <p>The abstract operation Construct is used to call the [[Construct]] internal method of a function object. The operation is called with arguments _F_, and optionally _argumentsList_, and _newTarget_ where _F_ is the function object. _argumentsList_ and _newTarget_ are the values to be passed as the corresponding arguments of the internal method. If _argumentsList_ is not present, a new empty List is used as its value. If _newTarget_ is not present, _F_ is used as its value. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. If _newTarget_ is not present, set _newTarget_ to _F_.
        1. If _argumentsList_ is not present, set _argumentsList_ to a new empty List.
        1. Assert: IsConstructor(_F_) is *true*.
        1. Assert: IsConstructor(_newTarget_) is *true*.
        1. Return ? _F_.[[Construct]](_argumentsList_, _newTarget_).
      </emu-alg>
      <emu-note>
        <p>If _newTarget_ is not present, this operation is equivalent to: `new F(...argumentsList)`</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-setintegritylevel" aoid="SetIntegrityLevel">
      <h1>SetIntegrityLevel ( _O_, _level_ )</h1>
      <p>The abstract operation SetIntegrityLevel is used to fix the set of own properties of an object. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. Assert: Type(_O_) is Object.
        1. Assert: _level_ is either `"sealed"` or `"frozen"`.
        1. Let _status_ be ? _O_.[[PreventExtensions]]().
        1. If _status_ is *false*, return *false*.
        1. Let _keys_ be ? _O_.[[OwnPropertyKeys]]().
        1. If _level_ is `"sealed"`, then
          1. For each element _k_ of _keys_, do
            1. Perform ? DefinePropertyOrThrow(_O_, _k_, PropertyDescriptor { [[Configurable]]: *false* }).
        1. Else _level_ is `"frozen"`,
          1. For each element _k_ of _keys_, do
            1. Let _currentDesc_ be ? _O_.[[GetOwnProperty]](_k_).
            1. If _currentDesc_ is not *undefined*, then
              1. If IsAccessorDescriptor(_currentDesc_) is *true*, then
                1. Let _desc_ be the PropertyDescriptor { [[Configurable]]: *false* }.
              1. Else,
                1. Let _desc_ be the PropertyDescriptor { [[Configurable]]: *false*, [[Writable]]: *false* }.
              1. Perform ? DefinePropertyOrThrow(_O_, _k_, _desc_).
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-testintegritylevel" aoid="TestIntegrityLevel">
      <h1>TestIntegrityLevel ( _O_, _level_ )</h1>
      <p>The abstract operation TestIntegrityLevel is used to determine if the set of own properties of an object are fixed. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. Assert: Type(_O_) is Object.
        1. Assert: _level_ is either `"sealed"` or `"frozen"`.
        1. Let _extensible_ be ? IsExtensible(_O_).
        1. If _extensible_ is *true*, return *false*.
        1. NOTE: If the object is extensible, none of its properties are examined.
        1. Let _keys_ be ? _O_.[[OwnPropertyKeys]]().
        1. For each element _k_ of _keys_, do
          1. Let _currentDesc_ be ? _O_.[[GetOwnProperty]](_k_).
          1. If _currentDesc_ is not *undefined*, then
            1. If _currentDesc_.[[Configurable]] is *true*, return *false*.
            1. If _level_ is `"frozen"` and IsDataDescriptor(_currentDesc_) is *true*, then
              1. If _currentDesc_.[[Writable]] is *true*, return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createarrayfromlist" aoid="CreateArrayFromList">
      <h1>CreateArrayFromList ( _elements_ )</h1>
      <p>The abstract operation CreateArrayFromList is used to create an Array object whose elements are provided by a List. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. Assert: _elements_ is a List whose elements are all ECMAScript language values.
        1. Let _array_ be ! ArrayCreate(0).
        1. Let _n_ be 0.
        1. For each element _e_ of _elements_, do
          1. Let _status_ be CreateDataProperty(_array_, ! ToString(_n_), _e_).
          1. Assert: _status_ is *true*.
          1. Increment _n_ by 1.
        1. Return _array_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createlistfromarraylike" aoid="CreateListFromArrayLike">
      <h1>CreateListFromArrayLike ( _obj_ [ , _elementTypes_ ] )</h1>
      <p>The abstract operation CreateListFromArrayLike is used to create a List value whose elements are provided by the indexed properties of an array-like object, _obj_. The optional argument _elementTypes_ is a List containing the names of ECMAScript Language Types that are allowed for element values of the List that is created. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. If _elementTypes_ is not present, set _elementTypes_ to &laquo; Undefined, Null, Boolean, String, Symbol, Number, Object &raquo;.
        1. If Type(_obj_) is not Object, throw a *TypeError* exception.
        1. Let _len_ be ? ToLength(? Get(_obj_, `"length"`)).
        1. Let _list_ be a new empty List.
        1. Let _index_ be 0.
        1. Repeat, while _index_ &lt; _len_
          1. Let _indexName_ be ! ToString(_index_).
          1. Let _next_ be ? Get(_obj_, _indexName_).
          1. If Type(_next_) is not an element of _elementTypes_, throw a *TypeError* exception.
          1. Append _next_ as the last element of _list_.
          1. Increase _index_ by 1.
        1. Return _list_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-invoke" aoid="Invoke">
      <h1>Invoke ( _V_, _P_ [ , _argumentsList_ ] )</h1>
      <p>The abstract operation Invoke is used to call a method property of an ECMAScript language value. The operation is called with arguments _V_, _P_, and optionally _argumentsList_ where _V_ serves as both the lookup point for the property and the *this* value of the call, _P_ is the property key, and _argumentsList_ is the list of arguments values passed to the method. If _argumentsList_ is not present, a new empty List is used as its value. This abstract operation performs the following steps:</p>

      <emu-alg>
        1. Assert: IsPropertyKey(_P_) is *true*.
        1. If _argumentsList_ is not present, set _argumentsList_ to a new empty List.
        1. Let _func_ be ? GetV(_V_, _P_).
        1. Return ? Call(_func_, _V_, _argumentsList_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-ordinaryhasinstance" aoid="OrdinaryHasInstance">
      <h1>OrdinaryHasInstance ( _C_, _O_ )</h1>
      <p>The abstract operation OrdinaryHasInstance implements the default algorithm for determining if an object _O_ inherits from the instance object inheritance path provided by constructor _C_. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. If IsCallable(_C_) is *false*, return *false*.
        1. If _C_ has a [[BoundTargetFunction]] internal slot, then
          1. Let _BC_ be _C_.[[BoundTargetFunction]].
          1. Return ? InstanceofOperator(_O_, _BC_).
        1. If Type(_O_) is not Object, return *false*.
        1. Let _P_ be ? Get(_C_, `"prototype"`).
        1. If Type(_P_) is not Object, throw a *TypeError* exception.
        1. Repeat,
          1. Set _O_ to ? _O_.[[GetPrototypeOf]]().
          1. If _O_ is *null*, return *false*.
          1. If SameValue(_P_, _O_) is *true*, return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-speciesconstructor" aoid="SpeciesConstructor">
      <h1>SpeciesConstructor ( _O_, _defaultConstructor_ )</h1>
      <p>The abstract operation SpeciesConstructor is used to retrieve the constructor that should be used to create new objects that are derived from the argument object _O_. The _defaultConstructor_ argument is the constructor to use if a constructor @@species property cannot be found starting from _O_. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. Assert: Type(_O_) is Object.
        1. Let _C_ be ? Get(_O_, `"constructor"`).
        1. If _C_ is *undefined*, return _defaultConstructor_.
        1. If Type(_C_) is not Object, throw a *TypeError* exception.
        1. Let _S_ be ? Get(_C_, @@species).
        1. If _S_ is either *undefined* or *null*, return _defaultConstructor_.
        1. If IsConstructor(_S_) is *true*, return _S_.
        1. Throw a *TypeError* exception.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-enumerableownpropertynames" aoid="EnumerableOwnPropertyNames" oldids="sec-enumerableownproperties">
      <h1>EnumerableOwnPropertyNames ( _O_, _kind_ )</h1>
      <p>When the abstract operation EnumerableOwnPropertyNames is called with Object _O_ and String _kind_ the following steps are taken:</p>
      <emu-alg>
        1. Assert: Type(_O_) is Object.
        1. Let _ownKeys_ be ? _O_.[[OwnPropertyKeys]]().
        1. Let _properties_ be a new empty List.
        1. For each element _key_ of _ownKeys_ in List order, do
          1. If Type(_key_) is String, then
            1. Let _desc_ be ? _O_.[[GetOwnProperty]](_key_).
            1. If _desc_ is not *undefined* and _desc_.[[Enumerable]] is *true*, then
              1. If _kind_ is *"key"*, append _key_ to _properties_.
              1. Else,
                1. Let _value_ be ? Get(_O_, _key_).
                1. If _kind_ is *"value"*, append _value_ to _properties_.
                1. Else,
                  1. Assert: _kind_ is *"key+value"*.
                  1. Let _entry_ be CreateArrayFromList(&laquo; _key_, _value_ &raquo;).
                  1. Append _entry_ to _properties_.
        1. Order the elements of _properties_ so they are in the same relative order as would be produced by the Iterator that would be returned if the EnumerateObjectProperties internal method were invoked with _O_.
        1. Return _properties_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getfunctionrealm" aoid="GetFunctionRealm">
      <h1>GetFunctionRealm ( _obj_ )</h1>
      <p>The abstract operation GetFunctionRealm with argument _obj_ performs the following steps:</p>
      <emu-alg>
        1. Assert: _obj_ is a callable object.
        1. If _obj_ has a [[Realm]] internal slot, then
          1. Return _obj_.[[Realm]].
        1. If _obj_ is a Bound Function exotic object, then
          1. Let _target_ be _obj_.[[BoundTargetFunction]].
          1. Return ? GetFunctionRealm(_target_).
        1. If _obj_ is a Proxy exotic object, then
          1. If _obj_.[[ProxyHandler]] is *null*, throw a *TypeError* exception.
          1. Let _proxyTarget_ be _obj_.[[ProxyTarget]].
          1. Return ? GetFunctionRealm(_proxyTarget_).
        1. Return the current Realm Record.
      </emu-alg>
      <emu-note>
        <p>Step 5 will only be reached if _obj_ is a non-standard function exotic object that does not have a [[Realm]] internal slot.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-copydataproperties" aoid="CopyDataProperties">
      <h1>CopyDataProperties ( _target_, _source_, _excludedItems_ )</h1>
      <p>When the abstract operation CopyDataProperties is called with arguments _target_, _source_, and _excludedItems_, the following steps are taken:</p>
      <emu-alg>
        1. Assert: Type(_target_) is Object.
        1. Assert: _excludedItems_ is a List of property keys.
        1. If _source_ is *undefined* or *null*, return _target_.
        1. Let _from_ be ! ToObject(_source_).
        1. Let _keys_ be ? _from_.[[OwnPropertyKeys]]().
        1. For each element _nextKey_ of _keys_ in List order, do
          1. Let _excluded_ be *false*.
          1. For each element _e_ of _excludedItems_ in List order, do
            1. If SameValue(_e_, _nextKey_) is *true*, then
              1. Set _excluded_ to *true*.
          1. If _excluded_ is *false*, then
            1. Let _desc_ be ? _from_.[[GetOwnProperty]](_nextKey_).
            1. If _desc_ is not *undefined* and _desc_.[[Enumerable]] is *true*, then
              1. Let _propValue_ be ? Get(_from_, _nextKey_).
              1. Perform ! CreateDataProperty(_target_, _nextKey_, _propValue_).
        1. Return _target_.
      </emu-alg>
      <emu-note>
        <p>The target passed in here is always a newly created object which is not directly accessible in case of an error being thrown.</p>
      </emu-note>
    </emu-clause>

  </emu-clause>

  <emu-clause id="sec-operations-on-iterator-objects">
    <h1>Operations on Iterator Objects</h1>
    <p>See Common Iteration Interfaces (<emu-xref href="#sec-iteration"></emu-xref>).</p>

    <emu-clause id="sec-getiterator" aoid="GetIterator">
      <h1>GetIterator ( _obj_ [ , _hint_ [ , _method_ ] ] )</h1>
      <p>The abstract operation GetIterator with argument _obj_ and optional arguments _hint_ and _method_ performs the following steps:</p>
      <emu-alg>
        1. If _hint_ is not present, set _hint_ to ~sync~.
        1. Assert: _hint_ is either ~sync~ or ~async~.
        1. If _method_ is not present, then
          1. If _hint_ is ~async~, then
            1. Set _method_ to ? GetMethod(_obj_, @@asyncIterator).
            1. If _method_ is *undefined*, then
              1. Let _syncMethod_ be ? GetMethod(_obj_, @@iterator).
              1. Let _syncIteratorRecord_ be ? GetIterator(_obj_, ~sync~, _syncMethod_).
              1. Return ? CreateAsyncFromSyncIterator(_syncIteratorRecord_).
          1. Otherwise, set _method_ to ? GetMethod(_obj_, @@iterator).
        1. Let _iterator_ be ? Call(_method_, _obj_).
        1. If Type(_iterator_) is not Object, throw a *TypeError* exception.
        1. Let _nextMethod_ be ? GetV(_iterator_, `"next"`).
        1. Let _iteratorRecord_ be Record { [[Iterator]]: _iterator_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* }.
        1. Return _iteratorRecord_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratornext" aoid="IteratorNext">
      <h1>IteratorNext ( _iteratorRecord_ [ , _value_ ] )</h1>
      <p>The abstract operation IteratorNext with argument _iteratorRecord_ and optional argument _value_ performs the following steps:</p>
      <emu-alg>
        1. If _value_ is not present, then
          1. Let _result_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]]).
        1. Else,
          1. Let _result_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]], &laquo; _value_ &raquo;).
        1. If Type(_result_) is not Object, throw a *TypeError* exception.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorcomplete" aoid="IteratorComplete">
      <h1>IteratorComplete ( _iterResult_ )</h1>
      <p>The abstract operation IteratorComplete with argument _iterResult_ performs the following steps:</p>
      <emu-alg>
        1. Assert: Type(_iterResult_) is Object.
        1. Return ToBoolean(? Get(_iterResult_, `"done"`)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorvalue" aoid="IteratorValue">
      <h1>IteratorValue ( _iterResult_ )</h1>
      <p>The abstract operation IteratorValue with argument _iterResult_ performs the following steps:</p>
      <emu-alg>
        1. Assert: Type(_iterResult_) is Object.
        1. Return ? Get(_iterResult_, `"value"`).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorstep" aoid="IteratorStep">
      <h1>IteratorStep ( _iteratorRecord_ )</h1>
      <p>The abstract operation IteratorStep with argument _iteratorRecord_ requests the next value from _iteratorRecord_.[[Iterator]] by calling _iteratorRecord_.[[NextMethod]] and returns either *false* indicating that the iterator has reached its end or the IteratorResult object if a next value is available. IteratorStep performs the following steps:</p>
      <emu-alg>
        1. Let _result_ be ? IteratorNext(_iteratorRecord_).
        1. Let _done_ be ? IteratorComplete(_result_).
        1. If _done_ is *true*, return *false*.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorclose" aoid="IteratorClose">
      <h1>IteratorClose ( _iteratorRecord_, _completion_ )</h1>
      <p>The abstract operation IteratorClose with arguments _iteratorRecord_ and _completion_ is used to notify an iterator that it should perform any actions it would normally perform when it has reached its completed state:</p>
      <emu-alg>
        1. Assert: Type(_iteratorRecord_.[[Iterator]]) is Object.
        1. Assert: _completion_ is a Completion Record.
        1. Let _iterator_ be _iteratorRecord_.[[Iterator]].
        1. Let _return_ be ? GetMethod(_iterator_, `"return"`).
        1. If _return_ is *undefined*, return Completion(_completion_).
        1. Let _innerResult_ be Call(_return_, _iterator_).
        1. If _completion_.[[Type]] is ~throw~, return Completion(_completion_).
        1. If _innerResult_.[[Type]] is ~throw~, return Completion(_innerResult_).
        1. If Type(_innerResult_.[[Value]]) is not Object, throw a *TypeError* exception.
        1. Return Completion(_completion_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-asynciteratorclose" aoid="AsyncIteratorClose">
      <h1>AsyncIteratorClose ( _iteratorRecord_, _completion_ )</h1>
      <p>The abstract operation AsyncIteratorClose with arguments _iteratorRecord_ and _completion_ is used to notify an async iterator that it should perform any actions it would normally perform when it has reached its completed state:</p>
      <emu-alg>
        1. Assert: Type(_iteratorRecord_.[[Iterator]]) is Object.
        1. Assert: _completion_ is a Completion Record.
        1. Let _iterator_ be _iteratorRecord_.[[Iterator]].
        1. Let _return_ be ? GetMethod(_iterator_, `"return"`).
        1. If _return_ is *undefined*, return Completion(_completion_).
        1. Let _innerResult_ be Call(_return_, _iterator_).
        1. If _innerResult_.[[Type]] is ~normal~, set _innerResult_ to Await(_innerResult_.[[Value]]).
        1. If _completion_.[[Type]] is ~throw~, return Completion(_completion_).
        1. If _innerResult_.[[Type]] is ~throw~, return Completion(_innerResult_).
        1. If Type(_innerResult_.[[Value]]) is not Object, throw a *TypeError* exception.
        1. Return Completion(_completion_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createiterresultobject" aoid="CreateIterResultObject">
      <h1>CreateIterResultObject ( _value_, _done_ )</h1>
      <p>The abstract operation CreateIterResultObject with arguments _value_ and _done_ creates an object that supports the IteratorResult interface by performing the following steps:</p>
      <emu-alg>
        1. Assert: Type(_done_) is Boolean.
        1. Let _obj_ be ObjectCreate(%ObjectPrototype%).
        1. Perform CreateDataProperty(_obj_, `"value"`, _value_).
        1. Perform CreateDataProperty(_obj_, `"done"`, _done_).
        1. Return _obj_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createlistiteratorRecord" oldids="sec-createlistiterator" aoid="CreateListIteratorRecord">
      <h1>CreateListIteratorRecord ( _list_ )</h1>
      <p>The abstract operation CreateListIteratorRecord with argument _list_ creates an Iterator (<emu-xref href="#sec-iterator-interface"></emu-xref>) object record whose next method returns the successive elements of _list_. It performs the following steps:</p>
      <emu-alg>
        1. Let _iterator_ be ObjectCreate(%IteratorPrototype%, &laquo; [[IteratedList]], [[ListIteratorNextIndex]] &raquo;).
        1. Set _iterator_.[[IteratedList]] to _list_.
        1. Set _iterator_.[[ListIteratorNextIndex]] to 0.
        1. Let _steps_ be the algorithm steps defined in ListIterator `next` (<emu-xref href="#sec-listiterator-next"></emu-xref>).
        1. Let _next_ be CreateBuiltinFunction(_steps_, &laquo; &raquo;).
        1. Return Record { [[Iterator]]: _iterator_, [[NextMethod]]: _next_, [[Done]]: *false* }.
      </emu-alg>
      <emu-note>
        <p>The list iterator object is never directly accessible to ECMAScript code.</p>
      </emu-note>

      <emu-clause id="sec-listiterator-next">
        <h1>ListIterator next ( )</h1>
        <p>The ListIterator `next` method is a standard built-in function object (clause <emu-xref href="#sec-ecmascript-standard-built-in-objects"></emu-xref>) that performs the following steps:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Assert: Type(_O_) is Object.
          1. Assert: _O_ has an [[IteratedList]] internal slot.
          1. Let _list_ be _O_.[[IteratedList]].
          1. Let _index_ be _O_.[[ListIteratorNextIndex]].
          1. Let _len_ be the number of elements of _list_.
          1. If _index_ &ge; _len_, then
            1. Return CreateIterResultObject(*undefined*, *true*).
          1. Set _O_.[[ListIteratorNextIndex]] to _index_ + 1.
          1. Return CreateIterResultObject(_list_[_index_], *false*).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-executable-code-and-execution-contexts">
  <h1>Executable Code and Execution Contexts</h1>

  <emu-clause id="sec-lexical-environments">
    <h1>Lexical Environments</h1>
    <p>A <dfn>Lexical Environment</dfn> is a specification type used to define the association of |Identifier|s to specific variables and functions based upon the lexical nesting structure of ECMAScript code. A Lexical Environment consists of an Environment Record and a possibly null reference to an <em>outer</em> Lexical Environment. Usually a Lexical Environment is associated with some specific syntactic structure of ECMAScript code such as a |FunctionDeclaration|, a |BlockStatement|, or a |Catch| clause of a |TryStatement| and a new Lexical Environment is created each time such code is evaluated.</p>
    <p>An Environment Record records the identifier bindings that are created within the scope of its associated Lexical Environment. It is referred to as the Lexical Environment's <dfn>EnvironmentRecord</dfn>.</p>
    <p>The outer environment reference is used to model the logical nesting of Lexical Environment values. The outer reference of a (inner) Lexical Environment is a reference to the Lexical Environment that logically surrounds the inner Lexical Environment. An outer Lexical Environment may, of course, have its own outer Lexical Environment. A Lexical Environment may serve as the outer environment for multiple inner Lexical Environments. For example, if a |FunctionDeclaration| contains two nested |FunctionDeclaration|s then the Lexical Environments of each of the nested functions will have as their outer Lexical Environment the Lexical Environment of the current evaluation of the surrounding function.</p>
    <p>A <dfn id="global-environment">global environment</dfn> is a Lexical Environment which does not have an outer environment. The global environment's outer environment reference is *null*. A global environment's EnvironmentRecord may be prepopulated with identifier bindings and includes an associated global object whose properties provide some of the global environment's identifier bindings. As ECMAScript code is executed, additional properties may be added to the global object and the initial properties may be modified.</p>
    <p>A <dfn id="module-environment">module environment</dfn> is a Lexical Environment that contains the bindings for the top level declarations of a |Module|. It also contains the bindings that are explicitly imported by the |Module|. The outer environment of a module environment is a global environment.</p>
    <p>A <dfn id="function-environment">function environment</dfn> is a Lexical Environment that corresponds to the invocation of an ECMAScript function object. A function environment may establish a new `this` binding. A function environment also captures the state necessary to support `super` method invocations.</p>
    <p>Lexical Environments and Environment Record values are purely specification mechanisms and need not correspond to any specific artefact of an ECMAScript implementation. It is impossible for an ECMAScript program to directly access or manipulate such values.</p>

    <emu-clause id="sec-environment-records">
      <h1>Environment Records</h1>
      <p>There are two primary kinds of <dfn>Environment Record</dfn> values used in this specification: <em>declarative Environment Records</em> and <em>object Environment Records</em>. Declarative Environment Records are used to define the effect of ECMAScript language syntactic elements such as |FunctionDeclaration|s, |VariableDeclaration|s, and |Catch| clauses that directly associate identifier bindings with ECMAScript language values. Object Environment Records are used to define the effect of ECMAScript elements such as |WithStatement| that associate identifier bindings with the properties of some object. Global Environment Records and function Environment Records are specializations that are used for specifically for |Script| global declarations and for top-level declarations within functions.</p>
      <p>For specification purposes Environment Record values are values of the Record specification type and can be thought of as existing in a simple object-oriented hierarchy where Environment Record is an abstract class with three concrete subclasses, declarative Environment Record, object Environment Record, and global Environment Record. Function Environment Records and module Environment Records are subclasses of declarative Environment Record. The abstract class includes the abstract specification methods defined in <emu-xref href="#table-15"></emu-xref>. These abstract methods have distinct concrete algorithms for each of the concrete subclasses.</p>
      <emu-table id="table-15" caption="Abstract Methods of Environment Records">
        <table>
          <tbody>
          <tr>
            <th>
              Method
            </th>
            <th>
              Purpose
            </th>
          </tr>
          <tr>
            <td>
              HasBinding(N)
            </td>
            <td>
              Determine if an Environment Record has a binding for the String value _N_. Return *true* if it does and *false* if it does not.
            </td>
          </tr>
          <tr>
            <td>
              CreateMutableBinding(N, D)
            </td>
            <td>
              Create a new but uninitialized mutable binding in an Environment Record. The String value _N_ is the text of the bound name. If the Boolean argument _D_ is *true* the binding may be subsequently deleted.
            </td>
          </tr>
          <tr>
            <td>
              CreateImmutableBinding(N, S)
            </td>
            <td>
              Create a new but uninitialized immutable binding in an Environment Record. The String value _N_ is the text of the bound name. If _S_ is *true* then attempts to set it after it has been initialized will always throw an exception, regardless of the strict mode setting of operations that reference that binding.
            </td>
          </tr>
          <tr>
            <td>
              InitializeBinding(N, V)
            </td>
            <td>
              Set the value of an already existing but uninitialized binding in an Environment Record. The String value _N_ is the text of the bound name. _V_ is the value for the binding and is a value of any ECMAScript language type.
            </td>
          </tr>
          <tr>
            <td>
              SetMutableBinding(N, V, S)
            </td>
            <td>
              Set the value of an already existing mutable binding in an Environment Record. The String value _N_ is the text of the bound name. _V_ is the value for the binding and may be a value of any ECMAScript language type. _S_ is a Boolean flag. If _S_ is *true* and the binding cannot be set throw a *TypeError* exception.
            </td>
          </tr>
          <tr>
            <td>
              GetBindingValue(N, S)
            </td>
            <td>
              Returns the value of an already existing binding from an Environment Record. The String value _N_ is the text of the bound name. _S_ is used to identify references originating in strict mode code or that otherwise require strict mode reference semantics. If _S_ is *true* and the binding does not exist throw a *ReferenceError* exception. If the binding exists but is uninitialized a *ReferenceError* is thrown, regardless of the value of _S_.
            </td>
          </tr>
          <tr>
            <td>
              DeleteBinding(N)
            </td>
            <td>
              Delete a binding from an Environment Record. The String value _N_ is the text of the bound name. If a binding for _N_ exists, remove the binding and return *true*. If the binding exists but cannot be removed return *false*. If the binding does not exist return *true*.
            </td>
          </tr>
          <tr>
            <td>
              HasThisBinding()
            </td>
            <td>
              Determine if an Environment Record establishes a `this` binding. Return *true* if it does and *false* if it does not.
            </td>
          </tr>
          <tr>
            <td>
              HasSuperBinding()
            </td>
            <td>
              Determine if an Environment Record establishes a `super` method binding. Return *true* if it does and *false* if it does not.
            </td>
          </tr>
          <tr>
            <td>
              WithBaseObject()
            </td>
            <td>
              If this Environment Record is associated with a `with` statement, return the with object. Otherwise, return *undefined*.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>

      <emu-clause id="sec-declarative-environment-records">
        <h1>Declarative Environment Records</h1>
        <p>Each declarative Environment Record is associated with an ECMAScript program scope containing variable, constant, let, class, module, import, and/or function declarations. A declarative Environment Record binds the set of identifiers defined by the declarations contained within its scope.</p>
        <p>The behaviour of the concrete specification methods for declarative Environment Records is defined by the following algorithms.</p>

        <emu-clause id="sec-declarative-environment-records-hasbinding-n">
          <h1>HasBinding ( _N_ )</h1>
          <p>The concrete Environment Record method HasBinding for declarative Environment Records simply determines if the argument identifier is one of the identifiers bound by the record:</p>
          <emu-alg>
            1. Let _envRec_ be the declarative Environment Record for which the method was invoked.
            1. If _envRec_ has a binding for the name that is the value of _N_, return *true*.
            1. Return *false*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-createmutablebinding-n-d">
          <h1>CreateMutableBinding ( _N_, _D_ )</h1>
          <p>The concrete Environment Record method CreateMutableBinding for declarative Environment Records creates a new mutable binding for the name _N_ that is uninitialized. A binding must not already exist in this Environment Record for _N_. If Boolean argument _D_ has the value *true* the new binding is marked as being subject to deletion.</p>
          <emu-alg>
            1. Let _envRec_ be the declarative Environment Record for which the method was invoked.
            1. Assert: _envRec_ does not already have a binding for _N_.
            1. Create a mutable binding in _envRec_ for _N_ and record that it is uninitialized. If _D_ is *true*, record that the newly created binding may be deleted by a subsequent DeleteBinding call.
            1. Return NormalCompletion(~empty~).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-createimmutablebinding-n-s">
          <h1>CreateImmutableBinding ( _N_, _S_ )</h1>
          <p>The concrete Environment Record method CreateImmutableBinding for declarative Environment Records creates a new immutable binding for the name _N_ that is uninitialized. A binding must not already exist in this Environment Record for _N_. If the Boolean argument _S_ has the value *true* the new binding is marked as a strict binding.</p>
          <emu-alg>
            1. Let _envRec_ be the declarative Environment Record for which the method was invoked.
            1. Assert: _envRec_ does not already have a binding for _N_.
            1. Create an immutable binding in _envRec_ for _N_ and record that it is uninitialized. If _S_ is *true*, record that the newly created binding is a strict binding.
            1. Return NormalCompletion(~empty~).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-initializebinding-n-v">
          <h1>InitializeBinding ( _N_, _V_ )</h1>
          <p>The concrete Environment Record method InitializeBinding for declarative Environment Records is used to set the bound value of the current binding of the identifier whose name is the value of the argument _N_ to the value of argument _V_. An uninitialized binding for _N_ must already exist.</p>
          <emu-alg>
            1. Let _envRec_ be the declarative Environment Record for which the method was invoked.
            1. Assert: _envRec_ must have an uninitialized binding for _N_.
            1. Set the bound value for _N_ in _envRec_ to _V_.
            1. Record that the binding for _N_ in _envRec_ has been initialized.
            1. Return NormalCompletion(~empty~).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-setmutablebinding-n-v-s">
          <h1>SetMutableBinding ( _N_, _V_, _S_ )</h1>
          <p>The concrete Environment Record method SetMutableBinding for declarative Environment Records attempts to change the bound value of the current binding of the identifier whose name is the value of the argument _N_ to the value of argument _V_. A binding for _N_ normally already exists, but in rare cases it may not. If the binding is an immutable binding, a *TypeError* is thrown if _S_ is *true*.</p>
          <emu-alg>
            1. Let _envRec_ be the declarative Environment Record for which the method was invoked.
            1. If _envRec_ does not have a binding for _N_, then
              1. If _S_ is *true*, throw a *ReferenceError* exception.
              1. Perform _envRec_.CreateMutableBinding(_N_, *true*).
              1. Perform _envRec_.InitializeBinding(_N_, _V_).
              1. Return NormalCompletion(~empty~).
            1. If the binding for _N_ in _envRec_ is a strict binding, set _S_ to *true*.
            1. If the binding for _N_ in _envRec_ has not yet been initialized, throw a *ReferenceError* exception.
            1. Else if the binding for _N_ in _envRec_ is a mutable binding, change its bound value to _V_.
            1. Else,
              1. Assert: This is an attempt to change the value of an immutable binding.
              1. If _S_ is *true*, throw a *TypeError* exception.
            1. Return NormalCompletion(~empty~).
          </emu-alg>
          <emu-note>
            <p>An example of ECMAScript code that results in a missing binding at step 2 is:</p>
            <pre><code class="javascript">function f(){eval("var x; x = (delete x, 0);")}</code></pre>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-getbindingvalue-n-s">
          <h1>GetBindingValue ( _N_, _S_ )</h1>
          <p>The concrete Environment Record method GetBindingValue for declarative Environment Records simply returns the value of its bound identifier whose name is the value of the argument _N_. If the binding exists but is uninitialized a *ReferenceError* is thrown, regardless of the value of _S_.</p>
          <emu-alg>
            1. Let _envRec_ be the declarative Environment Record for which the method was invoked.
            1. Assert: _envRec_ has a binding for _N_.
            1. If the binding for _N_ in _envRec_ is an uninitialized binding, throw a *ReferenceError* exception.
            1. Return the value currently bound to _N_ in _envRec_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-deletebinding-n">
          <h1>DeleteBinding ( _N_ )</h1>
          <p>The concrete Environment Record method DeleteBinding for declarative Environment Records can only delete bindings that have been explicitly designated as being subject to deletion.</p>
          <emu-alg>
            1. Let _envRec_ be the declarative Environment Record for which the method was invoked.
            1. Assert: _envRec_ has a binding for the name that is the value of _N_.
            1. If the binding for _N_ in _envRec_ cannot be deleted, return *false*.
            1. Remove the binding for _N_ from _envRec_.
            1. Return *true*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-hasthisbinding">
          <h1>HasThisBinding ( )</h1>
          <p>Regular declarative Environment Records do not provide a `this` binding.</p>
          <emu-alg>
            1. Return *false*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-hassuperbinding">
          <h1>HasSuperBinding ( )</h1>
          <p>Regular declarative Environment Records do not provide a `super` binding.</p>
          <emu-alg>
            1. Return *false*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-withbaseobject">
          <h1>WithBaseObject ( )</h1>
          <p>Declarative Environment Records always return *undefined* as their WithBaseObject.</p>
          <emu-alg>
            1. Return *undefined*.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object-environment-records">
        <h1>Object Environment Records</h1>
        <p>Each object Environment Record is associated with an object called its <em>binding object</em>. An object Environment Record binds the set of string identifier names that directly correspond to the property names of its binding object. Property keys that are not strings in the form of an |IdentifierName| are not included in the set of bound identifiers. Both own and inherited properties are included in the set regardless of the setting of their [[Enumerable]] attribute. Because properties can be dynamically added and deleted from objects, the set of identifiers bound by an object Environment Record may potentially change as a side-effect of any operation that adds or deletes properties. Any bindings that are created as a result of such a side-effect are considered to be a mutable binding even if the Writable attribute of the corresponding property has the value *false*. Immutable bindings do not exist for object Environment Records.</p>
        <p>Object Environment Records created for `with` statements (<emu-xref href="#sec-with-statement"></emu-xref>) can provide their binding object as an implicit *this* value for use in function calls. The capability is controlled by a _withEnvironment_ Boolean value that is associated with each object Environment Record. By default, the value of _withEnvironment_ is *false* for any object Environment Record.</p>
        <p>The behaviour of the concrete specification methods for object Environment Records is defined by the following algorithms.</p>

        <emu-clause id="sec-object-environment-records-hasbinding-n">
          <h1>HasBinding ( _N_ )</h1>
          <p>The concrete Environment Record method HasBinding for object Environment Records determines if its associated binding object has a property whose name is the value of the argument _N_:</p>
          <emu-alg>
            1. Let _envRec_ be the object Environment Record for which the method was invoked.
            1. Let _bindings_ be the binding object for _envRec_.
            1. Let _foundBinding_ be ? HasProperty(_bindings_, _N_).
            1. If _foundBinding_ is *false*, return *false*.
            1. If the _withEnvironment_ flag of _envRec_ is *false*, return *true*.
            1. Let _unscopables_ be ? Get(_bindings_, @@unscopables).
            1. If Type(_unscopables_) is Object, then
              1. Let _blocked_ be ToBoolean(? Get(_unscopables_, _N_)).
              1. If _blocked_ is *true*, return *false*.
            1. Return *true*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-createmutablebinding-n-d">
          <h1>CreateMutableBinding ( _N_, _D_ )</h1>
          <p>The concrete Environment Record method CreateMutableBinding for object Environment Records creates in an Environment Record's associated binding object a property whose name is the String value and initializes it to the value *undefined*. If Boolean argument _D_ has the value *true* the new property's [[Configurable]] attribute is set to *true*; otherwise it is set to *false*.</p>
          <emu-alg>
            1. Let _envRec_ be the object Environment Record for which the method was invoked.
            1. Let _bindings_ be the binding object for _envRec_.
            1. Return ? DefinePropertyOrThrow(_bindings_, _N_, PropertyDescriptor { [[Value]]: *undefined*, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: _D_ }).
          </emu-alg>
          <emu-note>
            <p>Normally _envRec_ will not have a binding for _N_ but if it does, the semantics of DefinePropertyOrThrow may result in an existing binding being replaced or shadowed or cause an abrupt completion to be returned.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-createimmutablebinding-n-s">
          <h1>CreateImmutableBinding ( _N_, _S_ )</h1>
          <p>The concrete Environment Record method CreateImmutableBinding is never used within this specification in association with object Environment Records.</p>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-initializebinding-n-v">
          <h1>InitializeBinding ( _N_, _V_ )</h1>
          <p>The concrete Environment Record method InitializeBinding for object Environment Records is used to set the bound value of the current binding of the identifier whose name is the value of the argument _N_ to the value of argument _V_. An uninitialized binding for _N_ must already exist.</p>
          <emu-alg>
            1. Let _envRec_ be the object Environment Record for which the method was invoked.
            1. Assert: _envRec_ must have an uninitialized binding for _N_.
            1. Record that the binding for _N_ in _envRec_ has been initialized.
            1. Return ? _envRec_.SetMutableBinding(_N_, _V_, *false*).
          </emu-alg>
          <emu-note>
            <p>In this specification, all uses of CreateMutableBinding for object Environment Records are immediately followed by a call to InitializeBinding for the same name. Hence, implementations do not need to explicitly track the initialization state of individual object Environment Record bindings.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-setmutablebinding-n-v-s">
          <h1>SetMutableBinding ( _N_, _V_, _S_ )</h1>
          <p>The concrete Environment Record method SetMutableBinding for object Environment Records attempts to set the value of the Environment Record's associated binding object's property whose name is the value of the argument _N_ to the value of argument _V_. A property named _N_ normally already exists but if it does not or is not currently writable, error handling is determined by the value of the Boolean argument _S_.</p>
          <emu-alg>
            1. Let _envRec_ be the object Environment Record for which the method was invoked.
            1. Let _bindings_ be the binding object for _envRec_.
            1. Return ? Set(_bindings_, _N_, _V_, _S_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-getbindingvalue-n-s">
          <h1>GetBindingValue ( _N_, _S_ )</h1>
          <p>The concrete Environment Record method GetBindingValue for object Environment Records returns the value of its associated binding object's property whose name is the String value of the argument identifier _N_. The property should already exist but if it does not the result depends upon the value of the _S_ argument:</p>
          <emu-alg>
            1. Let _envRec_ be the object Environment Record for which the method was invoked.
            1. Let _bindings_ be the binding object for _envRec_.
            1. Let _value_ be ? HasProperty(_bindings_, _N_).
            1. If _value_ is *false*, then
              1. If _S_ is *false*, return the value *undefined*; otherwise throw a *ReferenceError* exception.
            1. Return ? Get(_bindings_, _N_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-deletebinding-n">
          <h1>DeleteBinding ( _N_ )</h1>
          <p>The concrete Environment Record method DeleteBinding for object Environment Records can only delete bindings that correspond to properties of the environment object whose [[Configurable]] attribute have the value *true*.</p>
          <emu-alg>
            1. Let _envRec_ be the object Environment Record for which the method was invoked.
            1. Let _bindings_ be the binding object for _envRec_.
            1. Return ? _bindings_.[[Delete]](_N_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-hasthisbinding">
          <h1>HasThisBinding ( )</h1>
          <p>Regular object Environment Records do not provide a `this` binding.</p>
          <emu-alg>
            1. Return *false*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-hassuperbinding">
          <h1>HasSuperBinding ( )</h1>
          <p>Regular object Environment Records do not provide a `super` binding.</p>
          <emu-alg>
            1. Return *false*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-withbaseobject">
          <h1>WithBaseObject ( )</h1>
          <p>Object Environment Records return *undefined* as their WithBaseObject unless their _withEnvironment_ flag is *true*.</p>
          <emu-alg>
            1. Let _envRec_ be the object Environment Record for which the method was invoked.
            1. If the _withEnvironment_ flag of _envRec_ is *true*, return the binding object for _envRec_.
            1. Otherwise, return *undefined*.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-function-environment-records">
        <h1>Function Environment Records</h1>
        <p>A <dfn>function Environment Record</dfn> is a declarative Environment Record that is used to represent the top-level scope of a function and, if the function is not an |ArrowFunction|, provides a `this` binding. If a function is not an |ArrowFunction| function and references `super`, its function Environment Record also contains the state that is used to perform `super` method invocations from within the function.</p>
        <p>Function Environment Records have the additional state fields listed in <emu-xref href="#table-16"></emu-xref>.</p>
        <emu-table id="table-16" caption="Additional Fields of Function Environment Records">
          <table>
            <tbody>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[ThisValue]]
              </td>
              <td>
                Any
              </td>
              <td>
                This is the *this* value used for this invocation of the function.
              </td>
            </tr>
            <tr>
              <td>
                [[ThisBindingStatus]]
              </td>
              <td>
                `"lexical"` | `"initialized"` | `"uninitialized"`
              </td>
              <td>
                If the value is `"lexical"`, this is an |ArrowFunction| and does not have a local this value.
              </td>
            </tr>
            <tr>
              <td>
                [[FunctionObject]]
              </td>
              <td>
                Object
              </td>
              <td>
                The function object whose invocation caused this Environment Record to be created.
              </td>
            </tr>
            <tr>
              <td>
                [[HomeObject]]
              </td>
              <td>
                Object | *undefined*
              </td>
              <td>
                If the associated function has `super` property accesses and is not an |ArrowFunction|, [[HomeObject]] is the object that the function is bound to as a method. The default value for [[HomeObject]] is *undefined*.
              </td>
            </tr>
            <tr>
              <td>
                [[NewTarget]]
              </td>
              <td>
                Object | *undefined*
              </td>
              <td>
                If this Environment Record was created by the [[Construct]] internal method, [[NewTarget]] is the value of the [[Construct]] _newTarget_ parameter. Otherwise, its value is *undefined*.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
        <p>Function Environment Records support all of the declarative Environment Record methods listed in <emu-xref href="#table-15"></emu-xref> and share the same specifications for all of those methods except for HasThisBinding and HasSuperBinding. In addition, function Environment Records support the methods listed in <emu-xref href="#table-17"></emu-xref>:</p>
        <emu-table id="table-17" caption="Additional Methods of Function Environment Records">
          <table>
            <tbody>
            <tr>
              <th>
                Method
              </th>
              <th>
                Purpose
              </th>
            </tr>
            <tr>
              <td>
                BindThisValue(V)
              </td>
              <td>
                Set the [[ThisValue]] and record that it has been initialized.
              </td>
            </tr>
            <tr>
              <td>
                GetThisBinding()
              </td>
              <td>
                Return the value of this Environment Record's `this` binding. Throws a *ReferenceError* if the `this` binding has not been initialized.
              </td>
            </tr>
            <tr>
              <td>
                GetSuperBase()
              </td>
              <td>
                Return the object that is the base for `super` property accesses bound in this Environment Record. The object is derived from this Environment Record's [[HomeObject]] field. The value *undefined* indicates that `super` property accesses will produce runtime errors.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
        <p>The behaviour of the additional concrete specification methods for function Environment Records is defined by the following algorithms:</p>

        <emu-clause id="sec-bindthisvalue">
          <h1>BindThisValue ( _V_ )</h1>
          <emu-alg>
            1. Let _envRec_ be the function Environment Record for which the method was invoked.
            1. Assert: _envRec_.[[ThisBindingStatus]] is not `"lexical"`.
            1. If _envRec_.[[ThisBindingStatus]] is `"initialized"`, throw a *ReferenceError* exception.
            1. Set _envRec_.[[ThisValue]] to _V_.
            1. Set _envRec_.[[ThisBindingStatus]] to `"initialized"`.
            1. Return _V_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-function-environment-records-hasthisbinding">
          <h1>HasThisBinding ( )</h1>
          <emu-alg>
            1. Let _envRec_ be the function Environment Record for which the method was invoked.
            1. If _envRec_.[[ThisBindingStatus]] is `"lexical"`, return *false*; otherwise, return *true*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-function-environment-records-hassuperbinding">
          <h1>HasSuperBinding ( )</h1>
          <emu-alg>
            1. Let _envRec_ be the function Environment Record for which the method was invoked.
            1. If _envRec_.[[ThisBindingStatus]] is `"lexical"`, return *false*.
            1. If _envRec_.[[HomeObject]] has the value *undefined*, return *false*; otherwise, return *true*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-function-environment-records-getthisbinding">
          <h1>GetThisBinding ( )</h1>
          <emu-alg>
            1. Let _envRec_ be the function Environment Record for which the method was invoked.
            1. Assert: _envRec_.[[ThisBindingStatus]] is not `"lexical"`.
            1. If _envRec_.[[ThisBindingStatus]] is `"uninitialized"`, throw a *ReferenceError* exception.
            1. Return _envRec_.[[ThisValue]].
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-getsuperbase">
          <h1>GetSuperBase ( )</h1>
          <emu-alg>
            1. Let _envRec_ be the function Environment Record for which the method was invoked.
            1. Let _home_ be _envRec_.[[HomeObject]].
            1. If _home_ has the value *undefined*, return *undefined*.
            1. Assert: Type(_home_) is Object.
            1. Return ? _home_.[[GetPrototypeOf]]().
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-global-environment-records">
        <h1>Global Environment Records</h1>
        <p>A global Environment Record is used to represent the outer most scope that is shared by all of the ECMAScript |Script| elements that are processed in a common realm. A global Environment Record provides the bindings for built-in globals (clause <emu-xref href="#sec-global-object"></emu-xref>), properties of the global object, and for all top-level declarations (<emu-xref href="#sec-block-static-semantics-toplevellexicallyscopeddeclarations"></emu-xref>, <emu-xref href="#sec-block-static-semantics-toplevelvarscopeddeclarations"></emu-xref>) that occur within a |Script|.</p>
        <p>A global Environment Record is logically a single record but it is specified as a composite encapsulating an object Environment Record and a declarative Environment Record. The object Environment Record has as its base object the global object of the associated Realm Record. This global object is the value returned by the global Environment Record's GetThisBinding concrete method. The object Environment Record component of a global Environment Record contains the bindings for all built-in globals (clause <emu-xref href="#sec-global-object"></emu-xref>) and all bindings introduced by a |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, |AsyncGeneratorDeclaration|, or |VariableStatement| contained in global code. The bindings for all other ECMAScript declarations in global code are contained in the declarative Environment Record component of the global Environment Record.</p>
        <p>Properties may be created directly on a global object. Hence, the object Environment Record component of a global Environment Record may contain both bindings created explicitly by |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, |AsyncGeneratorDeclaration|, or |VariableDeclaration| declarations and bindings created implicitly as properties of the global object. In order to identify which bindings were explicitly created using declarations, a global Environment Record maintains a list of the names bound using its CreateGlobalVarBinding and CreateGlobalFunctionBinding concrete methods.</p>
        <p>Global Environment Records have the additional fields listed in <emu-xref href="#table-18"></emu-xref> and the additional methods listed in <emu-xref href="#table-19"></emu-xref>.</p>
        <emu-table id="table-18" caption="Additional Fields of Global Environment Records">
          <table>
            <tbody>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[ObjectRecord]]
              </td>
              <td>
                Object Environment Record
              </td>
              <td>
                Binding object is the global object. It contains global built-in bindings as well as |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, |AsyncGeneratorDeclaration|, and |VariableDeclaration| bindings in global code for the associated realm.
              </td>
            </tr>
            <tr>
              <td>
                [[GlobalThisValue]]
              </td>
              <td>
                Object
              </td>
              <td>
                The value returned by `this` in global scope. Hosts may provide any ECMAScript Object value.
              </td>
            </tr>
            <tr>
              <td>
                [[DeclarativeRecord]]
              </td>
              <td>
                Declarative Environment Record
              </td>
              <td>
                Contains bindings for all declarations in global code for the associated realm code except for |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, |AsyncGeneratorDeclaration|, and |VariableDeclaration| _bindings_.
              </td>
            </tr>
            <tr>
              <td>
                [[VarNames]]
              </td>
              <td>
                List of String
              </td>
              <td>
                The string names bound by |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, |AsyncGeneratorDeclaration|, and |VariableDeclaration| declarations in global code for the associated realm.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
        <emu-table id="table-19" caption="Additional Methods of Global Environment Records">
          <table>
            <tbody>
            <tr>
              <th>
                Method
              </th>
              <th>
                Purpose
              </th>
            </tr>
            <tr>
              <td>
                GetThisBinding()
              </td>
              <td>
                Return the value of this Environment Record's `this` binding.
              </td>
            </tr>
            <tr>
              <td>
                HasVarDeclaration (N)
              </td>
              <td>
                Determines if the argument identifier has a binding in this Environment Record that was created using a |VariableDeclaration|, |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, or |AsyncGeneratorDeclaration|.
              </td>
            </tr>
            <tr>
              <td>
                HasLexicalDeclaration (N)
              </td>
              <td>
                Determines if the argument identifier has a binding in this Environment Record that was created using a lexical declaration such as a |LexicalDeclaration| or a |ClassDeclaration|.
              </td>
            </tr>
            <tr>
              <td>
                HasRestrictedGlobalProperty (N)
              </td>
              <td>
                Determines if the argument is the name of a global object property that may not be shadowed by a global lexical binding.
              </td>
            </tr>
            <tr>
              <td>
                CanDeclareGlobalVar (N)
              </td>
              <td>
                Determines if a corresponding CreateGlobalVarBinding call would succeed if called for the same argument _N_.
              </td>
            </tr>
            <tr>
              <td>
                CanDeclareGlobalFunction (N)
              </td>
              <td>
                Determines if a corresponding CreateGlobalFunctionBinding call would succeed if called for the same argument _N_.
              </td>
            </tr>
            <tr>
              <td>
                CreateGlobalVarBinding(N, D)
              </td>
              <td>
                Used to create and initialize to *undefined* a global `var` binding in the [[ObjectRecord]] component of a global Environment Record. The binding will be a mutable binding. The corresponding global object property will have attribute values appropriate for a `var`. The String value _N_ is the bound name. If _D_ is *true* the binding may be deleted. Logically equivalent to CreateMutableBinding followed by a SetMutableBinding but it allows var declarations to receive special treatment.
              </td>
            </tr>
            <tr>
              <td>
                CreateGlobalFunctionBinding(N, V, D)
              </td>
              <td>
                Create and initialize a global `function` binding in the [[ObjectRecord]] component of a global Environment Record. The binding will be a mutable binding. The corresponding global object property will have attribute values appropriate for a `function`. The String value _N_ is the bound name. _V_ is the initialization value. If the Boolean argument _D_ is *true* the binding may be deleted. Logically equivalent to CreateMutableBinding followed by a SetMutableBinding but it allows function declarations to receive special treatment.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
        <p>The behaviour of the concrete specification methods for global Environment Records is defined by the following algorithms.</p>

        <emu-clause id="sec-global-environment-records-hasbinding-n">
          <h1>HasBinding ( _N_ )</h1>
          <p>The concrete Environment Record method HasBinding for global Environment Records simply determines if the argument identifier is one of the identifiers bound by the record:</p>
          <emu-alg>
            1. Let _envRec_ be the global Environment Record for which the method was invoked.
            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].
            1. If _DclRec_.HasBinding(_N_) is *true*, return *true*.
            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].
            1. Return ? _ObjRec_.HasBinding(_N_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-createmutablebinding-n-d">
          <h1>CreateMutableBinding ( _N_, _D_ )</h1>
          <p>The concrete Environment Record method CreateMutableBinding for global Environment Records creates a new mutable binding for the name _N_ that is uninitialized. The binding is created in the associated DeclarativeRecord. A binding for _N_ must not already exist in the DeclarativeRecord. If Boolean argument _D_ has the value *true* the new binding is marked as being subject to deletion.</p>
          <emu-alg>
            1. Let _envRec_ be the global Environment Record for which the method was invoked.
            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].
            1. If _DclRec_.HasBinding(_N_) is *true*, throw a *TypeError* exception.
            1. Return _DclRec_.CreateMutableBinding(_N_, _D_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-createimmutablebinding-n-s">
          <h1>CreateImmutableBinding ( _N_, _S_ )</h1>
          <p>The concrete Environment Record method CreateImmutableBinding for global Environment Records creates a new immutable binding for the name _N_ that is uninitialized. A binding must not already exist in this Environment Record for _N_. If the Boolean argument _S_ has the value *true* the new binding is marked as a strict binding.</p>
          <emu-alg>
            1. Let _envRec_ be the global Environment Record for which the method was invoked.
            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].
            1. If _DclRec_.HasBinding(_N_) is *true*, throw a *TypeError* exception.
            1. Return _DclRec_.CreateImmutableBinding(_N_, _S_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-initializebinding-n-v">
          <h1>InitializeBinding ( _N_, _V_ )</h1>
          <p>The concrete Environment Record method InitializeBinding for global Environment Records is used to set the bound value of the current binding of the identifier whose name is the value of the argument _N_ to the value of argument _V_. An uninitialized binding for _N_ must already exist.</p>
          <emu-alg>
            1. Let _envRec_ be the global Environment Record for which the method was invoked.
            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].
            1. If _DclRec_.HasBinding(_N_) is *true*, then
              1. Return _DclRec_.InitializeBinding(_N_, _V_).
            1. Assert: If the binding exists, it must be in the object Environment Record.
            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].
            1. Return ? _ObjRec_.InitializeBinding(_N_, _V_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-setmutablebinding-n-v-s">
          <h1>SetMutableBinding ( _N_, _V_, _S_ )</h1>
          <p>The concrete Environment Record method SetMutableBinding for global Environment Records attempts to change the bound value of the current binding of the identifier whose name is the value of the argument _N_ to the value of argument _V_. If the binding is an immutable binding, a *TypeError* is thrown if _S_ is *true*. A property named _N_ normally already exists but if it does not or is not currently writable, error handling is determined by the value of the Boolean argument _S_.</p>
          <emu-alg>
            1. Let _envRec_ be the global Environment Record for which the method was invoked.
            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].
            1. If _DclRec_.HasBinding(_N_) is *true*, then
              1. Return _DclRec_.SetMutableBinding(_N_, _V_, _S_).
            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].
            1. Return ? _ObjRec_.SetMutableBinding(_N_, _V_, _S_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-getbindingvalue-n-s">
          <h1>GetBindingValue ( _N_, _S_ )</h1>
          <p>The concrete Environment Record method GetBindingValue for global Environment Records returns the value of its bound identifier whose name is the value of the argument _N_. If the binding is an uninitialized binding throw a *ReferenceError* exception. A property named _N_ normally already exists but if it does not or is not currently writable, error handling is determined by the value of the Boolean argument _S_.</p>
          <emu-alg>
            1. Let _envRec_ be the global Environment Record for which the method was invoked.
            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].
            1. If _DclRec_.HasBinding(_N_) is *true*, then
              1. Return _DclRec_.GetBindingValue(_N_, _S_).
            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].
            1. Return ? _ObjRec_.GetBindingValue(_N_, _S_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-deletebinding-n">
          <h1>DeleteBinding ( _N_ )</h1>
          <p>The concrete Environment Record method DeleteBinding for global Environment Records can only delete bindings that have been explicitly designated as being subject to deletion.</p>
          <emu-alg>
            1. Let _envRec_ be the global Environment Record for which the method was invoked.
            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].
            1. If _DclRec_.HasBinding(_N_) is *true*, then
              1. Return _DclRec_.DeleteBinding(_N_).
            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].
            1. Let _globalObject_ be the binding object for _ObjRec_.
            1. Let _existingProp_ be ? HasOwnProperty(_globalObject_, _N_).
            1. If _existingProp_ is *true*, then
              1. Let _status_ be ? _ObjRec_.DeleteBinding(_N_).
              1. If _status_ is *true*, then
                1. Let _varNames_ be _envRec_.[[VarNames]].
                1. If _N_ is an element of _varNames_, remove that element from the _varNames_.
              1. Return _status_.
            1. Return *true*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-hasthisbinding">
          <h1>HasThisBinding ( )</h1>
          <emu-alg>
            1. Return *true*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-hassuperbinding">
          <h1>HasSuperBinding ( )</h1>
          <emu-alg>
            1. Return *false*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-withbaseobject">
          <h1>WithBaseObject ( )</h1>
          <p>Global Environment Records always return *undefined* as their WithBaseObject.</p>
          <emu-alg>
            1. Return *undefined*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-getthisbinding">
          <h1>GetThisBinding ( )</h1>
          <emu-alg>
            1. Let _envRec_ be the global Environment Record for which the method was invoked.
            1. Return _envRec_.[[GlobalThisValue]].
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-hasvardeclaration">
          <h1>HasVarDeclaration ( _N_ )</h1>
          <p>The concrete Environment Record method HasVarDeclaration for global Environment Records determines if the argument identifier has a binding in this record that was created using a |VariableStatement| or a |FunctionDeclaration|:</p>
          <emu-alg>
            1. Let _envRec_ be the global Environment Record for which the method was invoked.
            1. Let _varDeclaredNames_ be _envRec_.[[VarNames]].
            1. If _varDeclaredNames_ contains _N_, return *true*.
            1. Return *false*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-haslexicaldeclaration">
          <h1>HasLexicalDeclaration ( _N_ )</h1>
          <p>The concrete Environment Record method HasLexicalDeclaration for global Environment Records determines if the argument identifier has a binding in this record that was created using a lexical declaration such as a |LexicalDeclaration| or a |ClassDeclaration|:</p>
          <emu-alg>
            1. Let _envRec_ be the global Environment Record for which the method was invoked.
            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].
            1. Return _DclRec_.HasBinding(_N_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-hasrestrictedglobalproperty">
          <h1>HasRestrictedGlobalProperty ( _N_ )</h1>
          <p>The concrete Environment Record method HasRestrictedGlobalProperty for global Environment Records determines if the argument identifier is the name of a property of the global object that must not be shadowed by a global lexical binding:</p>
          <emu-alg>
            1. Let _envRec_ be the global Environment Record for which the method was invoked.
            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].
            1. Let _globalObject_ be the binding object for _ObjRec_.
            1. Let _existingProp_ be ? _globalObject_.[[GetOwnProperty]](_N_).
            1. If _existingProp_ is *undefined*, return *false*.
            1. If _existingProp_.[[Configurable]] is *true*, return *false*.
            1. Return *true*.
          </emu-alg>
          <emu-note>
            <p>Properties may exist upon a global object that were directly created rather than being declared using a var or function declaration. A global lexical binding may not be created that has the same name as a non-configurable property of the global object. The global property `undefined` is an example of such a property.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-candeclareglobalvar">
          <h1>CanDeclareGlobalVar ( _N_ )</h1>
          <p>The concrete Environment Record method CanDeclareGlobalVar for global Environment Records determines if a corresponding CreateGlobalVarBinding call would succeed if called for the same argument _N_. Redundant var declarations and var declarations for pre-existing global object properties are allowed.</p>
          <emu-alg>
            1. Let _envRec_ be the global Environment Record for which the method was invoked.
            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].
            1. Let _globalObject_ be the binding object for _ObjRec_.
            1. Let _hasProperty_ be ? HasOwnProperty(_globalObject_, _N_).
            1. If _hasProperty_ is *true*, return *true*.
            1. Return ? IsExtensible(_globalObject_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-candeclareglobalfunction">
          <h1>CanDeclareGlobalFunction ( _N_ )</h1>
          <p>The concrete Environment Record method CanDeclareGlobalFunction for global Environment Records determines if a corresponding CreateGlobalFunctionBinding call would succeed if called for the same argument _N_.</p>
          <emu-alg>
            1. Let _envRec_ be the global Environment Record for which the method was invoked.
            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].
            1. Let _globalObject_ be the binding object for _ObjRec_.
            1. Let _existingProp_ be ? _globalObject_.[[GetOwnProperty]](_N_).
            1. If _existingProp_ is *undefined*, return ? IsExtensible(_globalObject_).
            1. If _existingProp_.[[Configurable]] is *true*, return *true*.
            1. If IsDataDescriptor(_existingProp_) is *true* and _existingProp_ has attribute values { [[Writable]]: *true*, [[Enumerable]]: *true* }, return *true*.
            1. Return *false*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-createglobalvarbinding">
          <h1>CreateGlobalVarBinding ( _N_, _D_ )</h1>
          <p>The concrete Environment Record method CreateGlobalVarBinding for global Environment Records creates and initializes a mutable binding in the associated object Environment Record and records the bound name in the associated [[VarNames]] List. If a binding already exists, it is reused and assumed to be initialized.</p>
          <emu-alg>
            1. Let _envRec_ be the global Environment Record for which the method was invoked.
            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].
            1. Let _globalObject_ be the binding object for _ObjRec_.
            1. Let _hasProperty_ be ? HasOwnProperty(_globalObject_, _N_).
            1. Let _extensible_ be ? IsExtensible(_globalObject_).
            1. If _hasProperty_ is *false* and _extensible_ is *true*, then
              1. Perform ? _ObjRec_.CreateMutableBinding(_N_, _D_).
              1. Perform ? _ObjRec_.InitializeBinding(_N_, *undefined*).
            1. Let _varDeclaredNames_ be _envRec_.[[VarNames]].
            1. If _varDeclaredNames_ does not contain _N_, then
              1. Append _N_ to _varDeclaredNames_.
            1. Return NormalCompletion(~empty~).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-createglobalfunctionbinding">
          <h1>CreateGlobalFunctionBinding ( _N_, _V_, _D_ )</h1>
          <p>The concrete Environment Record method CreateGlobalFunctionBinding for global Environment Records creates and initializes a mutable binding in the associated object Environment Record and records the bound name in the associated [[VarNames]] List. If a binding already exists, it is replaced.</p>
          <emu-alg>
            1. Let _envRec_ be the global Environment Record for which the method was invoked.
            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].
            1. Let _globalObject_ be the binding object for _ObjRec_.
            1. Let _existingProp_ be ? _globalObject_.[[GetOwnProperty]](_N_).
            1. If _existingProp_ is *undefined* or _existingProp_.[[Configurable]] is *true*, then
              1. Let _desc_ be the PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: _D_ }.
            1. Else,
              1. Let _desc_ be the PropertyDescriptor { [[Value]]: _V_ }.
            1. Perform ? DefinePropertyOrThrow(_globalObject_, _N_, _desc_).
            1. Record that the binding for _N_ in _ObjRec_ has been initialized.
            1. Perform ? Set(_globalObject_, _N_, _V_, *false*).
            1. Let _varDeclaredNames_ be _envRec_.[[VarNames]].
            1. If _varDeclaredNames_ does not contain _N_, then
              1. Append _N_ to _varDeclaredNames_.
            1. Return NormalCompletion(~empty~).
          </emu-alg>
          <emu-note>
            <p>Global function declarations are always represented as own properties of the global object. If possible, an existing own property is reconfigured to have a standard set of attribute values. Steps 8-9 are equivalent to what calling the InitializeBinding concrete method would do and if _globalObject_ is a Proxy will produce the same sequence of Proxy trap calls.</p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-module-environment-records">
        <h1>Module Environment Records</h1>
        <p>A module Environment Record is a declarative Environment Record that is used to represent the outer scope of an ECMAScript |Module|. In additional to normal mutable and immutable bindings, module Environment Records also provide immutable import bindings which are bindings that provide indirect access to a target binding that exists in another Environment Record.</p>
        <p>Module Environment Records support all of the declarative Environment Record methods listed in <emu-xref href="#table-15"></emu-xref> and share the same specifications for all of those methods except for GetBindingValue, DeleteBinding, HasThisBinding and GetThisBinding. In addition, module Environment Records support the methods listed in <emu-xref href="#table-20"></emu-xref>:</p>
        <emu-table id="table-20" caption="Additional Methods of Module Environment Records">
          <table>
            <tbody>
            <tr>
              <th>
                Method
              </th>
              <th>
                Purpose
              </th>
            </tr>
            <tr>
              <td>
                CreateImportBinding(N, M, N2)
              </td>
              <td>
                Create an immutable indirect binding in a module Environment Record. The String value _N_ is the text of the bound name. _M_ is a Module Record, and _N2_ is a binding that exists in M's module Environment Record.
              </td>
            </tr>
            <tr>
              <td>
                GetThisBinding()
              </td>
              <td>
                Return the value of this Environment Record's `this` binding.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
        <p>The behaviour of the additional concrete specification methods for module Environment Records are defined by the following algorithms:</p>

        <emu-clause id="sec-module-environment-records-getbindingvalue-n-s">
          <h1>GetBindingValue ( _N_, _S_ )</h1>
          <p>The concrete Environment Record method GetBindingValue for module Environment Records returns the value of its bound identifier whose name is the value of the argument _N_. However, if the binding is an indirect binding the value of the target binding is returned. If the binding exists but is uninitialized a *ReferenceError* is thrown.</p>
          <emu-alg>
            1. Assert: _S_ is *true*.
            1. Let _envRec_ be the module Environment Record for which the method was invoked.
            1. Assert: _envRec_ has a binding for _N_.
            1. If the binding for _N_ is an indirect binding, then
              1. Let _M_ and _N2_ be the indirection values provided when this binding for _N_ was created.
              1. Let _targetEnv_ be _M_.[[Environment]].
              1. If _targetEnv_ is *undefined*, throw a *ReferenceError* exception.
              1. Let _targetER_ be _targetEnv_'s EnvironmentRecord.
              1. Return ? _targetER_.GetBindingValue(_N2_, *true*).
            1. If the binding for _N_ in _envRec_ is an uninitialized binding, throw a *ReferenceError* exception.
            1. Return the value currently bound to _N_ in _envRec_.
          </emu-alg>
          <emu-note>
            <p>_S_ will always be *true* because a |Module| is always strict mode code.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-module-environment-records-deletebinding-n">
          <h1>DeleteBinding ( _N_ )</h1>
          <p>The concrete Environment Record method DeleteBinding for module Environment Records refuses to delete bindings.</p>
          <emu-alg>
            1. Assert: This method is never invoked. See <emu-xref href="#sec-delete-operator-static-semantics-early-errors"></emu-xref>.
          </emu-alg>
          <emu-note>
            <p>Module Environment Records are only used within strict code and an early error rule prevents the delete operator, in strict code, from being applied to a Reference that would resolve to a module Environment Record binding. See <emu-xref href="#sec-delete-operator-static-semantics-early-errors"></emu-xref>.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-module-environment-records-hasthisbinding">
          <h1>HasThisBinding ( )</h1>
          <p>Module Environment Records provide a `this` binding.</p>
          <emu-alg>
            1. Return *true*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-module-environment-records-getthisbinding">
          <h1>GetThisBinding ( )</h1>
          <emu-alg>
            1. Return *undefined*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-createimportbinding">
          <h1>CreateImportBinding ( _N_, _M_, _N2_ )</h1>
          <p>The concrete Environment Record method CreateImportBinding for module Environment Records creates a new initialized immutable indirect binding for the name _N_. A binding must not already exist in this Environment Record for _N_. _M_ is a Module Record, and _N2_ is the name of a binding that exists in M's module Environment Record. Accesses to the value of the new binding will indirectly access the bound value of the target binding.</p>
          <emu-alg>
            1. Let _envRec_ be the module Environment Record for which the method was invoked.
            1. Assert: _envRec_ does not already have a binding for _N_.
            1. Assert: _M_ is a Module Record.
            1. Assert: When _M_.[[Environment]] is instantiated it will have a direct binding for _N2_.
            1. Create an immutable indirect binding in _envRec_ for _N_ that references _M_ and _N2_ as its target binding and record that the binding is initialized.
            1. Return NormalCompletion(~empty~).
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-lexical-environment-operations">
      <h1>Lexical Environment Operations</h1>
      <p>The following abstract operations are used in this specification to operate upon lexical environments:</p>

      <emu-clause id="sec-getidentifierreference" aoid="GetIdentifierReference">
        <h1>GetIdentifierReference ( _lex_, _name_, _strict_ )</h1>
        <p>The abstract operation GetIdentifierReference is called with a Lexical Environment _lex_, a String _name_, and a Boolean flag _strict_. The value of _lex_ may be *null*. When called, the following steps are performed:</p>
        <emu-alg>
          1. If _lex_ is the value *null*, then
            1. Return a value of type Reference whose base value component is *undefined*, whose referenced name component is _name_, and whose strict reference flag is _strict_.
          1. Let _envRec_ be _lex_'s EnvironmentRecord.
          1. Let _exists_ be ? _envRec_.HasBinding(_name_).
          1. If _exists_ is *true*, then
            1. Return a value of type Reference whose base value component is _envRec_, whose referenced name component is _name_, and whose strict reference flag is _strict_.
          1. Else,
            1. Let _outer_ be the value of _lex_'s outer environment reference.
            1. Return ? GetIdentifierReference(_outer_, _name_, _strict_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newdeclarativeenvironment" aoid="NewDeclarativeEnvironment">
        <h1>NewDeclarativeEnvironment ( _E_ )</h1>
        <p>When the abstract operation NewDeclarativeEnvironment is called with a Lexical Environment as argument _E_ the following steps are performed:</p>
        <emu-alg>
          1. Let _env_ be a new Lexical Environment.
          1. Let _envRec_ be a new declarative Environment Record containing no bindings.
          1. Set _env_'s EnvironmentRecord to _envRec_.
          1. Set the outer lexical environment reference of _env_ to _E_.
          1. Return _env_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newobjectenvironment" aoid="NewObjectEnvironment">
        <h1>NewObjectEnvironment ( _O_, _E_ )</h1>
        <p>When the abstract operation NewObjectEnvironment is called with an Object _O_ and a Lexical Environment _E_ as arguments, the following steps are performed:</p>
        <emu-alg>
          1. Let _env_ be a new Lexical Environment.
          1. Let _envRec_ be a new object Environment Record containing _O_ as the binding object.
          1. Set _env_'s EnvironmentRecord to _envRec_.
          1. Set the outer lexical environment reference of _env_ to _E_.
          1. Return _env_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newfunctionenvironment" aoid="NewFunctionEnvironment">
        <h1>NewFunctionEnvironment ( _F_, _newTarget_ )</h1>
        <p>When the abstract operation NewFunctionEnvironment is called with arguments _F_ and _newTarget_ the following steps are performed:</p>
        <emu-alg>
          1. Assert: _F_ is an ECMAScript function.
          1. Assert: Type(_newTarget_) is Undefined or Object.
          1. Let _env_ be a new Lexical Environment.
          1. Let _envRec_ be a new function Environment Record containing no bindings.
          1. Set _envRec_.[[FunctionObject]] to _F_.
          1. If _F_.[[ThisMode]] is ~lexical~, set _envRec_.[[ThisBindingStatus]] to `"lexical"`.
          1. Else, set _envRec_.[[ThisBindingStatus]] to `"uninitialized"`.
          1. Let _home_ be _F_.[[HomeObject]].
          1. Set _envRec_.[[HomeObject]] to _home_.
          1. Set _envRec_.[[NewTarget]] to _newTarget_.
          1. Set _env_'s EnvironmentRecord to _envRec_.
          1. Set the outer lexical environment reference of _env_ to _F_.[[Environment]].
          1. Return _env_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newglobalenvironment" aoid="NewGlobalEnvironment">
        <h1>NewGlobalEnvironment ( _G_, _thisValue_ )</h1>
        <p>When the abstract operation NewGlobalEnvironment is called with arguments _G_ and _thisValue_, the following steps are performed:</p>
        <emu-alg>
          1. Let _env_ be a new Lexical Environment.
          1. Let _objRec_ be a new object Environment Record containing _G_ as the binding object.
          1. Let _dclRec_ be a new declarative Environment Record containing no bindings.
          1. Let _globalRec_ be a new global Environment Record.
          1. Set _globalRec_.[[ObjectRecord]] to _objRec_.
          1. Set _globalRec_.[[GlobalThisValue]] to _thisValue_.
          1. Set _globalRec_.[[DeclarativeRecord]] to _dclRec_.
          1. Set _globalRec_.[[VarNames]] to a new empty List.
          1. Set _env_'s EnvironmentRecord to _globalRec_.
          1. Set the outer lexical environment reference of _env_ to *null*.
          1. Return _env_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newmoduleenvironment" aoid="NewModuleEnvironment">
        <h1>NewModuleEnvironment ( _E_ )</h1>
        <p>When the abstract operation NewModuleEnvironment is called with a Lexical Environment argument _E_ the following steps are performed:</p>
        <emu-alg>
          1. Let _env_ be a new Lexical Environment.
          1. Let _envRec_ be a new module Environment Record containing no bindings.
          1. Set _env_'s EnvironmentRecord to _envRec_.
          1. Set the outer lexical environment reference of _env_ to _E_.
          1. Return _env_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-code-realms">
    <h1>Realms</h1>
    <p>Before it is evaluated, all ECMAScript code must be associated with a <dfn id="realm">realm</dfn>. Conceptually, a realm consists of a set of intrinsic objects, an ECMAScript global environment, all of the ECMAScript code that is loaded within the scope of that global environment, and other associated state and resources.</p>
    <p>A realm is represented in this specification as a <dfn id="realm-record">Realm Record</dfn> with the fields specified in <emu-xref href="#table-21"></emu-xref>:</p>
    <emu-table id="table-21" caption="Realm Record Fields">
      <table>
        <tbody>
        <tr>
          <th>
            Field Name
          </th>
          <th>
            Value
          </th>
          <th>
            Meaning
          </th>
        </tr>
        <tr>
          <td>
            [[Intrinsics]]
          </td>
          <td>
            Record whose field names are intrinsic keys and whose values are objects
          </td>
          <td>
            The intrinsic values used by code associated with this realm
          </td>
        </tr>
        <tr>
          <td>
            [[GlobalObject]]
          </td>
          <td>
            Object
          </td>
          <td>
            The global object for this realm
          </td>
        </tr>
        <tr>
          <td>
            [[GlobalEnv]]
          </td>
          <td>
            Lexical Environment
          </td>
          <td>
            The global environment for this realm
          </td>
        </tr>
        <tr>
          <td>
            [[TemplateMap]]
          </td>
          <td>
            A List of Record { [[Site]]: Parse Node, [[Array]]: Object }.
          </td>
          <td>
            <p>Template objects are canonicalized separately for each realm using its Realm Record's [[TemplateMap]]. Each [[Site]] value is a Parse Node that is a |TemplateLiteral|. The associated [[Array]] value is the corresponding template object that is passed to a tag function.</p>
            <emu-note>Once a Parse Node becomes unreachable, the corresponding [[Array]] is also unreachable, and it would be unobservable if an implementation removed the pair from the [[TemplateMap]] list.</emu-note>
          </td>
        </tr>
        <tr>
          <td>
            [[HostDefined]]
          </td>
          <td>
            Any, default value is *undefined*.
          </td>
          <td>
            Field reserved for use by host environments that need to associate additional information with a Realm Record.
          </td>
        </tr>
        </tbody>
      </table>
    </emu-table>

    <emu-clause id="sec-createrealm" aoid="CreateRealm">
      <h1>CreateRealm ( )</h1>
      <p>The abstract operation CreateRealm with no arguments performs the following steps:</p>
      <emu-alg>
        1. Let _realmRec_ be a new Realm Record.
        1. Perform CreateIntrinsics(_realmRec_).
        1. Set _realmRec_.[[GlobalObject]] to *undefined*.
        1. Set _realmRec_.[[GlobalEnv]] to *undefined*.
        1. Set _realmRec_.[[TemplateMap]] to a new empty List.
        1. Return _realmRec_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createintrinsics" aoid="CreateIntrinsics">
      <h1>CreateIntrinsics ( _realmRec_ )</h1>
      <p>The abstract operation CreateIntrinsics with argument _realmRec_ performs the following steps:</p>
      <emu-alg>
        1. Let _intrinsics_ be a new Record.
        1. Set _realmRec_.[[Intrinsics]] to _intrinsics_.
        1. Let _objProto_ be ObjectCreate(*null*).
        1. Set _intrinsics_.[[%ObjectPrototype%]] to _objProto_.
        1. Let _throwerSteps_ be the algorithm steps specified in <emu-xref href="#sec-%throwtypeerror%"></emu-xref> for the %ThrowTypeError% function.
        1. Let _thrower_ be CreateBuiltinFunction(_throwerSteps_, &laquo; &raquo;, _realmRec_, *null*).
        1. Set _intrinsics_.[[%ThrowTypeError%]] to _thrower_.
        1. Let _noSteps_ be an empty sequence of algorithm steps.
        1. Let _funcProto_ be CreateBuiltinFunction(_noSteps_, &laquo; &raquo;, _realmRec_, _objProto_).
        1. Set _intrinsics_.[[%FunctionPrototype%]] to _funcProto_.
        1. Call _thrower_.[[SetPrototypeOf]](_funcProto_).
        1. Perform AddRestrictedFunctionProperties(_funcProto_, _realmRec_).
        1. Set fields of _intrinsics_ with the values listed in <emu-xref href="#table-7"></emu-xref> that have not already been handled above. The field names are the names listed in column one of the table. The value of each field is a new object value fully and recursively populated with property values as defined by the specification of each object in clauses 18-26. All object property values are newly created object values. All values that are built-in function objects are created by performing CreateBuiltinFunction(&lt;steps&gt;, &lt;slots&gt;, _realmRec_, &lt;prototype&gt;) where &lt;steps&gt; is the definition of that function provided by this specification, &lt;slots&gt; is a list of the names, if any, of the function's specified internal slots, and &lt;prototype&gt; is the specified value of the function's [[Prototype]] internal slot. The creation of the intrinsics and their properties must be ordered to avoid any dependencies upon objects that have not yet been created.
        1. Return _intrinsics_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-setrealmglobalobject" aoid="SetRealmGlobalObject">
      <h1>SetRealmGlobalObject ( _realmRec_, _globalObj_, _thisValue_ )</h1>
      <p>The abstract operation SetRealmGlobalObject with arguments _realmRec_, _globalObj_, and _thisValue_ performs the following steps:</p>
      <emu-alg>
        1. If _globalObj_ is *undefined*, then
          1. Let _intrinsics_ be _realmRec_.[[Intrinsics]].
          1. Set _globalObj_ to ObjectCreate(_intrinsics_.[[%ObjectPrototype%]]).
        1. Assert: Type(_globalObj_) is Object.
        1. If _thisValue_ is *undefined*, set _thisValue_ to _globalObj_.
        1. Set _realmRec_.[[GlobalObject]] to _globalObj_.
        1. Let _newGlobalEnv_ be NewGlobalEnvironment(_globalObj_, _thisValue_).
        1. Set _realmRec_.[[GlobalEnv]] to _newGlobalEnv_.
        1. Return _realmRec_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-setdefaultglobalbindings" aoid="SetDefaultGlobalBindings">
      <h1>SetDefaultGlobalBindings ( _realmRec_ )</h1>
      <p>The abstract operation SetDefaultGlobalBindings with argument _realmRec_ performs the following steps:</p>
      <emu-alg>
        1. Let _global_ be _realmRec_.[[GlobalObject]].
        1. For each property of the Global Object specified in clause <emu-xref href="#sec-global-object"></emu-xref>, do
          1. Let _name_ be the String value of the property name.
          1. Let _desc_ be the fully populated data property descriptor for the property containing the specified attributes for the property. For properties listed in <emu-xref href="#sec-function-properties-of-the-global-object"></emu-xref>, <emu-xref href="#sec-constructor-properties-of-the-global-object"></emu-xref>, or <emu-xref href="#sec-other-properties-of-the-global-object"></emu-xref> the value of the [[Value]] attribute is the corresponding intrinsic object from _realmRec_.
          1. Perform ? DefinePropertyOrThrow(_global_, _name_, _desc_).
        1. Return _global_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-execution-contexts">
    <h1>Execution Contexts</h1>
    <p>An <dfn>execution context</dfn> is a specification device that is used to track the runtime evaluation of code by an ECMAScript implementation. At any point in time, there is at most one execution context per agent that is actually executing code. This is known as the agent's <dfn id="running-execution-context">running execution context</dfn>.  All references to the running execution context in this specification denote the running execution context of the surrounding agent.</p>
    <p>The <dfn id="execution-context-stack">execution context stack</dfn> is used to track execution contexts. The running execution context is always the top element of this stack. A new execution context is created whenever control is transferred from the executable code associated with the currently running execution context to executable code that is not associated with that execution context. The newly created execution context is pushed onto the stack and becomes the running execution context.</p>
    <p>An execution context contains whatever implementation specific state is necessary to track the execution progress of its associated code. Each execution context has at least the state components listed in <emu-xref href="#table-22"></emu-xref>.</p>
    <emu-table id="table-22" caption="State Components for All Execution Contexts">
      <table>
        <tbody>
        <tr>
          <th>
            Component
          </th>
          <th>
            Purpose
          </th>
        </tr>
        <tr>
          <td>
            code evaluation state
          </td>
          <td>
            Any state needed to perform, suspend, and resume evaluation of the code associated with this execution context.
          </td>
        </tr>
        <tr>
          <td>
            Function
          </td>
          <td>
            If this execution context is evaluating the code of a function object, then the value of this component is that function object. If the context is evaluating the code of a |Script| or |Module|, the value is *null*.
          </td>
        </tr>
        <tr>
          <td>
            Realm
          </td>
          <td>
            The Realm Record from which associated code accesses ECMAScript resources.
          </td>
        </tr>
        <tr>
          <td>
            ScriptOrModule
          </td>
          <td>
            The Module Record or Script Record from which associated code originates. If there is no originating script or module, as is the case for the original execution context created in InitializeHostDefinedRealm, the value is *null*.
          </td>
        </tr>
        </tbody>
      </table>
    </emu-table>
    <p>Evaluation of code by the running execution context may be suspended at various points defined within this specification. Once the running execution context has been suspended a different execution context may become the running execution context and commence evaluating its code. At some later time a suspended execution context may again become the running execution context and continue evaluating its code at the point where it had previously been suspended. Transition of the running execution context status among execution contexts usually occurs in stack-like last-in/first-out manner. However, some ECMAScript features require non-LIFO transitions of the running execution context.</p>
    <p>The value of the Realm component of the running execution context is also called <dfn id="current-realm">the current Realm Record</dfn>. The value of the Function component of the running execution context is also called the <dfn id="active-function-object">active function object</dfn>.</p>
    <p>Execution contexts for ECMAScript code have the additional state components listed in <emu-xref href="#table-23"></emu-xref>.</p>
    <emu-table id="table-23" caption="Additional State Components for ECMAScript Code Execution Contexts">
      <table>
        <tbody>
        <tr>
          <th>
            Component
          </th>
          <th>
            Purpose
          </th>
        </tr>
        <tr>
          <td>
            LexicalEnvironment
          </td>
          <td>
            Identifies the Lexical Environment used to resolve identifier references made by code within this execution context.
          </td>
        </tr>
        <tr>
          <td>
            VariableEnvironment
          </td>
          <td>
            Identifies the Lexical Environment whose EnvironmentRecord holds bindings created by |VariableStatement|s within this execution context.
          </td>
        </tr>
        </tbody>
      </table>
    </emu-table>
    <p>The LexicalEnvironment and VariableEnvironment components of an execution context are always Lexical Environments.</p>
    <p>Execution contexts representing the evaluation of generator objects have the additional state components listed in <emu-xref href="#table-24"></emu-xref>.</p>
    <emu-table id="table-24" caption="Additional State Components for Generator Execution Contexts">
      <table>
        <tbody>
        <tr>
          <th>
            Component
          </th>
          <th>
            Purpose
          </th>
        </tr>
        <tr>
          <td>
            Generator
          </td>
          <td>
            The GeneratorObject that this execution context is evaluating.
          </td>
        </tr>
        </tbody>
      </table>
    </emu-table>
    <p>In most situations only the running execution context (the top of the execution context stack) is directly manipulated by algorithms within this specification. Hence when the terms &ldquo;LexicalEnvironment&rdquo;, and &ldquo;VariableEnvironment&rdquo; are used without qualification they are in reference to those components of the running execution context.</p>
    <p>An execution context is purely a specification mechanism and need not correspond to any particular artefact of an ECMAScript implementation. It is impossible for ECMAScript code to directly access or observe an execution context.</p>

    <emu-clause id="sec-getactivescriptormodule" aoid="GetActiveScriptOrModule">
      <h1>GetActiveScriptOrModule ( )</h1>
      <p>The GetActiveScriptOrModule abstract operation is used to determine the running script or module, based on the running execution context. GetActiveScriptOrModule performs the following steps:</p>

      <emu-alg>
        1. If the execution context stack is empty, return *null*.
        1. Let _ec_ be the topmost execution context on the execution context stack whose ScriptOrModule component is not *null*.
        1. If no such execution context exists, return *null*. Otherwise, return _ec_'s ScriptOrModule component.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-resolvebinding" aoid="ResolveBinding">
      <h1>ResolveBinding ( _name_ [ , _env_ ] )</h1>
      <p>The ResolveBinding abstract operation is used to determine the binding of _name_ passed as a String value. The optional argument _env_ can be used to explicitly provide the Lexical Environment that is to be searched for the binding. During execution of ECMAScript code, ResolveBinding is performed using the following algorithm:</p>
      <emu-alg>
        1. If _env_ is not present or if _env_ is *undefined*, then
          1. Set _env_ to the running execution context's LexicalEnvironment.
        1. Assert: _env_ is a Lexical Environment.
        1. If the code matching the syntactic production that is being evaluated is contained in strict mode code, let _strict_ be *true*, else let _strict_ be *false*.
        1. Return ? GetIdentifierReference(_env_, _name_, _strict_).
      </emu-alg>
      <emu-note>
        <p>The result of ResolveBinding is always a Reference value with its referenced name component equal to the _name_ argument.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-getthisenvironment" aoid="GetThisEnvironment">
      <h1>GetThisEnvironment ( )</h1>
      <p>The abstract operation GetThisEnvironment finds the Environment Record that currently supplies the binding of the keyword `this`. GetThisEnvironment performs the following steps:</p>
      <emu-alg>
        1. Let _lex_ be the running execution context's LexicalEnvironment.
        1. Repeat,
          1. Let _envRec_ be _lex_'s EnvironmentRecord.
          1. Let _exists_ be _envRec_.HasThisBinding().
          1. If _exists_ is *true*, return _envRec_.
          1. Let _outer_ be the value of _lex_'s outer environment reference.
          1. Assert: _outer_ is not *null*.
          1. Set _lex_ to _outer_.
      </emu-alg>
      <emu-note>
        <p>The loop in step 2 will always terminate because the list of environments always ends with the global environment which has a `this` binding.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-resolvethisbinding" aoid="ResolveThisBinding">
      <h1>ResolveThisBinding ( )</h1>
      <p>The abstract operation ResolveThisBinding determines the binding of the keyword `this` using the LexicalEnvironment of the running execution context. ResolveThisBinding performs the following steps:</p>
      <emu-alg>
        1. Let _envRec_ be GetThisEnvironment().
        1. Return ? _envRec_.GetThisBinding().
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getnewtarget" aoid="GetNewTarget">
      <h1>GetNewTarget ( )</h1>
      <p>The abstract operation GetNewTarget determines the NewTarget value using the LexicalEnvironment of the running execution context. GetNewTarget performs the following steps:</p>
      <emu-alg>
        1. Let _envRec_ be GetThisEnvironment().
        1. Assert: _envRec_ has a [[NewTarget]] field.
        1. Return _envRec_.[[NewTarget]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getglobalobject" aoid="GetGlobalObject">
      <h1>GetGlobalObject ( )</h1>
      <p>The abstract operation GetGlobalObject returns the global object used by the currently running execution context. GetGlobalObject performs the following steps:</p>
      <emu-alg>
        1. Let _ctx_ be the running execution context.
        1. Let _currentRealm_ be _ctx_'s Realm.
        1. Return _currentRealm_.[[GlobalObject]].
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-jobs-and-job-queues">
    <h1>Jobs and Job Queues</h1>
    <p>A Job is an abstract operation that initiates an ECMAScript computation when no other ECMAScript computation is currently in progress. A Job abstract operation may be defined to accept an arbitrary set of job parameters.</p>
    <p>Execution of a Job can be initiated only when there is no running execution context and the execution context stack is empty. A PendingJob is a request for the future execution of a Job. A PendingJob is an internal Record whose fields are specified in <emu-xref href="#table-25"></emu-xref>. Once execution of a Job is initiated, the Job always executes to completion. No other Job may be initiated until the currently running Job completes. However, the currently running Job or external events may cause the enqueuing of additional PendingJobs that may be initiated sometime after completion of the currently running Job.</p>
    <emu-table id="table-25" caption="PendingJob Record Fields">
      <table>
        <tbody>
        <tr>
          <th>
            Field Name
          </th>
          <th>
            Value
          </th>
          <th>
            Meaning
          </th>
        </tr>
        <tr>
          <td>
            [[Job]]
          </td>
          <td>
            The name of a Job abstract operation
          </td>
          <td>
            This is the abstract operation that is performed when execution of this PendingJob is initiated.
          </td>
        </tr>
        <tr>
          <td>
            [[Arguments]]
          </td>
          <td>
            A List
          </td>
          <td>
            The List of argument values that are to be passed to [[Job]] when it is activated.
          </td>
        </tr>
        <tr>
          <td>
            [[Realm]]
          </td>
          <td>
            A Realm Record
          </td>
          <td>
            The Realm Record for the initial execution context when this PendingJob is initiated.
          </td>
        </tr>
        <tr>
          <td>
            [[ScriptOrModule]]
          </td>
          <td>
            A Script Record or Module Record
          </td>
          <td>
            The script or module for the initial execution context when this PendingJob is initiated.
          </td>
        </tr>
        <tr>
          <td>
            [[HostDefined]]
          </td>
          <td>
            Any, default value is *undefined*.
          </td>
          <td>
            Field reserved for use by host environments that need to associate additional information with a pending Job.
          </td>
        </tr>
        </tbody>
      </table>
    </emu-table>
    <p>A Job Queue is a FIFO queue of PendingJob records. Each Job Queue has a name and the full set of available Job Queues are defined by an ECMAScript implementation. Every ECMAScript implementation has at least the Job Queues defined in <emu-xref href="#table-26"></emu-xref>.</p>
    <p>Each agent has its own set of named Job Queues.  All references to a named job queue in this specification denote the named job queue of the surrounding agent.</p>
    <emu-table id="table-26" caption="Required Job Queues">
      <table>
        <tbody>
        <tr>
          <th>
            Name
          </th>
          <th>
            Purpose
          </th>
        </tr>
        <tr>
          <td>
            ScriptJobs
          </td>
          <td>
            Jobs that validate and evaluate ECMAScript |Script| and |Module| source text. See clauses 10 and 15.
          </td>
        </tr>
        <tr>
          <td>
            PromiseJobs
          </td>
          <td>
            Jobs that are responses to the settlement of a Promise (see <emu-xref href="#sec-promise-objects"></emu-xref>).
          </td>
        </tr>
        </tbody>
      </table>
    </emu-table>
    <p>A request for the future execution of a Job is made by enqueueing, on a Job Queue, a PendingJob record that includes a Job abstract operation name and any necessary argument values. When there is no running execution context and the execution context stack is empty, the ECMAScript implementation removes the first PendingJob from a Job Queue and uses the information contained in it to create an execution context and starts execution of the associated Job abstract operation.</p>
    <p>The PendingJob records from a single Job Queue are always initiated in FIFO order. This specification does not define the order in which multiple Job Queues are serviced. An ECMAScript implementation may interweave the FIFO evaluation of the PendingJob records of a Job Queue with the evaluation of the PendingJob records of one or more other Job Queues. An implementation must define what occurs when there are no running execution context and all Job Queues are empty.</p>
    <emu-note>
      <p>Typically an ECMAScript implementation will have its Job Queues pre-initialized with at least one PendingJob and one of those Jobs will be the first to be executed. An implementation might choose to free all resources and terminate if the current Job completes and all Job Queues are empty. Alternatively, it might choose to wait for a some implementation specific agent or mechanism to enqueue new PendingJob requests.</p>
    </emu-note>
    <p>The following abstract operations are used to create and manage Jobs and Job Queues:</p>

    <emu-clause id="sec-enqueuejob" aoid="EnqueueJob">
      <h1>EnqueueJob ( _queueName_, _job_, _arguments_ )</h1>
      <p>The EnqueueJob abstract operation requires three arguments: _queueName_, _job_, and _arguments_. It performs the following steps:</p>
      <emu-alg>
        1. Assert: Type(_queueName_) is String and its value is the name of a Job Queue recognized by this implementation.
        1. Assert: _job_ is the name of a Job.
        1. Assert: _arguments_ is a List that has the same number of elements as the number of parameters required by _job_.
        1. Let _callerContext_ be the running execution context.
        1. Let _callerRealm_ be _callerContext_'s Realm.
        1. Let _callerScriptOrModule_ be _callerContext_'s ScriptOrModule.
        1. Let _pending_ be PendingJob { [[Job]]: _job_, [[Arguments]]: _arguments_, [[Realm]]: _callerRealm_, [[ScriptOrModule]]: _callerScriptOrModule_, [[HostDefined]]: *undefined* }.
        1. Perform any implementation or host environment defined processing of _pending_. This may include modifying the [[HostDefined]] field or any other field of _pending_.
        1. Add _pending_ at the back of the Job Queue named by _queueName_.
        1. Return NormalCompletion(~empty~).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-initializehostdefinedrealm" aoid="InitializeHostDefinedRealm">
    <h1>InitializeHostDefinedRealm ( )</h1>
    <p>The abstract operation InitializeHostDefinedRealm performs the following steps:</p>

    <emu-alg>
      1. Let _realm_ be CreateRealm().
      1. Let _newContext_ be a new execution context.
      1. Set the Function of _newContext_ to *null*.
      1. Set the Realm of _newContext_ to _realm_.
      1. Set the ScriptOrModule of _newContext_ to *null*.
      1. Push _newContext_ onto the execution context stack; _newContext_ is now the running execution context.
      1. If the host requires use of an exotic object to serve as _realm_'s global object, let _global_ be such an object created in an implementation-defined manner. Otherwise, let _global_ be *undefined*, indicating that an ordinary object should be created as the global object.
      1. If the host requires that the `this` binding in _realm_'s global scope return an object other than the global object, let _thisValue_ be such an object created in an implementation-defined manner. Otherwise, let _thisValue_ be *undefined*, indicating that _realm_'s global `this` binding should be the global object.
      1. Perform SetRealmGlobalObject(_realm_, _global_, _thisValue_).
      1. Let _globalObj_ be ? SetDefaultGlobalBindings(_realm_).
      1. Create any implementation-defined global object properties on _globalObj_.
      1. Return NormalCompletion(~empty~).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-runjobs" aoid="RunJobs">
    <h1>RunJobs ( )</h1>
    <p>The abstract operation RunJobs performs the following steps:</p>
    <emu-alg>
      1. Perform ? InitializeHostDefinedRealm().
      1. In an implementation-dependent manner, obtain the ECMAScript source texts (see clause <emu-xref href="#sec-ecmascript-language-source-code"></emu-xref>) and any associated host-defined values for zero or more ECMAScript scripts and/or ECMAScript modules. For each such _sourceText_ and _hostDefined_, do
        1. If _sourceText_ is the source code of a script, then
          1. Perform EnqueueJob(`"ScriptJobs"`, ScriptEvaluationJob, &laquo; _sourceText_, _hostDefined_ &raquo;).
        1. Else _sourceText_ is the source code of a module,
          1. Perform EnqueueJob(`"ScriptJobs"`, TopLevelModuleEvaluationJob, &laquo; _sourceText_, _hostDefined_ &raquo;).
      1. Repeat,
        1. Suspend the running execution context and remove it from the execution context stack.
        1. Assert: The execution context stack is now empty.
        1. Let _nextQueue_ be a non-empty Job Queue chosen in an implementation-defined manner. If all Job Queues are empty, the result is implementation-defined.
        1. Let _nextPending_ be the PendingJob record at the front of _nextQueue_. Remove that record from _nextQueue_.
        1. Let _newContext_ be a new execution context.
        1. Set _newContext_'s Function to *null*.
        1. Set _newContext_'s Realm to _nextPending_.[[Realm]].
        1. Set _newContext_'s ScriptOrModule to _nextPending_.[[ScriptOrModule]].
        1. Push _newContext_ onto the execution context stack; _newContext_ is now the running execution context.
        1. Perform any implementation or host environment defined job initialization using _nextPending_.
        1. Let _result_ be the result of performing the abstract operation named by _nextPending_.[[Job]] using the elements of _nextPending_.[[Arguments]] as its arguments.
        1. If _result_ is an abrupt completion, perform HostReportErrors(&laquo; _result_.[[Value]] &raquo;).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-agents">
    <h1>Agents</h1>

    <p>An <dfn id="agent">agent</dfn> comprises a set of ECMAScript execution contexts, an execution context stack, a running execution context, a set of named job queues, an <dfn id="agent-record">Agent Record</dfn>, and an <dfn id="executing-thread">executing thread</dfn>.  Except for the executing thread, the constituents of an agent belong exclusively to that agent.</p>
    <p>An agent's executing thread executes the jobs in the agent's job queues on the agent's execution contexts independently of other agents, except that an executing thread may be used as the executing thread by multiple agents, provided none of the agents sharing the thread have an Agent Record whose [[CanBlock]] property is *true*.</p>
    <emu-note>
      <p>Some web browsers share a single executing thread across multiple unrelated tabs of a browser window, for example.</p>
    </emu-note>
    <p>While an agent's executing thread executes the jobs in the agent's job queues, the agent is the <dfn id="surrounding-agent">surrounding agent</dfn> for the code in those jobs.  The code uses the surrounding agent to access the specification level execution objects held within the agent: the running execution context, the execution context stack, the named job queues, and the Agent Record's fields.</p>
    <emu-table id="table-agent-record" caption="Agent Record Fields">
      <table>
        <tbody>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[LittleEndian]]</td>
            <td>Boolean</td>
            <td>The default value computed for the <em>isLittleEndian</em> parameter when it is needed by the algorithms GetValueFromBuffer and SetValueInBuffer. The choice is implementation-dependent and should be the alternative that is most efficient for the implementation.  Once the value has been observed it cannot change.</td>
          </tr>
          <tr>
            <td>[[CanBlock]]</td>
            <td>Boolean</td>
            <td>Determines whether the agent can block or not.</td>
          </tr>
          <tr>
            <td>[[Signifier]]</td>
            <td>Any globally-unique value</td>
            <td>Uniquely identifies the agent within its agent cluster.</td>
          </tr>
          <tr>
            <td>[[IsLockFree1]]</td>
            <td>Boolean</td>
            <td>*true* if atomic operations on one-byte values are lock-free, *false* otherwise.</td>
          </tr>
          <tr>
            <td>[[IsLockFree2]]</td>
            <td>Boolean</td>
            <td>*true* if atomic operations on two-byte values are lock-free, *false* otherwise.</td>
          </tr>
          <tr>
            <td>[[CandidateExecution]]</td>
            <td>A candidate execution Record</td>
            <td>See the memory model.</td>
          </tr>
        </tbody>
      </table>
    </emu-table>

    <p>Once the values of [[Signifier]], [[IsLockFree1]], and [[IsLockFree2]] have been observed by any agent in the agent cluster they cannot change.</p>

    <emu-note>
      <p>The values of [[IsLockFree1]] and [[IsLockFree2]] are not necessarily determined by the hardware, but may also reflect implementation choices that can vary over time and between ECMAScript implementations.</p>

      <p>There is no [[IsLockFree4]] property: 4-byte atomic operations are always lock-free.</p>

      <p>In practice, if an atomic operation is implemented with any type of lock the operation is not lock-free.  Lock-free does not imply wait-free: there is no upper bound on how many machine steps may be required to complete a lock-free atomic operation.</p>

      <p>That an atomic access of size <em>n</em> is lock-free does not imply anything about the (perceived) atomicity of non-atomic accesses of size <em>n</em>, specifically, non-atomic accesses may still be performed as a sequence of several separate memory accesses.  See ReadSharedMemory and WriteSharedMemory for details.</p>
    </emu-note>

    <emu-note>
      <p>An agent is a specification mechanism and need not correspond to any particular artefact of an ECMAScript implementation.</p>
    </emu-note>

    <emu-clause id="sec-agentsignifier" aoid="AgentSignifier">
      <h1>AgentSignifier ( )</h1>
      <p>The abstract operation AgentSignifier takes no arguments. It performs the following steps:</p>
      <emu-alg>
        1. Let _AR_ be the Agent Record of the surrounding agent.
        1. Return _AR_.[[Signifier]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-agentcansuspend" aoid="AgentCanSuspend">
      <h1>AgentCanSuspend ( )</h1>
      <p>The abstract operation AgentCanSuspend takes no arguments. It performs the following steps:</p>
      <emu-alg>
        1. Let _AR_ be the Agent Record of the surrounding agent.
        1. Return _AR_.[[CanBlock]].
      </emu-alg>
      <emu-note>
        <p>In some environments it may not be reasonable for a given agent to suspend. For example, in a web browser environment, it may be reasonable to disallow suspending a document's main event handling thread, while still allowing workers' event handling threads to suspend.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-agent-clusters">
    <h1>Agent Clusters</h1>

    <p>An <dfn>agent cluster</dfn> is a maximal set of agents that can communicate by operating on shared memory.</p>

    <emu-note>
      <p>Programs within different agents may share memory by unspecified means.  At a minimum, the backing memory for SharedArrayBuffer objects can be shared among the agents in the cluster.</p>

      <p>There may be agents that can communicate by message passing that cannot share memory; they are never in the same agent cluster.</p>
    </emu-note>

    <p>Every agent belongs to exactly one agent cluster.</p>

    <emu-note>
      <p>The agents in a cluster need not all be alive at some particular point in time.  If agent <b>A</b> creates another agent <b>B</b>, after which <b>A</b> terminates and <b>B</b> creates agent <b>C</b>, the three agents are in the same cluster if <b>A</b> could share some memory with <b>B</b> and <b>B</b> could share some memory with <b>C</b>.</p>
    </emu-note>

    <p>All agents within a cluster must have the same value for the [[LittleEndian]] property in their respective Agent Records.</p>

    <emu-note>
      <p>If different agents within an agent cluster have different values of [[LittleEndian]] it becomes hard to use shared memory for multi-byte data.</p>
    </emu-note>

    <p>All agents within a cluster must have the same values for the [[IsLockFree1]] property in their respective Agent Records; similarly for the [[IsLockFree2]] property.</p>

    <p>All agents within a cluster must have different values for the [[Signifier]] property in their respective Agent Records.</p>

    <p>An embedding may deactivate (stop forward progress) or activate (resume forward progress) an agent without the agent's knowledge or cooperation.  If the embedding does so, it must not leave some agents in the cluster active while other agents in the cluster are deactivated indefinitely.</p>

    <emu-note>
      <p>The purpose of the preceding restriction is to avoid a situation where an agent deadlocks or starves because another agent has been deactivated.  For example, if an HTML shared worker that has a lifetime independent of documents in any windows were allowed to share memory with the dedicated worker of such an independent document, and the document and its dedicated worker were to be deactivated while the dedicated worker holds a lock (say, the document is pushed into its window's history), and the shared worker then tries to acquire the lock, then the shared worker will be blocked until the dedicated worker is activated again, if ever.  Meanwhile other workers trying to access the shared worker from other windows will starve.</p>

      <p>The implication of the restriction is that it will not be possible to share memory between agents that don't belong to the same suspend/wake collective within the embedding.</p>
    </emu-note>

    <p>An embedding may terminate an agent without any of the agent's cluster's other agents' prior knowledge or cooperation.  If an agent is terminated not by programmatic action of its own or of another agent in the cluster but by forces external to the cluster, then the embedding must choose one of two strategies: Either terminate all the agents in the cluster, or provide reliable APIs that allow the agents in the cluster to coordinate so that at least one remaining member of the cluster will be able to detect the termination, with the termination data containing enough information to identify the agent that was terminated.</p>

    <emu-note>
      <p>Examples of that type of termination are: operating systems or users terminating agents that are running in separate processes; the embedding itself terminating an agent that is running in-process with the other agents when per-agent resource accounting indicates that the agent is runaway.</p>
    </emu-note>

    <p>Prior to any evaluation of any ECMAScript code by any agent in a cluster, the [[CandidateExecution]] field of the Agent Record for all agents in the cluster is set to the initial candidate execution. The initial candidate execution is an empty candidate execution whose [[EventsRecords]] field is a List containing, for each agent, an Agent Events Record whose [[AgentSignifier]] field is that agent's signifier, and whose [[EventList]] and [[AgentSynchronizesWith]] fields are empty Lists.</p>

    <emu-note>
      <p>All agents in an agent cluster share the same candidate execution in its Agent Record's [[CandidateExecution]] field. The candidate execution is a specification mechanism used by the memory model.</p>
    </emu-note>

    <emu-note>
      <p>An agent cluster is a specification mechanism and need not correspond to any particular artefact of an ECMAScript implementation.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-forward-progress">
    <h1>Forward Progress</h1>
    <p>For an agent to <em>make forward progress</em> is for it to perform an evaluation step according to this specification.</p>
    <p>An agent becomes <em>blocked</em> when its running execution context waits synchronously and indefinitely for an external event. Only agents whose Agent Record's [[CanBlock]] property is *true* can become blocked in this sense.  An <em>unblocked</em> agent is one that is not blocked.</p>

    <p>Implementations must ensure that:</p>
    <ul>
      <li>every unblocked agent with a dedicated executing thread eventually makes forward progress</li>
      <li>in a set of agents that share an executing thread, one agent eventually makes forward progress</li>
      <li>an agent does not cause another agent to become blocked except via explicit APIs that provide blocking.</li>
    </ul>

    <emu-note>
      <p>This, along with the liveness guarantee in the memory model, ensures that all `"SeqCst"` writes eventually become observable to all agents.</p>
    </emu-note>
  </emu-clause>

</emu-clause>

<emu-clause id="sec-ordinary-and-exotic-objects-behaviours">
  <h1>Ordinary and Exotic Objects Behaviours</h1>

  <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots">
    <h1>Ordinary Object Internal Methods and Internal Slots</h1>
    <p>All ordinary objects have an internal slot called [[Prototype]]. The value of this internal slot is either *null* or an object and is used for implementing inheritance. Data properties of the [[Prototype]] object are inherited (and visible as properties of the child object) for the purposes of get access, but not for set access. Accessor properties are inherited for both get access and set access.</p>
    <p>Every ordinary object has a Boolean-valued [[Extensible]] internal slot which is used to fulfill the extensibility-related internal method invariants specified in <emu-xref href="#sec-invariants-of-the-essential-internal-methods"></emu-xref>. Namely, once the value of an object's [[Extensible]] internal slot has been set to *false*, it is no longer possible to add properties to the object, to modify the value of the object's [[Prototype]] internal slot, or to subsequently change the value of [[Extensible]] to *true*.</p>
    <p>In the following algorithm descriptions, assume _O_ is an ordinary object, _P_ is a property key value, _V_ is any ECMAScript language value, and _Desc_ is a Property Descriptor record.</p>
    <p>Each ordinary object internal method delegates to a similarly-named abstract operation. If such an abstract operation depends on another internal method, then the internal method is invoked on _O_ rather than calling the similarly-named abstract operation directly. These semantics ensure that exotic objects have their overridden internal methods invoked when ordinary object internal methods are applied to them.</p>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof">
      <h1>[[GetPrototypeOf]] ( )</h1>
      <p>When the [[GetPrototypeOf]] internal method of _O_ is called, the following steps are taken:</p>
      <emu-alg>
        1. Return ! OrdinaryGetPrototypeOf(_O_).
      </emu-alg>

      <emu-clause id="sec-ordinarygetprototypeof" aoid="OrdinaryGetPrototypeOf">
        <h1>OrdinaryGetPrototypeOf ( _O_ )</h1>
        <p>When the abstract operation OrdinaryGetPrototypeOf is called with Object _O_, the following steps are taken:</p>
        <emu-alg>
          1. Return _O_.[[Prototype]].
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-setprototypeof-v">
      <h1>[[SetPrototypeOf]] ( _V_ )</h1>
      <p>When the [[SetPrototypeOf]] internal method of _O_ is called with argument _V_, the following steps are taken:</p>
      <emu-alg>
        1. Return ! OrdinarySetPrototypeOf(_O_, _V_).
      </emu-alg>

      <emu-clause id="sec-ordinarysetprototypeof" aoid="OrdinarySetPrototypeOf">
        <h1>OrdinarySetPrototypeOf ( _O_, _V_ )</h1>
        <p>When the abstract operation OrdinarySetPrototypeOf is called with Object _O_ and value _V_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: Either Type(_V_) is Object or Type(_V_) is Null.
          1. Let _current_ be _O_.[[Prototype]].
          1. If SameValue(_V_, _current_) is *true*, return *true*.
          1. Let _extensible_ be _O_.[[Extensible]].
          1. If _extensible_ is *false*, return *false*.
          1. Let _p_ be _V_.
          1. Let _done_ be *false*.
          1. Repeat, while _done_ is *false*,
            1. If _p_ is *null*, set _done_ to *true*.
            1. Else if SameValue(_p_, _O_) is *true*, return *false*.
            1. Else,
              1. If _p_.[[GetPrototypeOf]] is not the ordinary object internal method defined in <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof"></emu-xref>, set _done_ to *true*.
              1. Else, set _p_ to _p_.[[Prototype]].
          1. Set _O_.[[Prototype]] to _V_.
          1. Return *true*.
        </emu-alg>
        <emu-note>
          <p>The loop in step 8 guarantees that there will be no circularities in any prototype chain that only includes objects that use the ordinary object definitions for [[GetPrototypeOf]] and [[SetPrototypeOf]].</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-isextensible">
      <h1>[[IsExtensible]] ( )</h1>
      <p>When the [[IsExtensible]] internal method of _O_ is called, the following steps are taken:</p>
      <emu-alg>
        1. Return ! OrdinaryIsExtensible(_O_).
      </emu-alg>

      <emu-clause id="sec-ordinaryisextensible" aoid="OrdinaryIsExtensible">
        <h1>OrdinaryIsExtensible ( _O_ )</h1>
        <p>When the abstract operation OrdinaryIsExtensible is called with Object _O_, the following steps are taken:</p>
        <emu-alg>
          1. Return _O_.[[Extensible]].
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-preventextensions">
      <h1>[[PreventExtensions]] ( )</h1>
      <p>When the [[PreventExtensions]] internal method of _O_ is called, the following steps are taken:</p>
      <emu-alg>
        1. Return ! OrdinaryPreventExtensions(_O_).
      </emu-alg>

      <emu-clause id="sec-ordinarypreventextensions" aoid="OrdinaryPreventExtensions">
        <h1>OrdinaryPreventExtensions ( _O_ )</h1>
        <p>When the abstract operation OrdinaryPreventExtensions is called with Object _O_, the following steps are taken:</p>
        <emu-alg>
          1. Set _O_.[[Extensible]] to *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-getownproperty-p">
      <h1>[[GetOwnProperty]] ( _P_ )</h1>
      <p>When the [[GetOwnProperty]] internal method of _O_ is called with property key _P_, the following steps are taken:</p>
      <emu-alg>
        1. Return ! OrdinaryGetOwnProperty(_O_, _P_).
      </emu-alg>

      <emu-clause id="sec-ordinarygetownproperty" aoid="OrdinaryGetOwnProperty">
        <h1>OrdinaryGetOwnProperty ( _O_, _P_ )</h1>
        <p>When the abstract operation OrdinaryGetOwnProperty is called with Object _O_ and with property key _P_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: IsPropertyKey(_P_) is *true*.
          1. If _O_ does not have an own property with key _P_, return *undefined*.
          1. Let _D_ be a newly created Property Descriptor with no fields.
          1. Let _X_ be _O_'s own property whose key is _P_.
          1. If _X_ is a data property, then
            1. Set _D_.[[Value]] to the value of _X_'s [[Value]] attribute.
            1. Set _D_.[[Writable]] to the value of _X_'s [[Writable]] attribute.
          1. Else _X_ is an accessor property,
            1. Set _D_.[[Get]] to the value of _X_'s [[Get]] attribute.
            1. Set _D_.[[Set]] to the value of _X_'s [[Set]] attribute.
          1. Set _D_.[[Enumerable]] to the value of _X_'s [[Enumerable]] attribute.
          1. Set _D_.[[Configurable]] to the value of _X_'s [[Configurable]] attribute.
          1. Return _D_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-defineownproperty-p-desc">
      <h1>[[DefineOwnProperty]] ( _P_, _Desc_ )</h1>
      <p>When the [[DefineOwnProperty]] internal method of _O_ is called with property key _P_ and Property Descriptor _Desc_, the following steps are taken:</p>
      <emu-alg>
        1. Return ? OrdinaryDefineOwnProperty(_O_, _P_, _Desc_).
      </emu-alg>

      <emu-clause id="sec-ordinarydefineownproperty" aoid="OrdinaryDefineOwnProperty">
        <h1>OrdinaryDefineOwnProperty ( _O_, _P_, _Desc_ )</h1>
        <p>When the abstract operation OrdinaryDefineOwnProperty is called with Object _O_, property key _P_, and Property Descriptor _Desc_, the following steps are taken:</p>
        <emu-alg>
          1. Let _current_ be ? _O_.[[GetOwnProperty]](_P_).
          1. Let _extensible_ be ? IsExtensible(_O_).
          1. Return ValidateAndApplyPropertyDescriptor(_O_, _P_, _extensible_, _Desc_, _current_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iscompatiblepropertydescriptor" aoid="IsCompatiblePropertyDescriptor">
        <h1>IsCompatiblePropertyDescriptor ( _Extensible_, _Desc_, _Current_ )</h1>
        <p>When the abstract operation IsCompatiblePropertyDescriptor is called with Boolean value _Extensible_, and Property Descriptors _Desc_, and _Current_, the following steps are taken:</p>
        <emu-alg>
          1. Return ValidateAndApplyPropertyDescriptor(*undefined*, *undefined*, _Extensible_, _Desc_, _Current_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-validateandapplypropertydescriptor" aoid="ValidateAndApplyPropertyDescriptor">
        <h1>ValidateAndApplyPropertyDescriptor ( _O_, _P_, _extensible_, _Desc_, _current_ )</h1>
        <p>When the abstract operation ValidateAndApplyPropertyDescriptor is called with Object _O_, property key _P_, Boolean value _extensible_, and Property Descriptors _Desc_, and _current_, the following steps are taken:</p>
        <emu-note>
          <p>If *undefined* is passed as _O_, only validation is performed and no object updates are performed.</p>
        </emu-note>
        <emu-alg>
          1. Assert: If _O_ is not *undefined*, then IsPropertyKey(_P_) is *true*.
          1. If _current_ is *undefined*, then
            1. If _extensible_ is *false*, return *false*.
            1. Assert: _extensible_ is *true*.
            1. If IsGenericDescriptor(_Desc_) is *true* or IsDataDescriptor(_Desc_) is *true*, then
              1. If _O_ is not *undefined*, create an own data property named _P_ of object _O_ whose [[Value]], [[Writable]], [[Enumerable]] and [[Configurable]] attribute values are described by _Desc_. If the value of an attribute field of _Desc_ is absent, the attribute of the newly created property is set to its default value.
            1. Else _Desc_ must be an accessor Property Descriptor,
              1. If _O_ is not *undefined*, create an own accessor property named _P_ of object _O_ whose [[Get]], [[Set]], [[Enumerable]] and [[Configurable]] attribute values are described by _Desc_. If the value of an attribute field of _Desc_ is absent, the attribute of the newly created property is set to its default value.
            1. Return *true*.
          1. If every field in _Desc_ is absent, return *true*.
          1. If _current_.[[Configurable]] is *false*, then
            1. If _Desc_.[[Configurable]] is present and its value is *true*, return *false*.
            1. If _Desc_.[[Enumerable]] is present and the [[Enumerable]] fields of _current_ and _Desc_ are the Boolean negation of each other, return *false*.
          1. If IsGenericDescriptor(_Desc_) is *true*, no further validation is required.
          1. Else if IsDataDescriptor(_current_) and IsDataDescriptor(_Desc_) have different results, then
            1. If _current_.[[Configurable]] is *false*, return *false*.
            1. If IsDataDescriptor(_current_) is *true*, then
              1. If _O_ is not *undefined*, convert the property named _P_ of object _O_ from a data property to an accessor property. Preserve the existing values of the converted property's [[Configurable]] and [[Enumerable]] attributes and set the rest of the property's attributes to their default values.
            1. Else,
              1. If _O_ is not *undefined*, convert the property named _P_ of object _O_ from an accessor property to a data property. Preserve the existing values of the converted property's [[Configurable]] and [[Enumerable]] attributes and set the rest of the property's attributes to their default values.
          1. Else if IsDataDescriptor(_current_) and IsDataDescriptor(_Desc_) are both *true*, then
            1. If _current_.[[Configurable]] is *false* and _current_.[[Writable]] is *false*, then
              1. If _Desc_.[[Writable]] is present and _Desc_.[[Writable]] is *true*, return *false*.
              1. If _Desc_.[[Value]] is present and SameValue(_Desc_.[[Value]], _current_.[[Value]]) is *false*, return *false*.
              1. Return *true*.
          1. Else IsAccessorDescriptor(_current_) and IsAccessorDescriptor(_Desc_) are both *true*,
            1. If _current_.[[Configurable]] is *false*, then
              1. If _Desc_.[[Set]] is present and SameValue(_Desc_.[[Set]], _current_.[[Set]]) is *false*, return *false*.
              1. If _Desc_.[[Get]] is present and SameValue(_Desc_.[[Get]], _current_.[[Get]]) is *false*, return *false*.
              1. Return *true*.
          1. If _O_ is not *undefined*, then
            1. For each field of _Desc_ that is present, set the corresponding attribute of the property named _P_ of object _O_ to the value of the field.
          1. Return *true*.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-hasproperty-p">
      <h1>[[HasProperty]] ( _P_ )</h1>
      <p>When the [[HasProperty]] internal method of _O_ is called with property key _P_, the following steps are taken:</p>
      <emu-alg>
        1. Return ? OrdinaryHasProperty(_O_, _P_).
      </emu-alg>

      <emu-clause id="sec-ordinaryhasproperty" aoid="OrdinaryHasProperty">
        <h1>OrdinaryHasProperty ( _O_, _P_ )</h1>
        <p>When the abstract operation OrdinaryHasProperty is called with Object _O_ and with property key _P_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: IsPropertyKey(_P_) is *true*.
          1. Let _hasOwn_ be ? _O_.[[GetOwnProperty]](_P_).
          1. If _hasOwn_ is not *undefined*, return *true*.
          1. Let _parent_ be ? _O_.[[GetPrototypeOf]]().
          1. If _parent_ is not *null*, then
            1. Return ? _parent_.[[HasProperty]](_P_).
          1. Return *false*.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver">
      <h1>[[Get]] ( _P_, _Receiver_ )</h1>
      <p>When the [[Get]] internal method of _O_ is called with property key _P_ and ECMAScript language value _Receiver_, the following steps are taken:</p>

      <emu-alg>
        1. Return ? OrdinaryGet(_O_, _P_, _Receiver_).
      </emu-alg>

      <emu-clause id="sec-ordinaryget" aoid="OrdinaryGet">
        <h1>OrdinaryGet ( _O_, _P_, _Receiver_ )</h1>
        <p>When the abstract operation OrdinaryGet is called with Object _O_, property key _P_, and ECMAScript language value _Receiver_, the following steps are taken:</p>

        <emu-alg>
          1. Assert: IsPropertyKey(_P_) is *true*.
          1. Let _desc_ be ? _O_.[[GetOwnProperty]](_P_).
          1. If _desc_ is *undefined*, then
            1. Let _parent_ be ? _O_.[[GetPrototypeOf]]().
            1. If _parent_ is *null*, return *undefined*.
            1. Return ? _parent_.[[Get]](_P_, _Receiver_).
          1. If IsDataDescriptor(_desc_) is *true*, return _desc_.[[Value]].
          1. Assert: IsAccessorDescriptor(_desc_) is *true*.
          1. Let _getter_ be _desc_.[[Get]].
          1. If _getter_ is *undefined*, return *undefined*.
          1. Return ? Call(_getter_, _Receiver_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-set-p-v-receiver">
      <h1>[[Set]] ( _P_, _V_, _Receiver_ )</h1>
      <p>When the [[Set]] internal method of _O_ is called with property key _P_, value _V_, and ECMAScript language value _Receiver_, the following steps are taken:</p>
      <emu-alg>
        1. Return ? OrdinarySet(_O_, _P_, _V_, _Receiver_).
      </emu-alg>

      <emu-clause id="sec-ordinaryset" aoid="OrdinarySet">
        <h1>OrdinarySet ( _O_, _P_, _V_, _Receiver_ )</h1>
        <p>When the abstract operation OrdinarySet is called with Object _O_, property key _P_, value _V_, and ECMAScript language value _Receiver_, the following steps are taken:</p>

        <emu-alg>
          1. Assert: IsPropertyKey(_P_) is *true*.
          1. Let _ownDesc_ be ? _O_.[[GetOwnProperty]](_P_).
          1. Return OrdinarySetWithOwnDescriptor(_O_, _P_, _V_, _Receiver_, _ownDesc_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ordinarysetwithowndescriptor" aoid="OrdinarySetWithOwnDescriptor">
        <h1>OrdinarySetWithOwnDescriptor ( _O_, _P_, _V_, _Receiver_, _ownDesc_ )</h1>
        <p>When the abstract operation OrdinarySetWithOwnDescriptor is called with Object _O_, property key _P_, value _V_, ECMAScript language value _Receiver_, and Property Descriptor (or *undefined*) _ownDesc_, the following steps are taken:</p>

        <emu-alg>
          1. Assert: IsPropertyKey(_P_) is *true*.
          1. If _ownDesc_ is *undefined*, then
            1. Let _parent_ be ? _O_.[[GetPrototypeOf]]().
            1. If _parent_ is not *null*, then
              1. Return ? _parent_.[[Set]](_P_, _V_, _Receiver_).
            1. Else,
              1. Set _ownDesc_ to the PropertyDescriptor { [[Value]]: *undefined*, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* }.
          1. If IsDataDescriptor(_ownDesc_) is *true*, then
            1. If _ownDesc_.[[Writable]] is *false*, return *false*.
            1. If Type(_Receiver_) is not Object, return *false*.
            1. Let _existingDescriptor_ be ? _Receiver_.[[GetOwnProperty]](_P_).
            1. If _existingDescriptor_ is not *undefined*, then
              1. If IsAccessorDescriptor(_existingDescriptor_) is *true*, return *false*.
              1. If _existingDescriptor_.[[Writable]] is *false*, return *false*.
              1. Let _valueDesc_ be the PropertyDescriptor { [[Value]]: _V_ }.
              1. Return ? _Receiver_.[[DefineOwnProperty]](_P_, _valueDesc_).
            1. Else _Receiver_ does not currently have a property _P_,
              1. Return ? CreateDataProperty(_Receiver_, _P_, _V_).
          1. Assert: IsAccessorDescriptor(_ownDesc_) is *true*.
          1. Let _setter_ be _ownDesc_.[[Set]].
          1. If _setter_ is *undefined*, return *false*.
          1. Perform ? Call(_setter_, _Receiver_, &laquo; _V_ &raquo;).
          1. Return *true*.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-delete-p">
      <h1>[[Delete]] ( _P_ )</h1>
      <p>When the [[Delete]] internal method of _O_ is called with property key _P_, the following steps are taken:</p>
      <emu-alg>
        1. Return ? OrdinaryDelete(_O_, _P_).
      </emu-alg>

      <emu-clause id="sec-ordinarydelete" aoid="OrdinaryDelete">
        <h1>OrdinaryDelete ( _O_, _P_ )</h1>
        <p>When the abstract operation OrdinaryDelete is called with Object _O_ and property key _P_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: IsPropertyKey(_P_) is *true*.
          1. Let _desc_ be ? _O_.[[GetOwnProperty]](_P_).
          1. If _desc_ is *undefined*, return *true*.
          1. If _desc_.[[Configurable]] is *true*, then
            1. Remove the own property with name _P_ from _O_.
            1. Return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys">
      <h1>[[OwnPropertyKeys]] ( )</h1>
      <p>When the [[OwnPropertyKeys]] internal method of _O_ is called, the following steps are taken:</p>
      <emu-alg>
        1. Return ! OrdinaryOwnPropertyKeys(_O_).
      </emu-alg>

      <emu-clause id="sec-ordinaryownpropertykeys" aoid="OrdinaryOwnPropertyKeys">
        <h1>OrdinaryOwnPropertyKeys ( _O_ )</h1>
        <p>When the abstract operation OrdinaryOwnPropertyKeys is called with Object _O_, the following steps are taken:</p>

        <emu-alg>
          1. Let _keys_ be a new empty List.
          1. For each own property key _P_ of _O_ that is an array index, in ascending numeric index order, do
            1. Add _P_ as the last element of _keys_.
          1. For each own property key _P_ of _O_ that is a String but is not an array index, in ascending chronological order of property creation, do
            1. Add _P_ as the last element of _keys_.
          1. For each own property key _P_ of _O_ that is a Symbol, in ascending chronological order of property creation, do
            1. Add _P_ as the last element of _keys_.
          1. Return _keys_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-objectcreate" aoid="ObjectCreate">
      <h1>ObjectCreate ( _proto_ [ , _internalSlotsList_ ] )</h1>
      <p>The abstract operation ObjectCreate with argument _proto_ (an object or null) is used to specify the runtime creation of new ordinary objects. The optional argument _internalSlotsList_ is a List of the names of additional internal slots that must be defined as part of the object. If the list is not provided, a new empty List is used. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. If _internalSlotsList_ is not present, set _internalSlotsList_ to a new empty List.
        1. Let _obj_ be a newly created object with an internal slot for each name in _internalSlotsList_.
        1. Set _obj_'s essential internal methods to the default ordinary object definitions specified in <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>.
        1. Set _obj_.[[Prototype]] to _proto_.
        1. Set _obj_.[[Extensible]] to *true*.
        1. Return _obj_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-ordinarycreatefromconstructor" aoid="OrdinaryCreateFromConstructor">
      <h1>OrdinaryCreateFromConstructor ( _constructor_, _intrinsicDefaultProto_ [ , _internalSlotsList_ ] )</h1>
      <p>The abstract operation OrdinaryCreateFromConstructor creates an ordinary object whose [[Prototype]] value is retrieved from a constructor's `prototype` property, if it exists. Otherwise the intrinsic named by _intrinsicDefaultProto_ is used for [[Prototype]]. The optional _internalSlotsList_ is a List of the names of additional internal slots that must be defined as part of the object. If the list is not provided, a new empty List is used. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. Assert: _intrinsicDefaultProto_ is a String value that is this specification's name of an intrinsic object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]] value of an object.
        1. Let _proto_ be ? GetPrototypeFromConstructor(_constructor_, _intrinsicDefaultProto_).
        1. Return ObjectCreate(_proto_, _internalSlotsList_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getprototypefromconstructor" aoid="GetPrototypeFromConstructor">
      <h1>GetPrototypeFromConstructor ( _constructor_, _intrinsicDefaultProto_ )</h1>
      <p>The abstract operation GetPrototypeFromConstructor determines the [[Prototype]] value that should be used to create an object corresponding to a specific constructor. The value is retrieved from the constructor's `prototype` property, if it exists. Otherwise the intrinsic named by _intrinsicDefaultProto_ is used for [[Prototype]]. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. Assert: _intrinsicDefaultProto_ is a String value that is this specification's name of an intrinsic object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]] value of an object.
        1. Assert: IsCallable(_constructor_) is *true*.
        1. Let _proto_ be ? Get(_constructor_, `"prototype"`).
        1. If Type(_proto_) is not Object, then
          1. Let _realm_ be ? GetFunctionRealm(_constructor_).
          1. Set _proto_ to _realm_'s intrinsic object named _intrinsicDefaultProto_.
        1. Return _proto_.
      </emu-alg>
      <emu-note>
        <p>If _constructor_ does not supply a [[Prototype]] value, the default value that is used is obtained from the realm of the _constructor_ function rather than from the running execution context.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-requireinternalslot" aoid="RequireInternalSlot">
      <h1>RequireInternalSlot ( _O_, _internalSlot_ )</h1>
      <p>The abstract operation RequireInternalSlot throws an exception unless _O_ is an Object and has the given internal slot.</p>
      <emu-alg>
        1. If Type(_O_) is not Object, throw a *TypeError* exception.
        1. If _O_ does not have an _internalSlot_ internal slot, throw a *TypeError* exception.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-ecmascript-function-objects">
    <h1>ECMAScript Function Objects</h1>
    <p>ECMAScript function objects encapsulate parameterized ECMAScript code closed over a lexical environment and support the dynamic evaluation of that code. An ECMAScript function object is an ordinary object and has the same internal slots and the same internal methods as other ordinary objects. The code of an ECMAScript function object may be either strict mode code (<emu-xref href="#sec-strict-mode-code"></emu-xref>) or non-strict code. An ECMAScript function object whose code is strict mode code is called a <dfn id="strict-function">strict function</dfn>. One whose code is not strict mode code is called a <dfn id="non-strict-function">non-strict function</dfn>.</p>
    <p>ECMAScript function objects have the additional internal slots listed in <emu-xref href="#table-27"></emu-xref>.</p>
    <emu-table id="table-27" caption="Internal Slots of ECMAScript Function Objects">
      <table>
        <tbody>
        <tr>
          <th>
            Internal Slot
          </th>
          <th>
            Type
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td>
            [[Environment]]
          </td>
          <td>
            Lexical Environment
          </td>
          <td>
            The Lexical Environment that the function was closed over. Used as the outer environment when evaluating the code of the function.
          </td>
        </tr>
        <tr>
          <td>
            [[FormalParameters]]
          </td>
          <td>
            Parse Node
          </td>
          <td>
            The root parse node of the source text that defines the function's formal parameter list.
          </td>
        </tr>
        <tr>
          <td>
            [[FunctionKind]]
          </td>
          <td>
            String
          </td>
          <td>
            Either `"normal"`, `"classConstructor"`, `"generator"`, `"async"`, or `"async generator"`.
          </td>
        </tr>
        <tr>
          <td>
            [[ECMAScriptCode]]
          </td>
          <td>
            Parse Node
          </td>
          <td>
            The root parse node of the source text that defines the function's body.
          </td>
        </tr>
        <tr>
          <td>
            [[ConstructorKind]]
          </td>
          <td>
            String
          </td>
          <td>
            Either `"base"` or `"derived"`.
          </td>
        </tr>
        <tr>
          <td>
            [[Realm]]
          </td>
          <td>
            Realm Record
          </td>
          <td>
            The realm in which the function was created and which provides any intrinsic objects that are accessed when evaluating the function.
          </td>
        </tr>
        <tr>
          <td>
            [[ScriptOrModule]]
          </td>
          <td>
            Script Record or Module Record
          </td>
          <td>
            The script or module in which the function was created.
          </td>
        </tr>
        <tr>
          <td>
            [[ThisMode]]
          </td>
          <td>
            (lexical, strict, global)
          </td>
          <td>
            Defines how `this` references are interpreted within the formal parameters and code body of the function. ~lexical~ means that `this` refers to the *this* value of a lexically enclosing function. ~strict~ means that the *this* value is used exactly as provided by an invocation of the function. ~global~ means that a *this* value of *undefined* is interpreted as a reference to the global object.
          </td>
        </tr>
        <tr>
          <td>
            [[Strict]]
          </td>
          <td>
            Boolean
          </td>
          <td>
            *true* if this is a strict function, *false* if this is a non-strict function.
          </td>
        </tr>
        <tr>
          <td>
            [[HomeObject]]
          </td>
          <td>
            Object
          </td>
          <td>
            If the function uses `super`, this is the object whose [[GetPrototypeOf]] provides the object where `super` property lookups begin.
          </td>
        </tr>
        <tr>
          <td>
            [[SourceText]]
          </td>
          <td>
            String
          </td>
          <td>
            The <emu-xref href="#sec-source-text">source text</emu-xref> that defines the function.
          </td>
        </tr>
        </tbody>
      </table>
    </emu-table>
    <p>All ECMAScript function objects have the [[Call]] internal method defined here. ECMAScript functions that are also constructors in addition have the [[Construct]] internal method.</p>

    <emu-clause id="sec-ecmascript-function-objects-call-thisargument-argumentslist">
      <h1>[[Call]] ( _thisArgument_, _argumentsList_ )</h1>
      <p>The [[Call]] internal method for an ECMAScript function object _F_ is called with parameters _thisArgument_ and _argumentsList_, a List of ECMAScript language values. The following steps are taken:</p>
      <emu-alg>
        1. Assert: _F_ is an ECMAScript function object.
        1. If _F_.[[FunctionKind]] is `"classConstructor"`, throw a *TypeError* exception.
        1. Let _callerContext_ be the running execution context.
        1. Let _calleeContext_ be PrepareForOrdinaryCall(_F_, *undefined*).
        1. Assert: _calleeContext_ is now the running execution context.
        1. Perform OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_).
        1. Let _result_ be OrdinaryCallEvaluateBody(_F_, _argumentsList_).
        1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.
        1. If _result_.[[Type]] is ~return~, return NormalCompletion(_result_.[[Value]]).
        1. ReturnIfAbrupt(_result_).
        1. Return NormalCompletion(*undefined*).
      </emu-alg>
      <emu-note>
        <p>When _calleeContext_ is removed from the execution context stack in step 8 it must not be destroyed if it is suspended and retained for later resumption by an accessible generator object.</p>
      </emu-note>

      <emu-clause id="sec-prepareforordinarycall" aoid="PrepareForOrdinaryCall">
        <h1>PrepareForOrdinaryCall ( _F_, _newTarget_ )</h1>
        <p>When the abstract operation PrepareForOrdinaryCall is called with function object _F_ and ECMAScript language value _newTarget_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: Type(_newTarget_) is Undefined or Object.
          1. Let _callerContext_ be the running execution context.
          1. Let _calleeContext_ be a new ECMAScript code execution context.
          1. Set the Function of _calleeContext_ to _F_.
          1. Let _calleeRealm_ be _F_.[[Realm]].
          1. Set the Realm of _calleeContext_ to _calleeRealm_.
          1. Set the ScriptOrModule of _calleeContext_ to _F_.[[ScriptOrModule]].
          1. Let _localEnv_ be NewFunctionEnvironment(_F_, _newTarget_).
          1. Set the LexicalEnvironment of _calleeContext_ to _localEnv_.
          1. Set the VariableEnvironment of _calleeContext_ to _localEnv_.
          1. If _callerContext_ is not already suspended, suspend _callerContext_.
          1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.
          1. NOTE: Any exception objects produced after this point are associated with _calleeRealm_.
          1. Return _calleeContext_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ordinarycallbindthis" aoid="OrdinaryCallBindThis">
        <h1>OrdinaryCallBindThis ( _F_, _calleeContext_, _thisArgument_ )</h1>
        <p>When the abstract operation OrdinaryCallBindThis is called with function object _F_, execution context _calleeContext_, and ECMAScript value _thisArgument_, the following steps are taken:</p>
        <emu-alg>
          1. Let _thisMode_ be _F_.[[ThisMode]].
          1. If _thisMode_ is ~lexical~, return NormalCompletion(*undefined*).
          1. Let _calleeRealm_ be _F_.[[Realm]].
          1. Let _localEnv_ be the LexicalEnvironment of _calleeContext_.
          1. If _thisMode_ is ~strict~, let _thisValue_ be _thisArgument_.
          1. Else,
            1. If _thisArgument_ is *undefined* or *null*, then
              1. Let _globalEnv_ be _calleeRealm_.[[GlobalEnv]].
              1. Let _globalEnvRec_ be _globalEnv_'s EnvironmentRecord.
              1. Assert: _globalEnvRec_ is a global Environment Record.
              1. Let _thisValue_ be _globalEnvRec_.[[GlobalThisValue]].
            1. Else,
              1. Let _thisValue_ be ! ToObject(_thisArgument_).
              1. NOTE: ToObject produces wrapper objects using _calleeRealm_.
          1. Let _envRec_ be _localEnv_'s EnvironmentRecord.
          1. Assert: _envRec_ is a function Environment Record.
          1. Assert: The next step never returns an abrupt completion because _envRec_.[[ThisBindingStatus]] is not `"initialized"`.
          1. Return _envRec_.BindThisValue(_thisValue_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ordinarycallevaluatebody" aoid="OrdinaryCallEvaluateBody">
        <h1>OrdinaryCallEvaluateBody ( _F_, _argumentsList_ )</h1>
        <p>When the abstract operation OrdinaryCallEvaluateBody is called with function object _F_ and List _argumentsList_, the following steps are taken:</p>
        <emu-alg>
          1. Return the result of EvaluateBody of the parsed code that is _F_.[[ECMAScriptCode]] passing _F_ and _argumentsList_ as the arguments.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ecmascript-function-objects-construct-argumentslist-newtarget">
      <h1>[[Construct]] ( _argumentsList_, _newTarget_ )</h1>
      <p>The [[Construct]] internal method for an ECMAScript function object _F_ is called with parameters _argumentsList_ and _newTarget_. _argumentsList_ is a possibly empty List of ECMAScript language values. The following steps are taken:</p>
      <emu-alg>
        1. Assert: _F_ is an ECMAScript function object.
        1. Assert: Type(_newTarget_) is Object.
        1. Let _callerContext_ be the running execution context.
        1. Let _kind_ be _F_.[[ConstructorKind]].
        1. If _kind_ is `"base"`, then
          1. Let _thisArgument_ be ? OrdinaryCreateFromConstructor(_newTarget_, `"%ObjectPrototype%"`).
        1. Let _calleeContext_ be PrepareForOrdinaryCall(_F_, _newTarget_).
        1. Assert: _calleeContext_ is now the running execution context.
        1. If _kind_ is `"base"`, perform OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_).
        1. Let _constructorEnv_ be the LexicalEnvironment of _calleeContext_.
        1. Let _envRec_ be _constructorEnv_'s EnvironmentRecord.
        1. Let _result_ be OrdinaryCallEvaluateBody(_F_, _argumentsList_).
        1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.
        1. If _result_.[[Type]] is ~return~, then
          1. If Type(_result_.[[Value]]) is Object, return NormalCompletion(_result_.[[Value]]).
          1. If _kind_ is `"base"`, return NormalCompletion(_thisArgument_).
          1. If _result_.[[Value]] is not *undefined*, throw a *TypeError* exception.
        1. Else, ReturnIfAbrupt(_result_).
        1. Return ? _envRec_.GetThisBinding().
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-functionallocate" aoid="FunctionAllocate">
      <h1>FunctionAllocate ( _functionPrototype_, _strict_, _functionKind_ )</h1>
      <p>The abstract operation FunctionAllocate requires the three arguments _functionPrototype_, _strict_ and _functionKind_. FunctionAllocate performs the following steps:</p>
      <emu-alg>
        1. Assert: Type(_functionPrototype_) is Object.
        1. Assert: _functionKind_ is either `"normal"`, `"non-constructor"`, `"generator"`, `"async"`, or `"async generator"`.
        1. If _functionKind_ is `"normal"`, let _needsConstruct_ be *true*.
        1. Else, let _needsConstruct_ be *false*.
        1. If _functionKind_ is `"non-constructor"`, set _functionKind_ to `"normal"`.
        1. Let _F_ be a newly created ECMAScript function object with the internal slots listed in <emu-xref href="#table-27"></emu-xref>.
        1. Set _F_'s essential internal methods to the default ordinary object definitions specified in <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>.
        1. Set _F_.[[Call]] to the definition specified in <emu-xref href="#sec-ecmascript-function-objects-call-thisargument-argumentslist"></emu-xref>.
        1. If _needsConstruct_ is *true*, then
          1. Set _F_.[[Construct]] to the definition specified in <emu-xref href="#sec-ecmascript-function-objects-construct-argumentslist-newtarget"></emu-xref>.
          1. Set _F_.[[ConstructorKind]] to `"base"`.
        1. Set _F_.[[Strict]] to _strict_.
        1. Set _F_.[[FunctionKind]] to _functionKind_.
        1. Set _F_.[[Prototype]] to _functionPrototype_.
        1. Set _F_.[[Extensible]] to *true*.
        1. Set _F_.[[Realm]] to the current Realm Record.
        1. Return _F_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-functioninitialize" aoid="FunctionInitialize">
      <h1>FunctionInitialize ( _F_, _kind_, _ParameterList_, _Body_, _Scope_ )</h1>
      <p>The abstract operation FunctionInitialize requires the arguments: a function object _F_, _kind_ which is one of (Normal, Method, Arrow), a parameter list Parse Node specified by _ParameterList_, a body Parse Node specified by _Body_, a Lexical Environment specified by _Scope_. FunctionInitialize performs the following steps:</p>
      <emu-alg>
        1. Let _len_ be the ExpectedArgumentCount of _ParameterList_.
        1. Perform ! SetFunctionLength(_F_, _len_).
        1. Let _Strict_ be _F_.[[Strict]].
        1. Set _F_.[[Environment]] to _Scope_.
        1. Set _F_.[[FormalParameters]] to _ParameterList_.
        1. Set _F_.[[ECMAScriptCode]] to _Body_.
        1. Set _F_.[[ScriptOrModule]] to GetActiveScriptOrModule().
        1. If _kind_ is ~Arrow~, set _F_.[[ThisMode]] to ~lexical~.
        1. Else if _Strict_ is *true*, set _F_.[[ThisMode]] to ~strict~.
        1. Else, set _F_.[[ThisMode]] to ~global~.
        1. Return _F_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-functioncreate" aoid="FunctionCreate">
      <h1>FunctionCreate ( _kind_, _ParameterList_, _Body_, _Scope_, _Strict_ [ , _prototype_ ] )</h1>
      <p>The abstract operation FunctionCreate requires the arguments: _kind_ which is one of (Normal, Method, Arrow), a parameter list Parse Node specified by _ParameterList_, a body Parse Node specified by _Body_, a Lexical Environment specified by _Scope_, a Boolean flag _Strict_, and optionally, an object _prototype_. FunctionCreate performs the following steps:</p>
      <emu-alg>
        1. If _prototype_ is not present, then
          1. Set _prototype_ to the intrinsic object %FunctionPrototype%.
        1. If _kind_ is not ~Normal~, let _allocKind_ be `"non-constructor"`.
        1. Else, let _allocKind_ be `"normal"`.
        1. Let _F_ be FunctionAllocate(_prototype_, _Strict_, _allocKind_).
        1. Return FunctionInitialize(_F_, _kind_, _ParameterList_, _Body_, _Scope_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-generatorfunctioncreate" aoid="GeneratorFunctionCreate">
      <h1>GeneratorFunctionCreate ( _kind_, _ParameterList_, _Body_, _Scope_, _Strict_ )</h1>
      <p>The abstract operation GeneratorFunctionCreate requires the arguments: _kind_ which is one of (Normal, Method), a parameter list Parse Node specified by _ParameterList_, a body Parse Node specified by _Body_, a Lexical Environment specified by _Scope_, and a Boolean flag _Strict_. GeneratorFunctionCreate performs the following steps:</p>
      <emu-alg>
        1. Let _functionPrototype_ be the intrinsic object %Generator%.
        1. Let _F_ be FunctionAllocate(_functionPrototype_, _Strict_, `"generator"`).
        1. Return FunctionInitialize(_F_, _kind_, _ParameterList_, _Body_, _Scope_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-asyncgeneratorfunctioncreate" aoid="AsyncGeneratorFunctionCreate">
      <h1>AsyncGeneratorFunctionCreate ( _kind_, _ParameterList_, _Body_, _Scope_, _Strict_ )</h1>
      <p>The abstract operation AsyncGeneratorFunctionCreate requires the arguments: _kind_ which is one of (~Normal~, ~Method~), a parameter list Parse Node specified by _ParameterList_, a body Parse Node specified by _Body_, a Lexical Environment specified by _Scope_, and a Boolean flag _Strict_. AsyncGeneratorFunctionCreate performs the following steps:</p>
      <emu-alg>
        1. Let _functionPrototype_ be the intrinsic object %AsyncGenerator%.
        1. Let _F_ be ! FunctionAllocate(_functionPrototype_, _Strict_, `"generator"`).
        1. Return ! FunctionInitialize(_F_, _kind_, _ParameterList_, _Body_, _Scope_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-functions-abstract-operations-async-function-create" aoid="AsyncFunctionCreate">
      <h1>AsyncFunctionCreate ( _kind_, _parameters_, _body_, _Scope_, _Strict_ )</h1>
      <p>The abstract operation AsyncFunctionCreate requires the arguments: _kind_ which is one of (~Normal~, ~Method~, ~Arrow~), a parameter list Parse Node specified by _parameters_, a body Parse Node specified by _body_, a Lexical Environment specified by _Scope_, and a Boolean flag _Strict_. AsyncFunctionCreate performs the following steps:</p>
      <emu-alg>
        1. Let _functionPrototype_ be the intrinsic object %AsyncFunctionPrototype%.
        2. Let _F_ be ! FunctionAllocate(_functionPrototype_, _Strict_, `"async"`).
        3. Return ! FunctionInitialize(_F_, _kind_, _parameters_, _body_, _Scope_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-addrestrictedfunctionproperties" aoid="AddRestrictedFunctionProperties">
      <h1>AddRestrictedFunctionProperties ( _F_, _realm_ )</h1>
      <p>The abstract operation AddRestrictedFunctionProperties is called with a function object _F_ and Realm Record _realm_ as its argument. It performs the following steps:</p>
      <emu-alg>
        1. Assert: _realm_.[[Intrinsics]].[[%ThrowTypeError%]] exists and has been initialized.
        1. Let _thrower_ be _realm_.[[Intrinsics]].[[%ThrowTypeError%]].
        1. Perform ! DefinePropertyOrThrow(_F_, `"caller"`, PropertyDescriptor { [[Get]]: _thrower_, [[Set]]: _thrower_, [[Enumerable]]: *false*, [[Configurable]]: *true* }).
        1. Return ! DefinePropertyOrThrow(_F_, `"arguments"`, PropertyDescriptor { [[Get]]: _thrower_, [[Set]]: _thrower_, [[Enumerable]]: *false*, [[Configurable]]: *true* }).
      </emu-alg>

      <emu-clause id="sec-%throwtypeerror%">
        <h1>%ThrowTypeError% ( )</h1>
        <p>The <dfn>%ThrowTypeError%</dfn> intrinsic is an anonymous built-in function object that is defined once for each realm. When %ThrowTypeError% is called it performs the following steps:</p>
        <emu-alg>
          1. Throw a *TypeError* exception.
        </emu-alg>
        <p>The value of the [[Extensible]] internal slot of a %ThrowTypeError% function is *false*.</p>
        <p>The `"length"` property of a %ThrowTypeError% function has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-makeconstructor" aoid="MakeConstructor">
      <h1>MakeConstructor ( _F_ [ , _writablePrototype_ [ , _prototype_ ] ] )</h1>
      <p>The abstract operation MakeConstructor requires a Function argument _F_ and optionally, a Boolean _writablePrototype_ and an object _prototype_. If _prototype_ is provided it is assumed to already contain, if needed, a `"constructor"` property whose value is _F_. This operation converts _F_ into a constructor by performing the following steps:</p>
      <emu-alg>
        1. Assert: _F_ is an ECMAScript function object.
        1. Assert: IsConstructor(_F_) is *true*.
        1. Assert: _F_ is an extensible object that does not have a `prototype` own property.
        1. If _writablePrototype_ is not present, set _writablePrototype_ to *true*.
        1. If _prototype_ is not present, then
          1. Set _prototype_ to ObjectCreate(%ObjectPrototype%).
          1. Perform ! DefinePropertyOrThrow(_prototype_, `"constructor"`, PropertyDescriptor { [[Value]]: _F_, [[Writable]]: _writablePrototype_, [[Enumerable]]: *false*, [[Configurable]]: *true* }).
        1. Perform ! DefinePropertyOrThrow(_F_, `"prototype"`, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: _writablePrototype_, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Return NormalCompletion(*undefined*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-makeclassconstructor" aoid="MakeClassConstructor">
      <h1>MakeClassConstructor ( _F_ )</h1>
      <p>The abstract operation MakeClassConstructor with argument _F_ performs the following steps:</p>
      <emu-alg>
        1. Assert: _F_ is an ECMAScript function object.
        1. Assert: _F_.[[FunctionKind]] is `"normal"`.
        1. Set _F_.[[FunctionKind]] to `"classConstructor"`.
        1. Return NormalCompletion(*undefined*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-makemethod" aoid="MakeMethod">
      <h1>MakeMethod ( _F_, _homeObject_ )</h1>
      <p>The abstract operation MakeMethod with arguments _F_ and _homeObject_ configures _F_ as a method by performing the following steps:</p>
      <emu-alg>
        1. Assert: _F_ is an ECMAScript function object.
        1. Assert: Type(_homeObject_) is Object.
        1. Set _F_.[[HomeObject]] to _homeObject_.
        1. Return NormalCompletion(*undefined*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-setfunctionname" aoid="SetFunctionName">
      <h1>SetFunctionName ( _F_, _name_ [ , _prefix_ ] )</h1>
      <p>The abstract operation SetFunctionName requires a Function argument _F_, a String or Symbol argument _name_ and optionally a String argument _prefix_. This operation adds a `name` property to _F_ by performing the following steps:</p>
      <emu-alg>
        1. Assert: _F_ is an extensible object that does not have a `name` own property.
        1. Assert: Type(_name_) is either Symbol or String.
        1. Assert: If _prefix_ is present, then Type(_prefix_) is String.
        1. If Type(_name_) is Symbol, then
          1. Let _description_ be _name_'s [[Description]] value.
          1. If _description_ is *undefined*, set _name_ to the empty String.
          1. Else, set _name_ to the string-concatenation of `"["`, _description_, and `"]"`.
        1. If _prefix_ is present, then
          1. Set _name_ to the string-concatenation of _prefix_, the code unit 0x0020 (SPACE), and _name_.
        1. Return ! DefinePropertyOrThrow(_F_, `"name"`, PropertyDescriptor { [[Value]]: _name_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-setfunctionlength" aoid="SetFunctionLength">
      <h1>SetFunctionLength ( _F_, _length_ )</h1>
      <p>The abstract operation SetFunctionLength requires a Function argument _F_ and a Number argument _length_. This operation adds a `"length"` property to _F_ by performing the following steps:</p>
      <emu-alg>
        1. Assert: _F_ is an extensible object that does not have a `"length"` own property.
        1. Assert: Type(_length_) is Number.
        1. Assert: _length_  0 and ! ToInteger(_length_) is equal to _length_.
        1. Return ! DefinePropertyOrThrow(_F_, `"length"`, PropertyDescriptor { [[Value]]: _length_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-functiondeclarationinstantiation" aoid="FunctionDeclarationInstantiation">
      <h1>FunctionDeclarationInstantiation ( _func_, _argumentsList_ )</h1>
      <emu-note>
        <p>When an execution context is established for evaluating an ECMAScript function a new function Environment Record is created and bindings for each formal parameter are instantiated in that Environment Record. Each declaration in the function body is also instantiated. If the function's formal parameters do not include any default value initializers then the body declarations are instantiated in the same Environment Record as the parameters. If default value parameter initializers exist, a second Environment Record is created for the body declarations. Formal parameters and functions are initialized as part of FunctionDeclarationInstantiation. All other bindings are initialized during evaluation of the function body.</p>
      </emu-note>
      <p>FunctionDeclarationInstantiation is performed as follows using arguments _func_ and _argumentsList_. _func_ is the function object for which the execution context is being established.</p>
      <!--
        WARNING: If you add, remove, rename, or repurpose any variable names
                 within this algorithm, you may need to update
                 #sec-web-compat-functiondeclarationinstantiation accordingly.
      -->
      <emu-alg>
        1. Let _calleeContext_ be the running execution context.
        1. Let _env_ be the LexicalEnvironment of _calleeContext_.
        1. Let _envRec_ be _env_'s EnvironmentRecord.
        1. Let _code_ be _func_.[[ECMAScriptCode]].
        1. Let _strict_ be _func_.[[Strict]].
        1. Let _formals_ be _func_.[[FormalParameters]].
        1. Let _parameterNames_ be the BoundNames of _formals_.
        1. If _parameterNames_ has any duplicate entries, let _hasDuplicates_ be *true*. Otherwise, let _hasDuplicates_ be *false*.
        1. Let _simpleParameterList_ be IsSimpleParameterList of _formals_.
        1. Let _hasParameterExpressions_ be ContainsExpression of _formals_.
        1. Let _varNames_ be the VarDeclaredNames of _code_.
        1. Let _varDeclarations_ be the VarScopedDeclarations of _code_.
        1. Let _lexicalNames_ be the LexicallyDeclaredNames of _code_.
        1. Let _functionNames_ be a new empty List.
        1. Let _functionsToInitialize_ be a new empty List.
        1. For each _d_ in _varDeclarations_, in reverse list order, do
          1. If _d_ is neither a |VariableDeclaration| nor a |ForBinding| nor a |BindingIdentifier|, then
            1. Assert: _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|.
            1. Let _fn_ be the sole element of the BoundNames of _d_.
            1. If _fn_ is not an element of _functionNames_, then
              1. Insert _fn_ as the first element of _functionNames_.
              1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.
              1. Insert _d_ as the first element of _functionsToInitialize_.
        1. Let _argumentsObjectNeeded_ be *true*.
        1. If _func_.[[ThisMode]] is ~lexical~, then
          1. NOTE: Arrow functions never have an arguments objects.
          1. Set _argumentsObjectNeeded_ to *false*.
        1. Else if `"arguments"` is an element of _parameterNames_, then
          1. Set _argumentsObjectNeeded_ to *false*.
        1. Else if _hasParameterExpressions_ is *false*, then
          1. If `"arguments"` is an element of _functionNames_ or if `"arguments"` is an element of _lexicalNames_, then
            1. Set _argumentsObjectNeeded_ to *false*.
        1. For each String _paramName_ in _parameterNames_, do
          1. Let _alreadyDeclared_ be _envRec_.HasBinding(_paramName_).
          1. NOTE: Early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters.
          1. If _alreadyDeclared_ is *false*, then
            1. Perform ! _envRec_.CreateMutableBinding(_paramName_, *false*).
            1. If _hasDuplicates_ is *true*, then
              1. Perform ! _envRec_.InitializeBinding(_paramName_, *undefined*).
        1. If _argumentsObjectNeeded_ is *true*, then
          1. If _strict_ is *true* or if _simpleParameterList_ is *false*, then
            1. Let _ao_ be CreateUnmappedArgumentsObject(_argumentsList_).
          1. Else,
            1. NOTE: mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters.
            1. Let _ao_ be CreateMappedArgumentsObject(_func_, _formals_, _argumentsList_, _envRec_).
          1. If _strict_ is *true*, then
            1. Perform ! _envRec_.CreateImmutableBinding(`"arguments"`, *false*).
          1. Else,
            1. Perform ! _envRec_.CreateMutableBinding(`"arguments"`, *false*).
          1. Call _envRec_.InitializeBinding(`"arguments"`, _ao_).
          1. Let _parameterBindings_ be a new List of _parameterNames_ with `"arguments"` appended.
        1. Else,
          1. Let _parameterBindings_ be _parameterNames_.
        1. Let _iteratorRecord_ be CreateListIteratorRecord(_argumentsList_).
        1. If _hasDuplicates_ is *true*, then
          1. Perform ? IteratorBindingInitialization for _formals_ with _iteratorRecord_ and *undefined* as arguments.
        1. Else,
          1. Perform ? IteratorBindingInitialization for _formals_ with _iteratorRecord_ and _env_ as arguments.
        1. If _hasParameterExpressions_ is *false*, then
          1. NOTE: Only a single lexical environment is needed for the parameters and top-level vars.
          1. Let _instantiatedVarNames_ be a copy of the List _parameterBindings_.
          1. For each _n_ in _varNames_, do
            1. If _n_ is not an element of _instantiatedVarNames_, then
              1. Append _n_ to _instantiatedVarNames_.
              1. Perform ! _envRec_.CreateMutableBinding(_n_, *false*).
              1. Call _envRec_.InitializeBinding(_n_, *undefined*).
          1. Let _varEnv_ be _env_.
          1. Let _varEnvRec_ be _envRec_.
        1. Else,
          1. NOTE: A separate Environment Record is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body.
          1. Let _varEnv_ be NewDeclarativeEnvironment(_env_).
          1. Let _varEnvRec_ be _varEnv_'s EnvironmentRecord.
          1. Set the VariableEnvironment of _calleeContext_ to _varEnv_.
          1. Let _instantiatedVarNames_ be a new empty List.
          1. For each _n_ in _varNames_, do
            1. If _n_ is not an element of _instantiatedVarNames_, then
              1. Append _n_ to _instantiatedVarNames_.
              1. Perform ! _varEnvRec_.CreateMutableBinding(_n_, *false*).
              1. If _n_ is not an element of _parameterBindings_ or if _n_ is an element of _functionNames_, let _initialValue_ be *undefined*.
              1. Else,
                1. Let _initialValue_ be ! _envRec_.GetBindingValue(_n_, *false*).
              1. Call _varEnvRec_.InitializeBinding(_n_, _initialValue_).
              1. NOTE: vars whose names are the same as a formal parameter, initially have the same value as the corresponding initialized parameter.
        1. NOTE: Annex <emu-xref href="#sec-web-compat-functiondeclarationinstantiation"></emu-xref> adds additional steps at this point.
        1. If _strict_ is *false*, then
          1. Let _lexEnv_ be NewDeclarativeEnvironment(_varEnv_).
          1. NOTE: Non-strict functions use a separate lexical Environment Record for top-level lexical declarations so that a direct eval can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. This is not needed for strict functions because a strict direct eval always places all declarations into a new Environment Record.
        1. Else, let _lexEnv_ be _varEnv_.
        1. Let _lexEnvRec_ be _lexEnv_'s EnvironmentRecord.
        1. Set the LexicalEnvironment of _calleeContext_ to _lexEnv_.
        1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _code_.
        1. For each element _d_ in _lexDeclarations_, do
          1. NOTE: A lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. Lexically declared names are only instantiated here but not initialized.
          1. For each element _dn_ of the BoundNames of _d_, do
            1. If IsConstantDeclaration of _d_ is *true*, then
              1. Perform ! _lexEnvRec_.CreateImmutableBinding(_dn_, *true*).
            1. Else,
              1. Perform ! _lexEnvRec_.CreateMutableBinding(_dn_, *false*).
        1. For each Parse Node _f_ in _functionsToInitialize_, do
          1. Let _fn_ be the sole element of the BoundNames of _f_.
          1. Let _fo_ be the result of performing InstantiateFunctionObject for _f_ with argument _lexEnv_.
          1. Perform ! _varEnvRec_.SetMutableBinding(_fn_, _fo_, *false*).
        1. Return NormalCompletion(~empty~).
      </emu-alg>
      <emu-note>
        <p><emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics"></emu-xref> provides an extension to the above algorithm that is necessary for backwards compatibility with web browser implementations of ECMAScript that predate ECMAScript 2015.</p>
      </emu-note>
      <emu-note>
        <p>Parameter |Initializer|s may contain direct eval expressions. Any top level declarations of such evals are only visible to the eval code (<emu-xref href="#sec-types-of-source-code"></emu-xref>). The creation of the environment for such declarations is described in <emu-xref href="#sec-function-definitions-runtime-semantics-iteratorbindinginitialization"></emu-xref>.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-built-in-function-objects">
    <h1>Built-in Function Objects</h1>
    <p>The built-in function objects defined in this specification may be implemented as either ECMAScript function objects (<emu-xref href="#sec-ecmascript-function-objects"></emu-xref>) whose behaviour is provided using ECMAScript code or as implementation provided function exotic objects whose behaviour is provided in some other manner. In either case, the effect of calling such functions must conform to their specifications. An implementation may also provide additional built-in function objects that are not defined in this specification.</p>
    <p>If a built-in function object is implemented as an exotic object it must have the ordinary object behaviour specified in <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>. All such function exotic objects also have [[Prototype]], [[Extensible]], [[Realm]], and [[ScriptOrModule]] internal slots.</p>
    <p>Unless otherwise specified every built-in function object has the %FunctionPrototype% object as the initial value of its [[Prototype]] internal slot.</p>
    <p>The behaviour specified for each built-in function via algorithm steps or other means is the specification of the function body behaviour for both [[Call]] and [[Construct]] invocations of the function. However, [[Construct]] invocation is not supported by all built-in functions. For each built-in function, when invoked with [[Call]], the [[Call]] _thisArgument_ provides the *this* value, the [[Call]] _argumentsList_ provides the named parameters, and the NewTarget value is *undefined*. When invoked with [[Construct]], the *this* value is uninitialized, the [[Construct]] _argumentsList_ provides the named parameters, and the [[Construct]] _newTarget_ parameter provides the NewTarget value. If the built-in function is implemented as an ECMAScript function object then this specified behaviour must be implemented by the ECMAScript code that is the body of the function. Built-in functions that are ECMAScript function objects must be strict functions. If a built-in constructor has any [[Call]] behaviour other than throwing a *TypeError* exception, an ECMAScript implementation of the function must be done in a manner that does not cause the function's [[FunctionKind]] internal slot to have the value `"classConstructor"`.</p>
    <p>Built-in function objects that are not identified as constructors do not implement the [[Construct]] internal method unless otherwise specified in the description of a particular function. When a built-in constructor is called as part of a `new` expression the _argumentsList_ parameter of the invoked [[Construct]] internal method provides the values for the built-in constructor's named parameters.</p>
    <p>Built-in functions that are not constructors do not have a `prototype` property unless otherwise specified in the description of a particular function.</p>
    <p>If a built-in function object is not implemented as an ECMAScript function it must provide [[Call]] and [[Construct]] internal methods that conform to the following definitions:</p>

    <emu-clause id="sec-built-in-function-objects-call-thisargument-argumentslist">
      <h1>[[Call]] ( _thisArgument_, _argumentsList_ )</h1>
      <p>The [[Call]] internal method for a built-in function object _F_ is called with parameters _thisArgument_ and _argumentsList_, a List of ECMAScript language values. The following steps are taken:</p>
      <emu-alg>
        1. Let _callerContext_ be the running execution context.
        1. If _callerContext_ is not already suspended, suspend _callerContext_.
        1. Let _calleeContext_ be a new ECMAScript code execution context.
        1. Set the Function of _calleeContext_ to _F_.
        1. Let _calleeRealm_ be _F_.[[Realm]].
        1. Set the Realm of _calleeContext_ to _calleeRealm_.
        1. Set the ScriptOrModule of _calleeContext_ to _F_.[[ScriptOrModule]].
        1. Perform any necessary implementation-defined initialization of _calleeContext_.
        1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.
        1. Let _result_ be the Completion Record that is the result of evaluating _F_ in an implementation-defined manner that conforms to the specification of _F_. _thisArgument_ is the *this* value, _argumentsList_ provides the named parameters, and the NewTarget value is *undefined*.
        1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.
        1. Return _result_.
      </emu-alg>
      <emu-note>
        <p>When _calleeContext_ is removed from the execution context stack it must not be destroyed if it has been suspended and retained by an accessible generator object for later resumption.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-built-in-function-objects-construct-argumentslist-newtarget">
      <h1>[[Construct]] ( _argumentsList_, _newTarget_ )</h1>
      <p>The [[Construct]] internal method for built-in function object _F_ is called with parameters _argumentsList_ and _newTarget_. The steps performed are the same as [[Call]] (see <emu-xref href="#sec-built-in-function-objects-call-thisargument-argumentslist"></emu-xref>) except that step 10 is replaced by:</p>
      <emu-alg>
        10. Let _result_ be the Completion Record that is the result of evaluating _F_ in an implementation-defined manner that conforms to the specification of _F_. The *this* value is uninitialized, _argumentsList_ provides the named parameters, and _newTarget_ provides the NewTarget value.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createbuiltinfunction" aoid="CreateBuiltinFunction">
      <h1>CreateBuiltinFunction ( _steps_, _internalSlotsList_ [ , _realm_ [ , _prototype_ ] ] )</h1>
      <p>The abstract operation CreateBuiltinFunction takes arguments _steps_, _internalSlotsList_, _realm_, and _prototype_. The argument _internalSlotsList_ is a List of the names of additional internal slots that must be defined as part of the object. CreateBuiltinFunction returns a built-in function object created by the following steps:</p>
      <emu-alg>
        1. Assert: _steps_ is either a set of algorithm steps or other definition of a function's behaviour provided in this specification.
        1. If _realm_ is not present, set _realm_ to the current Realm Record.
        1. Assert: _realm_ is a Realm Record.
        1. If _prototype_ is not present, set _prototype_ to _realm_.[[Intrinsics]].[[%FunctionPrototype%]].
        1. Let _func_ be a new built-in function object that when called performs the action described by _steps_. The new function object has internal slots whose names are the elements of _internalSlotsList_.
        1. Set _func_.[[Realm]] to _realm_.
        1. Set _func_.[[Prototype]] to _prototype_.
        1. Set _func_.[[Extensible]] to *true*.
        1. Set _func_.[[ScriptOrModule]] to *null*.
        1. Return _func_.
      </emu-alg>
      <p>Each built-in function defined in this specification is created by calling the CreateBuiltinFunction abstract operation.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-built-in-exotic-object-internal-methods-and-slots">
    <h1>Built-in Exotic Object Internal Methods and Slots</h1>
    <p>This specification defines several kinds of built-in exotic objects. These objects generally behave similar to ordinary objects except for a few specific situations. The following exotic objects use the ordinary object internal methods except where it is explicitly specified otherwise below:</p>

    <emu-clause id="sec-bound-function-exotic-objects">
      <h1>Bound Function Exotic Objects</h1>
      <p>A <dfn>bound function</dfn> is an exotic object that wraps another function object. A bound function is callable (it has a [[Call]] internal method and may have a [[Construct]] internal method). Calling a bound function generally results in a call of its wrapped function.</p>
      <p>Bound function objects do not have the internal slots of ECMAScript function objects defined in <emu-xref href="#table-27"></emu-xref>. Instead they have the internal slots defined in <emu-xref href="#table-28"></emu-xref>.</p>
      <emu-table id="table-28" caption="Internal Slots of Bound Function Exotic Objects">
        <table>
          <tbody>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Type
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[BoundTargetFunction]]
            </td>
            <td>
              Callable Object
            </td>
            <td>
              The wrapped function object.
            </td>
          </tr>
          <tr>
            <td>
              [[BoundThis]]
            </td>
            <td>
              Any
            </td>
            <td>
              The value that is always passed as the *this* value when calling the wrapped function.
            </td>
          </tr>
          <tr>
            <td>
              [[BoundArguments]]
            </td>
            <td>
              List of Any
            </td>
            <td>
              A list of values whose elements are used as the first arguments to any call to the wrapped function.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
      <p>Bound function objects provide all of the essential internal methods as specified in <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>. However, they use the following definitions for the essential internal methods of function objects.</p>

      <emu-clause id="sec-bound-function-exotic-objects-call-thisargument-argumentslist">
        <h1>[[Call]] ( _thisArgument_, _argumentsList_ )</h1>
        <p>When the [[Call]] internal method of a bound function exotic object, _F_, which was created using the bind function is called with parameters _thisArgument_ and _argumentsList_, a List of ECMAScript language values, the following steps are taken:</p>
        <emu-alg>
          1. Let _target_ be _F_.[[BoundTargetFunction]].
          1. Let _boundThis_ be _F_.[[BoundThis]].
          1. Let _boundArgs_ be _F_.[[BoundArguments]].
          1. Let _args_ be a new list containing the same values as the list _boundArgs_ in the same order followed by the same values as the list _argumentsList_ in the same order.
          1. Return ? Call(_target_, _boundThis_, _args_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bound-function-exotic-objects-construct-argumentslist-newtarget">
        <h1>[[Construct]] ( _argumentsList_, _newTarget_ )</h1>
        <p>When the [[Construct]] internal method of a bound function exotic object, _F_ that was created using the bind function is called with a list of arguments _argumentsList_ and _newTarget_, the following steps are taken:</p>
        <emu-alg>
          1. Let _target_ be _F_.[[BoundTargetFunction]].
          1. Assert: IsConstructor(_target_) is *true*.
          1. Let _boundArgs_ be _F_.[[BoundArguments]].
          1. Let _args_ be a new list containing the same values as the list _boundArgs_ in the same order followed by the same values as the list _argumentsList_ in the same order.
          1. If SameValue(_F_, _newTarget_) is *true*, set _newTarget_ to _target_.
          1. Return ? Construct(_target_, _args_, _newTarget_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-boundfunctioncreate" aoid="BoundFunctionCreate">
        <h1>BoundFunctionCreate ( _targetFunction_, _boundThis_, _boundArgs_ )</h1>
        <p>The abstract operation BoundFunctionCreate with arguments _targetFunction_, _boundThis_ and _boundArgs_ is used to specify the creation of new Bound Function exotic objects. It performs the following steps:</p>
        <emu-alg>
          1. Assert: Type(_targetFunction_) is Object.
          1. Let _proto_ be ? _targetFunction_.[[GetPrototypeOf]]().
          1. Let _obj_ be a newly created bound function exotic object with the internal slots listed in <emu-xref href="#table-28"></emu-xref>.
          1. Set _obj_'s essential internal methods to the default ordinary object definitions specified in <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>.
          1. Set _obj_.[[Call]] as described in <emu-xref href="#sec-bound-function-exotic-objects-call-thisargument-argumentslist"></emu-xref>.
          1. If IsConstructor(_targetFunction_) is *true*, then
            1. Set _obj_.[[Construct]] as described in <emu-xref href="#sec-bound-function-exotic-objects-construct-argumentslist-newtarget"></emu-xref>.
          1. Set _obj_.[[Prototype]] to _proto_.
          1. Set _obj_.[[Extensible]] to *true*.
          1. Set _obj_.[[BoundTargetFunction]] to _targetFunction_.
          1. Set _obj_.[[BoundThis]] to _boundThis_.
          1. Set _obj_.[[BoundArguments]] to _boundArgs_.
          1. Return _obj_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-array-exotic-objects">
      <h1>Array Exotic Objects</h1>
      <p>An <em>Array object</em> is an exotic object that gives special treatment to array index property keys (see <emu-xref href="#sec-object-type"></emu-xref>). A property whose property name is an array index is also called an <em>element</em>. Every Array object has a non-configurable `"length"` property whose value is always a nonnegative integer less than 2<sup>32</sup>. The value of the `"length"` property is numerically greater than the name of every own property whose name is an array index; whenever an own property of an Array object is created or changed, other properties are adjusted as necessary to maintain this invariant. Specifically, whenever an own property is added whose name is an array index, the value of the `"length"` property is changed, if necessary, to be one more than the numeric value of that array index; and whenever the value of the `"length"` property is changed, every own property whose name is an array index whose value is not smaller than the new length is deleted. This constraint applies only to own properties of an Array object and is unaffected by `"length"` or array index properties that may be inherited from its prototypes.</p>
      <emu-note>
        <p>A String property name _P_ is an <em>array index</em> if and only if ToString(ToUint32(_P_)) is equal to _P_ and ToUint32(_P_) is not equal to <emu-eqn>2<sup>32</sup> - 1</emu-eqn>.</p>
      </emu-note>
      <p>Array exotic objects provide an alternative definition for the [[DefineOwnProperty]] internal method. Except for that internal method, Array exotic objects provide all of the other essential internal methods as specified in <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>.</p>

      <emu-clause id="sec-array-exotic-objects-defineownproperty-p-desc">
        <h1>[[DefineOwnProperty]] ( _P_, _Desc_ )</h1>
        <p>When the [[DefineOwnProperty]] internal method of an Array exotic object _A_ is called with property key _P_, and Property Descriptor _Desc_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: IsPropertyKey(_P_) is *true*.
          1. If _P_ is `"length"`, then
            1. Return ? ArraySetLength(_A_, _Desc_).
          1. Else if _P_ is an array index, then
            1. Let _oldLenDesc_ be OrdinaryGetOwnProperty(_A_, `"length"`).
            1. Assert: _oldLenDesc_ will never be *undefined* or an accessor descriptor because Array objects are created with a length data property that cannot be deleted or reconfigured.
            1. Let _oldLen_ be _oldLenDesc_.[[Value]].
            1. Let _index_ be ! ToUint32(_P_).
            1. If _index_ &ge; _oldLen_ and _oldLenDesc_.[[Writable]] is *false*, return *false*.
            1. Let _succeeded_ be ! OrdinaryDefineOwnProperty(_A_, _P_, _Desc_).
            1. If _succeeded_ is *false*, return *false*.
            1. If _index_ &ge; _oldLen_, then
              1. Set _oldLenDesc_.[[Value]] to _index_ + 1.
              1. Let _succeeded_ be OrdinaryDefineOwnProperty(_A_, `"length"`, _oldLenDesc_).
              1. Assert: _succeeded_ is *true*.
            1. Return *true*.
          1. Return OrdinaryDefineOwnProperty(_A_, _P_, _Desc_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraycreate" aoid="ArrayCreate">
        <h1>ArrayCreate ( _length_ [ , _proto_ ] )</h1>
        <p>The abstract operation ArrayCreate with argument _length_ (either 0 or a positive integer) and optional argument _proto_ is used to specify the creation of new Array exotic objects. It performs the following steps:</p>
        <emu-alg>
          1. Assert: _length_ is an integer Number &ge; 0.
          1. If _length_ is *-0*, set _length_ to *+0*.
          1. If _length_ &gt; 2<sup>32</sup> - 1, throw a *RangeError* exception.
          1. If _proto_ is not present, set _proto_ to the intrinsic object %ArrayPrototype%.
          1. Let _A_ be a newly created Array exotic object.
          1. Set _A_'s essential internal methods except for [[DefineOwnProperty]] to the default ordinary object definitions specified in <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>.
          1. Set _A_.[[DefineOwnProperty]] as specified in <emu-xref href="#sec-array-exotic-objects-defineownproperty-p-desc"></emu-xref>.
          1. Set _A_.[[Prototype]] to _proto_.
          1. Set _A_.[[Extensible]] to *true*.
          1. Perform ! OrdinaryDefineOwnProperty(_A_, `"length"`, PropertyDescriptor { [[Value]]: _length_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
          1. Return _A_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arrayspeciescreate" aoid="ArraySpeciesCreate">
        <h1>ArraySpeciesCreate ( _originalArray_, _length_ )</h1>
        <p>The abstract operation ArraySpeciesCreate with arguments _originalArray_ and _length_ is used to specify the creation of a new Array object using a constructor function that is derived from _originalArray_. It performs the following steps:</p>
        <emu-alg>
          1. Assert: _length_ is an integer Number &ge; 0.
          1. If _length_ is *-0*, set _length_ to *+0*.
          1. Let _isArray_ be ? IsArray(_originalArray_).
          1. If _isArray_ is *false*, return ? ArrayCreate(_length_).
          1. Let _C_ be ? Get(_originalArray_, `"constructor"`).
          1. If IsConstructor(_C_) is *true*, then
            1. Let _thisRealm_ be the current Realm Record.
            1. Let _realmC_ be ? GetFunctionRealm(_C_).
            1. If _thisRealm_ and _realmC_ are not the same Realm Record, then
              1. If SameValue(_C_, _realmC_.[[Intrinsics]].[[%Array%]]) is *true*, set _C_ to *undefined*.
          1. If Type(_C_) is Object, then
            1. Set _C_ to ? Get(_C_, @@species).
            1. If _C_ is *null*, set _C_ to *undefined*.
          1. If _C_ is *undefined*, return ? ArrayCreate(_length_).
          1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.
          1. Return ? Construct(_C_, &laquo; _length_ &raquo;).
        </emu-alg>
        <emu-note>
          <p>If _originalArray_ was created using the standard built-in Array constructor for a realm that is not the realm of the running execution context, then a new Array is created using the realm of the running execution context. This maintains compatibility with Web browsers that have historically had that behaviour for the Array.prototype methods that now are defined using ArraySpeciesCreate.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-arraysetlength" aoid="ArraySetLength">
        <h1>ArraySetLength ( _A_, _Desc_ )</h1>
        <p>When the abstract operation ArraySetLength is called with an Array exotic object _A_, and Property Descriptor _Desc_, the following steps are taken:</p>
        <emu-alg>
          1. If _Desc_.[[Value]] is absent, then
            1. Return OrdinaryDefineOwnProperty(_A_, `"length"`, _Desc_).
          1. Let _newLenDesc_ be a copy of _Desc_.
          1. Let _newLen_ be ? ToUint32(_Desc_.[[Value]]).
          1. Let _numberLen_ be ? ToNumber(_Desc_.[[Value]]).
          1. If _newLen_ &ne; _numberLen_, throw a *RangeError* exception.
          1. Set _newLenDesc_.[[Value]] to _newLen_.
          1. Let _oldLenDesc_ be OrdinaryGetOwnProperty(_A_, `"length"`).
          1. Assert: _oldLenDesc_ will never be *undefined* or an accessor descriptor because Array objects are created with a length data property that cannot be deleted or reconfigured.
          1. Let _oldLen_ be _oldLenDesc_.[[Value]].
          1. If _newLen_ &ge; _oldLen_, then
            1. Return OrdinaryDefineOwnProperty(_A_, `"length"`, _newLenDesc_).
          1. If _oldLenDesc_.[[Writable]] is *false*, return *false*.
          1. If _newLenDesc_.[[Writable]] is absent or has the value *true*, let _newWritable_ be *true*.
          1. Else,
            1. Need to defer setting the [[Writable]] attribute to *false* in case any elements cannot be deleted.
            1. Let _newWritable_ be *false*.
            1. Set _newLenDesc_.[[Writable]] to *true*.
          1. Let _succeeded_ be ! OrdinaryDefineOwnProperty(_A_, `"length"`, _newLenDesc_).
          1. If _succeeded_ is *false*, return *false*.
          1. Repeat, while _newLen_ &lt; _oldLen_,
            1. Decrease _oldLen_ by 1.
            1. Let _deleteSucceeded_ be ! _A_.[[Delete]](! ToString(_oldLen_)).
            1. If _deleteSucceeded_ is *false*, then
              1. Set _newLenDesc_.[[Value]] to _oldLen_ + 1.
              1. If _newWritable_ is *false*, set _newLenDesc_.[[Writable]] to *false*.
              1. Perform ! OrdinaryDefineOwnProperty(_A_, `"length"`, _newLenDesc_).
              1. Return *false*.
          1. If _newWritable_ is *false*, then
            1. Return OrdinaryDefineOwnProperty(_A_, `"length"`, PropertyDescriptor { [[Writable]]: *false* }). This call will always return *true*.
          1. Return *true*.
        </emu-alg>
        <emu-note>
          <p>In steps 3 and 4, if _Desc_.[[Value]] is an object then its `valueOf` method is called twice. This is legacy behaviour that was specified with this effect starting with the 2<sup>nd</sup> Edition of this specification.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-string-exotic-objects">
      <h1>String Exotic Objects</h1>
      <p>A <em>String object</em> is an exotic object that encapsulates a String value and exposes virtual integer-indexed data properties corresponding to the individual code unit elements of the String value. String exotic objects always have a data property named `"length"` whose value is the number of code unit elements in the encapsulated String value. Both the code unit data properties and the `"length"` property are non-writable and non-configurable.</p>
      <p>String exotic objects have the same internal slots as ordinary objects. They also have a [[StringData]] internal slot.</p>
      <p>String exotic objects provide alternative definitions for the following internal methods. All of the other String exotic object essential internal methods that are not defined below are as specified in <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>.</p>

      <emu-clause id="sec-string-exotic-objects-getownproperty-p">
        <h1>[[GetOwnProperty]] ( _P_ )</h1>
        <p>When the [[GetOwnProperty]] internal method of a String exotic object _S_ is called with property key _P_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: IsPropertyKey(_P_) is *true*.
          1. Let _desc_ be OrdinaryGetOwnProperty(_S_, _P_).
          1. If _desc_ is not *undefined*, return _desc_.
          1. Return ! StringGetOwnProperty(_S_, _P_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string-exotic-objects-defineownproperty-p-desc">
        <h1>[[DefineOwnProperty]] ( _P_, _Desc_ )</h1>
        <p>When the [[DefineOwnProperty]] internal method of a String exotic object _S_ is called with property key _P_, and Property Descriptor _Desc_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: IsPropertyKey(_P_) is *true*.
          1. Let _stringDesc_ be ! StringGetOwnProperty(_S_, _P_).
          1. If _stringDesc_ is not *undefined*, then
            1. Let _extensible_ be _S_.[[Extensible]].
            1. Return ! IsCompatiblePropertyDescriptor(_extensible_, _Desc_, _stringDesc_).
          1. Return ! OrdinaryDefineOwnProperty(_S_, _P_, _Desc_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string-exotic-objects-ownpropertykeys">
        <h1>[[OwnPropertyKeys]] ( )</h1>
        <p>When the [[OwnPropertyKeys]] internal method of a String exotic object _O_ is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _keys_ be a new empty List.
          1. Let _str_ be _O_.[[StringData]].
          1. Assert: Type(_str_) is String.
          1. Let _len_ be the length of _str_.
          1. For each integer _i_ starting with 0 such that _i_ &lt; _len_, in ascending order, do
            1. Add ! ToString(_i_) as the last element of _keys_.
          1. For each own property key _P_ of _O_ such that _P_ is an array index and ToInteger(_P_) &ge; _len_, in ascending numeric index order, do
            1. Add _P_ as the last element of _keys_.
          1. For each own property key _P_ of _O_ such that Type(_P_) is String and _P_ is not an array index, in ascending chronological order of property creation, do
            1. Add _P_ as the last element of _keys_.
          1. For each own property key _P_ of _O_ such that Type(_P_) is Symbol, in ascending chronological order of property creation, do
            1. Add _P_ as the last element of _keys_.
          1. Return _keys_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-stringcreate" aoid="StringCreate">
        <h1>StringCreate ( _value_, _prototype_ )</h1>
        <p>The abstract operation StringCreate with arguments _value_ and _prototype_ is used to specify the creation of new String exotic objects. It performs the following steps:</p>
        <emu-alg>
          1. Assert: Type(_value_) is String.
          1. Let _S_ be a newly created String exotic object with a [[StringData]] internal slot.
          1. Set _S_.[[StringData]] to _value_.
          1. Set _S_'s essential internal methods to the default ordinary object definitions specified in <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>.
          1. Set _S_.[[GetOwnProperty]] as specified in <emu-xref href="#sec-string-exotic-objects-getownproperty-p"></emu-xref>.
          1. Set _S_.[[DefineOwnProperty]] as specified in <emu-xref href="#sec-string-exotic-objects-defineownproperty-p-desc"></emu-xref>.
          1. Set _S_.[[OwnPropertyKeys]] as specified in <emu-xref href="#sec-string-exotic-objects-ownpropertykeys"></emu-xref>.
          1. Set _S_.[[Prototype]] to _prototype_.
          1. Set _S_.[[Extensible]] to *true*.
          1. Let _length_ be the number of code unit elements in _value_.
          1. Perform ! DefinePropertyOrThrow(_S_, `"length"`, PropertyDescriptor { [[Value]]: _length_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
          1. Return _S_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-stringgetownproperty" aoid="StringGetOwnProperty">
        <h1>StringGetOwnProperty ( _S_, _P_ )</h1>
        <p>The abstract operation StringGetOwnProperty called with arguments _S_ and _P_ performs the following steps:</p>
        <emu-alg>
          1. Assert: _S_ is an Object that has a [[StringData]] internal slot.
          1. Assert: IsPropertyKey(_P_) is *true*.
          1. If Type(_P_) is not String, return *undefined*.
          1. Let _index_ be ! CanonicalNumericIndexString(_P_).
          1. If _index_ is *undefined*, return *undefined*.
          1. If IsInteger(_index_) is *false*, return *undefined*.
          1. If _index_ = *-0*, return *undefined*.
          1. Let _str_ be _S_.[[StringData]].
          1. Assert: Type(_str_) is String.
          1. Let _len_ be the length of _str_.
          1. If _index_ &lt; 0 or _len_ &le; _index_, return *undefined*.
          1. Let _resultStr_ be the String value of length 1, containing one code unit from _str_, specifically the code unit at index _index_.
          1. Return a PropertyDescriptor { [[Value]]: _resultStr_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* }.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-arguments-exotic-objects">
      <h1>Arguments Exotic Objects</h1>
      <p>Most ECMAScript functions make an arguments object available to their code. Depending upon the characteristics of the function definition, its arguments object is either an ordinary object or an <em>arguments exotic object</em>. An arguments exotic object is an exotic object whose array index properties map to the formal parameters bindings of an invocation of its associated ECMAScript function.</p>
      <p>Arguments exotic objects have the same internal slots as ordinary objects. They also have a [[ParameterMap]] internal slot. Ordinary arguments objects also have a [[ParameterMap]] internal slot whose value is always undefined. For ordinary argument objects the [[ParameterMap]] internal slot is only used by `Object.prototype.toString` (<emu-xref href="#sec-object.prototype.tostring"></emu-xref>) to identify them as such.</p>
      <p>Arguments exotic objects provide alternative definitions for the following internal methods. All of the other arguments exotic object essential internal methods that are not defined below are as specified in <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref></p>
      <emu-note>
        <p>The integer-indexed data properties of an arguments exotic object whose numeric name values are less than the number of formal parameters of the corresponding function object initially share their values with the corresponding argument bindings in the function's execution context. This means that changing the property changes the corresponding value of the argument binding and vice-versa. This correspondence is broken if such a property is deleted and then redefined or if the property is changed into an accessor property. If the arguments object is an ordinary object, the values of its properties are simply a copy of the arguments passed to the function and there is no dynamic linkage between the property values and the formal parameter values.</p>
      </emu-note>
      <emu-note>
        <p>The ParameterMap object and its property values are used as a device for specifying the arguments object correspondence to argument bindings. The ParameterMap object and the objects that are the values of its properties are not directly observable from ECMAScript code. An ECMAScript implementation does not need to actually create or use such objects to implement the specified semantics.</p>
      </emu-note>
      <emu-note>
        <p>Ordinary arguments objects define a non-configurable accessor property named `"callee"` which throws a *TypeError* exception on access. The `"callee"` property has a more specific meaning for arguments exotic objects, which are created only for some class of non-strict functions. The definition of this property in the ordinary variant exists to ensure that it is not defined in any other manner by conforming ECMAScript implementations.</p>
      </emu-note>
      <emu-note>
        <p>ECMAScript implementations of arguments exotic objects have historically contained an accessor property named `"caller"`. Prior to ECMAScript 2017, this specification included the definition of a throwing `"caller"` property on ordinary arguments objects. Since implementations do not contain this extension any longer, ECMAScript 2017 dropped the requirement for a throwing `"caller"` accessor.</p>
      </emu-note>

      <emu-clause id="sec-arguments-exotic-objects-getownproperty-p">
        <h1>[[GetOwnProperty]] ( _P_ )</h1>
        <p>The [[GetOwnProperty]] internal method of an arguments exotic object when called with a property key _P_ performs the following steps:</p>
        <emu-alg>
          1. Let _args_ be the arguments object.
          1. Let _desc_ be OrdinaryGetOwnProperty(_args_, _P_).
          1. If _desc_ is *undefined*, return _desc_.
          1. Let _map_ be _args_.[[ParameterMap]].
          1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).
          1. If _isMapped_ is *true*, then
            1. Set _desc_.[[Value]] to Get(_map_, _P_).
          1. Return _desc_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-defineownproperty-p-desc">
        <h1>[[DefineOwnProperty]] ( _P_, _Desc_ )</h1>
        <p>The [[DefineOwnProperty]] internal method of an arguments exotic object when called with a property key _P_ and Property Descriptor _Desc_ performs the following steps:</p>
        <emu-alg>
          1. Let _args_ be the arguments object.
          1. Let _map_ be _args_.[[ParameterMap]].
          1. Let _isMapped_ be HasOwnProperty(_map_, _P_).
          1. Let _newArgDesc_ be _Desc_.
          1. If _isMapped_ is *true* and IsDataDescriptor(_Desc_) is *true*, then
            1. If _Desc_.[[Value]] is not present and _Desc_.[[Writable]] is present and its value is *false*, then
              1. Set _newArgDesc_ to a copy of _Desc_.
              1. Set _newArgDesc_.[[Value]] to Get(_map_, _P_).
          1. Let _allowed_ be ? OrdinaryDefineOwnProperty(_args_, _P_, _newArgDesc_).
          1. If _allowed_ is *false*, return *false*.
          1. If _isMapped_ is *true*, then
            1. If IsAccessorDescriptor(_Desc_) is *true*, then
              1. Call _map_.[[Delete]](_P_).
            1. Else,
              1. If _Desc_.[[Value]] is present, then
                1. Let _setStatus_ be Set(_map_, _P_, _Desc_.[[Value]], *false*).
                1. Assert: _setStatus_ is *true* because formal parameters mapped by argument objects are always writable.
              1. If _Desc_.[[Writable]] is present and its value is *false*, then
                1. Call _map_.[[Delete]](_P_).
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-get-p-receiver">
        <h1>[[Get]] ( _P_, _Receiver_ )</h1>
        <p>The [[Get]] internal method of an arguments exotic object when called with a property key _P_ and ECMAScript language value _Receiver_ performs the following steps:</p>
        <emu-alg>
          1. Let _args_ be the arguments object.
          1. Let _map_ be _args_.[[ParameterMap]].
          1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).
          1. If _isMapped_ is *false*, then
            1. Return ? OrdinaryGet(_args_, _P_, _Receiver_).
          1. Else _map_ contains a formal parameter mapping for _P_,
            1. Return Get(_map_, _P_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-set-p-v-receiver">
        <h1>[[Set]] ( _P_, _V_, _Receiver_ )</h1>
        <p>The [[Set]] internal method of an arguments exotic object when called with property key _P_, value _V_, and ECMAScript language value _Receiver_ performs the following steps:</p>
        <emu-alg>
          1. Let _args_ be the arguments object.
          1. If SameValue(_args_, _Receiver_) is *false*, then
            1. Let _isMapped_ be *false*.
          1. Else,
            1. Let _map_ be _args_.[[ParameterMap]].
            1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).
          1. If _isMapped_ is *true*, then
            1. Let _setStatus_ be Set(_map_, _P_, _V_, *false*).
            1. Assert: _setStatus_ is *true* because formal parameters mapped by argument objects are always writable.
          1. Return ? OrdinarySet(_args_, _P_, _V_, _Receiver_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-delete-p">
        <h1>[[Delete]] ( _P_ )</h1>
        <p>The [[Delete]] internal method of an arguments exotic object when called with a property key _P_ performs the following steps:</p>
        <emu-alg>
          1. Let _args_ be the arguments object.
          1. Let _map_ be _args_.[[ParameterMap]].
          1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).
          1. Let _result_ be ? OrdinaryDelete(_args_, _P_).
          1. If _result_ is *true* and _isMapped_ is *true*, then
            1. Call _map_.[[Delete]](_P_).
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createunmappedargumentsobject" aoid="CreateUnmappedArgumentsObject">
        <h1>CreateUnmappedArgumentsObject ( _argumentsList_ )</h1>
        <p>The abstract operation CreateUnmappedArgumentsObject called with an argument _argumentsList_ performs the following steps:</p>
        <emu-alg>
          1. Let _len_ be the number of elements in _argumentsList_.
          1. Let _obj_ be ObjectCreate(%ObjectPrototype%, &laquo; [[ParameterMap]] &raquo;).
          1. Set _obj_.[[ParameterMap]] to *undefined*.
          1. Perform DefinePropertyOrThrow(_obj_, `"length"`, PropertyDescriptor { [[Value]]: _len_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).
          1. Let _index_ be 0.
          1. Repeat, while _index_ &lt; _len_,
            1. Let _val_ be _argumentsList_[_index_].
            1. Perform CreateDataProperty(_obj_, ! ToString(_index_), _val_).
            1. Increase _index_ by 1.
          1. Perform ! DefinePropertyOrThrow(_obj_, @@iterator, PropertyDescriptor { [[Value]]: %ArrayProto_values%, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).
          1. Perform ! DefinePropertyOrThrow(_obj_, `"callee"`, PropertyDescriptor { [[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
          1. Return _obj_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createmappedargumentsobject" aoid="CreateMappedArgumentsObject">
        <h1>CreateMappedArgumentsObject ( _func_, _formals_, _argumentsList_, _env_ )</h1>
        <p>The abstract operation CreateMappedArgumentsObject is called with object _func_, Parse Node _formals_, List _argumentsList_, and Environment Record _env_. The following steps are performed:</p>
        <emu-alg>
          1. Assert: _formals_ does not contain a rest parameter, any binding patterns, or any initializers. It may contain duplicate identifiers.
          1. Let _len_ be the number of elements in _argumentsList_.
          1. Let _obj_ be a newly created arguments exotic object with a [[ParameterMap]] internal slot.
          1. Set _obj_.[[GetOwnProperty]] as specified in <emu-xref href="#sec-arguments-exotic-objects-getownproperty-p"></emu-xref>.
          1. Set _obj_.[[DefineOwnProperty]] as specified in <emu-xref href="#sec-arguments-exotic-objects-defineownproperty-p-desc"></emu-xref>.
          1. Set _obj_.[[Get]] as specified in <emu-xref href="#sec-arguments-exotic-objects-get-p-receiver"></emu-xref>.
          1. Set _obj_.[[Set]] as specified in <emu-xref href="#sec-arguments-exotic-objects-set-p-v-receiver"></emu-xref>.
          1. Set _obj_.[[Delete]] as specified in <emu-xref href="#sec-arguments-exotic-objects-delete-p"></emu-xref>.
          1. Set the remainder of _obj_'s essential internal methods to the default ordinary object definitions specified in <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>.
          1. Set _obj_.[[Prototype]] to %ObjectPrototype%.
          1. Set _obj_.[[Extensible]] to *true*.
          1. Let _map_ be ObjectCreate(*null*).
          1. Set _obj_.[[ParameterMap]] to _map_.
          1. Let _parameterNames_ be the BoundNames of _formals_.
          1. Let _numberOfParameters_ be the number of elements in _parameterNames_.
          1. Let _index_ be 0.
          1. Repeat, while _index_ &lt; _len_,
            1. Let _val_ be _argumentsList_[_index_].
            1. Perform CreateDataProperty(_obj_, ! ToString(_index_), _val_).
            1. Increase _index_ by 1.
          1. Perform DefinePropertyOrThrow(_obj_, `"length"`, PropertyDescriptor { [[Value]]: _len_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).
          1. Let _mappedNames_ be a new empty List.
          1. Let _index_ be _numberOfParameters_ - 1.
          1. Repeat, while _index_ &ge; 0,
            1. Let _name_ be _parameterNames_[_index_].
            1. If _name_ is not an element of _mappedNames_, then
              1. Add _name_ as an element of the list _mappedNames_.
              1. If _index_ &lt; _len_, then
                1. Let _g_ be MakeArgGetter(_name_, _env_).
                1. Let _p_ be MakeArgSetter(_name_, _env_).
                1. Perform _map_.[[DefineOwnProperty]](! ToString(_index_), PropertyDescriptor { [[Set]]: _p_, [[Get]]: _g_, [[Enumerable]]: *false*, [[Configurable]]: *true* }).
            1. Decrease _index_ by 1.
          1. Perform ! DefinePropertyOrThrow(_obj_, @@iterator, PropertyDescriptor { [[Value]]: %ArrayProto_values%, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).
          1. Perform ! DefinePropertyOrThrow(_obj_, `"callee"`, PropertyDescriptor { [[Value]]: _func_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).
          1. Return _obj_.
        </emu-alg>

        <emu-clause id="sec-makearggetter" aoid="MakeArgGetter">
          <h1>MakeArgGetter ( _name_, _env_ )</h1>
          <p>The abstract operation MakeArgGetter called with String _name_ and Environment Record _env_ creates a built-in function object that when executed returns the value bound for _name_ in _env_. It performs the following steps:</p>
          <emu-alg>
            1. Let _steps_ be the steps of an ArgGetter function as specified below.
            1. Let _getter_ be CreateBuiltinFunction(_steps_, &laquo; [[Name]], [[Env]] &raquo;).
            1. Set _getter_.[[Name]] to _name_.
            1. Set _getter_.[[Env]] to _env_.
            1. Return _getter_.
          </emu-alg>
          <p>An ArgGetter function is an anonymous built-in function with [[Name]] and [[Env]] internal slots. When an ArgGetter function that expects no arguments is called it performs the following steps:</p>
          <emu-alg>
            1. Let _f_ be the active function object.
            1. Let _name_ be _f_.[[Name]].
            1. Let _env_ be _f_.[[Env]].
            1. Return _env_.GetBindingValue(_name_, *false*).
          </emu-alg>
          <emu-note>
            <p>ArgGetter functions are never directly accessible to ECMAScript code.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-makeargsetter" aoid="MakeArgSetter">
          <h1>MakeArgSetter ( _name_, _env_ )</h1>
          <p>The abstract operation MakeArgSetter called with String _name_ and Environment Record _env_ creates a built-in function object that when executed sets the value bound for _name_ in _env_. It performs the following steps:</p>
          <emu-alg>
            1. Let _steps_ be the steps of an ArgSetter function as specified below.
            1. Let _setter_ be CreateBuiltinFunction(_steps_, &laquo; [[Name]], [[Env]] &raquo;).
            1. Set _setter_.[[Name]] to _name_.
            1. Set _setter_.[[Env]] to _env_.
            1. Return _setter_.
          </emu-alg>
          <p>An ArgSetter function is an anonymous built-in function with [[Name]] and [[Env]] internal slots. When an ArgSetter function is called with argument _value_ it performs the following steps:</p>
          <emu-alg>
            1. Let _f_ be the active function object.
            1. Let _name_ be _f_.[[Name]].
            1. Let _env_ be _f_.[[Env]].
            1. Return _env_.SetMutableBinding(_name_, _value_, *false*).
          </emu-alg>
          <emu-note>
            <p>ArgSetter functions are never directly accessible to ECMAScript code.</p>
          </emu-note>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-integer-indexed-exotic-objects">
      <h1>Integer-Indexed Exotic Objects</h1>
      <p>An <dfn id="integer-indexed-exotic-object">Integer-Indexed exotic object</dfn> is an exotic object that performs special handling of integer index property keys.</p>
      <p><emu-xref href="#integer-indexed-exotic-object">Integer-Indexed exotic objects</emu-xref> have the same internal slots as ordinary objects and additionally [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal slots.</p>
      <p><emu-xref href="#integer-indexed-exotic-object">Integer-Indexed exotic objects</emu-xref> provide alternative definitions for the following internal methods. All of the other Integer-Indexed exotic object essential internal methods that are not defined below are as specified in <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>.</p>

      <emu-clause id="sec-integer-indexed-exotic-objects-getownproperty-p">
        <h1>[[GetOwnProperty]] ( _P_ )</h1>
        <p>When the [[GetOwnProperty]] internal method of an Integer-Indexed exotic object _O_ is called with property key _P_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: IsPropertyKey(_P_) is *true*.
          1. Assert: _O_ is an Object that has a [[ViewedArrayBuffer]] internal slot.
          1. If Type(_P_) is String, then
            1. Let _numericIndex_ be ! CanonicalNumericIndexString(_P_).
            1. If _numericIndex_ is not *undefined*, then
              1. Let _value_ be ? IntegerIndexedElementGet(_O_, _numericIndex_).
              1. If _value_ is *undefined*, return *undefined*.
              1. Return a PropertyDescriptor { [[Value]]: _value_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *false* }.
          1. Return OrdinaryGetOwnProperty(_O_, _P_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-integer-indexed-exotic-objects-hasproperty-p">
        <h1>[[HasProperty]] ( _P_ )</h1>
        <p>When the [[HasProperty]] internal method of an Integer-Indexed exotic object _O_ is called with property key _P_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: IsPropertyKey(_P_) is *true*.
          1. Assert: _O_ is an Object that has a [[ViewedArrayBuffer]] internal slot.
          1. If Type(_P_) is String, then
            1. Let _numericIndex_ be ! CanonicalNumericIndexString(_P_).
            1. If _numericIndex_ is not *undefined*, then
              1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
              1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
              1. If IsInteger(_numericIndex_) is *false*, return *false*.
              1. If _numericIndex_ = *-0*, return *false*.
              1. If _numericIndex_ &lt; 0, return *false*.
              1. If _numericIndex_ &ge; _O_.[[ArrayLength]], return *false*.
              1. Return *true*.
          1. Return ? OrdinaryHasProperty(_O_, _P_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-integer-indexed-exotic-objects-defineownproperty-p-desc">
        <h1>[[DefineOwnProperty]] ( _P_, _Desc_ )</h1>
        <p>When the [[DefineOwnProperty]] internal method of an Integer-Indexed exotic object _O_ is called with property key _P_, and Property Descriptor _Desc_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: IsPropertyKey(_P_) is *true*.
          1. Assert: _O_ is an Object that has a [[ViewedArrayBuffer]] internal slot.
          1. If Type(_P_) is String, then
            1. Let _numericIndex_ be ! CanonicalNumericIndexString(_P_).
            1. If _numericIndex_ is not *undefined*, then
              1. If IsInteger(_numericIndex_) is *false*, return *false*.
              1. If _numericIndex_ = *-0*, return *false*.
              1. If _numericIndex_ &lt; 0, return *false*.
              1. Let _length_ be _O_.[[ArrayLength]].
              1. If _numericIndex_ &ge; _length_, return *false*.
              1. If IsAccessorDescriptor(_Desc_) is *true*, return *false*.
              1. If _Desc_ has a [[Configurable]] field and if _Desc_.[[Configurable]] is *true*, return *false*.
              1. If _Desc_ has an [[Enumerable]] field and if _Desc_.[[Enumerable]] is *false*, return *false*.
              1. If _Desc_ has a [[Writable]] field and if _Desc_.[[Writable]] is *false*, return *false*.
              1. If _Desc_ has a [[Value]] field, then
                1. Let _value_ be _Desc_.[[Value]].
                1. Return ? IntegerIndexedElementSet(_O_, _numericIndex_, _value_).
              1. Return *true*.
          1. Return ! OrdinaryDefineOwnProperty(_O_, _P_, _Desc_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-integer-indexed-exotic-objects-get-p-receiver">
        <h1>[[Get]] ( _P_, _Receiver_ )</h1>
        <p>When the [[Get]] internal method of an Integer-Indexed exotic object _O_ is called with property key _P_ and ECMAScript language value _Receiver_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: IsPropertyKey(_P_) is *true*.
          1. If Type(_P_) is String, then
            1. Let _numericIndex_ be ! CanonicalNumericIndexString(_P_).
            1. If _numericIndex_ is not *undefined*, then
              1. Return ? IntegerIndexedElementGet(_O_, _numericIndex_).
          1. Return ? OrdinaryGet(_O_, _P_, _Receiver_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-integer-indexed-exotic-objects-set-p-v-receiver">
        <h1>[[Set]] ( _P_, _V_, _Receiver_ )</h1>
        <p>When the [[Set]] internal method of an Integer-Indexed exotic object _O_ is called with property key _P_, value _V_, and ECMAScript language value _Receiver_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: IsPropertyKey(_P_) is *true*.
          1. If Type(_P_) is String, then
            1. Let _numericIndex_ be ! CanonicalNumericIndexString(_P_).
            1. If _numericIndex_ is not *undefined*, then
              1. Return ? IntegerIndexedElementSet(_O_, _numericIndex_, _V_).
          1. Return ? OrdinarySet(_O_, _P_, _V_, _Receiver_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-integer-indexed-exotic-objects-ownpropertykeys">
        <h1>[[OwnPropertyKeys]] ( )</h1>
        <p>When the [[OwnPropertyKeys]] internal method of an Integer-Indexed exotic object _O_ is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _keys_ be a new empty List.
          1. Assert: _O_ is an Object that has [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal slots.
          1. Let _len_ be _O_.[[ArrayLength]].
          1. For each integer _i_ starting with 0 such that _i_ &lt; _len_, in ascending order, do
            1. Add ! ToString(_i_) as the last element of _keys_.
          1. For each own property key _P_ of _O_ such that Type(_P_) is String and _P_ is not an integer index, in ascending chronological order of property creation, do
            1. Add _P_ as the last element of _keys_.
          1. For each own property key _P_ of _O_ such that Type(_P_) is Symbol, in ascending chronological order of property creation, do
            1. Add _P_ as the last element of _keys_.
          1. Return _keys_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-integerindexedobjectcreate" aoid="IntegerIndexedObjectCreate">
        <h1>IntegerIndexedObjectCreate ( _prototype_, _internalSlotsList_ )</h1>
        <p>The abstract operation IntegerIndexedObjectCreate with arguments _prototype_ and _internalSlotsList_ is used to specify the creation of new <emu-xref href="#integer-indexed-exotic-object">Integer-Indexed exotic objects</emu-xref>. The argument _internalSlotsList_ is a List of the names of additional internal slots that must be defined as part of the object. IntegerIndexedObjectCreate performs the following steps:</p>
        <emu-alg>
          1. Assert: _internalSlotsList_ contains the names [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]].
          1. Let _A_ be a newly created Integer-Indexed exotic object with an internal slot for each name in _internalSlotsList_.
          1. Set _A_'s essential internal methods to the default ordinary object definitions specified in <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>.
          1. Set _A_.[[GetOwnProperty]] as specified in <emu-xref href="#sec-integer-indexed-exotic-objects-getownproperty-p"></emu-xref>.
          1. Set _A_.[[HasProperty]] as specified in <emu-xref href="#sec-integer-indexed-exotic-objects-hasproperty-p"></emu-xref>.
          1. Set _A_.[[DefineOwnProperty]] as specified in <emu-xref href="#sec-integer-indexed-exotic-objects-defineownproperty-p-desc"></emu-xref>.
          1. Set _A_.[[Get]] as specified in <emu-xref href="#sec-integer-indexed-exotic-objects-get-p-receiver"></emu-xref>.
          1. Set _A_.[[Set]] as specified in <emu-xref href="#sec-integer-indexed-exotic-objects-set-p-v-receiver"></emu-xref>.
          1. Set _A_.[[OwnPropertyKeys]] as specified in <emu-xref href="#sec-integer-indexed-exotic-objects-ownpropertykeys"></emu-xref>.
          1. Set _A_.[[Prototype]] to _prototype_.
          1. Set _A_.[[Extensible]] to *true*.
          1. Return _A_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-integerindexedelementget" aoid="IntegerIndexedElementGet">
        <h1>IntegerIndexedElementGet ( _O_, _index_ )</h1>
        <p>The abstract operation IntegerIndexedElementGet with arguments _O_ and _index_ performs the following steps:</p>
        <emu-alg>
          1. Assert: Type(_index_) is Number.
          1. Assert: _O_ is an Object that has [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal slots.
          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
          1. If IsInteger(_index_) is *false*, return *undefined*.
          1. If _index_ = *-0*, return *undefined*.
          1. Let _length_ be _O_.[[ArrayLength]].
          1. If _index_ &lt; 0 or _index_ &ge; _length_, return *undefined*.
          1. Let _offset_ be _O_.[[ByteOffset]].
          1. Let _arrayTypeName_ be the String value of _O_.[[TypedArrayName]].
          1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.
          1. Let _indexedPosition_ be (_index_ &times; _elementSize_) + _offset_.
          1. Let _elementType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.
          1. Return GetValueFromBuffer(_buffer_, _indexedPosition_, _elementType_, *true*, `"Unordered"`).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-integerindexedelementset" aoid="IntegerIndexedElementSet">
        <h1>IntegerIndexedElementSet ( _O_, _index_, _value_ )</h1>
        <p>The abstract operation IntegerIndexedElementSet with arguments _O_, _index_, and _value_ performs the following steps:</p>
        <emu-alg>
          1. Assert: Type(_index_) is Number.
          1. Assert: _O_ is an Object that has [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal slots.
          1. Let _numValue_ be ? ToNumber(_value_).
          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
          1. If IsInteger(_index_) is *false*, return *false*.
          1. If _index_ = *-0*, return *false*.
          1. Let _length_ be _O_.[[ArrayLength]].
          1. If _index_ &lt; 0 or _index_ &ge; _length_, return *false*.
          1. Let _offset_ be _O_.[[ByteOffset]].
          1. Let _arrayTypeName_ be the String value of _O_.[[TypedArrayName]].
          1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.
          1. Let _indexedPosition_ be (_index_ &times; _elementSize_) + _offset_.
          1. Let _elementType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.
          1. Perform SetValueInBuffer(_buffer_, _indexedPosition_, _elementType_, _numValue_, *true*, `"Unordered"`).
          1. Return *true*.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-module-namespace-exotic-objects">
      <h1>Module Namespace Exotic Objects</h1>
      <p>A <em>module namespace object</em> is an exotic object that exposes the bindings exported from an ECMAScript |Module| (See <emu-xref href="#sec-exports"></emu-xref>). There is a one-to-one correspondence between the String-keyed own properties of a module namespace exotic object and the binding names exported by the |Module|. The exported bindings include any bindings that are indirectly exported using `export *` export items. Each String-valued own property key is the StringValue of the corresponding exported binding name. These are the only String-keyed properties of a module namespace exotic object. Each such property has the attributes { [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *false* }. Module namespace objects are not extensible.</p>
      <p>Module namespace objects have the internal slots defined in <emu-xref href="#table-29"></emu-xref>.</p>
      <emu-table id="table-29" caption="Internal Slots of Module Namespace Exotic Objects">
        <table>
          <tbody>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Type
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[Module]]
            </td>
            <td>
              Module Record
            </td>
            <td>
              The Module Record whose exports this namespace exposes.
            </td>
          </tr>
          <tr>
            <td>
              [[Exports]]
            </td>
            <td>
              List of String
            </td>
            <td>
              A List containing the String values of the exported names exposed as own properties of this object. The list is ordered as if an Array of those String values had been sorted using `Array.prototype.sort` using *undefined* as _comparefn_.
            </td>
          </tr>
          <tr>
            <td>
              [[Prototype]]
            </td>
            <td>
              Null
            </td>
            <td>
              This slot always contains the value *null* (see <emu-xref href="#sec-module-namespace-exotic-objects-setprototypeof-v"></emu-xref>).
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
      <p>Module namespace exotic objects provide alternative definitions for all of the internal methods except [[GetPrototypeOf]], which behaves as defined in <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof"></emu-xref>.</p>

      <emu-clause id="sec-module-namespace-exotic-objects-setprototypeof-v">
        <h1>[[SetPrototypeOf]] ( _V_ )</h1>
        <p>When the [[SetPrototypeOf]] internal method of a module namespace exotic object _O_ is called with argument _V_, the following steps are taken:</p>
        <emu-alg>
          1. Return ? SetImmutablePrototype(_O_, _V_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-isextensible">
        <h1>[[IsExtensible]] ( )</h1>
        <p>When the [[IsExtensible]] internal method of a module namespace exotic object _O_ is called, the following steps are taken:</p>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-preventextensions">
        <h1>[[PreventExtensions]] ( )</h1>
        <p>When the [[PreventExtensions]] internal method of a module namespace exotic object _O_ is called, the following steps are taken:</p>
        <emu-alg>
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-getownproperty-p">
        <h1>[[GetOwnProperty]] ( _P_ )</h1>
        <p>When the [[GetOwnProperty]] internal method of a module namespace exotic object _O_ is called with property key _P_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_P_) is Symbol, return OrdinaryGetOwnProperty(_O_, _P_).
          1. Let _exports_ be _O_.[[Exports]].
          1. If _P_ is not an element of _exports_, return *undefined*.
          1. Let _value_ be ? _O_.[[Get]](_P_, _O_).
          1. Return PropertyDescriptor { [[Value]]: _value_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *false* }.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-defineownproperty-p-desc">
        <h1>[[DefineOwnProperty]] ( _P_, _Desc_ )</h1>
        <p>When the [[DefineOwnProperty]] internal method of a module namespace exotic object _O_ is called with property key _P_ and Property Descriptor _Desc_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_P_) is Symbol, return OrdinaryDefineOwnProperty(_O_, _P_, _Desc_).
          1. Let _current_ be ? _O_.[[GetOwnProperty]](_P_).
          1. If _current_ is *undefined*, return *false*.
          1. If IsAccessorDescriptor(_Desc_) is *true*, return *false*.
          1. If _Desc_.[[Writable]] is present and has value *false*, return *false*.
          1. If _Desc_.[[Enumerable]] is present and has value *false*, return *false*.
          1. If _Desc_.[[Configurable]] is present and has value *true*, return *false*.
          1. If _Desc_.[[Value]] is present, return SameValue(_Desc_.[[Value]], _current_.[[Value]]).
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-hasproperty-p">
        <h1>[[HasProperty]] ( _P_ )</h1>
        <p>When the [[HasProperty]] internal method of a module namespace exotic object _O_ is called with property key _P_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_P_) is Symbol, return OrdinaryHasProperty(_O_, _P_).
          1. Let _exports_ be _O_.[[Exports]].
          1. If _P_ is an element of _exports_, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-get-p-receiver">
        <h1>[[Get]] ( _P_, _Receiver_ )</h1>
        <p>When the [[Get]] internal method of a module namespace exotic object _O_ is called with property key _P_ and ECMAScript language value _Receiver_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: IsPropertyKey(_P_) is *true*.
          1. If Type(_P_) is Symbol, then
            1. Return ? OrdinaryGet(_O_, _P_, _Receiver_).
          1. Let _exports_ be _O_.[[Exports]].
          1. If _P_ is not an element of _exports_, return *undefined*.
          1. Let _m_ be _O_.[[Module]].
          1. Let _binding_ be ! _m_.ResolveExport(_P_).
          1. Assert: _binding_ is a ResolvedBinding Record.
          1. Let _targetModule_ be _binding_.[[Module]].
          1. Assert: _targetModule_ is not *undefined*.
          1. Let _targetEnv_ be _targetModule_.[[Environment]].
          1. If _targetEnv_ is *undefined*, throw a *ReferenceError* exception.
          1. Let _targetEnvRec_ be _targetEnv_'s EnvironmentRecord.
          1. Return ? _targetEnvRec_.GetBindingValue(_binding_.[[BindingName]], *true*).
        </emu-alg>
        <emu-note>
          <p>ResolveExport is idempotent and side-effect free. An implementation might choose to pre-compute or cache the ResolveExport results for the [[Exports]] of each module namespace exotic object.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-set-p-v-receiver">
        <h1>[[Set]] ( _P_, _V_, _Receiver_ )</h1>
        <p>When the [[Set]] internal method of a module namespace exotic object _O_ is called with property key _P_, value _V_, and ECMAScript language value _Receiver_, the following steps are taken:</p>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-delete-p">
        <h1>[[Delete]] ( _P_ )</h1>
        <p>When the [[Delete]] internal method of a module namespace exotic object _O_ is called with property key _P_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: IsPropertyKey(_P_) is *true*.
          1. If Type(_P_) is Symbol, then
            1. Return ? OrdinaryDelete(_O_, _P_).
          1. Let _exports_ be _O_.[[Exports]].
          1. If _P_ is an element of _exports_, return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-ownpropertykeys">
        <h1>[[OwnPropertyKeys]] ( )</h1>
        <p>When the [[OwnPropertyKeys]] internal method of a module namespace exotic object _O_ is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _exports_ be a copy of _O_.[[Exports]].
          1. Let _symbolKeys_ be ! OrdinaryOwnPropertyKeys(_O_).
          1. Append all the entries of _symbolKeys_ to the end of _exports_.
          1. Return _exports_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-modulenamespacecreate" aoid="ModuleNamespaceCreate">
        <h1>ModuleNamespaceCreate ( _module_, _exports_ )</h1>
        <p>The abstract operation ModuleNamespaceCreate with arguments _module_, and _exports_ is used to specify the creation of new module namespace exotic objects. It performs the following steps:</p>
        <emu-alg>
          1. Assert: _module_ is a Module Record.
          1. Assert: _module_.[[Namespace]] is *undefined*.
          1. Assert: _exports_ is a List of String values.
          1. Let _M_ be a newly created module namespace exotic object with the internal slots listed in <emu-xref href="#table-29"></emu-xref>.
          1. Set _M_'s essential internal methods to the definitions specified in <emu-xref href="#sec-module-namespace-exotic-objects"></emu-xref>.
          1. Set _M_.[[Module]] to _module_.
          1. Let _sortedExports_ be a new List containing the same values as the list _exports_ where the values are ordered as if an Array of the same values had been sorted using `Array.prototype.sort` using *undefined* as _comparefn_.
          1. Set _M_.[[Exports]] to _sortedExports_.
          1. Create own properties of _M_ corresponding to the definitions in <emu-xref href="#sec-module-namespace-objects"></emu-xref>.
          1. Set _module_.[[Namespace]] to _M_.
          1. Return _M_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-immutable-prototype-exotic-objects">
      <h1>Immutable Prototype Exotic Objects</h1>
      <p>An <dfn>immutable prototype exotic object</dfn> is an exotic object that has a [[Prototype]] internal slot that will not change once it is initialized.</p>

      <p>Immutable prototype exotic objects have the same internal slots as ordinary objects. They are exotic only in the following internal methods. All other internal methods of immutable prototype exotic objects that are not explicitly defined below are instead defined as in <a href="#sec-ordinary-object-internal-methods-and-internal-slots">ordinary objects.</a></p>

      <emu-clause id="sec-immutable-prototype-exotic-objects-setprototypeof-v">
        <h1>[[SetPrototypeOf]] ( _V_ )</h1>
        <p>When the [[SetPrototypeOf]] internal method of an immutable prototype exotic object _O_ is called with argument _V_, the following steps are taken:</p>
        <emu-alg>
          1. Return ? SetImmutablePrototype(_O_, _V_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set-immutable-prototype" aoid="SetImmutablePrototype">
        <h1>SetImmutablePrototype ( _O_, _V_ )</h1>
        <p>When the SetImmutablePrototype abstract operation is called with arguments _O_ and _V_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: Either Type(_V_) is Object or Type(_V_) is Null.
          1. Let _current_ be ? _O_.[[GetPrototypeOf]]().
          1. If SameValue(_V_, _current_) is *true*, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots">
    <h1>Proxy Object Internal Methods and Internal Slots</h1>
    <p>A proxy object is an exotic object whose essential internal methods are partially implemented using ECMAScript code. Every proxy object has an internal slot called [[ProxyHandler]]. The value of [[ProxyHandler]] is an object, called the proxy's <em>handler object</em>, or *null*. Methods (see <emu-xref href="#table-30"></emu-xref>) of a handler object may be used to augment the implementation for one or more of the proxy object's internal methods. Every proxy object also has an internal slot called [[ProxyTarget]] whose value is either an object or the *null* value. This object is called the proxy's <em>target object</em>.</p>
    <emu-table id="table-30" caption="Proxy Handler Methods">
      <table>
        <tbody>
        <tr>
          <th>
            Internal Method
          </th>
          <th>
            Handler Method
          </th>
        </tr>
        <tr>
          <td>
            [[GetPrototypeOf]]
          </td>
          <td>
            `getPrototypeOf`
          </td>
        </tr>
        <tr>
          <td>
            [[SetPrototypeOf]]
          </td>
          <td>
            `setPrototypeOf`
          </td>
        </tr>
        <tr>
          <td>
            [[IsExtensible]]
          </td>
          <td>
            `isExtensible`
          </td>
        </tr>
        <tr>
          <td>
            [[PreventExtensions]]
          </td>
          <td>
            `preventExtensions`
          </td>
        </tr>
        <tr>
          <td>
            [[GetOwnProperty]]
          </td>
          <td>
            `getOwnPropertyDescriptor`
          </td>
        </tr>
        <tr>
          <td>
            [[DefineOwnProperty]]
          </td>
          <td>
            `defineProperty`
          </td>
        </tr>
        <tr>
          <td>
            [[HasProperty]]
          </td>
          <td>
            `has`
          </td>
        </tr>
        <tr>
          <td>
            [[Get]]
          </td>
          <td>
            `get`
          </td>
        </tr>
        <tr>
          <td>
            [[Set]]
          </td>
          <td>
            `set`
          </td>
        </tr>
        <tr>
          <td>
            [[Delete]]
          </td>
          <td>
            `deleteProperty`
          </td>
        </tr>
        <tr>
          <td>
            [[OwnPropertyKeys]]
          </td>
          <td>
            `ownKeys`
          </td>
        </tr>
        <tr>
          <td>
            [[Call]]
          </td>
          <td>
            `apply`
          </td>
        </tr>
        <tr>
          <td>
            [[Construct]]
          </td>
          <td>
            `construct`
          </td>
        </tr>
        </tbody>
      </table>
    </emu-table>
    <p>When a handler method is called to provide the implementation of a proxy object internal method, the handler method is passed the proxy's target object as a parameter. A proxy's handler object does not necessarily have a method corresponding to every essential internal method. Invoking an internal method on the proxy results in the invocation of the corresponding internal method on the proxy's target object if the handler object does not have a method corresponding to the internal trap.</p>
    <p>The [[ProxyHandler]] and [[ProxyTarget]] internal slots of a proxy object are always initialized when the object is created and typically may not be modified. Some proxy objects are created in a manner that permits them to be subsequently <em>revoked</em>. When a proxy is revoked, its [[ProxyHandler]] and [[ProxyTarget]] internal slots are set to *null* causing subsequent invocations of internal methods on that proxy object to throw a *TypeError* exception.</p>
    <p>Because proxy objects permit the implementation of internal methods to be provided by arbitrary ECMAScript code, it is possible to define a proxy object whose handler methods violates the invariants defined in <emu-xref href="#sec-invariants-of-the-essential-internal-methods"></emu-xref>. Some of the internal method invariants defined in <emu-xref href="#sec-invariants-of-the-essential-internal-methods"></emu-xref> are essential integrity invariants. These invariants are explicitly enforced by the proxy object internal methods specified in this section. An ECMAScript implementation must be robust in the presence of all possible invariant violations.</p>
    <p>In the following algorithm descriptions, assume _O_ is an ECMAScript proxy object, _P_ is a property key value, _V_ is any ECMAScript language value and _Desc_ is a Property Descriptor record.</p>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-getprototypeof">
      <h1>[[GetPrototypeOf]] ( )</h1>
      <p>When the [[GetPrototypeOf]] internal method of a Proxy exotic object _O_ is called, the following steps are taken:</p>
      <emu-alg>
        1. Let _handler_ be _O_.[[ProxyHandler]].
        1. If _handler_ is *null*, throw a *TypeError* exception.
        1. Assert: Type(_handler_) is Object.
        1. Let _target_ be _O_.[[ProxyTarget]].
        1. Let _trap_ be ? GetMethod(_handler_, `"getPrototypeOf"`).
        1. If _trap_ is *undefined*, then
          1. Return ? _target_.[[GetPrototypeOf]]().
        1. Let _handlerProto_ be ? Call(_trap_, _handler_, &laquo; _target_ &raquo;).
        1. If Type(_handlerProto_) is neither Object nor Null, throw a *TypeError* exception.
        1. Let _extensibleTarget_ be ? IsExtensible(_target_).
        1. If _extensibleTarget_ is *true*, return _handlerProto_.
        1. Let _targetProto_ be ? _target_.[[GetPrototypeOf]]().
        1. If SameValue(_handlerProto_, _targetProto_) is *false*, throw a *TypeError* exception.
        1. Return _handlerProto_.
      </emu-alg>
      <emu-note>
        <p>[[GetPrototypeOf]] for proxy objects enforces the following invariants:</p>
        <ul>
          <li>
            The result of [[GetPrototypeOf]] must be either an Object or *null*.
          </li>
          <li>
            If the target object is not extensible, [[GetPrototypeOf]] applied to the proxy object must return the same value as [[GetPrototypeOf]] applied to the proxy object's target object.
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-setprototypeof-v">
      <h1>[[SetPrototypeOf]] ( _V_ )</h1>
      <p>When the [[SetPrototypeOf]] internal method of a Proxy exotic object _O_ is called with argument _V_, the following steps are taken:</p>
      <emu-alg>
        1. Assert: Either Type(_V_) is Object or Type(_V_) is Null.
        1. Let _handler_ be _O_.[[ProxyHandler]].
        1. If _handler_ is *null*, throw a *TypeError* exception.
        1. Assert: Type(_handler_) is Object.
        1. Let _target_ be _O_.[[ProxyTarget]].
        1. Let _trap_ be ? GetMethod(_handler_, `"setPrototypeOf"`).
        1. If _trap_ is *undefined*, then
          1. Return ? _target_.[[SetPrototypeOf]](_V_).
        1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, &laquo; _target_, _V_ &raquo;)).
        1. If _booleanTrapResult_ is *false*, return *false*.
        1. Let _extensibleTarget_ be ? IsExtensible(_target_).
        1. If _extensibleTarget_ is *true*, return *true*.
        1. Let _targetProto_ be ? _target_.[[GetPrototypeOf]]().
        1. If SameValue(_V_, _targetProto_) is *false*, throw a *TypeError* exception.
        1. Return *true*.
      </emu-alg>
      <emu-note>
        <p>[[SetPrototypeOf]] for proxy objects enforces the following invariants:</p>
        <ul>
          <li>
            The result of [[SetPrototypeOf]] is a Boolean value.
          </li>
          <li>
            If the target object is not extensible, the argument value must be the same as the result of [[GetPrototypeOf]] applied to target object.
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-isextensible">
      <h1>[[IsExtensible]] ( )</h1>
      <p>When the [[IsExtensible]] internal method of a Proxy exotic object _O_ is called, the following steps are taken:</p>
      <emu-alg>
        1. Let _handler_ be _O_.[[ProxyHandler]].
        1. If _handler_ is *null*, throw a *TypeError* exception.
        1. Assert: Type(_handler_) is Object.
        1. Let _target_ be _O_.[[ProxyTarget]].
        1. Let _trap_ be ? GetMethod(_handler_, `"isExtensible"`).
        1. If _trap_ is *undefined*, then
          1. Return ? IsExtensible(_target_).
        1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, &laquo; _target_ &raquo;)).
        1. Let _targetResult_ be ? IsExtensible(_target_).
        1. If SameValue(_booleanTrapResult_, _targetResult_) is *false*, throw a *TypeError* exception.
        1. Return _booleanTrapResult_.
      </emu-alg>
      <emu-note>
        <p>[[IsExtensible]] for proxy objects enforces the following invariants:</p>
        <ul>
          <li>
            The result of [[IsExtensible]] is a Boolean value.
          </li>
          <li>
            [[IsExtensible]] applied to the proxy object must return the same value as [[IsExtensible]] applied to the proxy object's target object with the same argument.
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-preventextensions">
      <h1>[[PreventExtensions]] ( )</h1>
      <p>When the [[PreventExtensions]] internal method of a Proxy exotic object _O_ is called, the following steps are taken:</p>
      <emu-alg>
        1. Let _handler_ be _O_.[[ProxyHandler]].
        1. If _handler_ is *null*, throw a *TypeError* exception.
        1. Assert: Type(_handler_) is Object.
        1. Let _target_ be _O_.[[ProxyTarget]].
        1. Let _trap_ be ? GetMethod(_handler_, `"preventExtensions"`).
        1. If _trap_ is *undefined*, then
          1. Return ? _target_.[[PreventExtensions]]().
        1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, &laquo; _target_ &raquo;)).
        1. If _booleanTrapResult_ is *true*, then
          1. Let _extensibleTarget_ be ? IsExtensible(_target_).
          1. If _extensibleTarget_ is *true*, throw a *TypeError* exception.
        1. Return _booleanTrapResult_.
      </emu-alg>
      <emu-note>
        <p>[[PreventExtensions]] for proxy objects enforces the following invariants:</p>
        <ul>
          <li>
            The result of [[PreventExtensions]] is a Boolean value.
          </li>
          <li>
            [[PreventExtensions]] applied to the proxy object only returns *true* if [[IsExtensible]] applied to the proxy object's target object is *false*.
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-getownproperty-p">
      <h1>[[GetOwnProperty]] ( _P_ )</h1>
      <p>When the [[GetOwnProperty]] internal method of a Proxy exotic object _O_ is called with property key _P_, the following steps are taken:</p>
      <emu-alg>
        1. Assert: IsPropertyKey(_P_) is *true*.
        1. Let _handler_ be _O_.[[ProxyHandler]].
        1. If _handler_ is *null*, throw a *TypeError* exception.
        1. Assert: Type(_handler_) is Object.
        1. Let _target_ be _O_.[[ProxyTarget]].
        1. Let _trap_ be ? GetMethod(_handler_, `"getOwnPropertyDescriptor"`).
        1. If _trap_ is *undefined*, then
          1. Return ? _target_.[[GetOwnProperty]](_P_).
        1. Let _trapResultObj_ be ? Call(_trap_, _handler_, &laquo; _target_, _P_ &raquo;).
        1. If Type(_trapResultObj_) is neither Object nor Undefined, throw a *TypeError* exception.
        1. Let _targetDesc_ be ? _target_.[[GetOwnProperty]](_P_).
        1. If _trapResultObj_ is *undefined*, then
          1. If _targetDesc_ is *undefined*, return *undefined*.
          1. If _targetDesc_.[[Configurable]] is *false*, throw a *TypeError* exception.
          1. Let _extensibleTarget_ be ? IsExtensible(_target_).
          1. If _extensibleTarget_ is *false*, throw a *TypeError* exception.
          1. Return *undefined*.
        1. Let _extensibleTarget_ be ? IsExtensible(_target_).
        1. Let _resultDesc_ be ? ToPropertyDescriptor(_trapResultObj_).
        1. Call CompletePropertyDescriptor(_resultDesc_).
        1. Let _valid_ be IsCompatiblePropertyDescriptor(_extensibleTarget_, _resultDesc_, _targetDesc_).
        1. If _valid_ is *false*, throw a *TypeError* exception.
        1. If _resultDesc_.[[Configurable]] is *false*, then
          1. If _targetDesc_ is *undefined* or _targetDesc_.[[Configurable]] is *true*, then
            1. Throw a *TypeError* exception.
        1. Return _resultDesc_.
      </emu-alg>
      <emu-note>
        <p>[[GetOwnProperty]] for proxy objects enforces the following invariants:</p>
        <ul>
          <li>
            The result of [[GetOwnProperty]] must be either an Object or *undefined*.
          </li>
          <li>
            A property cannot be reported as non-existent, if it exists as a non-configurable own property of the target object.
          </li>
          <li>
            A property cannot be reported as non-existent, if it exists as an own property of the target object and the target object is not extensible.
          </li>
          <li>
            A property cannot be reported as existent, if it does not exist as an own property of the target object and the target object is not extensible.
          </li>
          <li>
            A property cannot be reported as non-configurable, if it does not exist as an own property of the target object or if it exists as a configurable own property of the target object.
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-defineownproperty-p-desc">
      <h1>[[DefineOwnProperty]] ( _P_, _Desc_ )</h1>
      <p>When the [[DefineOwnProperty]] internal method of a Proxy exotic object _O_ is called with property key _P_ and Property Descriptor _Desc_, the following steps are taken:</p>
      <emu-alg>
        1. Assert: IsPropertyKey(_P_) is *true*.
        1. Let _handler_ be _O_.[[ProxyHandler]].
        1. If _handler_ is *null*, throw a *TypeError* exception.
        1. Assert: Type(_handler_) is Object.
        1. Let _target_ be _O_.[[ProxyTarget]].
        1. Let _trap_ be ? GetMethod(_handler_, `"defineProperty"`).
        1. If _trap_ is *undefined*, then
          1. Return ? _target_.[[DefineOwnProperty]](_P_, _Desc_).
        1. Let _descObj_ be FromPropertyDescriptor(_Desc_).
        1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, &laquo; _target_, _P_, _descObj_ &raquo;)).
        1. If _booleanTrapResult_ is *false*, return *false*.
        1. Let _targetDesc_ be ? _target_.[[GetOwnProperty]](_P_).
        1. Let _extensibleTarget_ be ? IsExtensible(_target_).
        1. If _Desc_ has a [[Configurable]] field and if _Desc_.[[Configurable]] is *false*, then
          1. Let _settingConfigFalse_ be *true*.
        1. Else, let _settingConfigFalse_ be *false*.
        1. If _targetDesc_ is *undefined*, then
          1. If _extensibleTarget_ is *false*, throw a *TypeError* exception.
          1. If _settingConfigFalse_ is *true*, throw a *TypeError* exception.
        1. Else _targetDesc_ is not *undefined*,
          1. If IsCompatiblePropertyDescriptor(_extensibleTarget_, _Desc_, _targetDesc_) is *false*, throw a *TypeError* exception.
          1. If _settingConfigFalse_ is *true* and _targetDesc_.[[Configurable]] is *true*, throw a *TypeError* exception.
        1. Return *true*.
      </emu-alg>
      <emu-note>
        <p>[[DefineOwnProperty]] for proxy objects enforces the following invariants:</p>
        <ul>
          <li>
            The result of [[DefineOwnProperty]] is a Boolean value.
          </li>
          <li>
            A property cannot be added, if the target object is not extensible.
          </li>
          <li>
            A property cannot be non-configurable, unless there exists a corresponding non-configurable own property of the target object.
          </li>
          <li>
            If a property has a corresponding target object property then applying the Property Descriptor of the property to the target object using [[DefineOwnProperty]] will not throw an exception.
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-hasproperty-p">
      <h1>[[HasProperty]] ( _P_ )</h1>
      <p>When the [[HasProperty]] internal method of a Proxy exotic object _O_ is called with property key _P_, the following steps are taken:</p>
      <emu-alg>
        1. Assert: IsPropertyKey(_P_) is *true*.
        1. Let _handler_ be _O_.[[ProxyHandler]].
        1. If _handler_ is *null*, throw a *TypeError* exception.
        1. Assert: Type(_handler_) is Object.
        1. Let _target_ be _O_.[[ProxyTarget]].
        1. Let _trap_ be ? GetMethod(_handler_, `"has"`).
        1. If _trap_ is *undefined*, then
          1. Return ? _target_.[[HasProperty]](_P_).
        1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, &laquo; _target_, _P_ &raquo;)).
        1. If _booleanTrapResult_ is *false*, then
          1. Let _targetDesc_ be ? _target_.[[GetOwnProperty]](_P_).
          1. If _targetDesc_ is not *undefined*, then
            1. If _targetDesc_.[[Configurable]] is *false*, throw a *TypeError* exception.
            1. Let _extensibleTarget_ be ? IsExtensible(_target_).
            1. If _extensibleTarget_ is *false*, throw a *TypeError* exception.
        1. Return _booleanTrapResult_.
      </emu-alg>
      <emu-note>
        <p>[[HasProperty]] for proxy objects enforces the following invariants:</p>
        <ul>
          <li>
            The result of [[HasProperty]] is a Boolean value.
          </li>
          <li>
            A property cannot be reported as non-existent, if it exists as a non-configurable own property of the target object.
          </li>
          <li>
            A property cannot be reported as non-existent, if it exists as an own property of the target object and the target object is not extensible.
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver">
      <h1>[[Get]] ( _P_, _Receiver_ )</h1>
      <p>When the [[Get]] internal method of a Proxy exotic object _O_ is called with property key _P_ and ECMAScript language value _Receiver_, the following steps are taken:</p>
      <emu-alg>
        1. Assert: IsPropertyKey(_P_) is *true*.
        1. Let _handler_ be _O_.[[ProxyHandler]].
        1. If _handler_ is *null*, throw a *TypeError* exception.
        1. Assert: Type(_handler_) is Object.
        1. Let _target_ be _O_.[[ProxyTarget]].
        1. Let _trap_ be ? GetMethod(_handler_, `"get"`).
        1. If _trap_ is *undefined*, then
          1. Return ? _target_.[[Get]](_P_, _Receiver_).
        1. Let _trapResult_ be ? Call(_trap_, _handler_, &laquo; _target_, _P_, _Receiver_ &raquo;).
        1. Let _targetDesc_ be ? _target_.[[GetOwnProperty]](_P_).
        1. If _targetDesc_ is not *undefined* and _targetDesc_.[[Configurable]] is *false*, then
          1. If IsDataDescriptor(_targetDesc_) is *true* and _targetDesc_.[[Writable]] is *false*, then
            1. If SameValue(_trapResult_, _targetDesc_.[[Value]]) is *false*, throw a *TypeError* exception.
          1. If IsAccessorDescriptor(_targetDesc_) is *true* and _targetDesc_.[[Get]] is *undefined*, then
            1. If _trapResult_ is not *undefined*, throw a *TypeError* exception.
        1. Return _trapResult_.
      </emu-alg>
      <emu-note>
        <p>[[Get]] for proxy objects enforces the following invariants:</p>
        <ul>
          <li>
            The value reported for a property must be the same as the value of the corresponding target object property if the target object property is a non-writable, non-configurable own data property.
          </li>
          <li>
            The value reported for a property must be *undefined* if the corresponding target object property is a non-configurable own accessor property that has *undefined* as its [[Get]] attribute.
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-set-p-v-receiver">
      <h1>[[Set]] ( _P_, _V_, _Receiver_ )</h1>
      <p>When the [[Set]] internal method of a Proxy exotic object _O_ is called with property key _P_, value _V_, and ECMAScript language value _Receiver_, the following steps are taken:</p>
      <emu-alg>
        1. Assert: IsPropertyKey(_P_) is *true*.
        1. Let _handler_ be _O_.[[ProxyHandler]].
        1. If _handler_ is *null*, throw a *TypeError* exception.
        1. Assert: Type(_handler_) is Object.
        1. Let _target_ be _O_.[[ProxyTarget]].
        1. Let _trap_ be ? GetMethod(_handler_, `"set"`).
        1. If _trap_ is *undefined*, then
          1. Return ? _target_.[[Set]](_P_, _V_, _Receiver_).
        1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, &laquo; _target_, _P_, _V_, _Receiver_ &raquo;)).
        1. If _booleanTrapResult_ is *false*, return *false*.
        1. Let _targetDesc_ be ? _target_.[[GetOwnProperty]](_P_).
        1. If _targetDesc_ is not *undefined* and _targetDesc_.[[Configurable]] is *false*, then
          1. If IsDataDescriptor(_targetDesc_) is *true* and _targetDesc_.[[Writable]] is *false*, then
            1. If SameValue(_V_, _targetDesc_.[[Value]]) is *false*, throw a *TypeError* exception.
          1. If IsAccessorDescriptor(_targetDesc_) is *true*, then
            1. If _targetDesc_.[[Set]] is *undefined*, throw a *TypeError* exception.
        1. Return *true*.
      </emu-alg>
      <emu-note>
        <p>[[Set]] for proxy objects enforces the following invariants:</p>
        <ul>
          <li>
            The result of [[Set]] is a Boolean value.
          </li>
          <li>
            Cannot change the value of a property to be different from the value of the corresponding target object property if the corresponding target object property is a non-writable, non-configurable own data property.
          </li>
          <li>
            Cannot set the value of a property if the corresponding target object property is a non-configurable own accessor property that has *undefined* as its [[Set]] attribute.
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-delete-p">
      <h1>[[Delete]] ( _P_ )</h1>
      <p>When the [[Delete]] internal method of a Proxy exotic object _O_ is called with property key _P_, the following steps are taken:</p>
      <emu-alg>
        1. Assert: IsPropertyKey(_P_) is *true*.
        1. Let _handler_ be _O_.[[ProxyHandler]].
        1. If _handler_ is *null*, throw a *TypeError* exception.
        1. Assert: Type(_handler_) is Object.
        1. Let _target_ be _O_.[[ProxyTarget]].
        1. Let _trap_ be ? GetMethod(_handler_, `"deleteProperty"`).
        1. If _trap_ is *undefined*, then
          1. Return ? _target_.[[Delete]](_P_).
        1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, &laquo; _target_, _P_ &raquo;)).
        1. If _booleanTrapResult_ is *false*, return *false*.
        1. Let _targetDesc_ be ? _target_.[[GetOwnProperty]](_P_).
        1. If _targetDesc_ is *undefined*, return *true*.
        1. If _targetDesc_.[[Configurable]] is *false*, throw a *TypeError* exception.
        1. Return *true*.
      </emu-alg>
      <emu-note>
        <p>[[Delete]] for proxy objects enforces the following invariants:</p>
        <ul>
          <li>
            The result of [[Delete]] is a Boolean value.
          </li>
          <li>
            A property cannot be reported as deleted, if it exists as a non-configurable own property of the target object.
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-ownpropertykeys">
      <h1>[[OwnPropertyKeys]] ( )</h1>
      <p>When the [[OwnPropertyKeys]] internal method of a Proxy exotic object _O_ is called, the following steps are taken:</p>
      <emu-alg>
        1. Let _handler_ be _O_.[[ProxyHandler]].
        1. If _handler_ is *null*, throw a *TypeError* exception.
        1. Assert: Type(_handler_) is Object.
        1. Let _target_ be _O_.[[ProxyTarget]].
        1. Let _trap_ be ? GetMethod(_handler_, `"ownKeys"`).
        1. If _trap_ is *undefined*, then
          1. Return ? _target_.[[OwnPropertyKeys]]().
        1. Let _trapResultArray_ be ? Call(_trap_, _handler_, &laquo; _target_ &raquo;).
        1. Let _trapResult_ be ? CreateListFromArrayLike(_trapResultArray_, &laquo; String, Symbol &raquo;).
        1. If _trapResult_ contains any duplicate entries, throw a *TypeError* exception.
        1. Let _extensibleTarget_ be ? IsExtensible(_target_).
        1. Let _targetKeys_ be ? _target_.[[OwnPropertyKeys]]().
        1. Assert: _targetKeys_ is a List containing only String and Symbol values.
        1. Assert: _targetKeys_ contains no duplicate entries.
        1. Let _targetConfigurableKeys_ be a new empty List.
        1. Let _targetNonconfigurableKeys_ be a new empty List.
        1. For each element _key_ of _targetKeys_, do
          1. Let _desc_ be ? _target_.[[GetOwnProperty]](_key_).
          1. If _desc_ is not *undefined* and _desc_.[[Configurable]] is *false*, then
            1. Append _key_ as an element of _targetNonconfigurableKeys_.
          1. Else,
            1. Append _key_ as an element of _targetConfigurableKeys_.
        1. If _extensibleTarget_ is *true* and _targetNonconfigurableKeys_ is empty, then
          1. Return _trapResult_.
        1. Let _uncheckedResultKeys_ be a new List which is a copy of _trapResult_.
        1. For each _key_ that is an element of _targetNonconfigurableKeys_, do
          1. If _key_ is not an element of _uncheckedResultKeys_, throw a *TypeError* exception.
          1. Remove _key_ from _uncheckedResultKeys_.
        1. If _extensibleTarget_ is *true*, return _trapResult_.
        1. For each _key_ that is an element of _targetConfigurableKeys_, do
          1. If _key_ is not an element of _uncheckedResultKeys_, throw a *TypeError* exception.
          1. Remove _key_ from _uncheckedResultKeys_.
        1. If _uncheckedResultKeys_ is not empty, throw a *TypeError* exception.
        1. Return _trapResult_.
      </emu-alg>
      <emu-note>
        <p>[[OwnPropertyKeys]] for proxy objects enforces the following invariants:</p>
        <ul>
          <li>
            The result of [[OwnPropertyKeys]] is a List.
          </li>
          <li>
            The returned List contains no duplicate entries.
          </li>
          <li>
            The Type of each result List element is either String or Symbol.
          </li>
          <li>
            The result List must contain the keys of all non-configurable own properties of the target object.
          </li>
          <li>
            If the target object is not extensible, then the result List must contain all the keys of the own properties of the target object and no other values.
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist">
      <h1>[[Call]] ( _thisArgument_, _argumentsList_ )</h1>
      <p>The [[Call]] internal method of a Proxy exotic object _O_ is called with parameters _thisArgument_ and _argumentsList_, a List of ECMAScript language values. The following steps are taken:</p>
      <emu-alg>
        1. Let _handler_ be _O_.[[ProxyHandler]].
        1. If _handler_ is *null*, throw a *TypeError* exception.
        1. Assert: Type(_handler_) is Object.
        1. Let _target_ be _O_.[[ProxyTarget]].
        1. Let _trap_ be ? GetMethod(_handler_, `"apply"`).
        1. If _trap_ is *undefined*, then
          1. Return ? Call(_target_, _thisArgument_, _argumentsList_).
        1. Let _argArray_ be CreateArrayFromList(_argumentsList_).
        1. Return ? Call(_trap_, _handler_, &laquo; _target_, _thisArgument_, _argArray_ &raquo;).
      </emu-alg>
      <emu-note>
        <p>A Proxy exotic object only has a [[Call]] internal method if the initial value of its [[ProxyTarget]] internal slot is an object that has a [[Call]] internal method.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget">
      <h1>[[Construct]] ( _argumentsList_, _newTarget_ )</h1>
      <p>The [[Construct]] internal method of a Proxy exotic object _O_ is called with parameters _argumentsList_ which is a possibly empty List of ECMAScript language values and _newTarget_. The following steps are taken:</p>
      <emu-alg>
        1. Let _handler_ be _O_.[[ProxyHandler]].
        1. If _handler_ is *null*, throw a *TypeError* exception.
        1. Assert: Type(_handler_) is Object.
        1. Let _target_ be _O_.[[ProxyTarget]].
        1. Assert: IsConstructor(_target_) is *true*.
        1. Let _trap_ be ? GetMethod(_handler_, `"construct"`).
        1. If _trap_ is *undefined*, then
          1. Return ? Construct(_target_, _argumentsList_, _newTarget_).
        1. Let _argArray_ be CreateArrayFromList(_argumentsList_).
        1. Let _newObj_ be ? Call(_trap_, _handler_, &laquo; _target_, _argArray_, _newTarget_ &raquo;).
        1. If Type(_newObj_) is not Object, throw a *TypeError* exception.
        1. Return _newObj_.
      </emu-alg>
      <emu-note>
        <p>A Proxy exotic object only has a [[Construct]] internal method if the initial value of its [[ProxyTarget]] internal slot is an object that has a [[Construct]] internal method.</p>
      </emu-note>
      <emu-note>
        <p>[[Construct]] for proxy objects enforces the following invariants:</p>
        <ul>
          <li>
            The result of [[Construct]] must be an Object.
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxycreate" aoid="ProxyCreate">
      <h1>ProxyCreate ( _target_, _handler_ )</h1>
      <p>The abstract operation ProxyCreate with arguments _target_ and _handler_ is used to specify the creation of new Proxy exotic objects. It performs the following steps:</p>
      <emu-alg>
        1. If Type(_target_) is not Object, throw a *TypeError* exception.
        1. If _target_ is a Proxy exotic object and _target_.[[ProxyHandler]] is *null*, throw a *TypeError* exception.
        1. If Type(_handler_) is not Object, throw a *TypeError* exception.
        1. If _handler_ is a Proxy exotic object and _handler_.[[ProxyHandler]] is *null*, throw a *TypeError* exception.
        1. Let _P_ be a newly created Proxy exotic object with internal slots [[ProxyTarget]] and [[ProxyHandler]].
        1. Set _P_'s essential internal methods (except for [[Call]] and [[Construct]]) to the definitions specified in <emu-xref href="#sec-proxy-object-internal-methods-and-internal-slots"></emu-xref>.
        1. If IsCallable(_target_) is *true*, then
          1. Set _P_.[[Call]] as specified in <emu-xref href="#sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist"></emu-xref>.
          1. If IsConstructor(_target_) is *true*, then
            1. Set _P_.[[Construct]] as specified in <emu-xref href="#sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget"></emu-xref>.
        1. Set _P_.[[ProxyTarget]] to _target_.
        1. Set _P_.[[ProxyHandler]] to _handler_.
        1. Return _P_.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-source-code">
  <h1>ECMAScript Language: Source Code</h1>

  <emu-clause id="sec-source-text">
    <h1>Source Text</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      SourceCharacter ::
        &gt; any Unicode code point
    </emu-grammar>
    <p>ECMAScript code is expressed using Unicode. ECMAScript source text is a sequence of code points. All Unicode code point values from U+0000 to U+10FFFF, including surrogate code points, may occur in source text where permitted by the ECMAScript grammars. The actual encodings used to store and interchange ECMAScript source text is not relevant to this specification. Regardless of the external source text encoding, a conforming ECMAScript implementation processes the source text as if it was an equivalent sequence of |SourceCharacter| values, each |SourceCharacter| being a Unicode code point. Conforming ECMAScript implementations are not required to perform any normalization of source text, or behave as though they were performing normalization of source text.</p>
    <p>The components of a combining character sequence are treated as individual Unicode code points even though a user might think of the whole sequence as a single character.</p>
    <emu-note>
      <p>In string literals, regular expression literals, template literals and identifiers, any Unicode code point may also be expressed using Unicode escape sequences that explicitly express a code point's numeric value. Within a comment, such an escape sequence is effectively ignored as part of the comment.</p>
      <p>ECMAScript differs from the Java programming language in the behaviour of Unicode escape sequences. In a Java program, if the Unicode escape sequence `\\u000A`, for example, occurs within a single-line comment, it is interpreted as a line terminator (Unicode code point U+000A is LINE FEED (LF)) and therefore the next code point is not part of the comment. Similarly, if the Unicode escape sequence `\\u000A` occurs within a string literal in a Java program, it is likewise interpreted as a line terminator, which is not allowed within a string literal&mdash;one must write `\\n` instead of `\\u000A` to cause a LINE FEED (LF) to be part of the String value of a string literal. In an ECMAScript program, a Unicode escape sequence occurring within a comment is never interpreted and therefore cannot contribute to termination of the comment. Similarly, a Unicode escape sequence occurring within a string literal in an ECMAScript program always contributes to the literal and is never interpreted as a line terminator or as a code point that might terminate the string literal.</p>
    </emu-note>

    <emu-clause id="sec-utf16encoding" aoid="UTF16Encoding">
      <h1>Static Semantics: UTF16Encoding ( _cp_ )</h1>
      <p>The UTF16Encoding of a numeric code point value, _cp_, is determined as follows:</p>
      <emu-alg>
        1. Assert: 0 &le; _cp_ &le; 0x10FFFF.
        1. If _cp_ &le; 0xFFFF, return _cp_.
        1. Let _cu1_ be floor((_cp_ - 0x10000) / 0x400) + 0xD800.
        1. Let _cu2_ be ((_cp_ - 0x10000) modulo 0x400) + 0xDC00.
        1. Return the code unit sequence consisting of _cu1_ followed by _cu2_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-utf16decode" aoid="UTF16Decode">
      <h1>Static Semantics: UTF16Decode ( _lead_, _trail_ )</h1>
      <p>Two code units, _lead_ and _trail_, that form a UTF-16 <emu-xref href="#surrogate-pair"></emu-xref> are converted to a code point by performing the following steps:</p>
      <emu-alg>
        1. Assert: _lead_ is a <emu-xref href="#leading-surrogate"></emu-xref> and _trail_ is a <emu-xref href="#trailing-surrogate"></emu-xref>.
        1. Let _cp_ be (_lead_ - 0xD800) &times; 0x400 + (_trail_ - 0xDC00) + 0x10000.
        1. Return the code point _cp_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-types-of-source-code">
    <h1>Types of Source Code</h1>
    <p>There are four types of ECMAScript code:</p>
    <ul>
      <li>
        <em>Global code</em> is source text that is treated as an ECMAScript |Script|. The global code of a particular |Script| does not include any source text that is parsed as part of a |FunctionDeclaration|, |FunctionExpression|, |GeneratorDeclaration|, |GeneratorExpression|, |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, |MethodDefinition|, |ArrowFunction|, |AsyncArrowFunction|, |ClassDeclaration|, or |ClassExpression|.
      </li>
      <li>
        <em>Eval code</em> is the source text supplied to the built-in `eval` function. More precisely, if the parameter to the built-in `eval` function is a String, it is treated as an ECMAScript |Script|. The eval code for a particular invocation of `eval` is the global code portion of that |Script|.
      </li>
      <li>
        <em>Function code</em> is source text that is parsed to supply the value of the [[ECMAScriptCode]] and [[FormalParameters]] internal slots (see <emu-xref href="#sec-ecmascript-function-objects"></emu-xref>) of an ECMAScript function object. The function code of a particular ECMAScript function does not include any source text that is parsed as the function code of a nested |FunctionDeclaration|, |FunctionExpression|, |GeneratorDeclaration|, |GeneratorExpression|, |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, |MethodDefinition|, |ArrowFunction|, |AsyncArrowFunction|, |ClassDeclaration|, or |ClassExpression|.
      </li>
      <li>
        <em>Module code</em> is source text that is code that is provided as a |ModuleBody|. It is the code that is directly evaluated when a module is initialized. The module code of a particular module does not include any source text that is parsed as part of a nested |FunctionDeclaration|, |FunctionExpression|, |GeneratorDeclaration|, |GeneratorExpression|, |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, |MethodDefinition|, |ArrowFunction|, |AsyncArrowFunction|, |ClassDeclaration|, or |ClassExpression|.
      </li>
    </ul>
    <emu-note>
      <p>Function code is generally provided as the bodies of Function Definitions (<emu-xref href="#sec-function-definitions"></emu-xref>), Arrow Function Definitions (<emu-xref href="#sec-arrow-function-definitions"></emu-xref>), Method Definitions (<emu-xref href="#sec-method-definitions"></emu-xref>), Generator Function Definitions (<emu-xref href="#sec-generator-function-definitions"></emu-xref>), Async Function Definitions (<emu-xref href="#sec-async-function-definitions"></emu-xref>), Async Generator Function Definitions (<emu-xref href="#sec-async-generator-function-definitions"></emu-xref>), and Async Arrow Functions (<emu-xref href="#sec-async-arrow-function-definitions"></emu-xref>). Function code is also derived from the arguments to the `Function` constructor (<emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref>), the `GeneratorFunction` constructor (<emu-xref href="#sec-generatorfunction"></emu-xref>), and the `AsyncFunction` constructor (<emu-xref href="#sec-async-function-constructor-arguments"></emu-xref>).</p>
    </emu-note>

    <emu-clause id="sec-strict-mode-code">
      <h1>Strict Mode Code</h1>
      <p>An ECMAScript |Script| syntactic unit may be processed using either unrestricted or strict mode syntax and semantics. Code is interpreted as <dfn>strict mode code</dfn> in the following situations:</p>
      <ul>
        <li>
          Global code is strict mode code if it begins with a Directive Prologue that contains a Use Strict Directive.
        </li>
        <li>
          Module code is always strict mode code.
        </li>
        <li>
          All parts of a |ClassDeclaration| or a |ClassExpression| are strict mode code.
        </li>
        <li>
          Eval code is strict mode code if it begins with a Directive Prologue that contains a Use Strict Directive or if the call to `eval` is a direct eval that is contained in strict mode code.
        </li>
        <li>
          Function code is strict mode code if the associated |FunctionDeclaration|, |FunctionExpression|, |GeneratorDeclaration|, |GeneratorExpression|, |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, |MethodDefinition|, |ArrowFunction|, or |AsyncArrowFunction| is contained in strict mode code or if the code that produces the value of the function's [[ECMAScriptCode]] internal slot begins with a Directive Prologue that contains a Use Strict Directive.
        </li>
        <li>
          Function code that is supplied as the arguments to the built-in `Function`, `Generator`, `AsyncFunction`, and `AsyncGenerator` constructors is strict mode code if the last argument is a String that when processed is a |FunctionBody| that begins with a Directive Prologue that contains a Use Strict Directive.
        </li>
      </ul>
      <p>ECMAScript code that is not strict mode code is called <dfn id="non-strict-code">non-strict code</dfn>.</p>
    </emu-clause>

    <emu-clause id="sec-non-ecmascript-functions">
      <h1>Non-ECMAScript Functions</h1>
      <p>An ECMAScript implementation may support the evaluation of function exotic objects whose evaluative behaviour is expressed in some implementation-defined form of executable code other than via ECMAScript code. Whether a function object is an ECMAScript code function or a non-ECMAScript function is not semantically observable from the perspective of an ECMAScript code function that calls or is called by such a non-ECMAScript function.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-lexical-grammar">
  <h1>ECMAScript Language: Lexical Grammar</h1>
  <p>The source text of an ECMAScript |Script| or |Module| is first converted into a sequence of input elements, which are tokens, line terminators, comments, or white space. The source text is scanned from left to right, repeatedly taking the longest possible sequence of code points as the next input element.</p>
  <p>There are several situations where the identification of lexical input elements is sensitive to the syntactic grammar context that is consuming the input elements. This requires multiple goal symbols for the lexical grammar. The |InputElementRegExpOrTemplateTail| goal is used in syntactic grammar contexts where a |RegularExpressionLiteral|, a |TemplateMiddle|, or a |TemplateTail| is permitted. The |InputElementRegExp| goal symbol is used in all syntactic grammar contexts where a |RegularExpressionLiteral| is permitted but neither a |TemplateMiddle|, nor a |TemplateTail| is permitted. The |InputElementTemplateTail| goal is used in all syntactic grammar contexts where a |TemplateMiddle| or a |TemplateTail| is permitted but a |RegularExpressionLiteral| is not permitted. In all other contexts, |InputElementDiv| is used as the lexical goal symbol.</p>
  <emu-note>
    <p>The use of multiple lexical goals ensures that there are no lexical ambiguities that would affect automatic semicolon insertion. For example, there are no syntactic grammar contexts where both a leading division or division-assignment, and a leading |RegularExpressionLiteral| are permitted. This is not affected by semicolon insertion (see <emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>); in examples such as the following:</p>
    <pre><code class="javascript">
      a = b
      /hi/g.exec(c).map(d);
    </code></pre>
    <p>where the first non-whitespace, non-comment code point after a |LineTerminator| is U+002F (SOLIDUS) and the syntactic context allows division or division-assignment, no semicolon is inserted at the |LineTerminator|. That is, the above example is interpreted in the same way as:</p>
    <pre><code class="javascript">
      a = b / hi / g.exec(c).map(d);
    </code></pre>
  </emu-note>
  <h2>Syntax</h2>
  <emu-grammar type="definition">
    InputElementDiv ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      DivPunctuator
      RightBracePunctuator

    InputElementRegExp ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      RightBracePunctuator
      RegularExpressionLiteral

    InputElementRegExpOrTemplateTail ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      RegularExpressionLiteral
      TemplateSubstitutionTail

    InputElementTemplateTail ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      DivPunctuator
      TemplateSubstitutionTail
  </emu-grammar>

  <emu-clause id="sec-unicode-format-control-characters">
    <h1>Unicode Format-Control Characters</h1>
    <p>The Unicode format-control characters (i.e., the characters in category &ldquo;Cf&rdquo; in the Unicode Character Database such as LEFT-TO-RIGHT MARK or RIGHT-TO-LEFT MARK) are control codes used to control the formatting of a range of text in the absence of higher-level protocols for this (such as mark-up languages).</p>
    <p>It is useful to allow format-control characters in source text to facilitate editing and display. All format control characters may be used within comments, and within string literals, template literals, and regular expression literals.</p>
    <p>U+200C (ZERO WIDTH NON-JOINER) and U+200D (ZERO WIDTH JOINER) are format-control characters that are used to make necessary distinctions when forming words or phrases in certain languages. In ECMAScript source text these code points may also be used in an |IdentifierName| after the first character.</p>
    <p>U+FEFF (ZERO WIDTH NO-BREAK SPACE) is a format-control character used primarily at the start of a text to mark it as Unicode and to allow detection of the text's encoding and byte order. &lt;ZWNBSP&gt; characters intended for this purpose can sometimes also appear after the start of a text, for example as a result of concatenating files. In ECMAScript source text &lt;ZWNBSP&gt; code points are treated as white space characters (see <emu-xref href="#sec-white-space"></emu-xref>).</p>
    <p>The special treatment of certain format-control characters outside of comments, string literals, and regular expression literals is summarized in <emu-xref href="#table-31"></emu-xref>.</p>
    <emu-table id="table-31" caption="Format-Control Code Point Usage">
      <table>
        <tbody>
        <tr>
          <th>
            Code Point
          </th>
          <th>
            Name
          </th>
          <th>
            Abbreviation
          </th>
          <th>
            Usage
          </th>
        </tr>
        <tr>
          <td>
            `U+200C`
          </td>
          <td>
            ZERO WIDTH NON-JOINER
          </td>
          <td>
            &lt;ZWNJ&gt;
          </td>
          <td>
            |IdentifierPart|
          </td>
        </tr>
        <tr>
          <td>
            `U+200D`
          </td>
          <td>
            ZERO WIDTH JOINER
          </td>
          <td>
            &lt;ZWJ&gt;
          </td>
          <td>
            |IdentifierPart|
          </td>
        </tr>
        <tr>
          <td>
            `U+FEFF`
          </td>
          <td>
            ZERO WIDTH NO-BREAK SPACE
          </td>
          <td>
            &lt;ZWNBSP&gt;
          </td>
          <td>
            |WhiteSpace|
          </td>
        </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-white-space">
    <h1>White Space</h1>
    <p>White space code points are used to improve source text readability and to separate tokens (indivisible lexical units) from each other, but are otherwise insignificant. White space code points may occur between any two tokens and at the start or end of input. White space code points may occur within a |StringLiteral|, a |RegularExpressionLiteral|, a |Template|, or a |TemplateSubstitutionTail| where they are considered significant code points forming part of a literal value. They may also occur within a |Comment|, but cannot appear within any other kind of token.</p>
    <p>The ECMAScript white space code points are listed in <emu-xref href="#table-32"></emu-xref>.</p>
    <emu-table id="table-32" caption="White Space Code Points">
      <table>
        <tbody>
        <tr>
          <th>
            Code Point
          </th>
          <th>
            Name
          </th>
          <th>
            Abbreviation
          </th>
        </tr>
        <tr>
          <td>
            `U+0009`
          </td>
          <td>
            CHARACTER TABULATION
          </td>
          <td>
            &lt;TAB&gt;
          </td>
        </tr>
        <tr>
          <td>
            `U+000B`
          </td>
          <td>
            LINE TABULATION
          </td>
          <td>
            &lt;VT&gt;
          </td>
        </tr>
        <tr>
          <td>
            `U+000C`
          </td>
          <td>
            FORM FEED (FF)
          </td>
          <td>
            &lt;FF&gt;
          </td>
        </tr>
        <tr>
          <td>
            `U+0020`
          </td>
          <td>
            SPACE
          </td>
          <td>
            &lt;SP&gt;
          </td>
        </tr>
        <tr>
          <td>
            `U+00A0`
          </td>
          <td>
            NO-BREAK SPACE
          </td>
          <td>
            &lt;NBSP&gt;
          </td>
        </tr>
        <tr>
          <td>
            `U+FEFF`
          </td>
          <td>
            ZERO WIDTH NO-BREAK SPACE
          </td>
          <td>
            &lt;ZWNBSP&gt;
          </td>
        </tr>
        <tr>
          <td>
            Other category &ldquo;Zs&rdquo;
          </td>
          <td>
            Any other Unicode &ldquo;Space_Separator&rdquo; code point
          </td>
          <td>
            &lt;USP&gt;
          </td>
        </tr>
        </tbody>
      </table>
    </emu-table>
    <p>ECMAScript implementations must recognize as |WhiteSpace| code points listed in the &ldquo;Space_Separator&rdquo; (&ldquo;Zs&rdquo;) category.</p>
    <emu-note>
      <p>Other than for the code points listed in <emu-xref href="#table-32"></emu-xref>, ECMAScript |WhiteSpace| intentionally excludes all code points that have the Unicode &ldquo;White_Space&rdquo; property but which are not classified in category &ldquo;Space_Separator&rdquo; (&ldquo;Zs&rdquo;).</p>
    </emu-note>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      WhiteSpace ::
        &lt;TAB&gt;
        &lt;VT&gt;
        &lt;FF&gt;
        &lt;SP&gt;
        &lt;NBSP&gt;
        &lt;ZWNBSP&gt;
        &lt;USP&gt;
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-line-terminators">
    <h1>Line Terminators</h1>
    <p>Like white space code points, line terminator code points are used to improve source text readability and to separate tokens (indivisible lexical units) from each other. However, unlike white space code points, line terminators have some influence over the behaviour of the syntactic grammar. In general, line terminators may occur between any two tokens, but there are a few places where they are forbidden by the syntactic grammar. Line terminators also affect the process of automatic semicolon insertion (<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>). A line terminator cannot occur within any token except a |StringLiteral|, |Template|, or |TemplateSubstitutionTail|. &lt;LF&gt; and &lt;CR&gt; line terminators cannot occur within a |StringLiteral| token except as part of a |LineContinuation|.</p>
    <p>A line terminator can occur within a |MultiLineComment| but cannot occur within a |SingleLineComment|.</p>
    <p>Line terminators are included in the set of white space code points that are matched by the `\\s` class in regular expressions.</p>
    <p>The ECMAScript line terminator code points are listed in <emu-xref href="#table-33"></emu-xref>.</p>
    <emu-table id="table-33" caption="Line Terminator Code Points">
      <table>
        <tbody>
        <tr>
          <th>
            Code Point
          </th>
          <th>
            Unicode Name
          </th>
          <th>
            Abbreviation
          </th>
        </tr>
        <tr>
          <td>
            `U+000A`
          </td>
          <td>
            LINE FEED (LF)
          </td>
          <td>
            &lt;LF&gt;
          </td>
        </tr>
        <tr>
          <td>
            `U+000D`
          </td>
          <td>
            CARRIAGE RETURN (CR)
          </td>
          <td>
            &lt;CR&gt;
          </td>
        </tr>
        <tr>
          <td>
            `U+2028`
          </td>
          <td>
            LINE SEPARATOR
          </td>
          <td>
            &lt;LS&gt;
          </td>
        </tr>
        <tr>
          <td>
            `U+2029`
          </td>
          <td>
            PARAGRAPH SEPARATOR
          </td>
          <td>
            &lt;PS&gt;
          </td>
        </tr>
        </tbody>
      </table>
    </emu-table>
    <p>Only the Unicode code points in <emu-xref href="#table-33"></emu-xref> are treated as line terminators. Other new line or line breaking Unicode code points are not treated as line terminators but are treated as white space if they meet the requirements listed in <emu-xref href="#table-32"></emu-xref>. The sequence &lt;CR&gt;&lt;LF&gt; is commonly used as a line terminator. It should be considered a single |SourceCharacter| for the purpose of reporting line numbers.</p>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      LineTerminator ::
        &lt;LF&gt;
        &lt;CR&gt;
        &lt;LS&gt;
        &lt;PS&gt;

      LineTerminatorSequence ::
        &lt;LF&gt;
        &lt;CR&gt; [lookahead != &lt;LF&gt; ]
        &lt;LS&gt;
        &lt;PS&gt;
        &lt;CR&gt; &lt;LF&gt;
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-comments">
    <h1>Comments</h1>
    <p>Comments can be either single or multi-line. Multi-line comments cannot nest.</p>
    <p>Because a single-line comment can contain any Unicode code point except a |LineTerminator| code point, and because of the general rule that a token is always as long as possible, a single-line comment always consists of all code points from the `//` marker to the end of the line. However, the |LineTerminator| at the end of the line is not considered to be part of the single-line comment; it is recognized separately by the lexical grammar and becomes part of the stream of input elements for the syntactic grammar. This point is very important, because it implies that the presence or absence of single-line comments does not affect the process of automatic semicolon insertion (see <emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>).</p>
    <p>Comments behave like white space and are discarded except that, if a |MultiLineComment| contains a line terminator code point, then the entire comment is considered to be a |LineTerminator| for purposes of parsing by the syntactic grammar.</p>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      Comment ::
        MultiLineComment
        SingleLineComment

      MultiLineComment ::
        `/*` MultiLineCommentChars? `*/`

      MultiLineCommentChars ::
        MultiLineNotAsteriskChar MultiLineCommentChars?
        `*` PostAsteriskCommentChars?

      PostAsteriskCommentChars ::
        MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars?
        `*` PostAsteriskCommentChars?

      MultiLineNotAsteriskChar ::
        SourceCharacter but not `*`

      MultiLineNotForwardSlashOrAsteriskChar ::
        SourceCharacter but not one of `/` or `*`

      SingleLineComment ::
        `//` SingleLineCommentChars?

      SingleLineCommentChars ::
        SingleLineCommentChar SingleLineCommentChars?

      SingleLineCommentChar ::
        SourceCharacter but not LineTerminator
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-tokens">
    <h1>Tokens</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      CommonToken ::
        IdentifierName
        Punctuator
        NumericLiteral
        StringLiteral
        Template
    </emu-grammar>
    <emu-note>
      <p>The |DivPunctuator|, |RegularExpressionLiteral|, |RightBracePunctuator|, and |TemplateSubstitutionTail| productions derive additional tokens that are not included in the |CommonToken| production.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-names-and-keywords">
    <h1>Names and Keywords</h1>
    <p>|IdentifierName| and |ReservedWord| are tokens that are interpreted according to the Default Identifier Syntax given in Unicode Standard Annex #31, Identifier and Pattern Syntax, with some small modifications. |ReservedWord| is an enumerated subset of |IdentifierName|. The syntactic grammar defines |Identifier| as an |IdentifierName| that is not a |ReservedWord|. The Unicode identifier grammar is based on character properties specified by the Unicode Standard. The Unicode code points in the specified categories in the latest version of the Unicode standard must be treated as in those categories by all conforming ECMAScript implementations. ECMAScript implementations may recognize identifier code points defined in later editions of the Unicode Standard.</p>
    <emu-note>
      <p>This standard specifies specific code point additions: U+0024 (DOLLAR SIGN) and U+005F (LOW LINE) are permitted anywhere in an |IdentifierName|, and the code points U+200C (ZERO WIDTH NON-JOINER) and U+200D (ZERO WIDTH JOINER) are permitted anywhere after the first code point of an |IdentifierName|.</p>
    </emu-note>
    <p>Unicode escape sequences are permitted in an |IdentifierName|, where they contribute a single Unicode code point to the |IdentifierName|. The code point is expressed by the |CodePoint| of the |UnicodeEscapeSequence| (see <emu-xref href="#sec-literals-string-literals"></emu-xref>). The `\\` preceding the |UnicodeEscapeSequence| and the `u` and `{ }` code units, if they appear, do not contribute code points to the |IdentifierName|. A |UnicodeEscapeSequence| cannot be used to put a code point into an |IdentifierName| that would otherwise be illegal. In other words, if a `\\` |UnicodeEscapeSequence| sequence were replaced by the |SourceCharacter| it contributes, the result must still be a valid |IdentifierName| that has the exact same sequence of |SourceCharacter| elements as the original |IdentifierName|. All interpretations of |IdentifierName| within this specification are based upon their actual code points regardless of whether or not an escape sequence was used to contribute any particular code point.</p>
    <p>Two |IdentifierName|s that are canonically equivalent according to the Unicode standard are <em>not</em> equal unless, after replacement of each |UnicodeEscapeSequence|, they are represented by the exact same sequence of code points.</p>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      IdentifierName ::
        IdentifierStart
        IdentifierName IdentifierPart

      IdentifierStart ::
        UnicodeIDStart
        `$`
        `_`
        `\` UnicodeEscapeSequence

      IdentifierPart ::
        UnicodeIDContinue
        `$`
        `\` UnicodeEscapeSequence
        &lt;ZWNJ&gt;
        &lt;ZWJ&gt;

      UnicodeIDStart ::
        &gt; any Unicode code point with the Unicode property &ldquo;ID_Start&rdquo;

      UnicodeIDContinue ::
        &gt; any Unicode code point with the Unicode property &ldquo;ID_Continue&rdquo;
    </emu-grammar>
    <p>The definitions of the nonterminal |UnicodeEscapeSequence| is given in <emu-xref href="#sec-literals-string-literals"></emu-xref>.</p>
    <emu-note>
      <p>The nonterminal |IdentifierPart| derives `_` via |UnicodeIDContinue|.</p>
    </emu-note>
    <emu-note>
      <p>The sets of code points with Unicode properties &ldquo;ID_Start&rdquo; and &ldquo;ID_Continue&rdquo; include, respectively, the code points with Unicode properties &ldquo;Other_ID_Start&rdquo; and &ldquo;Other_ID_Continue&rdquo;.</p>
    </emu-note>

    <emu-clause id="sec-identifier-names">
      <h1>Identifier Names</h1>

      <emu-clause id="sec-identifier-names-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>IdentifierStart :: `\` UnicodeEscapeSequence</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if SV(|UnicodeEscapeSequence|) is none of `"$"`, or `"_"`, or the UTF16Encoding of a code point matched by the |UnicodeIDStart| lexical grammar production.
          </li>
        </ul>
        <emu-grammar>IdentifierPart :: `\` UnicodeEscapeSequence</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if SV(|UnicodeEscapeSequence|) is none of `"$"`, or `"_"`, or the UTF16Encoding of either &lt;ZWNJ&gt; or &lt;ZWJ&gt;, or the UTF16Encoding of a Unicode code point that would be matched by the |UnicodeIDContinue| lexical grammar production.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-identifier-names-static-semantics-stringvalue">
        <h1>Static Semantics: StringValue</h1>
        <emu-see-also-para op="StringValue"></emu-see-also-para>
        <emu-grammar>
          IdentifierName ::
            IdentifierStart
            IdentifierName IdentifierPart
        </emu-grammar>
        <emu-alg>
          1. Return the String value consisting of the sequence of code units corresponding to |IdentifierName|. In determining the sequence any occurrences of `\\` |UnicodeEscapeSequence| are first replaced with the code point represented by the |UnicodeEscapeSequence| and then the code points of the entire |IdentifierName| are converted to code units by UTF16Encoding each code point.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-reserved-words">
      <h1>Reserved Words</h1>
      <p>A reserved word is an |IdentifierName| that cannot be used as an |Identifier|.</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ReservedWord ::
          Keyword
          FutureReservedWord
          NullLiteral
          BooleanLiteral
      </emu-grammar>
      <emu-note>
        <p>The |ReservedWord| definitions are specified as literal sequences of specific |SourceCharacter| elements. A code point in a |ReservedWord| cannot be expressed by a `\\` |UnicodeEscapeSequence|.</p>
      </emu-note>

      <emu-clause id="sec-keywords">
        <h1>Keywords</h1>
        <p>The following tokens are ECMAScript keywords and may not be used as |Identifier|s in ECMAScript programs.</p>
        <h2>Syntax</h2>
        <emu-grammar type="definition">
          Keyword :: one of
            `await`
            `break`
            `case` `catch` `class` `const` `continue`
            `debugger` `default` `delete` `do`
            `else` `export` `extends`
            `finally` `for` `function`
            `if` `import` `in` `instanceof`
            `new`
            `return`
            `super` `switch`
            `this` `throw` `try` `typeof`
            `var` `void`
            `while` `with`
            `yield`
        </emu-grammar>
        <emu-note>
          <p>In some contexts `yield` and `await` are given the semantics of an |Identifier|. See <emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref>. In strict mode code, `let` and `static` are treated as reserved words through static semantic restrictions (see <emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-let-and-const-declarations-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-for-in-and-for-of-statements-static-semantics-early-errors"></emu-xref>, and <emu-xref href="#sec-class-definitions-static-semantics-early-errors"></emu-xref>) rather than the lexical grammar.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-future-reserved-words">
        <h1>Future Reserved Words</h1>
        <p>The following tokens are reserved for use as keywords in future language extensions.</p>
        <h2>Syntax</h2>
        <emu-grammar type="definition">
          FutureReservedWord ::
            `enum`
        </emu-grammar>
        <emu-note>
          <p>Use of the following tokens within strict mode code is also reserved. That usage is restricted using static semantic restrictions (see <emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref>) rather than the lexical grammar:</p>
          <figure>
            <table class="lightweight-table">
              <tbody>
              <tr>
                <td>
                  `implements`
                </td>
                <td>
                  `package`
                </td>
                <td>
                  `protected`
                </td>
                <td>
                </td>
              </tr>
              <tr>
                <td>
                  `interface`
                </td>
                <td>
                  `private`
                </td>
                <td>
                  `public`
                </td>
                <td>
                </td>
              </tr>
              </tbody>
            </table>
          </figure>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-punctuators">
    <h1>Punctuators</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      Punctuator :: one of
        `{` `(` `)` `[` `]`
        `.` `...` `;` `,`
        `&lt;` `&gt;` `&lt;=` `&gt;=`
        `==` `!=` `===` `!==`
        `+` `-` `*` `%` `**`
        `++` `--`
        `&lt;&lt;` `&gt;&gt;` `&gt;&gt;&gt;`
        `&amp;` `|` `^`
        `!` `~`
        `&amp;&amp;` `||`
        `?` `:`
        `=` `+=` `-=` `*=` `%=` `**=` `&lt;&lt;=` `&gt;&gt;=` `&gt;&gt;&gt;=` `&amp;=` `|=` `^=`
        `=&gt;`

      DivPunctuator ::
        `/`
        `/=`

      RightBracePunctuator ::
        `}`
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-ecmascript-language-lexical-grammar-literals">
    <h1>Literals</h1>

    <emu-clause id="sec-null-literals">
      <h1>Null Literals</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        NullLiteral ::
          `null`
      </emu-grammar>
    </emu-clause>

    <emu-clause id="sec-boolean-literals">
      <h1>Boolean Literals</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        BooleanLiteral ::
          `true`
          `false`
      </emu-grammar>
    </emu-clause>

    <emu-clause id="sec-literals-numeric-literals">
      <h1>Numeric Literals</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        NumericLiteral ::
          DecimalLiteral
          BinaryIntegerLiteral
          OctalIntegerLiteral
          HexIntegerLiteral

        DecimalLiteral ::
          DecimalIntegerLiteral `.` DecimalDigits? ExponentPart?
          `.` DecimalDigits ExponentPart?
          DecimalIntegerLiteral ExponentPart?

        DecimalIntegerLiteral ::
          `0`
          NonZeroDigit DecimalDigits?

        DecimalDigits ::
          DecimalDigit
          DecimalDigits DecimalDigit

        DecimalDigit :: one of
          `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`

        NonZeroDigit :: one of
          `1` `2` `3` `4` `5` `6` `7` `8` `9`

        ExponentPart ::
          ExponentIndicator SignedInteger

        ExponentIndicator :: one of
          `e` `E`

        SignedInteger ::
          DecimalDigits
          `+` DecimalDigits
          `-` DecimalDigits

        BinaryIntegerLiteral ::
          `0b` BinaryDigits
          `0B` BinaryDigits

        BinaryDigits ::
          BinaryDigit
          BinaryDigits BinaryDigit

        BinaryDigit :: one of
          `0` `1`

        OctalIntegerLiteral ::
          `0o` OctalDigits
          `0O` OctalDigits

        OctalDigits ::
          OctalDigit
          OctalDigits OctalDigit

        OctalDigit :: one of
          `0` `1` `2` `3` `4` `5` `6` `7`

        HexIntegerLiteral ::
          `0x` HexDigits
          `0X` HexDigits

        HexDigits ::
          HexDigit
          HexDigits HexDigit

        HexDigit :: one of
          `0` `1` `2` `3` `4` `5` `6` `7` `8` `9` `a` `b` `c` `d` `e` `f` `A` `B` `C` `D` `E` `F`
      </emu-grammar>
      <p>The |SourceCharacter| immediately following a |NumericLiteral| must not be an |IdentifierStart| or |DecimalDigit|.</p>
      <emu-note>
        <p>For example: `3in` is an error and not the two input elements `3` and `in`.</p>
      </emu-note>
      <p>A conforming implementation, when processing strict mode code, must not extend, as described in <emu-xref href="#sec-additional-syntax-numeric-literals"></emu-xref>, the syntax of |NumericLiteral| to include <emu-xref href="#prod-annexB-LegacyOctalIntegerLiteral"></emu-xref>, nor extend the syntax of |DecimalIntegerLiteral| to include <emu-xref href="#prod-annexB-NonOctalDecimalIntegerLiteral"></emu-xref>.</p>

      <emu-clause id="sec-static-semantics-mv">
        <h1>Static Semantics: MV</h1>
        <p>A numeric literal stands for a value of the Number type. This value is determined in two steps: first, a mathematical value (MV) is derived from the literal; second, this mathematical value is rounded as described below.</p>
        <ul>
          <li>
            The MV of <emu-grammar>NumericLiteral :: DecimalLiteral</emu-grammar> is the MV of |DecimalLiteral|.
          </li>
          <li>
            The MV of <emu-grammar>NumericLiteral :: BinaryIntegerLiteral</emu-grammar> is the MV of |BinaryIntegerLiteral|.
          </li>
          <li>
            The MV of <emu-grammar>NumericLiteral :: OctalIntegerLiteral</emu-grammar> is the MV of |OctalIntegerLiteral|.
          </li>
          <li>
            The MV of <emu-grammar>NumericLiteral :: HexIntegerLiteral</emu-grammar> is the MV of |HexIntegerLiteral|.
          </li>
          <li>
            The MV of <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral `.`</emu-grammar> is the MV of |DecimalIntegerLiteral|.
          </li>
          <li>
            The MV of <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral `.` DecimalDigits</emu-grammar> is the MV of |DecimalIntegerLiteral| plus (the MV of |DecimalDigits| &times; 10<sup>-_n_</sup>), where _n_ is the number of code points in |DecimalDigits|.
          </li>
          <li>
            The MV of <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral `.` ExponentPart</emu-grammar> is the MV of |DecimalIntegerLiteral| &times; 10<sup>_e_</sup>, where _e_ is the MV of |ExponentPart|.
          </li>
          <li>
            The MV of <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral `.` DecimalDigits ExponentPart</emu-grammar> is (the MV of |DecimalIntegerLiteral| plus (the MV of |DecimalDigits| &times; 10<sup>-_n_</sup>)) &times; 10<sup>_e_</sup>, where _n_ is the number of code points in |DecimalDigits| and _e_ is the MV of |ExponentPart|.
          </li>
          <li>
            The MV of <emu-grammar>DecimalLiteral :: `.` DecimalDigits</emu-grammar> is the MV of |DecimalDigits| &times; 10<sup>-_n_</sup>, where _n_ is the number of code points in |DecimalDigits|.
          </li>
          <li>
            The MV of <emu-grammar>DecimalLiteral :: `.` DecimalDigits ExponentPart</emu-grammar> is the MV of |DecimalDigits| &times; 10<sup>_e_ - _n_</sup>, where _n_ is the number of code points in |DecimalDigits| and _e_ is the MV of |ExponentPart|.
          </li>
          <li>
            The MV of <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral</emu-grammar> is the MV of |DecimalIntegerLiteral|.
          </li>
          <li>
            The MV of <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral ExponentPart</emu-grammar> is the MV of |DecimalIntegerLiteral| &times; 10<sup>_e_</sup>, where _e_ is the MV of |ExponentPart|.
          </li>
          <li>
            The MV of <emu-grammar>DecimalIntegerLiteral :: `0`</emu-grammar> is 0.
          </li>
          <li>
            The MV of <emu-grammar>DecimalIntegerLiteral :: NonZeroDigit</emu-grammar> is the MV of |NonZeroDigit|.
          </li>
          <li>
            The MV of <emu-grammar>DecimalIntegerLiteral :: NonZeroDigit DecimalDigits</emu-grammar> is (the MV of |NonZeroDigit| &times; 10<sup>_n_</sup>) plus the MV of |DecimalDigits|, where _n_ is the number of code points in |DecimalDigits|.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigits :: DecimalDigit</emu-grammar> is the MV of |DecimalDigit|.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigits :: DecimalDigits DecimalDigit</emu-grammar> is (the MV of |DecimalDigits| &times; 10) plus the MV of |DecimalDigit|.
          </li>
          <li>
            The MV of <emu-grammar>ExponentPart :: ExponentIndicator SignedInteger</emu-grammar> is the MV of |SignedInteger|.
          </li>
          <li>
            The MV of <emu-grammar>SignedInteger :: DecimalDigits</emu-grammar> is the MV of |DecimalDigits|.
          </li>
          <li>
            The MV of <emu-grammar>SignedInteger :: `+` DecimalDigits</emu-grammar> is the MV of |DecimalDigits|.
          </li>
          <li>
            The MV of <emu-grammar>SignedInteger :: `-` DecimalDigits</emu-grammar> is the negative of the MV of |DecimalDigits|.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigit :: `0`</emu-grammar> or of <emu-grammar>HexDigit :: `0`</emu-grammar> or of <emu-grammar>OctalDigit :: `0`</emu-grammar> or of <emu-grammar>BinaryDigit :: `0`</emu-grammar> is 0.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigit :: `1`</emu-grammar> or of <emu-grammar>NonZeroDigit :: `1`</emu-grammar> or of <emu-grammar>HexDigit :: `1`</emu-grammar> or of <emu-grammar>OctalDigit :: `1`</emu-grammar> or of <emu-grammar>BinaryDigit :: `1`</emu-grammar> is 1.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigit :: `2`</emu-grammar> or of <emu-grammar>NonZeroDigit :: `2`</emu-grammar> or of <emu-grammar>HexDigit :: `2`</emu-grammar> or of <emu-grammar>OctalDigit :: `2`</emu-grammar> is 2.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigit :: `3`</emu-grammar> or of <emu-grammar>NonZeroDigit :: `3`</emu-grammar> or of <emu-grammar>HexDigit :: `3`</emu-grammar> or of <emu-grammar>OctalDigit :: `3`</emu-grammar> is 3.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigit :: `4`</emu-grammar> or of <emu-grammar>NonZeroDigit :: `4`</emu-grammar> or of <emu-grammar>HexDigit :: `4`</emu-grammar> or of <emu-grammar>OctalDigit :: `4`</emu-grammar> is 4.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigit :: `5`</emu-grammar> or of <emu-grammar>NonZeroDigit :: `5`</emu-grammar> or of <emu-grammar>HexDigit :: `5`</emu-grammar> or of <emu-grammar>OctalDigit :: `5`</emu-grammar> is 5.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigit :: `6`</emu-grammar> or of <emu-grammar>NonZeroDigit :: `6`</emu-grammar> or of <emu-grammar>HexDigit :: `6`</emu-grammar> or of <emu-grammar>OctalDigit :: `6`</emu-grammar> is 6.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigit :: `7`</emu-grammar> or of <emu-grammar>NonZeroDigit :: `7`</emu-grammar> or of <emu-grammar>HexDigit :: `7`</emu-grammar> or of <emu-grammar>OctalDigit :: `7`</emu-grammar> is 7.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigit :: `8`</emu-grammar> or of <emu-grammar>NonZeroDigit :: `8`</emu-grammar> or of <emu-grammar>HexDigit :: `8`</emu-grammar> is 8.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigit :: `9`</emu-grammar> or of <emu-grammar>NonZeroDigit :: `9`</emu-grammar> or of <emu-grammar>HexDigit :: `9`</emu-grammar> is 9.
          </li>
          <li>
            The MV of <emu-grammar>HexDigit :: `a`</emu-grammar> or of <emu-grammar>HexDigit :: `A`</emu-grammar> is 10.
          </li>
          <li>
            The MV of <emu-grammar>HexDigit :: `b`</emu-grammar> or of <emu-grammar>HexDigit :: `B`</emu-grammar> is 11.
          </li>
          <li>
            The MV of <emu-grammar>HexDigit :: `c`</emu-grammar> or of <emu-grammar>HexDigit :: `C`</emu-grammar> is 12.
          </li>
          <li>
            The MV of <emu-grammar>HexDigit :: `d`</emu-grammar> or of <emu-grammar>HexDigit :: `D`</emu-grammar> is 13.
          </li>
          <li>
            The MV of <emu-grammar>HexDigit :: `e`</emu-grammar> or of <emu-grammar>HexDigit :: `E`</emu-grammar> is 14.
          </li>
          <li>
            The MV of <emu-grammar>HexDigit :: `f`</emu-grammar> or of <emu-grammar>HexDigit :: `F`</emu-grammar> is 15.
          </li>
          <li>
            The MV of <emu-grammar>BinaryIntegerLiteral :: `0b` BinaryDigits</emu-grammar> is the MV of |BinaryDigits|.
          </li>
          <li>
            The MV of <emu-grammar>BinaryIntegerLiteral :: `0B` BinaryDigits</emu-grammar> is the MV of |BinaryDigits|.
          </li>
          <li>
            The MV of <emu-grammar>BinaryDigits :: BinaryDigit</emu-grammar> is the MV of |BinaryDigit|.
          </li>
          <li>
            The MV of <emu-grammar>BinaryDigits :: BinaryDigits BinaryDigit</emu-grammar> is (the MV of |BinaryDigits| &times; 2) plus the MV of |BinaryDigit|.
          </li>
          <li>
            The MV of <emu-grammar>OctalIntegerLiteral :: `0o` OctalDigits</emu-grammar> is the MV of |OctalDigits|.
          </li>
          <li>
            The MV of <emu-grammar>OctalIntegerLiteral :: `0O` OctalDigits</emu-grammar> is the MV of |OctalDigits|.
          </li>
          <li>
            The MV of <emu-grammar>OctalDigits :: OctalDigit</emu-grammar> is the MV of |OctalDigit|.
          </li>
          <li>
            The MV of <emu-grammar>OctalDigits :: OctalDigits OctalDigit</emu-grammar> is (the MV of |OctalDigits| &times; 8) plus the MV of |OctalDigit|.
          </li>
          <li>
            The MV of <emu-grammar>HexIntegerLiteral :: `0x` HexDigits</emu-grammar> is the MV of |HexDigits|.
          </li>
          <li>
            The MV of <emu-grammar>HexIntegerLiteral :: `0X` HexDigits</emu-grammar> is the MV of |HexDigits|.
          </li>
          <li>
            The MV of <emu-grammar>HexDigits :: HexDigit</emu-grammar> is the MV of |HexDigit|.
          </li>
          <li>
            The MV of <emu-grammar>HexDigits :: HexDigits HexDigit</emu-grammar> is (the MV of |HexDigits| &times; 16) plus the MV of |HexDigit|.
          </li>
        </ul>
        <p>Once the exact MV for a numeric literal has been determined, it is then rounded to a value of the Number type. If the MV is 0, then the rounded value is *+0*; otherwise, the rounded value must be the Number value for the MV (as specified in <emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref>), unless the literal is a |DecimalLiteral| and the literal has more than 20 significant digits, in which case the Number value may be either the Number value for the MV of a literal produced by replacing each significant digit after the 20th with a `0` digit or the Number value for the MV of a literal produced by replacing each significant digit after the 20th with a `0` digit and then incrementing the literal at the 20th significant digit position. A digit is <em>significant</em> if it is not part of an |ExponentPart| and</p>
        <ul>
          <li>
            it is not `0`; or
          </li>
          <li>
            there is a nonzero digit to its left and there is a nonzero digit, not in the |ExponentPart|, to its right.
          </li>
        </ul>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-literals-string-literals">
      <h1>String Literals</h1>
      <emu-note>
        <p>A string literal is zero or more Unicode code points enclosed in single or double quotes. Unicode code points may also be represented by an escape sequence. All code points may appear literally in a string literal except for the closing quote code points, U+005C (REVERSE SOLIDUS), U+000D (CARRIAGE RETURN), and U+000A (LINE FEED). Any code points may appear in the form of an escape sequence. String literals evaluate to ECMAScript String values. When generating these String values Unicode code points are UTF-16 encoded as defined in <emu-xref href="#sec-utf16encoding"></emu-xref>. Code points belonging to the Basic Multilingual Plane are encoded as a single code unit element of the string. All other code points are encoded as two code unit elements of the string.</p>
      </emu-note>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        StringLiteral ::
          `"` DoubleStringCharacters? `"`
          `'` SingleStringCharacters? `'`

        DoubleStringCharacters ::
          DoubleStringCharacter DoubleStringCharacters?

        SingleStringCharacters ::
          SingleStringCharacter SingleStringCharacters?

        DoubleStringCharacter ::
          SourceCharacter but not one of `"` or `\` or LineTerminator
          &lt;LS&gt;
          &lt;PS&gt;
          `\` EscapeSequence
          LineContinuation

        SingleStringCharacter ::
          SourceCharacter but not one of `'` or `\` or LineTerminator
          &lt;LS&gt;
          &lt;PS&gt;
          `\` EscapeSequence
          LineContinuation

        LineContinuation ::
          `\` LineTerminatorSequence

        EscapeSequence ::
          CharacterEscapeSequence
          `0` [lookahead &lt;! DecimalDigit]
          HexEscapeSequence
          UnicodeEscapeSequence
      </emu-grammar>
      <p>A conforming implementation, when processing strict mode code, must not extend the syntax of |EscapeSequence| to include <emu-xref href="#prod-annexB-LegacyOctalEscapeSequence"></emu-xref> as described in <emu-xref href="#sec-additional-syntax-string-literals"></emu-xref>.</p>
      <emu-grammar type="definition">
        CharacterEscapeSequence ::
          SingleEscapeCharacter
          NonEscapeCharacter

        SingleEscapeCharacter :: one of
          `'` `"` `\` `b` `f` `n` `r` `t` `v`

        NonEscapeCharacter ::
          SourceCharacter but not one of EscapeCharacter or LineTerminator

        EscapeCharacter ::
          SingleEscapeCharacter
          DecimalDigit
          `x`
          `u`

        HexEscapeSequence ::
          `x` HexDigit HexDigit

        UnicodeEscapeSequence ::
          `u` Hex4Digits
          `u{` CodePoint `}`

        Hex4Digits ::
          HexDigit HexDigit HexDigit HexDigit
      </emu-grammar>
      <p>The definition of the nonterminal |HexDigit| is given in <emu-xref href="#sec-literals-numeric-literals"></emu-xref>. |SourceCharacter| is defined in <emu-xref href="#sec-source-text"></emu-xref>.</p>
      <emu-note>
        <p>&lt;LF&gt; and &lt;CR&gt; cannot appear in a string literal, except as part of a |LineContinuation| to produce the empty code points sequence. The proper way to include either in the String value of a string literal is to use an escape sequence such as `\\n` or `\\u000A`.</p>
      </emu-note>

      <emu-clause id="sec-string-literals-static-semantics-stringvalue">
        <h1>Static Semantics: StringValue</h1>
        <emu-see-also-para op="StringValue"></emu-see-also-para>
        <emu-grammar>
          StringLiteral ::
            `"` DoubleStringCharacters? `"`
            `'` SingleStringCharacters? `'`
        </emu-grammar>
        <emu-alg>
          1. Return the String value whose code units are the SV of this |StringLiteral|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-sv">
        <h1>Static Semantics: SV</h1>
        <p>A string literal stands for a value of the String type. The String value (SV) of the literal is described in terms of code unit values contributed by the various parts of the string literal. As part of this process, some Unicode code points within the string literal are interpreted as having a mathematical value (MV), as described below or in <emu-xref href="#sec-literals-numeric-literals"></emu-xref>.</p>
        <ul>
          <li>
            The SV of <emu-grammar>StringLiteral :: `"` `"`</emu-grammar> is the empty code unit sequence.
          </li>
          <li>
            The SV of <emu-grammar>StringLiteral :: `'` `'`</emu-grammar> is the empty code unit sequence.
          </li>
          <li>
            The SV of <emu-grammar>StringLiteral :: `"` DoubleStringCharacters `"`</emu-grammar> is the SV of |DoubleStringCharacters|.
          </li>
          <li>
            The SV of <emu-grammar>StringLiteral :: `'` SingleStringCharacters `'`</emu-grammar> is the SV of |SingleStringCharacters|.
          </li>
          <li>
            The SV of <emu-grammar>DoubleStringCharacters :: DoubleStringCharacter</emu-grammar> is a sequence of up to two code units that is the SV of |DoubleStringCharacter|.
          </li>
          <li>
            The SV of <emu-grammar>DoubleStringCharacters :: DoubleStringCharacter DoubleStringCharacters</emu-grammar> is a sequence of up to two code units that is the SV of |DoubleStringCharacter| followed by the code units of the SV of |DoubleStringCharacters| in order.
          </li>
          <li>
            The SV of <emu-grammar>SingleStringCharacters :: SingleStringCharacter</emu-grammar> is a sequence of up to two code units that is the SV of |SingleStringCharacter|.
          </li>
          <li>
            The SV of <emu-grammar>SingleStringCharacters :: SingleStringCharacter SingleStringCharacters</emu-grammar> is a sequence of up to two code units that is the SV of |SingleStringCharacter| followed by the code units of the SV of |SingleStringCharacters| in order.
          </li>
          <li>
            The SV of <emu-grammar>DoubleStringCharacter :: SourceCharacter but not one of `"` or `\` or LineTerminator</emu-grammar> is the UTF16Encoding of the code point value of |SourceCharacter|.
          </li>
          <li>
            The SV of <emu-grammar>DoubleStringCharacter :: &lt;LS&gt;</emu-grammar> is the code unit 0x2028 (LINE SEPARATOR).
          </li>
          <li>
            The SV of <emu-grammar>DoubleStringCharacter :: &lt;PS&gt;</emu-grammar> is the code unit 0x2029 (PARAGRAPH SEPARATOR).
          </li>
          <li>
            The SV of <emu-grammar>DoubleStringCharacter :: `\` EscapeSequence</emu-grammar> is the SV of the |EscapeSequence|.
          </li>
          <li>
            The SV of <emu-grammar>DoubleStringCharacter :: LineContinuation</emu-grammar> is the empty code unit sequence.
          </li>
          <li>
            The SV of <emu-grammar>SingleStringCharacter :: SourceCharacter but not one of `'` or `\` or LineTerminator</emu-grammar> is the UTF16Encoding of the code point value of |SourceCharacter|.
          </li>
          <li>
            The SV of <emu-grammar>SingleStringCharacter :: &lt;LS&gt;</emu-grammar> is the code unit 0x2028 (LINE SEPARATOR).
          </li>
          <li>
            The SV of <emu-grammar>SingleStringCharacter :: &lt;PS&gt;</emu-grammar> is the code unit 0x2029 (PARAGRAPH SEPARATOR).
          </li>
          <li>
            The SV of <emu-grammar>SingleStringCharacter :: `\` EscapeSequence</emu-grammar> is the SV of the |EscapeSequence|.
          </li>
          <li>
            The SV of <emu-grammar>SingleStringCharacter :: LineContinuation</emu-grammar> is the empty code unit sequence.
          </li>
          <li>
            The SV of <emu-grammar>EscapeSequence :: CharacterEscapeSequence</emu-grammar> is the SV of the |CharacterEscapeSequence|.
          </li>
          <li>
            The SV of <emu-grammar>EscapeSequence :: `0`</emu-grammar> is the code unit 0x0000 (NULL).
          </li>
          <li>
            The SV of <emu-grammar>EscapeSequence :: HexEscapeSequence</emu-grammar> is the SV of the |HexEscapeSequence|.
          </li>
          <li>
            The SV of <emu-grammar>EscapeSequence :: UnicodeEscapeSequence</emu-grammar> is the SV of the |UnicodeEscapeSequence|.
          </li>
          <li>
            The SV of <emu-grammar>CharacterEscapeSequence :: SingleEscapeCharacter</emu-grammar> is the code unit whose value is determined by the |SingleEscapeCharacter| according to <emu-xref href="#table-34"></emu-xref>.
          </li>
        </ul>
        <emu-table id="table-34" caption="String Single Character Escape Sequences">
          <table>
            <tbody>
            <tr>
              <th>
                Escape Sequence
              </th>
              <th>
                Code Unit Value
              </th>
              <th>
                Unicode Character Name
              </th>
              <th>
                Symbol
              </th>
            </tr>
            <tr>
              <td>
                `\\b`
              </td>
              <td>
                `0x0008`
              </td>
              <td>
                BACKSPACE
              </td>
              <td>
                &lt;BS&gt;
              </td>
            </tr>
            <tr>
              <td>
                `\\t`
              </td>
              <td>
                `0x0009`
              </td>
              <td>
                CHARACTER TABULATION
              </td>
              <td>
                &lt;HT&gt;
              </td>
            </tr>
            <tr>
              <td>
                `\\n`
              </td>
              <td>
                `0x000A`
              </td>
              <td>
                LINE FEED (LF)
              </td>
              <td>
                &lt;LF&gt;
              </td>
            </tr>
            <tr>
              <td>
                `\\v`
              </td>
              <td>
                `0x000B`
              </td>
              <td>
                LINE TABULATION
              </td>
              <td>
                &lt;VT&gt;
              </td>
            </tr>
            <tr>
              <td>
                `\\f`
              </td>
              <td>
                `0x000C`
              </td>
              <td>
                FORM FEED (FF)
              </td>
              <td>
                &lt;FF&gt;
              </td>
            </tr>
            <tr>
              <td>
                `\\r`
              </td>
              <td>
                `0x000D`
              </td>
              <td>
                CARRIAGE RETURN (CR)
              </td>
              <td>
                &lt;CR&gt;
              </td>
            </tr>
            <tr>
              <td>
                `\\"`
              </td>
              <td>
                `0x0022`
              </td>
              <td>
                QUOTATION MARK
              </td>
              <td>
                `"`
              </td>
            </tr>
            <tr>
              <td>
                `\\'`
              </td>
              <td>
                `0x0027`
              </td>
              <td>
                APOSTROPHE
              </td>
              <td>
                `'`
              </td>
            </tr>
            <tr>
              <td>
                `\\\\`
              </td>
              <td>
                `0x005C`
              </td>
              <td>
                REVERSE SOLIDUS
              </td>
              <td>
                `\\`
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
        <ul>
          <li>
            The SV of <emu-grammar>CharacterEscapeSequence :: NonEscapeCharacter</emu-grammar> is the SV of the |NonEscapeCharacter|.
          </li>
          <li>
            The SV of <emu-grammar>NonEscapeCharacter :: SourceCharacter but not one of EscapeCharacter or LineTerminator</emu-grammar> is the UTF16Encoding of the code point value of |SourceCharacter|.
          </li>
          <li>
            The SV of <emu-grammar>HexEscapeSequence :: `x` HexDigit HexDigit</emu-grammar> is the code unit whose value is (16 times the MV of the first |HexDigit|) plus the MV of the second |HexDigit|.
          </li>
          <li>
            The SV of <emu-grammar>UnicodeEscapeSequence :: `u` Hex4Digits</emu-grammar> is the SV of |Hex4Digits|.
          </li>
          <li>
            The SV of <emu-grammar>Hex4Digits :: HexDigit HexDigit HexDigit HexDigit</emu-grammar> is the code unit whose value is (0x1000 times the MV of the first |HexDigit|) plus (0x100 times the MV of the second |HexDigit|) plus (0x10 times the MV of the third |HexDigit|) plus the MV of the fourth |HexDigit|.
          </li>
          <li>
            The SV of <emu-grammar>UnicodeEscapeSequence :: `u{` CodePoint `}`</emu-grammar> is the UTF16Encoding of the MV of |CodePoint|.
          </li>
        </ul>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-literals-regular-expression-literals">
      <h1>Regular Expression Literals</h1>
      <emu-note>
        <p>A regular expression literal is an input element that is converted to a RegExp object (see <emu-xref href="#sec-regexp-regular-expression-objects"></emu-xref>) each time the literal is evaluated. Two regular expression literals in a program evaluate to regular expression objects that never compare as `===` to each other even if the two literals' contents are identical. A RegExp object may also be created at runtime by `new RegExp` or calling the `RegExp` constructor as a function (see <emu-xref href="#sec-regexp-constructor"></emu-xref>).</p>
      </emu-note>
      <p>The productions below describe the syntax for a regular expression literal and are used by the input element scanner to find the end of the regular expression literal. The source text comprising the |RegularExpressionBody| and the |RegularExpressionFlags| are subsequently parsed again using the more stringent ECMAScript Regular Expression grammar (<emu-xref href="#sec-patterns"></emu-xref>).</p>
      <p>An implementation may extend the ECMAScript Regular Expression grammar defined in <emu-xref href="#sec-patterns"></emu-xref>, but it must not extend the |RegularExpressionBody| and |RegularExpressionFlags| productions defined below or the productions used by these productions.</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        RegularExpressionLiteral ::
          `/` RegularExpressionBody `/` RegularExpressionFlags

        RegularExpressionBody ::
          RegularExpressionFirstChar RegularExpressionChars

        RegularExpressionChars ::
          [empty]
          RegularExpressionChars RegularExpressionChar

        RegularExpressionFirstChar ::
          RegularExpressionNonTerminator but not one of `*` or `\` or `/` or `[`
          RegularExpressionBackslashSequence
          RegularExpressionClass

        RegularExpressionChar ::
          RegularExpressionNonTerminator but not one of `\` or `/` or `[`
          RegularExpressionBackslashSequence
          RegularExpressionClass

        RegularExpressionBackslashSequence ::
          `\` RegularExpressionNonTerminator

        RegularExpressionNonTerminator ::
          SourceCharacter but not LineTerminator

        RegularExpressionClass ::
          `[` RegularExpressionClassChars `]`

        RegularExpressionClassChars ::
          [empty]
          RegularExpressionClassChars RegularExpressionClassChar

        RegularExpressionClassChar ::
          RegularExpressionNonTerminator but not one of `]` or `\`
          RegularExpressionBackslashSequence

        RegularExpressionFlags ::
          [empty]
          RegularExpressionFlags IdentifierPart
      </emu-grammar>
      <emu-note>
        <p>Regular expression literals may not be empty; instead of representing an empty regular expression literal, the code unit sequence `//` starts a single-line comment. To specify an empty regular expression, use: `/(?:)/`.</p>
      </emu-note>

      <emu-clause id="sec-literals-regular-expression-literals-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>RegularExpressionFlags :: RegularExpressionFlags IdentifierPart</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if |IdentifierPart| contains a Unicode escape sequence.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-bodytext">
        <h1>Static Semantics: BodyText</h1>
        <emu-grammar>RegularExpressionLiteral :: `/` RegularExpressionBody `/` RegularExpressionFlags</emu-grammar>
        <emu-alg>
          1. Return the source text that was recognized as |RegularExpressionBody|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-flagtext">
        <h1>Static Semantics: FlagText</h1>
        <emu-grammar>RegularExpressionLiteral :: `/` RegularExpressionBody `/` RegularExpressionFlags</emu-grammar>
        <emu-alg>
          1. Return the source text that was recognized as |RegularExpressionFlags|.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-template-literal-lexical-components">
      <h1>Template Literal Lexical Components</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        Template ::
          NoSubstitutionTemplate
          TemplateHead

        NoSubstitutionTemplate ::
          ``` TemplateCharacters? ```

        TemplateHead ::
          ``` TemplateCharacters? `${`

        TemplateSubstitutionTail ::
          TemplateMiddle
          TemplateTail

        TemplateMiddle ::
          `}` TemplateCharacters? `${`

        TemplateTail ::
          `}` TemplateCharacters? ```

        TemplateCharacters ::
          TemplateCharacter TemplateCharacters?

        TemplateCharacter ::
          `$` [lookahead != `{` ]
          `\` EscapeSequence
          `\` NotEscapeSequence
          LineContinuation
          LineTerminatorSequence
          SourceCharacter but not one of ``` or `\` or `$` or LineTerminator

        NotEscapeSequence ::
          `0` DecimalDigit
          DecimalDigit but not `0`
          `x` [lookahead &lt;! HexDigit]
          `x` HexDigit [lookahead &lt;! HexDigit]
          `u` [lookahead &lt;! HexDigit] [lookahead != `{`]
          `u` HexDigit [lookahead &lt;! HexDigit]
          `u` HexDigit HexDigit [lookahead &lt;! HexDigit]
          `u` HexDigit HexDigit HexDigit [lookahead &lt;! HexDigit]
          `u` `{` [lookahead &lt;! HexDigit]
          `u` `{` NotCodePoint [lookahead &lt;! HexDigit]
          `u` `{` CodePoint [lookahead &lt;! HexDigit] [lookahead != `}`]

        NotCodePoint ::
          HexDigits [> but only if MV of |HexDigits| &gt; 0x10FFFF ]

        CodePoint ::
          HexDigits [> but only if MV of |HexDigits| &le; 0x10FFFF ]
      </emu-grammar>
      <p>A conforming implementation must not use the extended definition of |EscapeSequence| described in <emu-xref href="#sec-additional-syntax-string-literals"></emu-xref> when parsing a |TemplateCharacter|.</p>
      <emu-note>
        <p>|TemplateSubstitutionTail| is used by the |InputElementTemplateTail| alternative lexical goal.</p>
      </emu-note>

      <emu-clause id="sec-static-semantics-tv-and-trv">
        <h1>Static Semantics: TV and TRV</h1>
        <p>A template literal component is interpreted as a sequence of Unicode code points. The Template Value (TV) of a literal component is described in terms of code unit values (SV, <emu-xref href="#sec-literals-string-literals"></emu-xref>) contributed by the various parts of the template literal component. As part of this process, some Unicode code points within the template component are interpreted as having a mathematical value (MV, <emu-xref href="#sec-literals-numeric-literals"></emu-xref>). In determining a TV, escape sequences are replaced by the UTF-16 code unit(s) of the Unicode code point represented by the escape sequence. The Template Raw Value (TRV) is similar to a Template Value with the difference that in TRVs escape sequences are interpreted literally.</p>
        <ul>
          <li>
            The TV and TRV of <emu-grammar>NoSubstitutionTemplate :: ``` ```</emu-grammar> is the empty code unit sequence.
          </li>
          <li>
            The TV and TRV of <emu-grammar>TemplateHead :: ``` `${`</emu-grammar> is the empty code unit sequence.
          </li>
          <li>
            The TV and TRV of <emu-grammar>TemplateMiddle :: `}` `${`</emu-grammar> is the empty code unit sequence.
          </li>
          <li>
            The TV and TRV of <emu-grammar>TemplateTail :: `}` ```</emu-grammar> is the empty code unit sequence.
          </li>
          <li>
            The TV of <emu-grammar>NoSubstitutionTemplate :: ``` TemplateCharacters ```</emu-grammar> is the TV of |TemplateCharacters|.
          </li>
          <li>
            The TV of <emu-grammar>TemplateHead :: ``` TemplateCharacters `${`</emu-grammar> is the TV of |TemplateCharacters|.
          </li>
          <li>
            The TV of <emu-grammar>TemplateMiddle :: `}` TemplateCharacters `${`</emu-grammar> is the TV of |TemplateCharacters|.
          </li>
          <li>
            The TV of <emu-grammar>TemplateTail :: `}` TemplateCharacters ```</emu-grammar> is the TV of |TemplateCharacters|.
          </li>
          <li>
            The TV of <emu-grammar>TemplateCharacters :: TemplateCharacter</emu-grammar> is the TV of |TemplateCharacter|.
          </li>
          <li>
            The TV of <emu-grammar>TemplateCharacters :: TemplateCharacter TemplateCharacters</emu-grammar> is *undefined* if either the TV of |TemplateCharacter| is *undefined* or the TV of |TemplateCharacters| is *undefined*. Otherwise, it is a sequence consisting of the code units of the TV of |TemplateCharacter| followed by the code units of the TV of |TemplateCharacters|.
          </li>
          <li>
            The TV of <emu-grammar>TemplateCharacter :: SourceCharacter but not one of ``` or `\` or `$` or LineTerminator</emu-grammar> is the UTF16Encoding of the code point value of |SourceCharacter|.
          </li>
          <li>
            The TV of <emu-grammar>TemplateCharacter :: `$`</emu-grammar> is the code unit 0x0024 (DOLLAR SIGN).
          </li>
          <li>
            The TV of <emu-grammar>TemplateCharacter :: `\` EscapeSequence</emu-grammar> is the SV of |EscapeSequence|.
          </li>
          <li>
            The TV of <emu-grammar>TemplateCharacter :: `\` NotEscapeSequence</emu-grammar> is *undefined*.
          </li>
          <li>
            The TV of <emu-grammar>TemplateCharacter :: LineContinuation</emu-grammar> is the TV of |LineContinuation|.
          </li>
          <li>
            The TV of <emu-grammar>TemplateCharacter :: LineTerminatorSequence</emu-grammar> is the TRV of |LineTerminatorSequence|.
          </li>
          <li>
            The TV of <emu-grammar>LineContinuation :: `\` LineTerminatorSequence</emu-grammar> is the empty code unit sequence.
          </li>
          <li>
            The TRV of <emu-grammar>NoSubstitutionTemplate :: ``` TemplateCharacters ```</emu-grammar> is the TRV of |TemplateCharacters|.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateHead :: ``` TemplateCharacters `${`</emu-grammar> is the TRV of |TemplateCharacters|.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateMiddle :: `}` TemplateCharacters `${`</emu-grammar> is the TRV of |TemplateCharacters|.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateTail :: `}` TemplateCharacters ```</emu-grammar> is the TRV of |TemplateCharacters|.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateCharacters :: TemplateCharacter</emu-grammar> is the TRV of |TemplateCharacter|.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateCharacters :: TemplateCharacter TemplateCharacters</emu-grammar> is a sequence consisting of the code units of the TRV of |TemplateCharacter| followed by the code units of the TRV of |TemplateCharacters|.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateCharacter :: SourceCharacter but not one of ``` or `\` or `$` or LineTerminator</emu-grammar> is the UTF16Encoding of the code point value of |SourceCharacter|.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateCharacter :: `$`</emu-grammar> is the code unit 0x0024 (DOLLAR SIGN).
          </li>
          <li>
            The TRV of <emu-grammar>TemplateCharacter :: `\` EscapeSequence</emu-grammar> is the sequence consisting of the code unit 0x005C (REVERSE SOLIDUS) followed by the code units of TRV of |EscapeSequence|.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateCharacter :: `\` NotEscapeSequence</emu-grammar> is the sequence consisting of the code unit 0x005C (REVERSE SOLIDUS) followed by the code units of TRV of |NotEscapeSequence|.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateCharacter :: LineContinuation</emu-grammar> is the TRV of |LineContinuation|.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateCharacter :: LineTerminatorSequence</emu-grammar> is the TRV of |LineTerminatorSequence|.
          </li>
          <li>
            The TRV of <emu-grammar>EscapeSequence :: CharacterEscapeSequence</emu-grammar> is the TRV of the |CharacterEscapeSequence|.
          </li>
          <li>
            The TRV of <emu-grammar>EscapeSequence :: `0`</emu-grammar> is the code unit 0x0030 (DIGIT ZERO).
          </li>
          <li>
            The TRV of <emu-grammar>EscapeSequence :: HexEscapeSequence</emu-grammar> is the TRV of the |HexEscapeSequence|.
          </li>
          <li>
            The TRV of <emu-grammar>EscapeSequence :: UnicodeEscapeSequence</emu-grammar> is the TRV of the |UnicodeEscapeSequence|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `0` DecimalDigit</emu-grammar> is the sequence consisting of the code unit 0x0030 (DIGIT ZERO) followed by the code units of the TRV of |DecimalDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `x` [lookahead &lt;! HexDigit]</emu-grammar> is the code unit 0x0078 (LATIN SMALL LETTER X).
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `x` HexDigit [lookahead &lt;! HexDigit]</emu-grammar> is the sequence consisting of the code unit 0x0078 (LATIN SMALL LETTER X) followed by the code units of the TRV of |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` [lookahead &lt;! HexDigit] [lookahead != `{`]</emu-grammar> is the code unit 0x0075 (LATIN SMALL LETTER U).
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` HexDigit [lookahead &lt;! HexDigit]</emu-grammar> is the sequence consisting of the code unit 0x0075 (LATIN SMALL LETTER U) followed by the code units of the TRV of |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` HexDigit HexDigit [lookahead &lt;! HexDigit]</emu-grammar> is the sequence consisting of the code unit 0x0075 (LATIN SMALL LETTER U) followed by the code units of the TRV of the first |HexDigit| followed by the code units of the TRV of the second |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` HexDigit HexDigit HexDigit [lookahead &lt;! HexDigit]</emu-grammar> is the sequence consisting of the code unit 0x0075 (LATIN SMALL LETTER U) followed by the code units of the TRV of the first |HexDigit| followed by the code units of the TRV of the second |HexDigit| followed by the code units of the TRV of the third |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` `{` [lookahead &lt;! HexDigit]</emu-grammar> is the sequence consisting of the code unit 0x0075 (LATIN SMALL LETTER U) followed by the code unit 0x007B (LEFT CURLY BRACKET).
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` `{` NotCodePoint [lookahead &lt;! HexDigit]</emu-grammar> is the sequence consisting of the code unit 0x0075 (LATIN SMALL LETTER U) followed by the code unit 0x007B (LEFT CURLY BRACKET) followed by the code units of the TRV of |NotCodePoint|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` `{` CodePoint [lookahead &lt;! HexDigit] [lookahead != `}`]</emu-grammar> is the sequence consisting of the code unit 0x0075 (LATIN SMALL LETTER U) followed by the code unit 0x007B (LEFT CURLY BRACKET) followed by the code units of the TRV of |CodePoint|.
          </li>
          <li>
            The TRV of <emu-grammar>DecimalDigit :: one of `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`</emu-grammar> is the SV of the |SourceCharacter| that is that single code point.
          </li>
          <li>
            The TRV of <emu-grammar>CharacterEscapeSequence :: SingleEscapeCharacter</emu-grammar> is the TRV of the |SingleEscapeCharacter|.
          </li>
          <li>
            The TRV of <emu-grammar>CharacterEscapeSequence :: NonEscapeCharacter</emu-grammar> is the SV of the |NonEscapeCharacter|.
          </li>
          <li>
            The TRV of <emu-grammar>SingleEscapeCharacter :: one of `'` `"` `\` `b` `f` `n` `r` `t` `v`</emu-grammar> is the SV of the |SourceCharacter| that is that single code point.
          </li>
          <li>
            The TRV of <emu-grammar>HexEscapeSequence :: `x` HexDigit HexDigit</emu-grammar> is the sequence consisting of the code unit 0x0078 (LATIN SMALL LETTER X) followed by TRV of the first |HexDigit| followed by the TRV of the second |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>UnicodeEscapeSequence :: `u` Hex4Digits</emu-grammar> is the sequence consisting of the code unit 0x0075 (LATIN SMALL LETTER U) followed by TRV of |Hex4Digits|.
          </li>
          <li>
            The TRV of <emu-grammar>UnicodeEscapeSequence :: `u{` CodePoint `}`</emu-grammar> is the sequence consisting of the code unit 0x0075 (LATIN SMALL LETTER U) followed by the code unit 0x007B (LEFT CURLY BRACKET) followed by TRV of |CodePoint| followed by the code unit 0x007D (RIGHT CURLY BRACKET).
          </li>
          <li>
            The TRV of <emu-grammar>Hex4Digits :: HexDigit HexDigit HexDigit HexDigit</emu-grammar> is the sequence consisting of the TRV of the first |HexDigit| followed by the TRV of the second |HexDigit| followed by the TRV of the third |HexDigit| followed by the TRV of the fourth |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>HexDigits :: HexDigit</emu-grammar> is the TRV of |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>HexDigits :: HexDigits HexDigit</emu-grammar> is the sequence consisting of TRV of |HexDigits| followed by TRV of |HexDigit|.
          </li>
          <li>
            The TRV of a |HexDigit| is the SV of the |SourceCharacter| that is that |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>LineContinuation :: `\` LineTerminatorSequence</emu-grammar> is the sequence consisting of the code unit 0x005C (REVERSE SOLIDUS) followed by the code units of TRV of |LineTerminatorSequence|.
          </li>
          <li>
            The TRV of <emu-grammar>LineTerminatorSequence :: &lt;LF&gt;</emu-grammar> is the code unit 0x000A (LINE FEED).
          </li>
          <li>
            The TRV of <emu-grammar>LineTerminatorSequence :: &lt;CR&gt;</emu-grammar> is the code unit 0x000A (LINE FEED).
          </li>
          <li>
            The TRV of <emu-grammar>LineTerminatorSequence :: &lt;LS&gt;</emu-grammar> is the code unit 0x2028 (LINE SEPARATOR).
          </li>
          <li>
            The TRV of <emu-grammar>LineTerminatorSequence :: &lt;PS&gt;</emu-grammar> is the code unit 0x2029 (PARAGRAPH SEPARATOR).
          </li>
          <li>
            The TRV of <emu-grammar>LineTerminatorSequence :: &lt;CR&gt;&lt;LF&gt;</emu-grammar> is the sequence consisting of the code unit 0x000A (LINE FEED).
          </li>
        </ul>
        <emu-note>
          <p>TV excludes the code units of |LineContinuation| while TRV includes them. &lt;CR&gt;&lt;LF&gt; and &lt;CR&gt; |LineTerminatorSequence|s are normalized to &lt;LF&gt; for both TV and TRV. An explicit |EscapeSequence| is needed to include a &lt;CR&gt; or &lt;CR&gt;&lt;LF&gt; sequence.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-automatic-semicolon-insertion">
    <h1>Automatic Semicolon Insertion</h1>
    <p>Most ECMAScript statements and declarations must be terminated with a semicolon. Such semicolons may always appear explicitly in the source text. For convenience, however, such semicolons may be omitted from the source text in certain situations. These situations are described by saying that semicolons are automatically inserted into the source code token stream in those situations.</p>

    <emu-clause id="sec-rules-of-automatic-semicolon-insertion" namespace=asi-rules>
      <h1>Rules of Automatic Semicolon Insertion</h1>
      <p>In the following rules, &ldquo;token&rdquo; means the actual recognized lexical token determined using the current lexical goal symbol as described in clause <emu-xref href="#sec-ecmascript-language-lexical-grammar"></emu-xref>.</p>
      <p>There are three basic rules of semicolon insertion:</p>
      <ol>
        <li>
          <p>When, as the source text is parsed from left to right, a token (called the <em>offending token</em>) is encountered that is not allowed by any production of the grammar, then a semicolon is automatically inserted before the offending token if one or more of the following conditions is true:</p>
          <ul>
            <li>
              The offending token is separated from the previous token by at least one |LineTerminator|.
            </li>
            <li>
              The offending token is `}`.
            </li>
            <li>
              The previous token is `)` and the inserted semicolon would then be parsed as the terminating semicolon of a do-while statement (<emu-xref href="#sec-do-while-statement"></emu-xref>).
            </li>
          </ul>
        </li>
        <li>
          When, as the source text is parsed from left to right, the end of the input stream of tokens is encountered and the parser is unable to parse the input token stream as a single instance of the goal nonterminal, then a semicolon is automatically inserted at the end of the input stream.
        </li>
        <li>
          When, as the source text is parsed from left to right, a token is encountered that is allowed by some production of the grammar, but the production is a <em>restricted production</em> and the token would be the first token for a terminal or nonterminal immediately following the annotation &ldquo;[no |LineTerminator| here]&rdquo; within the restricted production (and therefore such a token is called a restricted token), and the restricted token is separated from the previous token by at least one |LineTerminator|, then a semicolon is automatically inserted before the restricted token.
        </li>
      </ol>
      <p>However, there is an additional overriding condition on the preceding rules: a semicolon is never inserted automatically if the semicolon would then be parsed as an empty statement or if that semicolon would become one of the two semicolons in the header of a `for` statement (see <emu-xref href="#sec-for-statement"></emu-xref>).</p>
      <emu-note>
        <p>The following are the only restricted productions in the grammar:</p>
        <emu-grammar>
          UpdateExpression[Yield, Await] :
            LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `++`
            LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `--`

          ContinueStatement[Yield, Await] :
            `continue` `;`
            `continue` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`

          BreakStatement[Yield, Await] :
            `break` `;`
            `break` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`

          ReturnStatement[Yield, Await] :
            `return` `;`
            `return` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`

          ThrowStatement[Yield, Await] :
            `throw` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`

          ArrowFunction[In, Yield, Await] :
            ArrowParameters[?Yield, ?Await] [no LineTerminator here] `=&gt;` ConciseBody[?In]

          YieldExpression[In, Await] :
            `yield` [no LineTerminator here] AssignmentExpression[?In, +Yield, ?Await]
            `yield` [no LineTerminator here] `*` AssignmentExpression[?In, +Yield, ?Await]
        </emu-grammar>
        <p>The practical effect of these restricted productions is as follows:</p>
        <ul>
          <li>
            When a `++` or `--` token is encountered where the parser would treat it as a postfix operator, and at least one |LineTerminator| occurred between the preceding token and the `++` or `--` token, then a semicolon is automatically inserted before the `++` or `--` token.
          </li>
          <li>
            When a `continue`, `break`, `return`, `throw`, or `yield` token is encountered and a |LineTerminator| is encountered before the next token, a semicolon is automatically inserted after the `continue`, `break`, `return`, `throw`, or `yield` token.
          </li>
        </ul>
        <p>The resulting practical advice to ECMAScript programmers is:</p>
        <ul>
          <li>
            A postfix `++` or `--` operator should appear on the same line as its operand.
          </li>
          <li>
            An |Expression| in a `return` or `throw` statement or an |AssignmentExpression| in a `yield` expression should start on the same line as the `return`, `throw`, or `yield` token.
          </li>
          <li>
            A |LabelIdentifier| in a `break` or `continue` statement should be on the same line as the `break` or `continue` token.
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-examples-of-automatic-semicolon-insertion">
      <h1>Examples of Automatic Semicolon Insertion</h1>
      <p>The source</p>
      <pre><code class="javascript">{ 1 2 } 3</code></pre>
      <p>is not a valid sentence in the ECMAScript grammar, even with the automatic semicolon insertion rules. In contrast, the source</p>
      <pre><code class="javascript">
        { 1
        2 } 3
      </code></pre>
      <p>is also not a valid ECMAScript sentence, but is transformed by automatic semicolon insertion into the following:</p>
      <pre><code class="javascript">
        { 1
        ;2 ;} 3;
      </code></pre>
      <p>which is a valid ECMAScript sentence.</p>
      <p>The source</p>
      <pre><code class="javascript">
        for (a; b
        )
      </code></pre>
      <p>is not a valid ECMAScript sentence and is not altered by automatic semicolon insertion because the semicolon is needed for the header of a `for` statement. Automatic semicolon insertion never inserts one of the two semicolons in the header of a `for` statement.</p>
      <p>The source</p>
      <pre><code class="javascript">
        return
        a + b
      </code></pre>
      <p>is transformed by automatic semicolon insertion into the following:</p>
      <pre><code class="javascript">
        return;
        a + b;
      </code></pre>
      <emu-note>
        <p>The expression `a + b` is not treated as a value to be returned by the `return` statement, because a |LineTerminator| separates it from the token `return`.</p>
      </emu-note>
      <p>The source</p>
      <pre><code class="javascript">
        a = b
        ++c
      </code></pre>
      <p>is transformed by automatic semicolon insertion into the following:</p>
      <pre><code class="javascript">
        a = b;
        ++c;
      </code></pre>
      <emu-note>
        <p>The token `++` is not treated as a postfix operator applying to the variable `b`, because a |LineTerminator| occurs between `b` and `++`.</p>
      </emu-note>
      <p>The source</p>
      <pre><code class="javascript">
        if (a &gt; b)
        else c = d
      </code></pre>
      <p>is not a valid ECMAScript sentence and is not altered by automatic semicolon insertion before the `else` token, even though no production of the grammar applies at that point, because an automatically inserted semicolon would then be parsed as an empty statement.</p>
      <p>The source</p>
      <pre><code class="javascript">
        a = b + c
        (d + e).print()
      </code></pre>
      <p>is <em>not</em> transformed by automatic semicolon insertion, because the parenthesized expression that begins the second line can be interpreted as an argument list for a function call:</p>
      <pre><code class="javascript">a = b + c(d + e).print()</code></pre>
      <p>In the circumstance that an assignment statement must begin with a left parenthesis, it is a good idea for the programmer to provide an explicit semicolon at the end of the preceding statement rather than to rely on automatic semicolon insertion.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-expressions">
  <h1>ECMAScript Language: Expressions</h1>

  <emu-clause id="sec-identifiers">
    <h1>Identifiers</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      IdentifierReference[Yield, Await] :
        Identifier
        [~Yield] `yield`
        [~Await] `await`

      BindingIdentifier[Yield, Await] :
        Identifier
        `yield`
        `await`

      LabelIdentifier[Yield, Await] :
        Identifier
        [~Yield] `yield`
        [~Await] `await`

      Identifier :
        IdentifierName but not ReservedWord
    </emu-grammar>

    <emu-note>
      <p>`yield` and `await` are permitted as |BindingIdentifier| in the grammar, and prohibited with static semantics below, to prohibit automatic semicolon insertion in cases such as</p>
      <pre><code class="javascript">
        let
        await 0;
      </code></pre>
    </emu-note>

    <emu-clause id="sec-identifiers-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>BindingIdentifier : Identifier</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if the code matched by this production is contained in strict mode code and the StringValue of |Identifier| is `"arguments"` or `"eval"`.
        </li>
      </ul>
      <emu-grammar>
        IdentifierReference : `yield`

        BindingIdentifier : `yield`

        LabelIdentifier : `yield`
      </emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if the code matched by this production is contained in strict mode code.
        </li>
      </ul>
      <emu-grammar>
        IdentifierReference : `await`

        BindingIdentifier : `await`

        LabelIdentifier : `await`
      </emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if the goal symbol of the syntactic grammar is |Module|.
        </li>
      </ul>
      <emu-grammar>
        BindingIdentifier : `yield`
      </emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if this production has a <sub>[Yield]</sub> parameter.
        </li>
      </ul>
      <emu-grammar>
        BindingIdentifier : `await`
      </emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if this production has an <sub>[Await]</sub> parameter.
        </li>
      </ul>
      <emu-grammar>
        IdentifierReference[Yield, Await] : Identifier

        BindingIdentifier[Yield, Await] : Identifier

        LabelIdentifier[Yield, Await] : Identifier
      </emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if this production has a <sub>[Yield]</sub> parameter and StringValue of |Identifier| is `"yield"`.
        </li>
        <li>
          It is a Syntax Error if this production has an <sub>[Await]</sub> parameter and StringValue of |Identifier| is `"await"`.
        </li>
      </ul>
      <emu-grammar>Identifier : IdentifierName but not ReservedWord</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if this phrase is contained in strict mode code and the StringValue of |IdentifierName| is: `"implements"`, `"interface"`, `"let"`, `"package"`, `"private"`, `"protected"`, `"public"`, `"static"`, or `"yield"`.
        </li>
        <li>
          It is a Syntax Error if the goal symbol of the syntactic grammar is |Module| and the StringValue of |IdentifierName| is `"await"`.
        </li>
        <li>
          It is a Syntax Error if StringValue of |IdentifierName| is the same String value as the StringValue of any |ReservedWord| except for `yield` or `await`.
        </li>
      </ul>
      <emu-note>
        <p>StringValue of |IdentifierName| normalizes any Unicode escape sequences in |IdentifierName| hence such escapes cannot be used to write an |Identifier| whose code point sequence is the same as a |ReservedWord|.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-identifiers-static-semantics-boundnames">
      <h1>Static Semantics: BoundNames</h1>
      <emu-see-also-para op="BoundNames"></emu-see-also-para>
      <emu-grammar>BindingIdentifier : Identifier</emu-grammar>
      <emu-alg>
        1. Return a new List containing the StringValue of |Identifier|.
      </emu-alg>
      <emu-grammar>BindingIdentifier : `yield`</emu-grammar>
      <emu-alg>
        1. Return a new List containing `"yield"`.
      </emu-alg>
      <emu-grammar>BindingIdentifier : `await`</emu-grammar>
      <emu-alg>
        1. Return a new List containing `"await"`.
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-identifiers-static-semantics-isvalidsimpleassignmenttarget" id="sec-identifiers-static-semantics-assignmenttargettype">
      <h1>Static Semantics: AssignmentTargetType</h1>
      <emu-see-also-para op="AssignmentTargetType"></emu-see-also-para>
      <emu-grammar>IdentifierReference : Identifier</emu-grammar>
      <emu-alg>
        1. If this |IdentifierReference| is contained in strict mode code and StringValue of |Identifier| is `"eval"` or `"arguments"`, return ~strict~.
        1. Return ~simple~.
      </emu-alg>
      <emu-grammar>IdentifierReference : `yield`</emu-grammar>
      <emu-alg>
        1. Return ~simple~.
      </emu-alg>
      <emu-grammar>IdentifierReference : `await`</emu-grammar>
      <emu-alg>
        1. Return ~simple~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-identifiers-static-semantics-stringvalue">
      <h1>Static Semantics: StringValue</h1>
      <emu-see-also-para op="StringValue"></emu-see-also-para>
      <emu-grammar>
        IdentifierReference : `yield`

        BindingIdentifier : `yield`

        LabelIdentifier : `yield`
      </emu-grammar>
      <emu-alg>
        1. Return `"yield"`.
      </emu-alg>
      <emu-grammar>
        IdentifierReference : `await`

        BindingIdentifier : `await`

        LabelIdentifier : `await`
      </emu-grammar>
      <emu-alg>
        1. Return `"await"`.
      </emu-alg>
      <emu-grammar>Identifier : IdentifierName but not ReservedWord</emu-grammar>
      <emu-alg>
        1. Return the StringValue of |IdentifierName|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-identifiers-runtime-semantics-bindinginitialization">
      <h1>Runtime Semantics: BindingInitialization</h1>
      <p>With parameters _value_ and _environment_.</p>
      <emu-see-also-para op="BindingInitialization"></emu-see-also-para>
      <emu-note>
        <p>*undefined* is passed for _environment_ to indicate that a PutValue operation should be used to assign the initialization value. This is the case for `var` statements and formal parameter lists of some non-strict functions (See <emu-xref href="#sec-functiondeclarationinstantiation"></emu-xref>). In those cases a lexical binding is hoisted and preinitialized prior to evaluation of its initializer.</p>
      </emu-note>
      <emu-grammar>BindingIdentifier : Identifier</emu-grammar>
      <emu-alg>
        1. Let _name_ be StringValue of |Identifier|.
        1. Return ? InitializeBoundName(_name_, _value_, _environment_).
      </emu-alg>
      <emu-grammar>BindingIdentifier : `yield`</emu-grammar>
      <emu-alg>
        1. Return ? InitializeBoundName(`"yield"`, _value_, _environment_).
      </emu-alg>
      <emu-grammar>BindingIdentifier : `await`</emu-grammar>
      <emu-alg>
        1. Return ? InitializeBoundName(`"await"`, _value_, _environment_).
      </emu-alg>

      <emu-clause id="sec-initializeboundname" aoid="InitializeBoundName">
        <h1>Runtime Semantics: InitializeBoundName ( _name_, _value_, _environment_ )</h1>
        <emu-alg>
          1. Assert: Type(_name_) is String.
          1. If _environment_ is not *undefined*, then
            1. Let _env_ be the EnvironmentRecord component of _environment_.
            1. Perform _env_.InitializeBinding(_name_, _value_).
            1. Return NormalCompletion(*undefined*).
          1. Else,
            1. Let _lhs_ be ResolveBinding(_name_).
            1. Return ? PutValue(_lhs_, _value_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-identifiers-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>IdentifierReference : Identifier</emu-grammar>
      <emu-alg>
        1. Return ? ResolveBinding(StringValue of |Identifier|).
      </emu-alg>
      <emu-grammar>IdentifierReference : `yield`</emu-grammar>
      <emu-alg>
        1. Return ? ResolveBinding(`"yield"`).
      </emu-alg>
      <emu-grammar>IdentifierReference : `await`</emu-grammar>
      <emu-alg>
        1. Return ? ResolveBinding(`"await"`).
      </emu-alg>
      <emu-note>
        <p>The result of evaluating an |IdentifierReference| is always a value of type Reference.</p>
      </emu-note>
      <emu-note>
        <p>In non-strict code, the keyword `yield` may be used as an identifier. Evaluating the |IdentifierReference| resolves the binding of `yield` as if it was an |Identifier|. Early Error restriction ensures that such an evaluation only can occur for non-strict code.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-primary-expression">
    <h1>Primary Expression</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      PrimaryExpression[Yield, Await] :
        `this`
        IdentifierReference[?Yield, ?Await]
        Literal
        ArrayLiteral[?Yield, ?Await]
        ObjectLiteral[?Yield, ?Await]
        FunctionExpression
        ClassExpression[?Yield, ?Await]
        GeneratorExpression
        AsyncFunctionExpression
        AsyncGeneratorExpression
        RegularExpressionLiteral
        TemplateLiteral[?Yield, ?Await, ~Tagged]
        CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await] #parencover

      CoverParenthesizedExpressionAndArrowParameterList[Yield, Await] :
        `(` Expression[+In, ?Yield, ?Await] `)`
        `(` Expression[+In, ?Yield, ?Await] `,` `)`
        `(` `)`
        `(` `...` BindingIdentifier[?Yield, ?Await] `)`
        `(` `...` BindingPattern[?Yield, ?Await] `)`
        `(` Expression[+In, ?Yield, ?Await] `,` `...` BindingIdentifier[?Yield, ?Await] `)`
        `(` Expression[+In, ?Yield, ?Await] `,` `...` BindingPattern[?Yield, ?Await] `)`
    </emu-grammar>
    <h2>Supplemental Syntax</h2>
    <p>When processing an instance of the production
      <br>
      <emu-grammar>PrimaryExpression[Yield, Await] : CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]</emu-grammar>
      <br>
      the interpretation of |CoverParenthesizedExpressionAndArrowParameterList| is refined using the following grammar:</p>
    <emu-grammar type="definition">
      ParenthesizedExpression[Yield, Await] :
        `(` Expression[+In, ?Yield, ?Await] `)`
    </emu-grammar>

    <emu-clause id="sec-primary-expression-semantics">
      <h1>Semantics</h1>

      <emu-clause id="sec-static-semantics-coveredparenthesizedexpression">
        <h1>Static Semantics: CoveredParenthesizedExpression</h1>
        <emu-grammar>CoverParenthesizedExpressionAndArrowParameterList : `(` Expression `)`</emu-grammar>
        <emu-alg>
          1. Return the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-semantics-static-semantics-hasname">
        <h1>Static Semantics: HasName</h1>
        <emu-see-also-para op="HasName"></emu-see-also-para>
        <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
        <emu-alg>
          1. Let _expr_ be CoveredParenthesizedExpression of |CoverParenthesizedExpressionAndArrowParameterList|.
          1. If IsFunctionDefinition of _expr_ is *false*, return *false*.
          1. Return HasName of _expr_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-semantics-static-semantics-isfunctiondefinition">
        <h1>Static Semantics: IsFunctionDefinition</h1>
        <emu-see-also-para op="IsFunctionDefinition"></emu-see-also-para>
        <emu-grammar>
          PrimaryExpression :
            `this`
            IdentifierReference
            Literal
            ArrayLiteral
            ObjectLiteral
            RegularExpressionLiteral
            TemplateLiteral
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
        <emu-alg>
          1. Let _expr_ be CoveredParenthesizedExpression of |CoverParenthesizedExpressionAndArrowParameterList|.
          1. Return IsFunctionDefinition of _expr_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-semantics-static-semantics-isidentifierref">
        <h1>Static Semantics: IsIdentifierRef</h1>
        <emu-see-also-para op="IsIdentifierRef"></emu-see-also-para>
        <emu-grammar>PrimaryExpression : IdentifierReference</emu-grammar>
        <emu-alg>
          1. Return *true*.
        </emu-alg>
        <emu-grammar>
          PrimaryExpression :
            `this`
            Literal
            ArrayLiteral
            ObjectLiteral
            FunctionExpression
            ClassExpression
            GeneratorExpression
            AsyncFunctionExpression
            AsyncGeneratorExpression
            RegularExpressionLiteral
            TemplateLiteral
            CoverParenthesizedExpressionAndArrowParameterList
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-semantics-static-semantics-isvalidsimpleassignmenttarget" id="sec-semantics-static-semantics-assignmenttargettype">
        <h1>Static Semantics: AssignmentTargetType</h1>
        <emu-see-also-para op="AssignmentTargetType"></emu-see-also-para>
        <emu-grammar>
          PrimaryExpression :
            `this`
            Literal
            ArrayLiteral
            ObjectLiteral
            FunctionExpression
            ClassExpression
            GeneratorExpression
            AsyncFunctionExpression
            AsyncGeneratorExpression
            RegularExpressionLiteral
            TemplateLiteral
        </emu-grammar>
        <emu-alg>
          1. Return ~invalid~.
        </emu-alg>
        <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
        <emu-alg>
          1. Let _expr_ be CoveredParenthesizedExpression of |CoverParenthesizedExpressionAndArrowParameterList|.
          1. Return AssignmentTargetType of _expr_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-this-keyword">
      <h1>The `this` Keyword</h1>

      <emu-clause id="sec-this-keyword-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>PrimaryExpression : `this`</emu-grammar>
        <emu-alg>
          1. Return ? ResolveThisBinding().
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-identifier-reference">
      <h1>Identifier Reference</h1>
      <p>See <emu-xref href="#sec-identifiers"></emu-xref> for |IdentifierReference|.</p>
    </emu-clause>

    <emu-clause id="sec-primary-expression-literals">
      <h1>Literals</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        Literal :
          NullLiteral
          BooleanLiteral
          NumericLiteral
          StringLiteral
      </emu-grammar>

      <emu-clause id="sec-literals-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>Literal : NullLiteral</emu-grammar>
        <emu-alg>
          1. Return *null*.
        </emu-alg>
        <emu-grammar>Literal : BooleanLiteral</emu-grammar>
        <emu-alg>
          1. If |BooleanLiteral| is the token `false`, return *false*.
          1. If |BooleanLiteral| is the token `true`, return *true*.
        </emu-alg>
        <emu-grammar>Literal : NumericLiteral</emu-grammar>
        <emu-alg>
          1. Return the number whose value is MV of |NumericLiteral| as defined in <emu-xref href="#sec-literals-numeric-literals"></emu-xref>.
        </emu-alg>
        <emu-grammar>Literal : StringLiteral</emu-grammar>
        <emu-alg>
          1. Return the StringValue of |StringLiteral| as defined in <emu-xref href="#sec-string-literals-static-semantics-stringvalue"></emu-xref>.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-array-initializer">
      <h1>Array Initializer</h1>
      <emu-note>
        <p>An |ArrayLiteral| is an expression describing the initialization of an Array object, using a list, of zero or more expressions each of which represents an array element, enclosed in square brackets. The elements need not be literals; they are evaluated each time the array initializer is evaluated.</p>
      </emu-note>
      <p>Array elements may be elided at the beginning, middle or end of the element list. Whenever a comma in the element list is not preceded by an |AssignmentExpression| (i.e., a comma at the beginning or after another comma), the missing array element contributes to the length of the Array and increases the index of subsequent elements. Elided array elements are not defined. If an element is elided at the end of an array, that element does not contribute to the length of the Array.</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ArrayLiteral[Yield, Await] :
          `[` Elision? `]`
          `[` ElementList[?Yield, ?Await] `]`
          `[` ElementList[?Yield, ?Await] `,` Elision? `]`

        ElementList[Yield, Await] :
          Elision? AssignmentExpression[+In, ?Yield, ?Await]
          Elision? SpreadElement[?Yield, ?Await]
          ElementList[?Yield, ?Await] `,` Elision? AssignmentExpression[+In, ?Yield, ?Await]
          ElementList[?Yield, ?Await] `,` Elision? SpreadElement[?Yield, ?Await]

        Elision :
          `,`
          Elision `,`

        SpreadElement[Yield, Await] :
          `...` AssignmentExpression[+In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-static-semantics-elisionwidth">
        <h1>Static Semantics: ElisionWidth</h1>
        <emu-grammar>Elision : `,`</emu-grammar>
        <emu-alg>
          1. Return the numeric value 1.
        </emu-alg>
        <emu-grammar>Elision : Elision `,`</emu-grammar>
        <emu-alg>
          1. Let _preceding_ be the ElisionWidth of |Elision|.
          1. Return _preceding_ + 1.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-arrayaccumulation">
        <h1>Runtime Semantics: ArrayAccumulation</h1>
        <p>With parameters _array_ and _nextIndex_.</p>
        <emu-grammar>ElementList : Elision? AssignmentExpression</emu-grammar>
        <emu-alg>
          1. Let _padding_ be the ElisionWidth of |Elision|; if |Elision| is not present, use the numeric value zero.
          1. Let _initResult_ be the result of evaluating |AssignmentExpression|.
          1. Let _initValue_ be ? GetValue(_initResult_).
          1. Let _created_ be CreateDataProperty(_array_, ToString(ToUint32(_nextIndex_ + _padding_)), _initValue_).
          1. Assert: _created_ is *true*.
          1. Return _nextIndex_ + _padding_ + 1.
        </emu-alg>
        <emu-grammar>ElementList : Elision? SpreadElement</emu-grammar>
        <emu-alg>
          1. Let _padding_ be the ElisionWidth of |Elision|; if |Elision| is not present, use the numeric value zero.
          1. Return the result of performing ArrayAccumulation for |SpreadElement| with arguments _array_ and _nextIndex_ + _padding_.
        </emu-alg>
        <emu-grammar>ElementList : ElementList `,` Elision? AssignmentExpression</emu-grammar>
        <emu-alg>
          1. Let _postIndex_ be the result of performing ArrayAccumulation for |ElementList| with arguments _array_ and _nextIndex_.
          1. ReturnIfAbrupt(_postIndex_).
          1. Let _padding_ be the ElisionWidth of |Elision|; if |Elision| is not present, use the numeric value zero.
          1. Let _initResult_ be the result of evaluating |AssignmentExpression|.
          1. Let _initValue_ be ? GetValue(_initResult_).
          1. Let _created_ be CreateDataProperty(_array_, ToString(ToUint32(_postIndex_ + _padding_)), _initValue_).
          1. Assert: _created_ is *true*.
          1. Return _postIndex_ + _padding_ + 1.
        </emu-alg>
        <emu-grammar>ElementList : ElementList `,` Elision? SpreadElement</emu-grammar>
        <emu-alg>
          1. Let _postIndex_ be the result of performing ArrayAccumulation for |ElementList| with arguments _array_ and _nextIndex_.
          1. ReturnIfAbrupt(_postIndex_).
          1. Let _padding_ be the ElisionWidth of |Elision|; if |Elision| is not present, use the numeric value zero.
          1. Return the result of performing ArrayAccumulation for |SpreadElement| with arguments _array_ and _postIndex_ + _padding_.
        </emu-alg>
        <emu-grammar>SpreadElement : `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. Let _spreadRef_ be the result of evaluating |AssignmentExpression|.
          1. Let _spreadObj_ be ? GetValue(_spreadRef_).
          1. Let _iteratorRecord_ be ? GetIterator(_spreadObj_).
          1. Repeat,
            1. Let _next_ be ? IteratorStep(_iteratorRecord_).
            1. If _next_ is *false*, return _nextIndex_.
            1. Let _nextValue_ be ? IteratorValue(_next_).
            1. Let _status_ be CreateDataProperty(_array_, ToString(ToUint32(_nextIndex_)), _nextValue_).
            1. Assert: _status_ is *true*.
            1. Increase _nextIndex_ by 1.
        </emu-alg>
        <emu-note>
          <p>CreateDataProperty is used to ensure that own properties are defined for the array even if the standard built-in Array prototype object has been modified in a manner that would preclude the creation of new own properties using [[Set]].</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array-initializer-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>ArrayLiteral : `[` Elision? `]`</emu-grammar>
        <emu-alg>
          1. Let _array_ be ! ArrayCreate(0).
          1. Let _pad_ be the ElisionWidth of |Elision|; if |Elision| is not present, use the numeric value zero.
          1. Perform Set(_array_, `"length"`, ToUint32(_pad_), *false*).
          1. NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate.
          1. Return _array_.
        </emu-alg>
        <emu-grammar>ArrayLiteral : `[` ElementList `]`</emu-grammar>
        <emu-alg>
          1. Let _array_ be ! ArrayCreate(0).
          1. Let _len_ be the result of performing ArrayAccumulation for |ElementList| with arguments _array_ and 0.
          1. ReturnIfAbrupt(_len_).
          1. Perform Set(_array_, `"length"`, ToUint32(_len_), *false*).
          1. NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate.
          1. Return _array_.
        </emu-alg>
        <emu-grammar>ArrayLiteral : `[` ElementList `,` Elision? `]`</emu-grammar>
        <emu-alg>
          1. Let _array_ be ! ArrayCreate(0).
          1. Let _len_ be the result of performing ArrayAccumulation for |ElementList| with arguments _array_ and 0.
          1. ReturnIfAbrupt(_len_).
          1. Let _padding_ be the ElisionWidth of |Elision|; if |Elision| is not present, use the numeric value zero.
          1. Perform Set(_array_, `"length"`, ToUint32(_padding_ + _len_), *false*).
          1. NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate.
          1. Return _array_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-object-initializer">
      <h1>Object Initializer</h1>
      <emu-note>
        <p>An object initializer is an expression describing the initialization of an Object, written in a form resembling a literal. It is a list of zero or more pairs of property keys and associated values, enclosed in curly brackets. The values need not be literals; they are evaluated each time the object initializer is evaluated.</p>
      </emu-note>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ObjectLiteral[Yield, Await] :
          `{` `}`
          `{` PropertyDefinitionList[?Yield, ?Await] `}`
          `{` PropertyDefinitionList[?Yield, ?Await] `,` `}`

        PropertyDefinitionList[Yield, Await] :
          PropertyDefinition[?Yield, ?Await]
          PropertyDefinitionList[?Yield, ?Await] `,` PropertyDefinition[?Yield, ?Await]

        PropertyDefinition[Yield, Await] :
          IdentifierReference[?Yield, ?Await]
          CoverInitializedName[?Yield, ?Await]
          PropertyName[?Yield, ?Await] `:` AssignmentExpression[+In, ?Yield, ?Await]
          MethodDefinition[?Yield, ?Await]
          `...` AssignmentExpression[+In, ?Yield, ?Await]

        PropertyName[Yield, Await] :
          LiteralPropertyName
          ComputedPropertyName[?Yield, ?Await]

        LiteralPropertyName :
          IdentifierName
          StringLiteral
          NumericLiteral

        ComputedPropertyName[Yield, Await] :
          `[` AssignmentExpression[+In, ?Yield, ?Await] `]`

        CoverInitializedName[Yield, Await] :
          IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]

        Initializer[In, Yield, Await] :
          `=` AssignmentExpression[?In, ?Yield, ?Await]
      </emu-grammar>
      <emu-note>
        <p>|MethodDefinition| is defined in <emu-xref href="#sec-method-definitions"></emu-xref>.</p>
      </emu-note>
      <emu-note>
        <p>In certain contexts, |ObjectLiteral| is used as a cover grammar for a more restricted secondary grammar. The |CoverInitializedName| production is necessary to fully cover these secondary grammars. However, use of this production results in an early Syntax Error in normal contexts where an actual |ObjectLiteral| is expected.</p>
      </emu-note>

      <emu-clause id="sec-object-initializer-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>PropertyDefinition : MethodDefinition</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if HasDirectSuper of |MethodDefinition| is *true*.
          </li>
        </ul>
        <p>In addition to describing an actual object initializer the |ObjectLiteral| productions are also used as a cover grammar for |ObjectAssignmentPattern| and may be recognized as part of a |CoverParenthesizedExpressionAndArrowParameterList|. When |ObjectLiteral| appears in a context where |ObjectAssignmentPattern| is required the following Early Error rules are <b>not</b> applied. In addition, they are not applied when initially parsing a |CoverParenthesizedExpressionAndArrowParameterList| or |CoverCallExpressionAndAsyncArrowHead|.</p>
        <emu-grammar>PropertyDefinition : CoverInitializedName</emu-grammar>
        <ul>
          <li>
            Always throw a Syntax Error if code matches this production.
          </li>
        </ul>
        <emu-note>
          <p>This production exists so that |ObjectLiteral| can serve as a cover grammar for |ObjectAssignmentPattern|. It cannot occur in an actual object initializer.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object-initializer-static-semantics-computedpropertycontains">
        <h1>Static Semantics: ComputedPropertyContains</h1>
        <p>With parameter _symbol_.</p>
        <emu-see-also-para op="ComputedPropertyContains"></emu-see-also-para>
        <emu-grammar>PropertyName : LiteralPropertyName</emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>PropertyName : ComputedPropertyName</emu-grammar>
        <emu-alg>
          1. Return the result of |ComputedPropertyName| Contains _symbol_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object-initializer-static-semantics-contains">
        <h1>Static Semantics: Contains</h1>
        <p>With parameter _symbol_.</p>
        <emu-see-also-para op="Contains"></emu-see-also-para>
        <emu-grammar>PropertyDefinition : MethodDefinition</emu-grammar>
        <emu-alg>
          1. If _symbol_ is |MethodDefinition|, return *true*.
          1. Return the result of ComputedPropertyContains for |MethodDefinition| with argument _symbol_.
        </emu-alg>
        <emu-note>
          <p>Static semantic rules that depend upon substructure generally do not look into function definitions.</p>
        </emu-note>
        <emu-grammar>LiteralPropertyName : IdentifierName</emu-grammar>
        <emu-alg>
          1. If _symbol_ is a |ReservedWord|, return *false*.
          1. If _symbol_ is an |Identifier| and StringValue of _symbol_ is the same value as the StringValue of |IdentifierName|, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-iscomputedpropertykey">
        <h1>Static Semantics: IsComputedPropertyKey</h1>
        <emu-grammar>PropertyName : LiteralPropertyName</emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>PropertyName : ComputedPropertyName</emu-grammar>
        <emu-alg>
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object-initializer-static-semantics-propname">
        <h1>Static Semantics: PropName</h1>
        <emu-see-also-para op="PropName"></emu-see-also-para>
        <emu-grammar>PropertyDefinition : IdentifierReference</emu-grammar>
        <emu-alg>
          1. Return StringValue of |IdentifierReference|.
        </emu-alg>
        <emu-grammar>PropertyDefinition : `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. Return ~empty~.
        </emu-alg>
        <emu-grammar>PropertyDefinition : PropertyName `:` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. Return PropName of |PropertyName|.
        </emu-alg>
        <emu-grammar>LiteralPropertyName : IdentifierName</emu-grammar>
        <emu-alg>
          1. Return StringValue of |IdentifierName|.
        </emu-alg>
        <emu-grammar>LiteralPropertyName : StringLiteral</emu-grammar>
        <emu-alg>
          1. Return the String value whose code units are the SV of the |StringLiteral|.
        </emu-alg>
        <emu-grammar>LiteralPropertyName : NumericLiteral</emu-grammar>
        <emu-alg>
          1. Let _nbr_ be the result of forming the value of the |NumericLiteral|.
          1. Return ! ToString(_nbr_).
        </emu-alg>
        <emu-grammar>ComputedPropertyName : `[` AssignmentExpression `]`</emu-grammar>
        <emu-alg>
          1. Return ~empty~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-propertynamelist">
        <h1>Static Semantics: PropertyNameList</h1>
        <emu-grammar>PropertyDefinitionList : PropertyDefinition</emu-grammar>
        <emu-alg>
          1. If PropName of |PropertyDefinition| is ~empty~, return a new empty List.
          1. Return a new List containing PropName of |PropertyDefinition|.
        </emu-alg>
        <emu-grammar>PropertyDefinitionList : PropertyDefinitionList `,` PropertyDefinition</emu-grammar>
        <emu-alg>
          1. Let _list_ be PropertyNameList of |PropertyDefinitionList|.
          1. If PropName of |PropertyDefinition| is ~empty~, return _list_.
          1. Append PropName of |PropertyDefinition| to the end of _list_.
          1. Return _list_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object-initializer-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>ObjectLiteral : `{` `}`</emu-grammar>
        <emu-alg>
          1. Return ObjectCreate(%ObjectPrototype%).
        </emu-alg>
        <emu-grammar>
          ObjectLiteral :
            `{` PropertyDefinitionList `}`
            `{` PropertyDefinitionList `,` `}`
        </emu-grammar>
        <emu-alg>
          1. Let _obj_ be ObjectCreate(%ObjectPrototype%).
          1. Perform ? PropertyDefinitionEvaluation of |PropertyDefinitionList| with arguments _obj_ and *true*.
          1. Return _obj_.
        </emu-alg>
        <emu-grammar>LiteralPropertyName : IdentifierName</emu-grammar>
        <emu-alg>
          1. Return StringValue of |IdentifierName|.
        </emu-alg>
        <emu-grammar>LiteralPropertyName : StringLiteral</emu-grammar>
        <emu-alg>
          1. Return the String value whose code units are the SV of the |StringLiteral|.
        </emu-alg>
        <emu-grammar>LiteralPropertyName : NumericLiteral</emu-grammar>
        <emu-alg>
          1. Let _nbr_ be the result of forming the value of the |NumericLiteral|.
          1. Return ! ToString(_nbr_).
        </emu-alg>
        <emu-grammar>ComputedPropertyName : `[` AssignmentExpression `]`</emu-grammar>
        <emu-alg>
          1. Let _exprValue_ be the result of evaluating |AssignmentExpression|.
          1. Let _propName_ be ? GetValue(_exprValue_).
          1. Return ? ToPropertyKey(_propName_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object-initializer-runtime-semantics-propertydefinitionevaluation">
        <h1>Runtime Semantics: PropertyDefinitionEvaluation</h1>
        <p>With parameters _object_ and _enumerable_.</p>
        <emu-see-also-para op="PropertyDefinitionEvaluation"></emu-see-also-para>
        <emu-grammar>PropertyDefinitionList : PropertyDefinitionList `,` PropertyDefinition</emu-grammar>
        <emu-alg>
          1. Perform ? PropertyDefinitionEvaluation of |PropertyDefinitionList| with arguments _object_ and _enumerable_.
          1. Return the result of performing PropertyDefinitionEvaluation of |PropertyDefinition| with arguments _object_ and _enumerable_.
        </emu-alg>
        <emu-grammar>PropertyDefinition : `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. Let _exprValue_ be the result of evaluating |AssignmentExpression|.
          1. Let _fromValue_ be ? GetValue(_exprValue_).
          1. Let _excludedNames_ be a new empty List.
          1. Return ? CopyDataProperties(_object_, _fromValue_, _excludedNames_).
        </emu-alg>
        <emu-grammar>PropertyDefinition : IdentifierReference</emu-grammar>
        <emu-alg>
          1. Let _propName_ be StringValue of |IdentifierReference|.
          1. Let _exprValue_ be the result of evaluating |IdentifierReference|.
          1. Let _propValue_ be ? GetValue(_exprValue_).
          1. Assert: _enumerable_ is *true*.
          1. Assert: _object_ is an ordinary, extensible object with no non-configurable properties.
          1. Return ! CreateDataPropertyOrThrow(_object_, _propName_, _propValue_).
        </emu-alg>
        <emu-grammar>PropertyDefinition : PropertyName `:` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. Let _propKey_ be the result of evaluating |PropertyName|.
          1. ReturnIfAbrupt(_propKey_).
          1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true*, then
            1. Let _propValue_ be the result of performing NamedEvaluation for |AssignmentExpression| with argument _propKey_.
          1. Else,
            1. Let _exprValueRef_ be the result of evaluating |AssignmentExpression|.
            1. Let _propValue_ be ? GetValue(_exprValueRef_).
          1. Assert: _enumerable_ is *true*.
          1. Assert: _object_ is an ordinary, extensible object with no non-configurable properties.
          1. Return ! CreateDataPropertyOrThrow(_object_, _propKey_, _propValue_).
        </emu-alg>
        <emu-note>
          <p>An alternative semantics for this production is given in <emu-xref href="#sec-__proto__-property-names-in-object-initializers"></emu-xref>.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-defining-expressions">
      <h1>Function Defining Expressions</h1>
      <p>See <emu-xref href="#sec-function-definitions"></emu-xref> for <emu-grammar>PrimaryExpression : FunctionExpression</emu-grammar>.</p>
      <p>See <emu-xref href="#sec-generator-function-definitions"></emu-xref> for <emu-grammar>PrimaryExpression : GeneratorExpression</emu-grammar>.</p>
      <p>See <emu-xref href="#sec-class-definitions"></emu-xref> for <emu-grammar>PrimaryExpression : ClassExpression</emu-grammar>.</p>
      <p>See <emu-xref href="#sec-async-function-definitions"></emu-xref> for <emu-grammar>PrimaryExpression : AsyncFunctionExpression</emu-grammar>.</p>
      <p>See <emu-xref href="#sec-async-generator-function-definitions"></emu-xref> for <emu-grammar>PrimaryExpression : AsyncGeneratorExpression</emu-grammar>.</p>
    </emu-clause>

    <emu-clause id="sec-primary-expression-regular-expression-literals">
      <h1>Regular Expression Literals</h1>
      <h2>Syntax</h2>
      <p>See <emu-xref href="#sec-literals-regular-expression-literals"></emu-xref>.</p>

      <emu-clause id="sec-primary-expression-regular-expression-literals-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>PrimaryExpression : RegularExpressionLiteral</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if BodyText of |RegularExpressionLiteral| cannot be recognized using the goal symbol |Pattern| of the ECMAScript RegExp grammar specified in <emu-xref href="#sec-patterns"></emu-xref>.
          </li>
          <li>
            It is a Syntax Error if FlagText of |RegularExpressionLiteral| contains any code points other than `"g"`, `"i"`, `"m"`, `"s"`, `"u"`, or `"y"`, or if it contains the same code point more than once.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-regular-expression-literals-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>PrimaryExpression : RegularExpressionLiteral</emu-grammar>
        <emu-alg>
          1. Let _pattern_ be the String value consisting of the UTF16Encoding of each code point of BodyText of |RegularExpressionLiteral|.
          1. Let _flags_ be the String value consisting of the UTF16Encoding of each code point of FlagText of |RegularExpressionLiteral|.
          1. Return RegExpCreate(_pattern_, _flags_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-template-literals">
      <h1>Template Literals</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        TemplateLiteral[Yield, Await, Tagged] :
          NoSubstitutionTemplate
          SubstitutionTemplate[?Yield, ?Await, ?Tagged]

        SubstitutionTemplate[Yield, Await, Tagged] :
          TemplateHead Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]

        TemplateSpans[Yield, Await, Tagged] :
          TemplateTail
          TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateTail

        TemplateMiddleList[Yield, Await, Tagged] :
          TemplateMiddle Expression[+In, ?Yield, ?Await]
          TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-static-semantics-template-early-errors" oldids="sec-primary-expression-template-literals-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>
          TemplateLiteral[Yield, Await, Tagged] : NoSubstitutionTemplate
        </emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the number of elements in the result of TemplateStrings of |TemplateLiteral| with argument *false* is greater than 2<sup>32</sup> - 1.
          </li>
          <li>
            It is a Syntax Error if the <sub>[Tagged]</sub> parameter was not set and |NoSubstitutionTemplate| Contains |NotEscapeSequence|.
          </li>
        </ul>

        <emu-grammar>
          SubstitutionTemplate[Yield, Await, Tagged] : TemplateHead Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]
        </emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the <sub>[Tagged]</sub> parameter was not set and |TemplateHead| Contains |NotEscapeSequence|.
          </li>
        </ul>

        <emu-grammar>
          TemplateSpans[Yield, Await, Tagged] : TemplateTail
        </emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the <sub>[Tagged]</sub> parameter was not set and |TemplateTail| Contains |NotEscapeSequence|.
          </li>
        </ul>

        <emu-grammar>
          TemplateMiddleList[Yield, Await, Tagged] :
            TemplateMiddle Expression[+In, ?Yield, ?Await]
            TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]
        </emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the <sub>[Tagged]</sub> parameter was not set and |TemplateMiddle| Contains |NotEscapeSequence|.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-templatestrings">
        <h1>Static Semantics: TemplateStrings</h1>
        <p>With parameter _raw_.</p>
        <emu-grammar>TemplateLiteral : NoSubstitutionTemplate</emu-grammar>
        <emu-alg>
          1. If _raw_ is *false*, then
            1. Let _string_ be the TV of |NoSubstitutionTemplate|.
          1. Else,
            1. Let _string_ be the TRV of |NoSubstitutionTemplate|.
          1. Return a List containing the single element, _string_.
        </emu-alg>
        <emu-grammar>SubstitutionTemplate : TemplateHead Expression TemplateSpans</emu-grammar>
        <emu-alg>
          1. If _raw_ is *false*, then
            1. Let _head_ be the TV of |TemplateHead|.
          1. Else,
            1. Let _head_ be the TRV of |TemplateHead|.
          1. Let _tail_ be TemplateStrings of |TemplateSpans| with argument _raw_.
          1. Return a List containing _head_ followed by the elements, in order, of _tail_.
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateTail</emu-grammar>
        <emu-alg>
          1. If _raw_ is *false*, then
            1. Let _tail_ be the TV of |TemplateTail|.
          1. Else,
            1. Let _tail_ be the TRV of |TemplateTail|.
          1. Return a List containing the single element, _tail_.
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateMiddleList TemplateTail</emu-grammar>
        <emu-alg>
          1. Let _middle_ be TemplateStrings of |TemplateMiddleList| with argument _raw_.
          1. If _raw_ is *false*, then
            1. Let _tail_ be the TV of |TemplateTail|.
          1. Else,
            1. Let _tail_ be the TRV of |TemplateTail|.
          1. Return a List containing the elements, in order, of _middle_ followed by _tail_.
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. If _raw_ is *false*, then
            1. Let _string_ be the TV of |TemplateMiddle|.
          1. Else,
            1. Let _string_ be the TRV of |TemplateMiddle|.
          1. Return a List containing the single element, _string_.
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. Let _front_ be TemplateStrings of |TemplateMiddleList| with argument _raw_.
          1. If _raw_ is *false*, then
            1. Let _last_ be the TV of |TemplateMiddle|.
          1. Else,
            1. Let _last_ be the TRV of |TemplateMiddle|.
          1. Append _last_ as the last element of the List _front_.
          1. Return _front_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-template-literals-runtime-semantics-argumentlistevaluation">
        <h1>Runtime Semantics: ArgumentListEvaluation</h1>
        <emu-see-also-para op="ArgumentListEvaluation"></emu-see-also-para>
        <emu-grammar>TemplateLiteral : NoSubstitutionTemplate</emu-grammar>
        <emu-alg>
          1. Let _templateLiteral_ be this |TemplateLiteral|.
          1. Let _siteObj_ be GetTemplateObject(_templateLiteral_).
          1. Return a List containing the one element which is _siteObj_.
        </emu-alg>
        <emu-grammar>SubstitutionTemplate : TemplateHead Expression TemplateSpans</emu-grammar>
        <emu-alg>
          1. Let _templateLiteral_ be this |TemplateLiteral|.
          1. Let _siteObj_ be GetTemplateObject(_templateLiteral_).
          1. Let _firstSubRef_ be the result of evaluating |Expression|.
          1. Let _firstSub_ be ? GetValue(_firstSubRef_).
          1. Let _restSub_ be SubstitutionEvaluation of |TemplateSpans|.
          1. ReturnIfAbrupt(_restSub_).
          1. Assert: _restSub_ is a List.
          1. Return a List whose first element is _siteObj_, whose second elements is _firstSub_, and whose subsequent elements are the elements of _restSub_, in order. _restSub_ may contain no elements.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-gettemplateobject" aoid="GetTemplateObject">
        <h1>Runtime Semantics: GetTemplateObject ( _templateLiteral_ )</h1>
        <p>The abstract operation GetTemplateObject is called with a Parse Node, _templateLiteral_, as an argument. It performs the following steps:</p>
        <emu-alg>
          1. Let _rawStrings_ be TemplateStrings of _templateLiteral_ with argument *true*.
          1. Let _realm_ be the current Realm Record.
          1. Let _templateRegistry_ be _realm_.[[TemplateMap]].
          1. For each element _e_ of _templateRegistry_, do
            1. If _e_.[[Site]] is the same Parse Node as _templateLiteral_, then
              1. Return _e_.[[Array]].
          1. Let _cookedStrings_ be TemplateStrings of _templateLiteral_ with argument *false*.
          1. Let _count_ be the number of elements in the List _cookedStrings_.
          1. Assert: _count_ &le; 2<sup>32</sup> - 1.
          1. Let _template_ be ! ArrayCreate(_count_).
          1. Let _rawObj_ be ! ArrayCreate(_count_).
          1. Let _index_ be 0.
          1. Repeat, while _index_ &lt; _count_
            1. Let _prop_ be ! ToString(_index_).
            1. Let _cookedValue_ be the String value _cookedStrings_[_index_].
            1. Call _template_.[[DefineOwnProperty]](_prop_, PropertyDescriptor { [[Value]]: _cookedValue_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* }).
            1. Let _rawValue_ be the String value _rawStrings_[_index_].
            1. Call _rawObj_.[[DefineOwnProperty]](_prop_, PropertyDescriptor { [[Value]]: _rawValue_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* }).
            1. Increase _index_ by 1.
          1. Perform SetIntegrityLevel(_rawObj_, `"frozen"`).
          1. Call _template_.[[DefineOwnProperty]](`"raw"`, PropertyDescriptor { [[Value]]: _rawObj_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
          1. Perform SetIntegrityLevel(_template_, `"frozen"`).
          1. Append the Record { [[Site]]: _templateLiteral_, [[Array]]: _template_ } to _templateRegistry_.
          1. Return _template_.
        </emu-alg>
        <emu-note>
          <p>The creation of a template object cannot result in an abrupt completion.</p>
        </emu-note>
        <emu-note>
          <p>Each |TemplateLiteral| in the program code of a realm is associated with a unique template object that is used in the evaluation of tagged Templates (<emu-xref href="#sec-template-literals-runtime-semantics-evaluation"></emu-xref>). The template objects are frozen and the same template object is used each time a specific tagged Template is evaluated. Whether template objects are created lazily upon first evaluation of the |TemplateLiteral| or eagerly prior to first evaluation is an implementation choice that is not observable to ECMAScript code.</p>
        </emu-note>
        <emu-note>
          <p>Future editions of this specification may define additional non-enumerable properties of template objects.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-substitutionevaluation">
        <h1>Runtime Semantics: SubstitutionEvaluation</h1>
        <emu-grammar>TemplateSpans : TemplateTail</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateMiddleList TemplateTail</emu-grammar>
        <emu-alg>
          1. Return the result of SubstitutionEvaluation of |TemplateMiddleList|.
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. Let _subRef_ be the result of evaluating |Expression|.
          1. Let _sub_ be ? GetValue(_subRef_).
          1. Return a List containing only _sub_.
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. Let _preceding_ be the result of SubstitutionEvaluation of |TemplateMiddleList|.
          1. ReturnIfAbrupt(_preceding_).
          1. Let _nextRef_ be the result of evaluating |Expression|.
          1. Let _next_ be ? GetValue(_nextRef_).
          1. Append _next_ as the last element of the List _preceding_.
          1. Return _preceding_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-template-literals-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>TemplateLiteral : NoSubstitutionTemplate</emu-grammar>
        <emu-alg>
          1. Return the String value whose code units are the elements of the TV of |NoSubstitutionTemplate| as defined in <emu-xref href="#sec-template-literal-lexical-components"></emu-xref>.
        </emu-alg>
        <emu-grammar>SubstitutionTemplate : TemplateHead Expression TemplateSpans</emu-grammar>
        <emu-alg>
          1. Let _head_ be the TV of |TemplateHead| as defined in <emu-xref href="#sec-template-literal-lexical-components"></emu-xref>.
          1. Let _subRef_ be the result of evaluating |Expression|.
          1. Let _sub_ be ? GetValue(_subRef_).
          1. Let _middle_ be ? ToString(_sub_).
          1. Let _tail_ be the result of evaluating |TemplateSpans|.
          1. ReturnIfAbrupt(_tail_).
          1. Return the string-concatenation of _head_, _middle_, and _tail_.
        </emu-alg>
        <emu-note>
          <p>The string conversion semantics applied to the |Expression| value are like `String.prototype.concat` rather than the `+` operator.</p>
        </emu-note>
        <emu-grammar>TemplateSpans : TemplateTail</emu-grammar>
        <emu-alg>
          1. Let _tail_ be the TV of |TemplateTail| as defined in <emu-xref href="#sec-template-literal-lexical-components"></emu-xref>.
          1. Return the String value consisting of the code units of _tail_.
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateMiddleList TemplateTail</emu-grammar>
        <emu-alg>
          1. Let _head_ be the result of evaluating |TemplateMiddleList|.
          1. ReturnIfAbrupt(_head_).
          1. Let _tail_ be the TV of |TemplateTail| as defined in <emu-xref href="#sec-template-literal-lexical-components"></emu-xref>.
          1. Return the string-concatenation of _head_ and _tail_.
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. Let _head_ be the TV of |TemplateMiddle| as defined in <emu-xref href="#sec-template-literal-lexical-components"></emu-xref>.
          1. Let _subRef_ be the result of evaluating |Expression|.
          1. Let _sub_ be ? GetValue(_subRef_).
          1. Let _middle_ be ? ToString(_sub_).
          1. Return the sequence of code units consisting of the code units of _head_ followed by the elements of _middle_.
        </emu-alg>
        <emu-note>
          <p>The string conversion semantics applied to the |Expression| value are like `String.prototype.concat` rather than the `+` operator.</p>
        </emu-note>
        <emu-grammar>TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. Let _rest_ be the result of evaluating |TemplateMiddleList|.
          1. ReturnIfAbrupt(_rest_).
          1. Let _middle_ be the TV of |TemplateMiddle| as defined in <emu-xref href="#sec-template-literal-lexical-components"></emu-xref>.
          1. Let _subRef_ be the result of evaluating |Expression|.
          1. Let _sub_ be ? GetValue(_subRef_).
          1. Let _last_ be ? ToString(_sub_).
          1. Return the sequence of code units consisting of the elements of _rest_ followed by the code units of _middle_ followed by the elements of _last_.
        </emu-alg>
        <emu-note>
          <p>The string conversion semantics applied to the |Expression| value are like `String.prototype.concat` rather than the `+` operator.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-grouping-operator">
      <h1>The Grouping Operator</h1>

      <emu-clause id="sec-grouping-operator-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if |CoverParenthesizedExpressionAndArrowParameterList| is not covering a |ParenthesizedExpression|.
          </li>
          <li>
            All Early Error rules for |ParenthesizedExpression| and its derived productions also apply to CoveredParenthesizedExpression of |CoverParenthesizedExpressionAndArrowParameterList|.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-grouping-operator-static-semantics-isfunctiondefinition">
        <h1>Static Semantics: IsFunctionDefinition</h1>
        <emu-see-also-para op="IsFunctionDefinition"></emu-see-also-para>
        <emu-grammar>ParenthesizedExpression : `(` Expression `)`</emu-grammar>
        <emu-alg>
          1. Return IsFunctionDefinition of |Expression|.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-grouping-operator-static-semantics-isvalidsimpleassignmenttarget" id="sec-grouping-operator-static-semantics-assignmenttargettype">
        <h1>Static Semantics: AssignmentTargetType</h1>
        <emu-see-also-para op="AssignmentTargetType"></emu-see-also-para>
        <emu-grammar>ParenthesizedExpression : `(` Expression `)`</emu-grammar>
        <emu-alg>
          1. Return AssignmentTargetType of |Expression|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-grouping-operator-runtime-semantics-namedevaluation">
        <h1>Runtime Semantics: NamedEvaluation</h1>
        <p>With parameter _name_.</p>
        <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
        <emu-alg>
          1. Let _expr_ be CoveredParenthesizedExpression of |CoverParenthesizedExpressionAndArrowParameterList|.
          1. Return the result of performing NamedEvaluation for _expr_ with argument _name_.
        </emu-alg>
        <emu-grammar>ParenthesizedExpression : `(` Expression `)`</emu-grammar>
        <emu-alg>
          1. Assert: IsAnonymousFunctionDefinition(|Expression|) is *true*.
          1. Return the result of performing NamedEvaluation for |Expression| with argument _name_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-grouping-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
        <emu-alg>
          1. Let _expr_ be CoveredParenthesizedExpression of |CoverParenthesizedExpressionAndArrowParameterList|.
          1. Return the result of evaluating _expr_.
        </emu-alg>
        <emu-grammar>ParenthesizedExpression : `(` Expression `)`</emu-grammar>
        <emu-alg>
          1. Return the result of evaluating |Expression|. This may be of type Reference.
        </emu-alg>
        <emu-note>
          <p>This algorithm does not apply GetValue to the result of evaluating |Expression|. The principal motivation for this is so that operators such as `delete` and `typeof` may be applied to parenthesized expressions.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-left-hand-side-expressions">
    <h1>Left-Hand-Side Expressions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      MemberExpression[Yield, Await] :
        PrimaryExpression[?Yield, ?Await]
        MemberExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        MemberExpression[?Yield, ?Await] `.` IdentifierName
        MemberExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        SuperProperty[?Yield, ?Await]
        MetaProperty
        `new` MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]

      SuperProperty[Yield, Await] :
        `super` `[` Expression[+In, ?Yield, ?Await] `]`
        `super` `.` IdentifierName

      MetaProperty :
        NewTarget

      NewTarget :
        `new` `.` `target`

      NewExpression[Yield, Await] :
        MemberExpression[?Yield, ?Await]
        `new` NewExpression[?Yield, ?Await]

      CallExpression[Yield, Await] :
        CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] #callcover
        SuperCall[?Yield, ?Await]
        CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        CallExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        CallExpression[?Yield, ?Await] `.` IdentifierName
        CallExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]

      SuperCall[Yield, Await] :
        `super` Arguments[?Yield, ?Await]

      Arguments[Yield, Await] :
        `(` `)`
        `(` ArgumentList[?Yield, ?Await] `)`
        `(` ArgumentList[?Yield, ?Await] `,` `)`

      ArgumentList[Yield, Await] :
        AssignmentExpression[+In, ?Yield, ?Await]
        `...` AssignmentExpression[+In, ?Yield, ?Await]
        ArgumentList[?Yield, ?Await] `,` AssignmentExpression[+In, ?Yield, ?Await]
        ArgumentList[?Yield, ?Await] `,` `...` AssignmentExpression[+In, ?Yield, ?Await]

      LeftHandSideExpression[Yield, Await] :
        NewExpression[?Yield, ?Await]
        CallExpression[?Yield, ?Await]
    </emu-grammar>
    <h2>Supplemental Syntax</h2>
    <p>When processing an instance of the production <emu-grammar>CallExpression : CoverCallExpressionAndAsyncArrowHead</emu-grammar> the interpretation of |CoverCallExpressionAndAsyncArrowHead| is refined using the following grammar:</p>
    <emu-grammar type="definition">
      CallMemberExpression[Yield, Await] :
        MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-static-semantics">
      <h1>Static Semantics</h1>

      <emu-clause id="sec-left-hand-side-expressions-static-semantics-coveredcallexpression">
        <h1>Static Semantics: CoveredCallExpression</h1>
        <emu-grammar>
          CallExpression : CoverCallExpressionAndAsyncArrowHead
        </emu-grammar>
        <emu-alg>
          1. Return the |CallMemberExpression| that is covered by |CoverCallExpressionAndAsyncArrowHead|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-static-semantics-contains">
        <h1>Static Semantics: Contains</h1>
        <p>With parameter _symbol_.</p>
        <emu-see-also-para op="Contains"></emu-see-also-para>
        <emu-grammar>MemberExpression : MemberExpression `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. If |MemberExpression| Contains _symbol_ is *true*, return *true*.
          1. If _symbol_ is a |ReservedWord|, return *false*.
          1. If _symbol_ is an |Identifier| and StringValue of _symbol_ is the same value as the StringValue of |IdentifierName|, return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-grammar>SuperProperty : `super` `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. If _symbol_ is the |ReservedWord| `super`, return *true*.
          1. If _symbol_ is a |ReservedWord|, return *false*.
          1. If _symbol_ is an |Identifier| and StringValue of _symbol_ is the same value as the StringValue of |IdentifierName|, return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. If |CallExpression| Contains _symbol_ is *true*, return *true*.
          1. If _symbol_ is a |ReservedWord|, return *false*.
          1. If _symbol_ is an |Identifier| and StringValue of _symbol_ is the same value as the StringValue of |IdentifierName|, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-static-semantics-isfunctiondefinition">
        <h1>Static Semantics: IsFunctionDefinition</h1>
        <emu-see-also-para op="IsFunctionDefinition"></emu-see-also-para>
        <emu-grammar>
          MemberExpression :
            MemberExpression `[` Expression `]`
            MemberExpression `.` IdentifierName
            MemberExpression TemplateLiteral
            SuperProperty
            MetaProperty
            `new` MemberExpression Arguments

          NewExpression :
            `new` NewExpression

          LeftHandSideExpression :
            CallExpression
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-static-semantics-isdestructuring">
        <h1>Static Semantics: IsDestructuring</h1>
        <emu-see-also-para op="IsDestructuring"></emu-see-also-para>
        <emu-grammar>MemberExpression : PrimaryExpression</emu-grammar>
        <emu-alg>
          1. If |PrimaryExpression| is either an |ObjectLiteral| or an |ArrayLiteral|, return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-grammar>
          MemberExpression :
            MemberExpression `[` Expression `]`
            MemberExpression `.` IdentifierName
            MemberExpression TemplateLiteral
            SuperProperty
            MetaProperty
            `new` MemberExpression Arguments

          NewExpression :
            `new` NewExpression

          LeftHandSideExpression :
            CallExpression
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-static-semantics-isidentifierref">
        <h1>Static Semantics: IsIdentifierRef</h1>
        <emu-see-also-para op="IsIdentifierRef"></emu-see-also-para>
        <emu-grammar>
          MemberExpression :
            MemberExpression `[` Expression `]`
            MemberExpression `.` IdentifierName
            MemberExpression TemplateLiteral
            SuperProperty
            MetaProperty
            `new` MemberExpression Arguments

          NewExpression :
            `new` NewExpression

          LeftHandSideExpression :
            CallExpression
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-static-semantics-static-semantics-isvalidsimpleassignmenttarget" id="sec-static-semantics-static-semantics-assignmenttargettype">
        <h1>Static Semantics: AssignmentTargetType</h1>
        <emu-see-also-para op="AssignmentTargetType"></emu-see-also-para>
        <emu-grammar>
          CallExpression :
            CallExpression `[` Expression `]`
            CallExpression `.` IdentifierName

          MemberExpression :
            MemberExpression `[` Expression `]`
            MemberExpression `.` IdentifierName
            SuperProperty
        </emu-grammar>
        <emu-alg>
          1. Return ~simple~.
        </emu-alg>
        <emu-grammar>
          CallExpression :
            CoverCallExpressionAndAsyncArrowHead
            SuperCall
            CallExpression Arguments
            CallExpression TemplateLiteral

          NewExpression :
            `new` NewExpression

          MemberExpression :
            MemberExpression TemplateLiteral
            `new` MemberExpression Arguments

          NewTarget :
            `new` `.` `target`
        </emu-grammar>
        <emu-alg>
          1. Return ~invalid~.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-property-accessors">
      <h1>Property Accessors</h1>
      <emu-note>
        <p>Properties are accessed by name, using either the dot notation:</p>
        <div class="rhs">
          |MemberExpression| `.` |IdentifierName|
          <br>
          |CallExpression| `.` |IdentifierName|
        </div>
        <p>or the bracket notation:</p>
        <div class="rhs">
          |MemberExpression| `[` |Expression| `]`
          <br>
          |CallExpression| `[` |Expression| `]`
        </div>
        <p>The dot notation is explained by the following syntactic conversion:</p>
        <div class="rhs">
          |MemberExpression| `.` |IdentifierName|
        </div>
        <p>is identical in its behaviour to</p>
        <div class="rhs">
          |MemberExpression| `[` &lt;<i>identifier-name-string</i>&gt; `]`
        </div>
        <p>and similarly</p>
        <div class="rhs">
          |CallExpression| `.` |IdentifierName|
        </div>
        <p>is identical in its behaviour to</p>
        <div class="rhs">
          |CallExpression| `[` &lt;<i>identifier-name-string</i>&gt; `]`
        </div>
        <p>where &lt;<i>identifier-name-string</i>&gt; is the result of evaluating StringValue of |IdentifierName|.</p>
      </emu-note>

      <emu-clause id="sec-property-accessors-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>MemberExpression : MemberExpression `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. Let _baseReference_ be the result of evaluating |MemberExpression|.
          1. Let _baseValue_ be ? GetValue(_baseReference_).
          1. Let _propertyNameReference_ be the result of evaluating |Expression|.
          1. Let _propertyNameValue_ be ? GetValue(_propertyNameReference_).
          1. Let _bv_ be ? RequireObjectCoercible(_baseValue_).
          1. Let _propertyKey_ be ? ToPropertyKey(_propertyNameValue_).
          1. If the code matched by this |MemberExpression| is strict mode code, let _strict_ be *true*, else let _strict_ be *false*.
          1. Return a value of type Reference whose base value component is _bv_, whose referenced name component is _propertyKey_, and whose strict reference flag is _strict_.
        </emu-alg>
        <emu-grammar>MemberExpression : MemberExpression `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. Let _baseReference_ be the result of evaluating |MemberExpression|.
          1. Let _baseValue_ be ? GetValue(_baseReference_).
          1. Let _bv_ be ? RequireObjectCoercible(_baseValue_).
          1. Let _propertyNameString_ be StringValue of |IdentifierName|.
          1. If the code matched by this |MemberExpression| is strict mode code, let _strict_ be *true*, else let _strict_ be *false*.
          1. Return a value of type Reference whose base value component is _bv_, whose referenced name component is _propertyNameString_, and whose strict reference flag is _strict_.
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression `[` Expression `]`</emu-grammar>
        <p>Is evaluated in exactly the same manner as <emu-grammar>MemberExpression : MemberExpression `[` Expression `]`</emu-grammar> except that the contained |CallExpression| is evaluated in step 1.</p>
        <emu-grammar>CallExpression : CallExpression `.` IdentifierName</emu-grammar>
        <p>Is evaluated in exactly the same manner as <emu-grammar>MemberExpression : MemberExpression `.` IdentifierName</emu-grammar> except that the contained |CallExpression| is evaluated in step 1.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-new-operator">
      <h1>The `new` Operator</h1>

      <emu-clause id="sec-new-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>NewExpression : `new` NewExpression</emu-grammar>
        <emu-alg>
          1. Return ? EvaluateNew(|NewExpression|, ~empty~).
        </emu-alg>
        <emu-grammar>MemberExpression : `new` MemberExpression Arguments</emu-grammar>
        <emu-alg>
          1. Return ? EvaluateNew(|MemberExpression|, |Arguments|).
        </emu-alg>

        <emu-clause id="sec-evaluatenew" aoid="EvaluateNew">
          <h1>Runtime Semantics: EvaluateNew ( _constructExpr_, _arguments_ )</h1>
          <p>The abstract operation EvaluateNew with arguments _constructExpr_, and _arguments_ performs the following steps:</p>
          <emu-alg>
            1. Assert: _constructExpr_ is either a |NewExpression| or a |MemberExpression|.
            1. Assert: _arguments_ is either ~empty~ or an |Arguments|.
            1. Let _ref_ be the result of evaluating _constructExpr_.
            1. Let _constructor_ be ? GetValue(_ref_).
            1. If _arguments_ is ~empty~, let _argList_ be a new empty List.
            1. Else,
              1. Let _argList_ be ArgumentListEvaluation of _arguments_.
              1. ReturnIfAbrupt(_argList_).
            1. If IsConstructor(_constructor_) is *false*, throw a *TypeError* exception.
            1. Return ? Construct(_constructor_, _argList_).
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-calls">
      <h1>Function Calls</h1>

      <emu-clause id="sec-function-calls-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>CallExpression : CoverCallExpressionAndAsyncArrowHead</emu-grammar>
        <emu-alg>
          1. Let _expr_ be CoveredCallExpression of |CoverCallExpressionAndAsyncArrowHead|.
          1. Let _memberExpr_ be the |MemberExpression| of _expr_.
          1. Let _arguments_ be the |Arguments| of _expr_.
          1. Let _ref_ be the result of evaluating _memberExpr_.
          1. Let _func_ be ? GetValue(_ref_).
          1. If Type(_ref_) is Reference and IsPropertyReference(_ref_) is *false* and GetReferencedName(_ref_) is `"eval"`, then
            1. If SameValue(_func_, %eval%) is *true*, then
              1. Let _argList_ be ? ArgumentListEvaluation of _arguments_.
              1. If _argList_ has no elements, return *undefined*.
              1. Let _evalText_ be the first element of _argList_.
              1. If the source code matching this |CallExpression| is strict mode code, let _strictCaller_ be *true*. Otherwise let _strictCaller_ be *false*.
              1. Let _evalRealm_ be the current Realm Record.
              1. Perform ? HostEnsureCanCompileStrings(_evalRealm_, _evalRealm_).
              1. Return ? PerformEval(_evalText_, _evalRealm_, _strictCaller_, *true*).
          1. Let _thisCall_ be this |CallExpression|.
          1. Let _tailCall_ be IsInTailPosition(_thisCall_).
          1. Return ? EvaluateCall(_func_, _ref_, _arguments_, _tailCall_).
        </emu-alg>
        <p>A |CallExpression| evaluation that executes step 6.a.vii is a <dfn>direct eval</dfn>.</p>
        <emu-grammar>CallExpression : CallExpression Arguments</emu-grammar>
        <emu-alg>
          1. Let _ref_ be the result of evaluating |CallExpression|.
          1. Let _func_ be ? GetValue(_ref_).
          1. Let _thisCall_ be this |CallExpression|.
          1. Let _tailCall_ be IsInTailPosition(_thisCall_).
          1. Return ? EvaluateCall(_func_, _ref_, |Arguments|, _tailCall_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-evaluatecall" aoid="EvaluateCall" oldids="sec-evaluatedirectcall">
        <h1>Runtime Semantics: EvaluateCall ( _func_, _ref_, _arguments_, _tailPosition_ )</h1>
        <p>The abstract operation EvaluateCall takes as arguments a value _func_, a value _ref_, a Parse Node _arguments_, and a Boolean argument _tailPosition_. It performs the following steps:</p>
        <emu-alg>
          1. If Type(_ref_) is Reference, then
            1. If IsPropertyReference(_ref_) is *true*, then
              1. Let _thisValue_ be GetThisValue(_ref_).
            1. Else the base of _ref_ is an Environment Record,
              1. Let _refEnv_ be GetBase(_ref_).
              1. Let _thisValue_ be _refEnv_.WithBaseObject().
          1. Else Type(_ref_) is not Reference,
            1. Let _thisValue_ be *undefined*.
          1. Let _argList_ be ArgumentListEvaluation of _arguments_.
          1. ReturnIfAbrupt(_argList_).
          1. If Type(_func_) is not Object, throw a *TypeError* exception.
          1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.
          1. If _tailPosition_ is *true*, perform PrepareForTailCall().
          1. Let _result_ be Call(_func_, _thisValue_, _argList_).
          1. Assert: If _tailPosition_ is *true*, the above call will not return here, but instead evaluation will continue as if the following return has already occurred.
          1. Assert: If _result_ is not an abrupt completion, then Type(_result_) is an ECMAScript language type.
          1. Return _result_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-super-keyword">
      <h1>The `super` Keyword</h1>

      <emu-clause id="sec-super-keyword-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>SuperProperty : `super` `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. Let _env_ be GetThisEnvironment().
          1. Let _actualThis_ be ? _env_.GetThisBinding().
          1. Let _propertyNameReference_ be the result of evaluating |Expression|.
          1. Let _propertyNameValue_ be ? GetValue(_propertyNameReference_).
          1. Let _propertyKey_ be ? ToPropertyKey(_propertyNameValue_).
          1. If the code matched by this |SuperProperty| is strict mode code, let _strict_ be *true*, else let _strict_ be *false*.
          1. Return ? MakeSuperPropertyReference(_actualThis_, _propertyKey_, _strict_).
        </emu-alg>
        <emu-grammar>SuperProperty : `super` `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. Let _env_ be GetThisEnvironment().
          1. Let _actualThis_ be ? _env_.GetThisBinding().
          1. Let _propertyKey_ be StringValue of |IdentifierName|.
          1. If the code matched by this |SuperProperty| is strict mode code, let _strict_ be *true*, else let _strict_ be *false*.
          1. Return ? MakeSuperPropertyReference(_actualThis_, _propertyKey_, _strict_).
        </emu-alg>
        <emu-grammar>SuperCall : `super` Arguments</emu-grammar>
        <emu-alg>
          1. Let _newTarget_ be GetNewTarget().
          1. Assert: Type(_newTarget_) is Object.
          1. Let _func_ be ? GetSuperConstructor().
          1. Let _argList_ be ArgumentListEvaluation of |Arguments|.
          1. ReturnIfAbrupt(_argList_).
          1. Let _result_ be ? Construct(_func_, _argList_, _newTarget_).
          1. Let _thisER_ be GetThisEnvironment().
          1. Return ? _thisER_.BindThisValue(_result_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getsuperconstructor" aoid="GetSuperConstructor">
        <h1>Runtime Semantics: GetSuperConstructor ( )</h1>
        <p>The abstract operation GetSuperConstructor performs the following steps:</p>
        <emu-alg>
          1. Let _envRec_ be GetThisEnvironment().
          1. Assert: _envRec_ is a function Environment Record.
          1. Let _activeFunction_ be _envRec_.[[FunctionObject]].
          1. Assert: _activeFunction_ is an ECMAScript function object.
          1. Let _superConstructor_ be ! _activeFunction_.[[GetPrototypeOf]]().
          1. If IsConstructor(_superConstructor_) is *false*, throw a *TypeError* exception.
          1. Return _superConstructor_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makesuperpropertyreference" aoid="MakeSuperPropertyReference">
        <h1>Runtime Semantics: MakeSuperPropertyReference ( _actualThis_, _propertyKey_, _strict_ )</h1>
        <p>The abstract operation MakeSuperPropertyReference with arguments _actualThis_, _propertyKey_, and _strict_ performs the following steps:</p>
        <emu-alg>
          1. Let _env_ be GetThisEnvironment().
          1. Assert: _env_.HasSuperBinding() is *true*.
          1. Let _baseValue_ be ? _env_.GetSuperBase().
          1. Let _bv_ be ? RequireObjectCoercible(_baseValue_).
          1. Return a value of type Reference that is a Super Reference whose base value component is _bv_, whose referenced name component is _propertyKey_, whose thisValue component is _actualThis_, and whose strict reference flag is _strict_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-argument-lists">
      <h1>Argument Lists</h1>
      <emu-note>
        <p>The evaluation of an argument list produces a List of values.</p>
      </emu-note>

      <emu-clause id="sec-argument-lists-runtime-semantics-argumentlistevaluation">
        <h1>Runtime Semantics: ArgumentListEvaluation</h1>
        <emu-see-also-para op="ArgumentListEvaluation"></emu-see-also-para>
        <emu-grammar>Arguments : `(` `)`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ArgumentList : AssignmentExpression</emu-grammar>
        <emu-alg>
          1. Let _ref_ be the result of evaluating |AssignmentExpression|.
          1. Let _arg_ be ? GetValue(_ref_).
          1. Return a List whose sole item is _arg_.
        </emu-alg>
        <emu-grammar>ArgumentList : `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. Let _list_ be a new empty List.
          1. Let _spreadRef_ be the result of evaluating |AssignmentExpression|.
          1. Let _spreadObj_ be ? GetValue(_spreadRef_).
          1. Let _iteratorRecord_ be ? GetIterator(_spreadObj_).
          1. Repeat,
            1. Let _next_ be ? IteratorStep(_iteratorRecord_).
            1. If _next_ is *false*, return _list_.
            1. Let _nextArg_ be ? IteratorValue(_next_).
            1. Append _nextArg_ as the last element of _list_.
        </emu-alg>
        <emu-grammar>ArgumentList : ArgumentList `,` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. Let _precedingArgs_ be ArgumentListEvaluation of |ArgumentList|.
          1. ReturnIfAbrupt(_precedingArgs_).
          1. Let _ref_ be the result of evaluating |AssignmentExpression|.
          1. Let _arg_ be ? GetValue(_ref_).
          1. Append _arg_ to the end of _precedingArgs_.
          1. Return _precedingArgs_.
        </emu-alg>
        <emu-grammar>ArgumentList : ArgumentList `,` `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. Let _precedingArgs_ be ArgumentListEvaluation of |ArgumentList|.
          1. ReturnIfAbrupt(_precedingArgs_).
          1. Let _spreadRef_ be the result of evaluating |AssignmentExpression|.
          1. Let _iteratorRecord_ be ? GetIterator(? GetValue(_spreadRef_)).
          1. Repeat,
            1. Let _next_ be ? IteratorStep(_iteratorRecord_).
            1. If _next_ is *false*, return _precedingArgs_.
            1. Let _nextArg_ be ? IteratorValue(_next_).
            1. Append _nextArg_ as the last element of _precedingArgs_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-tagged-templates">
      <h1>Tagged Templates</h1>
      <emu-note>
        <p>A tagged template is a function call where the arguments of the call are derived from a |TemplateLiteral| (<emu-xref href="#sec-template-literals"></emu-xref>). The actual arguments include a template object (<emu-xref href="#sec-gettemplateobject"></emu-xref>) and the values produced by evaluating the expressions embedded within the |TemplateLiteral|.</p>
      </emu-note>

      <emu-clause id="sec-tagged-templates-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>MemberExpression : MemberExpression TemplateLiteral</emu-grammar>
        <emu-alg>
          1. Let _tagRef_ be the result of evaluating |MemberExpression|.
          1. Let _tagFunc_ be ? GetValue(_tagRef_).
          1. Let _thisCall_ be this |MemberExpression|.
          1. Let _tailCall_ be IsInTailPosition(_thisCall_).
          1. Return ? EvaluateCall(_tagFunc_, _tagRef_, |TemplateLiteral|, _tailCall_).
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression TemplateLiteral</emu-grammar>
        <emu-alg>
          1. Let _tagRef_ be the result of evaluating |CallExpression|.
          1. Let _tagFunc_ be ? GetValue(_tagRef_).
          1. Let _thisCall_ be this |CallExpression|.
          1. Let _tailCall_ be IsInTailPosition(_thisCall_).
          1. Return ? EvaluateCall(_tagFunc_, _tagRef_, |TemplateLiteral|, _tailCall_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-meta-properties">
      <h1>Meta Properties</h1>

      <emu-clause id="sec-meta-properties-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>NewTarget : `new` `.` `target`</emu-grammar>
        <emu-alg>
          1. Return GetNewTarget().
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-update-expressions">
    <h1>Update Expressions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      UpdateExpression[Yield, Await] :
        LeftHandSideExpression[?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `++`
        LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `--`
        `++` UnaryExpression[?Yield, ?Await]
        `--` UnaryExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-update-expressions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>
        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
      </emu-grammar>
      <ul>
        <li>
          It is an early Reference Error if AssignmentTargetType of |LeftHandSideExpression| is ~invalid~.
        </li>
        <li>
          It is an early Syntax Error if AssignmentTargetType of |LeftHandSideExpression| is ~strict~.
        </li>
      </ul>

      <emu-grammar>
        UpdateExpression :
          `++` UnaryExpression
          `--` UnaryExpression
      </emu-grammar>
      <ul>
        <li>
          It is an early Reference Error if AssignmentTargetType of |UnaryExpression| is ~invalid~.
        </li>
        <li>
          It is an early Syntax Error if AssignmentTargetType of |UnaryExpression| is ~strict~.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-update-expressions-static-semantics-isfunctiondefinition">
      <h1>Static Semantics: IsFunctionDefinition</h1>
      <emu-see-also-para op="IsFunctionDefinition"></emu-see-also-para>
      <emu-grammar>
        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
          `++` UnaryExpression
          `--` UnaryExpression
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-update-expressions-static-semantics-isvalidsimpleassignmenttarget" id="sec-update-expressions-static-semantics-assignmenttargettype">
      <h1>Static Semantics: AssignmentTargetType</h1>
      <emu-see-also-para op="AssignmentTargetType"></emu-see-also-para>
      <emu-grammar>
        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
          `++` UnaryExpression
          `--` UnaryExpression
      </emu-grammar>
      <emu-alg>
        1. Return ~invalid~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-postfix-increment-operator">
      <h1>Postfix Increment Operator</h1>

      <emu-clause id="sec-postfix-increment-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UpdateExpression : LeftHandSideExpression `++`</emu-grammar>
        <emu-alg>
          1. Let _lhs_ be the result of evaluating |LeftHandSideExpression|.
          1. Let _oldValue_ be ? ToNumber(? GetValue(_lhs_)).
          1. Let _newValue_ be the result of adding the value 1 to _oldValue_, using the same rules as for the `+` operator (see <emu-xref href="#sec-applying-the-additive-operators-to-numbers"></emu-xref>).
          1. Perform ? PutValue(_lhs_, _newValue_).
          1. Return _oldValue_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-postfix-decrement-operator">
      <h1>Postfix Decrement Operator</h1>

      <emu-clause id="sec-postfix-decrement-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UpdateExpression : LeftHandSideExpression `--`</emu-grammar>
        <emu-alg>
          1. Let _lhs_ be the result of evaluating |LeftHandSideExpression|.
          1. Let _oldValue_ be ? ToNumber(? GetValue(_lhs_)).
          1. Let _newValue_ be the result of subtracting the value 1 from _oldValue_, using the same rules as for the `-` operator (see <emu-xref href="#sec-applying-the-additive-operators-to-numbers"></emu-xref>).
          1. Perform ? PutValue(_lhs_, _newValue_).
          1. Return _oldValue_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-prefix-increment-operator">
      <h1>Prefix Increment Operator</h1>

      <emu-clause id="sec-prefix-increment-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UpdateExpression : `++` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be the result of evaluating |UnaryExpression|.
          1. Let _oldValue_ be ? ToNumber(? GetValue(_expr_)).
          1. Let _newValue_ be the result of adding the value 1 to _oldValue_, using the same rules as for the `+` operator (see <emu-xref href="#sec-applying-the-additive-operators-to-numbers"></emu-xref>).
          1. Perform ? PutValue(_expr_, _newValue_).
          1. Return _newValue_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-prefix-decrement-operator">
      <h1>Prefix Decrement Operator</h1>

      <emu-clause id="sec-prefix-decrement-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UpdateExpression : `--` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be the result of evaluating |UnaryExpression|.
          1. Let _oldValue_ be ? ToNumber(? GetValue(_expr_)).
          1. Let _newValue_ be the result of subtracting the value 1 from _oldValue_, using the same rules as for the `-` operator (see <emu-xref href="#sec-applying-the-additive-operators-to-numbers"></emu-xref>).
          1. Perform ? PutValue(_expr_, _newValue_).
          1. Return _newValue_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-unary-operators">
    <h1>Unary Operators</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      UnaryExpression[Yield, Await] :
        UpdateExpression[?Yield, ?Await]
        `delete` UnaryExpression[?Yield, ?Await]
        `void` UnaryExpression[?Yield, ?Await]
        `typeof` UnaryExpression[?Yield, ?Await]
        `+` UnaryExpression[?Yield, ?Await]
        `-` UnaryExpression[?Yield, ?Await]
        `~` UnaryExpression[?Yield, ?Await]
        `!` UnaryExpression[?Yield, ?Await]
        [+Await] AwaitExpression[?Yield]
    </emu-grammar>

    <emu-clause id="sec-unary-operators-static-semantics-isfunctiondefinition">
      <h1>Static Semantics: IsFunctionDefinition</h1>
      <emu-see-also-para op="IsFunctionDefinition"></emu-see-also-para>
      <emu-grammar>
        UnaryExpression :
          `delete` UnaryExpression
          `void` UnaryExpression
          `typeof` UnaryExpression
          `+` UnaryExpression
          `-` UnaryExpression
          `~` UnaryExpression
          `!` UnaryExpression
          AwaitExpression
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-unary-operators-static-semantics-isvalidsimpleassignmenttarget" id="sec-unary-operators-static-semantics-assignmenttargettype">
      <h1>Static Semantics: AssignmentTargetType</h1>
      <emu-see-also-para op="AssignmentTargetType"></emu-see-also-para>
      <emu-grammar>
        UnaryExpression :
          `delete` UnaryExpression
          `void` UnaryExpression
          `typeof` UnaryExpression
          `+` UnaryExpression
          `-` UnaryExpression
          `~` UnaryExpression
          `!` UnaryExpression
          AwaitExpression
      </emu-grammar>
      <emu-alg>
        1. Return ~invalid~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-delete-operator">
      <h1>The `delete` Operator</h1>

      <emu-clause id="sec-delete-operator-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>UnaryExpression : `delete` UnaryExpression</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the |UnaryExpression| is contained in strict mode code and the derived |UnaryExpression| is <emu-grammar>PrimaryExpression : IdentifierReference</emu-grammar>.
          </li>
          <li>
            <p>It is a Syntax Error if the derived |UnaryExpression| is
              <br>
              <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
              <br>
              and |CoverParenthesizedExpressionAndArrowParameterList| ultimately derives a phrase that, if used in place of |UnaryExpression|, would produce a Syntax Error according to these rules. This rule is recursively applied.</p>
          </li>
        </ul>
        <emu-note>
          <p>The last rule means that expressions such as `delete (((foo)))` produce early errors because of recursive application of the first rule.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-delete-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `delete` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _ref_ be the result of evaluating |UnaryExpression|.
          1. ReturnIfAbrupt(_ref_).
          1. If Type(_ref_) is not Reference, return *true*.
          1. If IsUnresolvableReference(_ref_) is *true*, then
            1. Assert: IsStrictReference(_ref_) is *false*.
            1. Return *true*.
          1. If IsPropertyReference(_ref_) is *true*, then
            1. If IsSuperReference(_ref_) is *true*, throw a *ReferenceError* exception.
            1. Let _baseObj_ be ! ToObject(GetBase(_ref_)).
            1. Let _deleteStatus_ be ? _baseObj_.[[Delete]](GetReferencedName(_ref_)).
            1. If _deleteStatus_ is *false* and IsStrictReference(_ref_) is *true*, throw a *TypeError* exception.
            1. Return _deleteStatus_.
          1. Else _ref_ is a Reference to an Environment Record binding,
            1. Let _bindings_ be GetBase(_ref_).
            1. Return ? _bindings_.DeleteBinding(GetReferencedName(_ref_)).
        </emu-alg>
        <emu-note>
          <p>When a `delete` operator occurs within strict mode code, a *SyntaxError* exception is thrown if its |UnaryExpression| is a direct reference to a variable, function argument, or function name. In addition, if a `delete` operator occurs within strict mode code and the property to be deleted has the attribute { [[Configurable]]: *false* }, a *TypeError* exception is thrown.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-void-operator">
      <h1>The `void` Operator</h1>

      <emu-clause id="sec-void-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `void` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be the result of evaluating |UnaryExpression|.
          1. Perform ? GetValue(_expr_).
          1. Return *undefined*.
        </emu-alg>
        <emu-note>
          <p>GetValue must be called even though its value is not used because it may have observable side-effects.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-typeof-operator">
      <h1>The `typeof` Operator</h1>

      <emu-clause id="sec-typeof-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `typeof` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _val_ be the result of evaluating |UnaryExpression|.
          1. If Type(_val_) is Reference, then
            1. If IsUnresolvableReference(_val_) is *true*, return `"undefined"`.
          1. Set _val_ to ? GetValue(_val_).
          1. Return a String according to <emu-xref href="#table-35"></emu-xref>.
        </emu-alg>
        <emu-table id="table-35" caption="typeof Operator Results">
          <table>
            <tbody>
            <tr>
              <th>
                Type of _val_
              </th>
              <th>
                Result
              </th>
            </tr>
            <tr>
              <td>
                Undefined
              </td>
              <td>
                `"undefined"`
              </td>
            </tr>
            <tr>
              <td>
                Null
              </td>
              <td>
                `"object"`
              </td>
            </tr>
            <tr>
              <td>
                Boolean
              </td>
              <td>
                `"boolean"`
              </td>
            </tr>
            <tr>
              <td>
                Number
              </td>
              <td>
                `"number"`
              </td>
            </tr>
            <tr>
              <td>
                String
              </td>
              <td>
                `"string"`
              </td>
            </tr>
            <tr>
              <td>
                Symbol
              </td>
              <td>
                `"symbol"`
              </td>
            </tr>
            <tr>
              <td>
                Object (does not implement [[Call]])
              </td>
              <td>
                `"object"`
              </td>
            </tr>
            <tr>
              <td>
                Object (implements [[Call]])
              </td>
              <td>
                `"function"`
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>


    <emu-clause id="sec-unary-plus-operator">
      <h1>Unary `+` Operator</h1>
      <emu-note>
        <p>The unary + operator converts its operand to Number type.</p>
      </emu-note>

      <emu-clause id="sec-unary-plus-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `+` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be the result of evaluating |UnaryExpression|.
          1. Return ? ToNumber(? GetValue(_expr_)).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-unary-minus-operator">
      <h1>Unary `-` Operator</h1>
      <emu-note>
        <p>The unary `-` operator converts its operand to Number type and then negates it. Negating *+0* produces *-0*, and negating *-0* produces *+0*.</p>
      </emu-note>

      <emu-clause id="sec-unary-minus-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `-` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be the result of evaluating |UnaryExpression|.
          1. Let _oldValue_ be ? ToNumber(? GetValue(_expr_)).
          1. If _oldValue_ is *NaN*, return *NaN*.
          1. Return the result of negating _oldValue_; that is, compute a Number with the same magnitude but opposite sign.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-bitwise-not-operator">
      <h1>Bitwise NOT Operator ( `~` )</h1>

      <emu-clause id="sec-bitwise-not-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `~` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be the result of evaluating |UnaryExpression|.
          1. Let _oldValue_ be ? ToInt32(? GetValue(_expr_)).
          1. Return the result of applying bitwise complement to _oldValue_. The result is a signed 32-bit integer.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-logical-not-operator">
      <h1>Logical NOT Operator ( `!` )</h1>

      <emu-clause id="sec-logical-not-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `!` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be the result of evaluating |UnaryExpression|.
          1. Let _oldValue_ be ToBoolean(? GetValue(_expr_)).
          1. If _oldValue_ is *true*, return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-exp-operator">
    <h1>Exponentiation Operator</h1>
    <h2>Syntax</h2>

    <emu-grammar type="definition">
      ExponentiationExpression[Yield, Await] :
        UnaryExpression[?Yield, ?Await]
        UpdateExpression[?Yield, ?Await] `**` ExponentiationExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-exp-operator-static-semantics-isfunctiondefinition">
      <h1>Static Semantics: IsFunctionDefinition</h1>
      <emu-see-also-para op="IsFunctionDefinition"></emu-see-also-para>
      <emu-grammar>
        ExponentiationExpression :
          UpdateExpression `**` ExponentiationExpression
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-exp-operator-static-semantics-isvalidsimpleassignmenttarget" id="sec-exp-operator-static-semantics-assignmenttargettype">
      <h1>Static Semantics: AssignmentTargetType</h1>
      <emu-see-also-para op="AssignmentTargetType"></emu-see-also-para>
      <emu-grammar>
        ExponentiationExpression :
          UpdateExpression `**` ExponentiationExpression
      </emu-grammar>
      <emu-alg>
        1. Return ~invalid~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-exp-operator-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>
        ExponentiationExpression : UpdateExpression `**` ExponentiationExpression
      </emu-grammar>
      <emu-alg>
        1. Let _left_ be the result of evaluating |UpdateExpression|.
        1. Let _leftValue_ be ? GetValue(_left_).
        1. Let _right_ be the result of evaluating |ExponentiationExpression|.
        1. Let _rightValue_ be ? GetValue(_right_).
        1. Let _base_ be ? ToNumber(_leftValue_).
        1. Let _exponent_ be ? ToNumber(_rightValue_).
        1. Return the result of <emu-xref href="#sec-applying-the-exp-operator" title>Applying the ** operator</emu-xref> with _base_ and _exponent_ as specified in <emu-xref href="#sec-applying-the-exp-operator"></emu-xref>.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-applying-the-exp-operator">
      <h1>Applying the `**` Operator</h1>
      <p>
        Returns an implementation-dependent approximation of the result of raising _base_ to the power _exponent_.
      </p>
      <ul>
        <li>If _exponent_ is *NaN*, the result is *NaN*.</li>
        <li>If _exponent_ is *+0*, the result is 1, even if _base_ is *NaN*.</li>
        <li>If _exponent_ is *-0*, the result is 1, even if _base_ is *NaN*.</li>
        <li>If _base_ is *NaN* and _exponent_ is nonzero, the result is *NaN*.</li>
        <li>If abs(_base_) &gt; 1 and _exponent_ is *+&infin;*, the result is *+&infin;*.</li>
        <li>If abs(_base_) &gt; 1 and _exponent_ is *-&infin;*, the result is *+0*.</li>
        <li>If abs(_base_) is 1 and _exponent_ is *+&infin;*, the result is *NaN*.</li>
        <li>If abs(_base_) is 1 and _exponent_ is *-&infin;*, the result is *NaN*.</li>
        <li>If abs(_base_) &lt; 1 and _exponent_ is *+&infin;*, the result is *+0*.</li>
        <li>If abs(_base_) &lt; 1 and _exponent_ is *-&infin;*, the result is *+&infin;*.</li>
        <li>If _base_ is *+&infin;* and _exponent_ &gt; 0, the result is *+&infin;*.</li>
        <li>If _base_ is *+&infin;* and _exponent_ &lt; 0, the result is *+0*.</li>
        <li>If _base_ is *-&infin;* and _exponent_ &gt; 0 and _exponent_ is an odd integer, the result is *-&infin;*.</li>
        <li>If _base_ is *-&infin;* and _exponent_ &gt; 0 and _exponent_ is not an odd integer, the result is *+&infin;*.</li>
        <li>If _base_ is *-&infin;* and _exponent_ &lt; 0 and _exponent_ is an odd integer, the result is *-0*.</li>
        <li>If _base_ is *-&infin;* and _exponent_ &lt; 0 and _exponent_ is not an odd integer, the result is *+0*.</li>
        <li>If _base_ is *+0* and _exponent_ &gt; 0, the result is *+0*.</li>
        <li>If _base_ is *+0* and _exponent_ &lt; 0, the result is *+&infin;*.</li>
        <li>If _base_ is *-0* and _exponent_ &gt; 0 and _exponent_ is an odd integer, the result is *-0*.</li>
        <li>If _base_ is *-0* and _exponent_ &gt; 0 and _exponent_ is not an odd integer, the result is *+0*.</li>
        <li>If _base_ is *-0* and _exponent_ &lt; 0 and _exponent_ is an odd integer, the result is *-&infin;*.</li>
        <li>If _base_ is *-0* and _exponent_ &lt; 0 and _exponent_ is not an odd integer, the result is *+&infin;*.</li>
        <li>If _base_ &lt; 0 and _base_ is finite and _exponent_ is finite and _exponent_ is not an integer, the result is *NaN*.</li>
      </ul>
      <emu-note>
        <p>The result of _base_ `**` _exponent_ when _base_ is *1* or *-1* and _exponent_ is *+Infinity* or *-Infinity* differs from IEEE 754-2008. The first edition of ECMAScript specified a result of *NaN* for this operation, whereas later versions of IEEE 754-2008 specified *1*. The historical ECMAScript behaviour is preserved for compatibility reasons.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-multiplicative-operators">
    <h1>Multiplicative Operators</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      MultiplicativeExpression[Yield, Await] :
        ExponentiationExpression[?Yield, ?Await]
        MultiplicativeExpression[?Yield, ?Await] MultiplicativeOperator ExponentiationExpression[?Yield, ?Await]

      MultiplicativeOperator : one of
        `*` `/` `%`
    </emu-grammar>

    <emu-clause id="sec-multiplicative-operators-static-semantics-isfunctiondefinition">
      <h1>Static Semantics: IsFunctionDefinition</h1>
      <emu-see-also-para op="IsFunctionDefinition"></emu-see-also-para>
      <emu-grammar>MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-multiplicative-operators-static-semantics-isvalidsimpleassignmenttarget" id="sec-multiplicative-operators-static-semantics-assignmenttargettype">
      <h1>Static Semantics: AssignmentTargetType</h1>
      <emu-see-also-para op="AssignmentTargetType"></emu-see-also-para>
      <emu-grammar>MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression</emu-grammar>
      <emu-alg>
        1. Return ~invalid~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-multiplicative-operators-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression</emu-grammar>
      <emu-alg>
        1. Let _left_ be the result of evaluating |MultiplicativeExpression|.
        1. Let _leftValue_ be ? GetValue(_left_).
        1. Let _right_ be the result of evaluating |ExponentiationExpression|.
        1. Let _rightValue_ be ? GetValue(_right_).
        1. Let _lnum_ be ? ToNumber(_leftValue_).
        1. Let _rnum_ be ? ToNumber(_rightValue_).
        1. Return the result of applying the |MultiplicativeOperator| (`*`, `/`, or `%`) to _lnum_ and _rnum_ as specified in <emu-xref href="#sec-applying-the-mul-operator"></emu-xref>, <emu-xref href="#sec-applying-the-div-operator"></emu-xref>, or <emu-xref href="#sec-applying-the-mod-operator"></emu-xref>.
      </emu-alg>

      <emu-clause id="sec-applying-the-mul-operator">
        <h1>Applying the `*` Operator</h1>
        <p>The `*` |MultiplicativeOperator| performs multiplication, producing the product of its operands. Multiplication is commutative. Multiplication is not always associative in ECMAScript, because of finite precision.</p>
        <p>The result of a floating-point multiplication is governed by the rules of IEEE 754-2008 binary double-precision arithmetic:</p>
        <ul>
          <li>
            If either operand is *NaN*, the result is *NaN*.
          </li>
          <li>
            The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.
          </li>
          <li>
            Multiplication of an infinity by a zero results in *NaN*.
          </li>
          <li>
            Multiplication of an infinity by an infinity results in an infinity. The sign is determined by the rule already stated above.
          </li>
          <li>
            Multiplication of an infinity by a finite nonzero value results in a signed infinity. The sign is determined by the rule already stated above.
          </li>
          <li>
            In the remaining cases, where neither an infinity nor *NaN* is involved, the product is computed and rounded to the nearest representable value using IEEE 754-2008 roundTiesToEven mode. If the magnitude is too large to represent, the result is then an infinity of appropriate sign. If the magnitude is too small to represent, the result is then a zero of appropriate sign. The ECMAScript language requires support of gradual underflow as defined by IEEE 754-2008.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-applying-the-div-operator">
        <h1>Applying the `/` Operator</h1>
        <p>The `/` |MultiplicativeOperator| performs division, producing the quotient of its operands. The left operand is the dividend and the right operand is the divisor. ECMAScript does not perform integer division. The operands and result of all division operations are double-precision floating-point numbers. The result of division is determined by the specification of IEEE 754-2008 arithmetic:</p>
        <ul>
          <li>
            If either operand is *NaN*, the result is *NaN*.
          </li>
          <li>
            The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.
          </li>
          <li>
            Division of an infinity by an infinity results in *NaN*.
          </li>
          <li>
            Division of an infinity by a zero results in an infinity. The sign is determined by the rule already stated above.
          </li>
          <li>
            Division of an infinity by a nonzero finite value results in a signed infinity. The sign is determined by the rule already stated above.
          </li>
          <li>
            Division of a finite value by an infinity results in zero. The sign is determined by the rule already stated above.
          </li>
          <li>
            Division of a zero by a zero results in *NaN*; division of zero by any other finite value results in zero, with the sign determined by the rule already stated above.
          </li>
          <li>
            Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule already stated above.
          </li>
          <li>
            In the remaining cases, where neither an infinity, nor a zero, nor *NaN* is involved, the quotient is computed and rounded to the nearest representable value using IEEE 754-2008 roundTiesToEven mode. If the magnitude is too large to represent, the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent, the operation underflows and the result is a zero of the appropriate sign. The ECMAScript language requires support of gradual underflow as defined by IEEE 754-2008.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-applying-the-mod-operator">
        <h1>Applying the `%` Operator</h1>
        <p>The `%` |MultiplicativeOperator| yields the remainder of its operands from an implied division; the left operand is the dividend and the right operand is the divisor.</p>
        <emu-note>
          <p>In C and C++, the remainder operator accepts only integral operands; in ECMAScript, it also accepts floating-point operands.</p>
        </emu-note>
        <p>The result of a floating-point remainder operation as computed by the `%` operator is not the same as the &ldquo;remainder&rdquo; operation defined by IEEE 754-2008. The IEEE 754-2008 &ldquo;remainder&rdquo; operation computes the remainder from a rounding division, not a truncating division, and so its behaviour is not analogous to that of the usual integer remainder operator. Instead the ECMAScript language defines `%` on floating-point operations to behave in a manner analogous to that of the Java integer remainder operator; this may be compared with the C library function fmod.</p>
        <p>The result of an ECMAScript floating-point remainder operation is determined by the rules of IEEE arithmetic:</p>
        <ul>
          <li>
            If either operand is *NaN*, the result is *NaN*.
          </li>
          <li>
            The sign of the result equals the sign of the dividend.
          </li>
          <li>
            If the dividend is an infinity, or the divisor is a zero, or both, the result is *NaN*.
          </li>
          <li>
            If the dividend is finite and the divisor is an infinity, the result equals the dividend.
          </li>
          <li>
            If the dividend is a zero and the divisor is nonzero and finite, the result is the same as the dividend.
          </li>
          <li>
            In the remaining cases, where neither an infinity, nor a zero, nor *NaN* is involved, the floating-point remainder r from a dividend n and a divisor d is defined by the mathematical relation r = n - (d &times; q) where q is an integer that is negative only if n/d is negative and positive only if n/d is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of n and d. r is computed and rounded to the nearest representable value using IEEE 754-2008 roundTiesToEven mode.
          </li>
        </ul>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-additive-operators">
    <h1>Additive Operators</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      AdditiveExpression[Yield, Await] :
        MultiplicativeExpression[?Yield, ?Await]
        AdditiveExpression[?Yield, ?Await] `+` MultiplicativeExpression[?Yield, ?Await]
        AdditiveExpression[?Yield, ?Await] `-` MultiplicativeExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-additive-operators-static-semantics-isfunctiondefinition">
      <h1>Static Semantics: IsFunctionDefinition</h1>
      <emu-see-also-para op="IsFunctionDefinition"></emu-see-also-para>
      <emu-grammar>
        AdditiveExpression :
          AdditiveExpression `+` MultiplicativeExpression
          AdditiveExpression `-` MultiplicativeExpression
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-additive-operators-static-semantics-isvalidsimpleassignmenttarget" id="sec-additive-operators-static-semantics-assignmenttargettype">
      <h1>Static Semantics: AssignmentTargetType</h1>
      <emu-see-also-para op="AssignmentTargetType"></emu-see-also-para>
      <emu-grammar>
        AdditiveExpression :
          AdditiveExpression `+` MultiplicativeExpression
          AdditiveExpression `-` MultiplicativeExpression
      </emu-grammar>
      <emu-alg>
        1. Return ~invalid~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-addition-operator-plus">
      <h1>The Addition Operator ( `+` )</h1>
      <emu-note>
        <p>The addition operator either performs string concatenation or numeric addition.</p>
      </emu-note>

      <emu-clause id="sec-addition-operator-plus-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>AdditiveExpression : AdditiveExpression `+` MultiplicativeExpression</emu-grammar>
        <emu-alg>
          1. Let _lref_ be the result of evaluating |AdditiveExpression|.
          1. Let _lval_ be ? GetValue(_lref_).
          1. Let _rref_ be the result of evaluating |MultiplicativeExpression|.
          1. Let _rval_ be ? GetValue(_rref_).
          1. Let _lprim_ be ? ToPrimitive(_lval_).
          1. Let _rprim_ be ? ToPrimitive(_rval_).
          1. If Type(_lprim_) is String or Type(_rprim_) is String, then
            1. Let _lstr_ be ? ToString(_lprim_).
            1. Let _rstr_ be ? ToString(_rprim_).
            1. Return the string-concatenation of _lstr_ and _rstr_.
          1. Let _lnum_ be ? ToNumber(_lprim_).
          1. Let _rnum_ be ? ToNumber(_rprim_).
          1. Return the result of applying the addition operation to _lnum_ and _rnum_. See the Note below <emu-xref href="#sec-applying-the-additive-operators-to-numbers"></emu-xref>.
        </emu-alg>
        <emu-note>
          <p>No hint is provided in the calls to ToPrimitive in steps 5 and 6. All standard objects except Date objects handle the absence of a hint as if the hint Number were given; Date objects handle the absence of a hint as if the hint String were given. Exotic objects may handle the absence of a hint in some other manner.</p>
        </emu-note>
        <emu-note>
          <p>Step 7 differs from step 3 of the Abstract Relational Comparison algorithm, by using the logical-or operation instead of the logical-and operation.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-subtraction-operator-minus">
      <h1>The Subtraction Operator ( `-` )</h1>

      <emu-clause id="sec-subtraction-operator-minus-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>AdditiveExpression : AdditiveExpression `-` MultiplicativeExpression</emu-grammar>
        <emu-alg>
          1. Let _lref_ be the result of evaluating |AdditiveExpression|.
          1. Let _lval_ be ? GetValue(_lref_).
          1. Let _rref_ be the result of evaluating |MultiplicativeExpression|.
          1. Let _rval_ be ? GetValue(_rref_).
          1. Let _lnum_ be ? ToNumber(_lval_).
          1. Let _rnum_ be ? ToNumber(_rval_).
          1. Return the result of applying the subtraction operation to _lnum_ and _rnum_. See the note below <emu-xref href="#sec-applying-the-additive-operators-to-numbers"></emu-xref>.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-applying-the-additive-operators-to-numbers">
      <h1>Applying the Additive Operators to Numbers</h1>
      <p>The `+` operator performs addition when applied to two operands of numeric type, producing the sum of the operands. The `-` operator performs subtraction, producing the difference of two numeric operands.</p>
      <p>Addition is a commutative operation, but not always associative.</p>
      <p>The result of an addition is determined using the rules of IEEE 754-2008 binary double-precision arithmetic:</p>
      <ul>
        <li>
          If either operand is *NaN*, the result is *NaN*.
        </li>
        <li>
          The sum of two infinities of opposite sign is *NaN*.
        </li>
        <li>
          The sum of two infinities of the same sign is the infinity of that sign.
        </li>
        <li>
          The sum of an infinity and a finite value is equal to the infinite operand.
        </li>
        <li>
          The sum of two negative zeroes is *-0*. The sum of two positive zeroes, or of two zeroes of opposite sign, is *+0*.
        </li>
        <li>
          The sum of a zero and a nonzero finite value is equal to the nonzero operand.
        </li>
        <li>
          The sum of two nonzero finite values of the same magnitude and opposite sign is *+0*.
        </li>
        <li>
          In the remaining cases, where neither an infinity, nor a zero, nor *NaN* is involved, and the operands have the same sign or have different magnitudes, the sum is computed and rounded to the nearest representable value using IEEE 754-2008 roundTiesToEven mode. If the magnitude is too large to represent, the operation overflows and the result is then an infinity of appropriate sign. The ECMAScript language requires support of gradual underflow as defined by IEEE 754-2008.
        </li>
      </ul>
      <emu-note>
        <p>The `-` operator performs subtraction when applied to two operands of numeric type, producing the difference of its operands; the left operand is the minuend and the right operand is the subtrahend. Given numeric operands `a` and `b`, it is always the case that `a - b` produces the same result as `a + (-b)`.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-bitwise-shift-operators">
    <h1>Bitwise Shift Operators</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ShiftExpression[Yield, Await] :
        AdditiveExpression[?Yield, ?Await]
        ShiftExpression[?Yield, ?Await] `&lt;&lt;` AdditiveExpression[?Yield, ?Await]
        ShiftExpression[?Yield, ?Await] `&gt;&gt;` AdditiveExpression[?Yield, ?Await]
        ShiftExpression[?Yield, ?Await] `&gt;&gt;&gt;` AdditiveExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-bitwise-shift-operators-static-semantics-isfunctiondefinition">
      <h1>Static Semantics: IsFunctionDefinition</h1>
      <emu-see-also-para op="IsFunctionDefinition"></emu-see-also-para>
      <emu-grammar>
        ShiftExpression :
          ShiftExpression `&lt;&lt;` AdditiveExpression
          ShiftExpression `&gt;&gt;` AdditiveExpression
          ShiftExpression `&gt;&gt;&gt;` AdditiveExpression
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-bitwise-shift-operators-static-semantics-isvalidsimpleassignmenttarget" id="sec-bitwise-shift-operators-static-semantics-assignmenttargettype">
      <h1>Static Semantics: AssignmentTargetType</h1>
      <emu-see-also-para op="AssignmentTargetType"></emu-see-also-para>
      <emu-grammar>
        ShiftExpression :
          ShiftExpression `&lt;&lt;` AdditiveExpression
          ShiftExpression `&gt;&gt;` AdditiveExpression
          ShiftExpression `&gt;&gt;&gt;` AdditiveExpression
      </emu-grammar>
      <emu-alg>
        1. Return ~invalid~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-left-shift-operator">
      <h1>The Left Shift Operator ( `&lt;&lt;` )</h1>
      <emu-note>
        <p>Performs a bitwise left shift operation on the left operand by the amount specified by the right operand.</p>
      </emu-note>

      <emu-clause id="sec-left-shift-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&lt;&lt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. Let _lref_ be the result of evaluating |ShiftExpression|.
          1. Let _lval_ be ? GetValue(_lref_).
          1. Let _rref_ be the result of evaluating |AdditiveExpression|.
          1. Let _rval_ be ? GetValue(_rref_).
          1. Let _lnum_ be ? ToInt32(_lval_).
          1. Let _rnum_ be ? ToUint32(_rval_).
          1. Let _shiftCount_ be the result of masking out all but the least significant 5 bits of _rnum_, that is, compute _rnum_ &amp; 0x1F.
          1. Return the result of left shifting _lnum_ by _shiftCount_ bits. The result is a signed 32-bit integer.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-signed-right-shift-operator">
      <h1>The Signed Right Shift Operator ( `&gt;&gt;` )</h1>
      <emu-note>
        <p>Performs a sign-filling bitwise right shift operation on the left operand by the amount specified by the right operand.</p>
      </emu-note>

      <emu-clause id="sec-signed-right-shift-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&gt;&gt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. Let _lref_ be the result of evaluating |ShiftExpression|.
          1. Let _lval_ be ? GetValue(_lref_).
          1. Let _rref_ be the result of evaluating |AdditiveExpression|.
          1. Let _rval_ be ? GetValue(_rref_).
          1. Let _lnum_ be ? ToInt32(_lval_).
          1. Let _rnum_ be ? ToUint32(_rval_).
          1. Let _shiftCount_ be the result of masking out all but the least significant 5 bits of _rnum_, that is, compute _rnum_ &amp; 0x1F.
          1. Return the result of performing a sign-extending right shift of _lnum_ by _shiftCount_ bits. The most significant bit is propagated. The result is a signed 32-bit integer.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-unsigned-right-shift-operator">
      <h1>The Unsigned Right Shift Operator ( `&gt;&gt;&gt;` )</h1>
      <emu-note>
        <p>Performs a zero-filling bitwise right shift operation on the left operand by the amount specified by the right operand.</p>
      </emu-note>

      <emu-clause id="sec-unsigned-right-shift-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&gt;&gt;&gt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. Let _lref_ be the result of evaluating |ShiftExpression|.
          1. Let _lval_ be ? GetValue(_lref_).
          1. Let _rref_ be the result of evaluating |AdditiveExpression|.
          1. Let _rval_ be ? GetValue(_rref_).
          1. Let _lnum_ be ? ToUint32(_lval_).
          1. Let _rnum_ be ? ToUint32(_rval_).
          1. Let _shiftCount_ be the result of masking out all but the least significant 5 bits of _rnum_, that is, compute _rnum_ &amp; 0x1F.
          1. Return the result of performing a zero-filling right shift of _lnum_ by _shiftCount_ bits. Vacated bits are filled with zero. The result is an unsigned 32-bit integer.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-relational-operators">
    <h1>Relational Operators</h1>
    <emu-note>
      <p>The result of evaluating a relational operator is always of type Boolean, reflecting whether the relationship named by the operator holds between its two operands.</p>
    </emu-note>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      RelationalExpression[In, Yield, Await] :
        ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&lt;` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&gt;` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&lt;=` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&gt;=` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `instanceof` ShiftExpression[?Yield, ?Await]
        [+In] RelationalExpression[+In, ?Yield, ?Await] `in` ShiftExpression[?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>The <sub>[In]</sub> grammar parameter is needed to avoid confusing the `in` operator in a relational expression with the `in` operator in a `for` statement.</p>
    </emu-note>

    <emu-clause id="sec-relational-operators-static-semantics-isfunctiondefinition">
      <h1>Static Semantics: IsFunctionDefinition</h1>
      <emu-see-also-para op="IsFunctionDefinition"></emu-see-also-para>
      <emu-grammar>
        RelationalExpression :
          RelationalExpression `&lt;` ShiftExpression
          RelationalExpression `&gt;` ShiftExpression
          RelationalExpression `&lt;=` ShiftExpression
          RelationalExpression `&gt;=` ShiftExpression
          RelationalExpression `instanceof` ShiftExpression
          RelationalExpression `in` ShiftExpression
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-relational-operators-static-semantics-isvalidsimpleassignmenttarget" id="sec-relational-operators-static-semantics-assignmenttargettype">
      <h1>Static Semantics: AssignmentTargetType</h1>
      <emu-see-also-para op="AssignmentTargetType"></emu-see-also-para>
      <emu-grammar>
        RelationalExpression :
          RelationalExpression `&lt;` ShiftExpression
          RelationalExpression `&gt;` ShiftExpression
          RelationalExpression `&lt;=` ShiftExpression
          RelationalExpression `&gt;=` ShiftExpression
          RelationalExpression `instanceof` ShiftExpression
          RelationalExpression `in` ShiftExpression
      </emu-grammar>
      <emu-alg>
        1. Return ~invalid~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-relational-operators-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>RelationalExpression : RelationalExpression `&lt;` ShiftExpression</emu-grammar>
      <emu-alg>
        1. Let _lref_ be the result of evaluating |RelationalExpression|.
        1. Let _lval_ be ? GetValue(_lref_).
        1. Let _rref_ be the result of evaluating |ShiftExpression|.
        1. Let _rval_ be ? GetValue(_rref_).
        1. Let _r_ be the result of performing Abstract Relational Comparison _lval_ &lt; _rval_.
        1. ReturnIfAbrupt(_r_).
        1. If _r_ is *undefined*, return *false*. Otherwise, return _r_.
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `&gt;` ShiftExpression</emu-grammar>
      <emu-alg>
        1. Let _lref_ be the result of evaluating |RelationalExpression|.
        1. Let _lval_ be ? GetValue(_lref_).
        1. Let _rref_ be the result of evaluating |ShiftExpression|.
        1. Let _rval_ be ? GetValue(_rref_).
        1. Let _r_ be the result of performing Abstract Relational Comparison _rval_ &lt; _lval_ with _LeftFirst_ equal to *false*.
        1. ReturnIfAbrupt(_r_).
        1. If _r_ is *undefined*, return *false*. Otherwise, return _r_.
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `&lt;=` ShiftExpression</emu-grammar>
      <emu-alg>
        1. Let _lref_ be the result of evaluating |RelationalExpression|.
        1. Let _lval_ be ? GetValue(_lref_).
        1. Let _rref_ be the result of evaluating |ShiftExpression|.
        1. Let _rval_ be ? GetValue(_rref_).
        1. Let _r_ be the result of performing Abstract Relational Comparison _rval_ &lt; _lval_ with _LeftFirst_ equal to *false*.
        1. ReturnIfAbrupt(_r_).
        1. If _r_ is *true* or *undefined*, return *false*. Otherwise, return *true*.
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `&gt;=` ShiftExpression</emu-grammar>
      <emu-alg>
        1. Let _lref_ be the result of evaluating |RelationalExpression|.
        1. Let _lval_ be ? GetValue(_lref_).
        1. Let _rref_ be the result of evaluating |ShiftExpression|.
        1. Let _rval_ be ? GetValue(_rref_).
        1. Let _r_ be the result of performing Abstract Relational Comparison _lval_ &lt; _rval_.
        1. ReturnIfAbrupt(_r_).
        1. If _r_ is *true* or *undefined*, return *false*. Otherwise, return *true*.
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `instanceof` ShiftExpression</emu-grammar>
      <emu-alg>
        1. Let _lref_ be the result of evaluating |RelationalExpression|.
        1. Let _lval_ be ? GetValue(_lref_).
        1. Let _rref_ be the result of evaluating |ShiftExpression|.
        1. Let _rval_ be ? GetValue(_rref_).
        1. Return ? InstanceofOperator(_lval_, _rval_).
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `in` ShiftExpression</emu-grammar>
      <emu-alg>
        1. Let _lref_ be the result of evaluating |RelationalExpression|.
        1. Let _lval_ be ? GetValue(_lref_).
        1. Let _rref_ be the result of evaluating |ShiftExpression|.
        1. Let _rval_ be ? GetValue(_rref_).
        1. If Type(_rval_) is not Object, throw a *TypeError* exception.
        1. Return ? HasProperty(_rval_, ToPropertyKey(_lval_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-instanceofoperator" aoid="InstanceofOperator">
      <h1>Runtime Semantics: InstanceofOperator ( _V_, _target_ )</h1>
      <p>The abstract operation InstanceofOperator(_V_, _target_) implements the generic algorithm for determining if  ECMAScript value _V_ is an instance of object _target_ either by consulting _target_'s @@hasinstance method or, if absent, determining whether the value of _target_'s `prototype` property is present in _V_'s prototype chain. This abstract operation performs the following steps:</p>
      <emu-alg>
        1. If Type(_target_) is not Object, throw a *TypeError* exception.
        1. Let _instOfHandler_ be ? GetMethod(_target_, @@hasInstance).
        1. If _instOfHandler_ is not *undefined*, then
          1. Return ToBoolean(? Call(_instOfHandler_, _target_, &laquo; _V_ &raquo;)).
        1. If IsCallable(_target_) is *false*, throw a *TypeError* exception.
        1. Return ? OrdinaryHasInstance(_target_, _V_).
      </emu-alg>
      <emu-note>
        <p>Steps 4 and 5 provide compatibility with previous editions of ECMAScript that did not use a @@hasInstance method to define the `instanceof` operator semantics. If an object does not define or inherit @@hasInstance it uses the default `instanceof` semantics.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-equality-operators">
    <h1>Equality Operators</h1>
    <emu-note>
      <p>The result of evaluating an equality operator is always of type Boolean, reflecting whether the relationship named by the operator holds between its two operands.</p>
    </emu-note>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      EqualityExpression[In, Yield, Await] :
        RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `==` RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `!=` RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `===` RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `!==` RelationalExpression[?In, ?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-equality-operators-static-semantics-isfunctiondefinition">
      <h1>Static Semantics: IsFunctionDefinition</h1>
      <emu-see-also-para op="IsFunctionDefinition"></emu-see-also-para>
      <emu-grammar>
        EqualityExpression :
          EqualityExpression `==` RelationalExpression
          EqualityExpression `!=` RelationalExpression
          EqualityExpression `===` RelationalExpression
          EqualityExpression `!==` RelationalExpression
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-equality-operators-static-semantics-isvalidsimpleassignmenttarget" id="sec-equality-operators-static-semantics-assignmenttargettype">
      <h1>Static Semantics: AssignmentTargetType</h1>
      <emu-see-also-para op="AssignmentTargetType"></emu-see-also-para>
      <emu-grammar>
        EqualityExpression :
          EqualityExpression `==` RelationalExpression
          EqualityExpression `!=` RelationalExpression
          EqualityExpression `===` RelationalExpression
          EqualityExpression `!==` RelationalExpression
      </emu-grammar>
      <emu-alg>
        1. Return ~invalid~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-equality-operators-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>EqualityExpression : EqualityExpression `==` RelationalExpression</emu-grammar>
      <emu-alg>
        1. Let _lref_ be the result of evaluating |EqualityExpression|.
        1. Let _lval_ be ? GetValue(_lref_).
        1. Let _rref_ be the result of evaluating |RelationalExpression|.
        1. Let _rval_ be ? GetValue(_rref_).
        1. Return the result of performing Abstract Equality Comparison _rval_ == _lval_.
      </emu-alg>
      <emu-grammar>EqualityExpression : EqualityExpression `!=` RelationalExpression</emu-grammar>
      <emu-alg>
        1. Let _lref_ be the result of evaluating |EqualityExpression|.
        1. Let _lval_ be ? GetValue(_lref_).
        1. Let _rref_ be the result of evaluating |RelationalExpression|.
        1. Let _rval_ be ? GetValue(_rref_).
        1. Let _r_ be the result of performing Abstract Equality Comparison _rval_ == _lval_.
        1. If _r_ is *true*, return *false*. Otherwise, return *true*.
      </emu-alg>
      <emu-grammar>EqualityExpression : EqualityExpression `===` RelationalExpression</emu-grammar>
      <emu-alg>
        1. Let _lref_ be the result of evaluating |EqualityExpression|.
        1. Let _lval_ be ? GetValue(_lref_).
        1. Let _rref_ be the result of evaluating |RelationalExpression|.
        1. Let _rval_ be ? GetValue(_rref_).
        1. Return the result of performing Strict Equality Comparison _rval_ === _lval_.
      </emu-alg>
      <emu-grammar>EqualityExpression : EqualityExpression `!==` RelationalExpression</emu-grammar>
      <emu-alg>
        1. Let _lref_ be the result of evaluating |EqualityExpression|.
        1. Let _lval_ be ? GetValue(_lref_).
        1. Let _rref_ be the result of evaluating |RelationalExpression|.
        1. Let _rval_ be ? GetValue(_rref_).
        1. Let _r_ be the result of performing Strict Equality Comparison _rval_ === _lval_.
        1. If _r_ is *true*, return *false*. Otherwise, return *true*.
      </emu-alg>
      <emu-note>
        <p>Given the above definition of equality:</p>
        <ul>
          <li>
            String comparison can be forced by: `"" + a == "" + b`.
          </li>
          <li>
            Numeric comparison can be forced by: `+a == +b`.
          </li>
          <li>
            Boolean comparison can be forced by: `!a == !b`.
          </li>
        </ul>
      </emu-note>
      <emu-note>
        <p>The equality operators maintain the following invariants:</p>
        <ul>
          <li>
            `A != B` is equivalent to `!(A == B)`.
          </li>
          <li>
            `A == B` is equivalent to `B == A`, except in the order of evaluation of `A` and `B`.
          </li>
        </ul>
      </emu-note>
      <emu-note>
        <p>The equality operator is not always transitive. For example, there might be two distinct String objects, each representing the same String value; each String object would be considered equal to the String value by the `==` operator, but the two String objects would not be equal to each other. For example:</p>
        <ul>
          <li>
            `new String("a") == "a"` and `"a" == new String("a")` are both *true*.
          </li>
          <li>
            `new String("a") == new String("a")` is *false*.
          </li>
        </ul>
      </emu-note>
      <emu-note>
        <p>Comparison of Strings uses a simple equality test on sequences of code unit values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore Strings values that are canonically equal according to the Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalized form.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-binary-bitwise-operators">
    <h1>Binary Bitwise Operators</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      BitwiseANDExpression[In, Yield, Await] :
        EqualityExpression[?In, ?Yield, ?Await]
        BitwiseANDExpression[?In, ?Yield, ?Await] `&amp;` EqualityExpression[?In, ?Yield, ?Await]

      BitwiseXORExpression[In, Yield, Await] :
        BitwiseANDExpression[?In, ?Yield, ?Await]
        BitwiseXORExpression[?In, ?Yield, ?Await] `^` BitwiseANDExpression[?In, ?Yield, ?Await]

      BitwiseORExpression[In, Yield, Await] :
        BitwiseXORExpression[?In, ?Yield, ?Await]
        BitwiseORExpression[?In, ?Yield, ?Await] `|` BitwiseXORExpression[?In, ?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-binary-bitwise-operators-static-semantics-isfunctiondefinition">
      <h1>Static Semantics: IsFunctionDefinition</h1>
      <emu-see-also-para op="IsFunctionDefinition"></emu-see-also-para>
      <emu-grammar>
        BitwiseANDExpression : BitwiseANDExpression `&amp;` EqualityExpression

        BitwiseXORExpression : BitwiseXORExpression `^` BitwiseANDExpression

        BitwiseORExpression : BitwiseORExpression `|` BitwiseXORExpression
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-binary-bitwise-operators-static-semantics-isvalidsimpleassignmenttarget" id="sec-binary-bitwise-operators-static-semantics-assignmenttargettype">
      <h1>Static Semantics: AssignmentTargetType</h1>
      <emu-see-also-para op="AssignmentTargetType"></emu-see-also-para>
      <emu-grammar>
        BitwiseANDExpression : BitwiseANDExpression `&amp;` EqualityExpression

        BitwiseXORExpression : BitwiseXORExpression `^` BitwiseANDExpression

        BitwiseORExpression : BitwiseORExpression `|` BitwiseXORExpression
      </emu-grammar>
      <emu-alg>
        1. Return ~invalid~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-binary-bitwise-operators-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <p>The production <emu-grammar type="example">A : A @ B</emu-grammar>, where @ is one of the bitwise operators in the productions above, is evaluated as follows:</p>
      <emu-alg>
        1. Let _lref_ be the result of evaluating _A_.
        1. Let _lval_ be ? GetValue(_lref_).
        1. Let _rref_ be the result of evaluating _B_.
        1. Let _rval_ be ? GetValue(_rref_).
        1. Let _lnum_ be ? ToInt32(_lval_).
        1. Let _rnum_ be ? ToInt32(_rval_).
        1. Return the result of applying the bitwise operator @ to _lnum_ and _rnum_. The result is a signed 32-bit integer.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-binary-logical-operators">
    <h1>Binary Logical Operators</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      LogicalANDExpression[In, Yield, Await] :
        BitwiseORExpression[?In, ?Yield, ?Await]
        LogicalANDExpression[?In, ?Yield, ?Await] `&amp;&amp;` BitwiseORExpression[?In, ?Yield, ?Await]

      LogicalORExpression[In, Yield, Await] :
        LogicalANDExpression[?In, ?Yield, ?Await]
        LogicalORExpression[?In, ?Yield, ?Await] `||` LogicalANDExpression[?In, ?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>The value produced by a `&amp;&amp;` or `||` operator is not necessarily of type Boolean. The value produced will always be the value of one of the two operand expressions.</p>
    </emu-note>

    <emu-clause id="sec-binary-logical-operators-static-semantics-isfunctiondefinition">
      <h1>Static Semantics: IsFunctionDefinition</h1>
      <emu-see-also-para op="IsFunctionDefinition"></emu-see-also-para>
      <emu-grammar>
        LogicalANDExpression : LogicalANDExpression `&amp;&amp;` BitwiseORExpression

        LogicalORExpression : LogicalORExpression `||` LogicalANDExpression
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-binary-logical-operators-static-semantics-isvalidsimpleassignmenttarget" id="sec-binary-logical-operators-static-semantics-assignmenttargettype">
      <h1>Static Semantics: AssignmentTargetType</h1>
      <emu-see-also-para op="AssignmentTargetType"></emu-see-also-para>
      <emu-grammar>
        LogicalANDExpression : LogicalANDExpression `&amp;&amp;` BitwiseORExpression

        LogicalORExpression : LogicalORExpression `||` LogicalANDExpression
      </emu-grammar>
      <emu-alg>
        1. Return ~invalid~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-binary-logical-operators-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>LogicalANDExpression : LogicalANDExpression `&amp;&amp;` BitwiseORExpression</emu-grammar>
      <emu-alg>
        1. Let _lref_ be the result of evaluating |LogicalANDExpression|.
        1. Let _lval_ be ? GetValue(_lref_).
        1. Let _lbool_ be ToBoolean(_lval_).
        1. If _lbool_ is *false*, return _lval_.
        1. Let _rref_ be the result of evaluating |BitwiseORExpression|.
        1. Return ? GetValue(_rref_).
      </emu-alg>
      <emu-grammar>LogicalORExpression : LogicalORExpression `||` LogicalANDExpression</emu-grammar>
      <emu-alg>
        1. Let _lref_ be the result of evaluating |LogicalORExpression|.
        1. Let _lval_ be ? GetValue(_lref_).
        1. Let _lbool_ be ToBoolean(_lval_).
        1. If _lbool_ is *true*, return _lval_.
        1. Let _rref_ be the result of evaluating |LogicalANDExpression|.
        1. Return ? GetValue(_rref_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-conditional-operator">
    <h1>Conditional Operator ( `? :` )</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ConditionalExpression[In, Yield, Await] :
        LogicalORExpression[?In, ?Yield, ?Await]
        LogicalORExpression[?In, ?Yield, ?Await] `?` AssignmentExpression[+In, ?Yield, ?Await] `:` AssignmentExpression[?In, ?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>The grammar for a |ConditionalExpression| in ECMAScript is slightly different from that in C and Java, which each allow the second subexpression to be an |Expression| but restrict the third expression to be a |ConditionalExpression|. The motivation for this difference in ECMAScript is to allow an assignment expression to be governed by either arm of a conditional and to eliminate the confusing and fairly useless case of a comma expression as the centre expression.</p>
    </emu-note>

    <emu-clause id="sec-conditional-operator-static-semantics-isfunctiondefinition">
      <h1>Static Semantics: IsFunctionDefinition</h1>
      <emu-see-also-para op="IsFunctionDefinition"></emu-see-also-para>
      <emu-grammar>ConditionalExpression : LogicalORExpression `?` AssignmentExpression `:` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-conditional-operator-static-semantics-isvalidsimpleassignmenttarget" id="sec-conditional-operator-static-semantics-assignmenttargettype">
      <h1>Static Semantics: AssignmentTargetType</h1>
      <emu-see-also-para op="AssignmentTargetType"></emu-see-also-para>
      <emu-grammar>ConditionalExpression : LogicalORExpression `?` AssignmentExpression `:` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Return ~invalid~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-conditional-operator-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>ConditionalExpression : LogicalORExpression `?` AssignmentExpression `:` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Let _lref_ be the result of evaluating |LogicalORExpression|.
        1. Let _lval_ be ToBoolean(? GetValue(_lref_)).
        1. If _lval_ is *true*, then
          1. Let _trueRef_ be the result of evaluating the first |AssignmentExpression|.
          1. Return ? GetValue(_trueRef_).
        1. Else,
          1. Let _falseRef_ be the result of evaluating the second |AssignmentExpression|.
          1. Return ? GetValue(_falseRef_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-assignment-operators">
    <h1>Assignment Operators</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      AssignmentExpression[In, Yield, Await] :
        ConditionalExpression[?In, ?Yield, ?Await]
        [+Yield] YieldExpression[?In, ?Await]
        ArrowFunction[?In, ?Yield, ?Await]
        AsyncArrowFunction[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] `=` AssignmentExpression[?In, ?Yield, ?Await] #assignment
        LeftHandSideExpression[?Yield, ?Await] AssignmentOperator AssignmentExpression[?In, ?Yield, ?Await]

      AssignmentOperator : one of
        `*=` `/=` `%=` `+=` `-=` `&lt;&lt;=` `&gt;&gt;=` `&gt;&gt;&gt;=` `&amp;=` `^=` `|=` `**=`
    </emu-grammar>

    <emu-clause id="sec-assignment-operators-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `=` AssignmentExpression</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if |LeftHandSideExpression| is either an |ObjectLiteral| or an |ArrayLiteral| and |LeftHandSideExpression| is not covering an |AssignmentPattern|.
        </li>
        <li>
          It is an early Reference Error if |LeftHandSideExpression| is neither an |ObjectLiteral| nor an |ArrayLiteral| and AssignmentTargetType of |LeftHandSideExpression| is ~invalid~.
        </li>
        <li>
          It is an early Syntax Error if |LeftHandSideExpression| is neither an |ObjectLiteral| nor an |ArrayLiteral| and AssignmentTargetType of |LeftHandSideExpression| is ~strict~.
        </li>
      </ul>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression</emu-grammar>
      <ul>
        <li>
          It is an early Reference Error if AssignmentTargetType of |LeftHandSideExpression| is ~invalid~.
        </li>
        <li>
          It is an early Syntax Error if AssignmentTargetType of |LeftHandSideExpression| is ~strict~.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-assignment-operators-static-semantics-isfunctiondefinition">
      <h1>Static Semantics: IsFunctionDefinition</h1>
      <emu-see-also-para op="IsFunctionDefinition"></emu-see-also-para>
      <emu-grammar>
        AssignmentExpression :
          ArrowFunction
          AsyncArrowFunction
      </emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      <emu-grammar>
        AssignmentExpression :
          YieldExpression
          LeftHandSideExpression `=` AssignmentExpression
          LeftHandSideExpression AssignmentOperator AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-assignment-operators-static-semantics-isvalidsimpleassignmenttarget" id="sec-assignment-operators-static-semantics-assignmenttargettype">
      <h1>Static Semantics: AssignmentTargetType</h1>
      <emu-see-also-para op="AssignmentTargetType"></emu-see-also-para>
      <emu-grammar>
        AssignmentExpression :
          YieldExpression
          ArrowFunction
          AsyncArrowFunction
          LeftHandSideExpression `=` AssignmentExpression
          LeftHandSideExpression AssignmentOperator AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. Return ~invalid~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-assignment-operators-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `=` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. If |LeftHandSideExpression| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then
          1. Let _lref_ be the result of evaluating |LeftHandSideExpression|.
          1. ReturnIfAbrupt(_lref_).
          1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) and IsIdentifierRef of |LeftHandSideExpression| are both *true*, then
            1. Let _rval_ be the result of performing NamedEvaluation for |AssignmentExpression| with argument GetReferencedName(_lref_).
          1. Else,
            1. Let _rref_ be the result of evaluating |AssignmentExpression|.
            1. Let _rval_ be ? GetValue(_rref_).
          1. Perform ? PutValue(_lref_, _rval_).
          1. Return _rval_.
        1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by |LeftHandSideExpression|.
        1. Let _rref_ be the result of evaluating |AssignmentExpression|.
        1. Let _rval_ be ? GetValue(_rref_).
        1. Perform ? DestructuringAssignmentEvaluation of _assignmentPattern_ using _rval_ as the argument.
        1. Return _rval_.
      </emu-alg>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Let _lref_ be the result of evaluating |LeftHandSideExpression|.
        1. Let _lval_ be ? GetValue(_lref_).
        1. Let _rref_ be the result of evaluating |AssignmentExpression|.
        1. Let _rval_ be ? GetValue(_rref_).
        1. Let _op_ be the `@` where |AssignmentOperator| is `@=`.
        1. Let _r_ be the result of applying _op_ to _lval_ and _rval_ as if evaluating the expression _lval_ _op_ _rval_.
        1. Perform ? PutValue(_lref_, _r_).
        1. Return _r_.
      </emu-alg>
      <emu-note>
        <p>When an assignment occurs within strict mode code, it is a runtime error if _lref_ in step 1.f of the first algorithm or step 7 of the second algorithm it is an unresolvable reference. If it is, a *ReferenceError* exception is thrown. The |LeftHandSideExpression| also may not be a reference to a data property with the attribute value { [[Writable]]: *false* }, to an accessor property with the attribute value { [[Set]]: *undefined* }, nor to a non-existent property of an object for which the IsExtensible predicate returns the value *false*. In these cases a *TypeError* exception is thrown.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-destructuring-assignment">
      <h1>Destructuring Assignment</h1>
      <h2>Supplemental Syntax</h2>
      <p>In certain circumstances when processing an instance of the production <emu-grammar>AssignmentExpression : LeftHandSideExpression `=` AssignmentExpression</emu-grammar> the following grammar is used to refine the interpretation of |LeftHandSideExpression|.</p>
      <emu-grammar type="definition">
        AssignmentPattern[Yield, Await] :
          ObjectAssignmentPattern[?Yield, ?Await]
          ArrayAssignmentPattern[?Yield, ?Await]

        ObjectAssignmentPattern[Yield, Await] :
          `{` `}`
          `{` AssignmentRestProperty[?Yield, ?Await] `}`
          `{` AssignmentPropertyList[?Yield, ?Await] `}`
          `{` AssignmentPropertyList[?Yield, ?Await] `,` AssignmentRestProperty[?Yield, ?Await]? `}`

        ArrayAssignmentPattern[Yield, Await] :
          `[` Elision? AssignmentRestElement[?Yield, ?Await]? `]`
          `[` AssignmentElementList[?Yield, ?Await] `]`
          `[` AssignmentElementList[?Yield, ?Await] `,` Elision? AssignmentRestElement[?Yield, ?Await]? `]`

        AssignmentRestProperty[Yield, Await] :
          `...` DestructuringAssignmentTarget[?Yield, ?Await]

        AssignmentPropertyList[Yield, Await] :
          AssignmentProperty[?Yield, ?Await]
          AssignmentPropertyList[?Yield, ?Await] `,` AssignmentProperty[?Yield, ?Await]

        AssignmentElementList[Yield, Await] :
          AssignmentElisionElement[?Yield, ?Await]
          AssignmentElementList[?Yield, ?Await] `,` AssignmentElisionElement[?Yield, ?Await]

        AssignmentElisionElement[Yield, Await] :
          Elision? AssignmentElement[?Yield, ?Await]

        AssignmentProperty[Yield, Await] :
          IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?
          PropertyName[?Yield, ?Await] `:` AssignmentElement[?Yield, ?Await]

        AssignmentElement[Yield, Await] :
          DestructuringAssignmentTarget[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

        AssignmentRestElement[Yield, Await] :
          `...` DestructuringAssignmentTarget[?Yield, ?Await]

        DestructuringAssignmentTarget[Yield, Await] :
          LeftHandSideExpression[?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-destructuring-assignment-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>AssignmentProperty : IdentifierReference Initializer?</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if AssignmentTargetType of |IdentifierReference| is not ~simple~.
          </li>
        </ul>
        <emu-grammar>AssignmentRestProperty : `...` DestructuringAssignmentTarget</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
          </li>
        </ul>
        <emu-grammar>DestructuringAssignmentTarget : LeftHandSideExpression</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if |LeftHandSideExpression| is either an |ObjectLiteral| or an |ArrayLiteral| and if |LeftHandSideExpression| is not covering an |AssignmentPattern|.
          </li>
          <li>
            It is a Syntax Error if |LeftHandSideExpression| is neither an |ObjectLiteral| nor an |ArrayLiteral| and AssignmentTargetType(|LeftHandSideExpression|) is not ~simple~.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-destructuringassignmentevaluation">
        <h1>Runtime Semantics: DestructuringAssignmentEvaluation</h1>
        <p>With parameter _value_.</p>
        <emu-grammar>ObjectAssignmentPattern : `{` `}`</emu-grammar>
        <emu-alg>
          1. Perform ? RequireObjectCoercible(_value_).
          1. Return NormalCompletion(~empty~).
        </emu-alg>
        <emu-grammar>
          ObjectAssignmentPattern :
            `{` AssignmentPropertyList `}`
            `{` AssignmentPropertyList `,` `}`
        </emu-grammar>
        <emu-alg>
          1. Perform ? RequireObjectCoercible(_value_).
          1. Perform ? PropertyDestructuringAssignmentEvaluation for |AssignmentPropertyList| using _value_ as the argument.
          1. Return NormalCompletion(~empty~).
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` `]`</emu-grammar>
        <emu-alg>
          1. Let _iteratorRecord_ be ? GetIterator(_value_).
          1. Return ? IteratorClose(_iteratorRecord_, NormalCompletion(~empty~)).
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` Elision `]`</emu-grammar>
        <emu-alg>
          1. Let _iteratorRecord_ be ? GetIterator(_value_).
          1. Let _result_ be the result of performing IteratorDestructuringAssignmentEvaluation of |Elision| with _iteratorRecord_ as the argument.
          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).
          1. Return _result_.
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` Elision? AssignmentRestElement `]`</emu-grammar>
        <emu-alg>
          1. Let _iteratorRecord_ be ? GetIterator(_value_).
          1. If |Elision| is present, then
            1. Let _status_ be the result of performing IteratorDestructuringAssignmentEvaluation of |Elision| with _iteratorRecord_ as the argument.
            1. If _status_ is an abrupt completion, then
              1. Assert: _iteratorRecord_.[[Done]] is *true*.
              1. Return Completion(_status_).
          1. Let _result_ be the result of performing IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with _iteratorRecord_ as the argument.
          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).
          1. Return _result_.
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` AssignmentElementList `]`</emu-grammar>
        <emu-alg>
          1. Let _iteratorRecord_ be ? GetIterator(_value_).
          1. Let _result_ be the result of performing IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| using _iteratorRecord_ as the argument.
          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).
          1. Return _result_.
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` AssignmentElementList `,` Elision? AssignmentRestElement? `]`</emu-grammar>
        <emu-alg>
          1. Let _iteratorRecord_ be ? GetIterator(_value_).
          1. Let _status_ be the result of performing IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| using _iteratorRecord_ as the argument.
          1. If _status_ is an abrupt completion, then
            1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).
            1. Return Completion(_status_).
          1. If |Elision| is present, then
            1. Set _status_ to the result of performing IteratorDestructuringAssignmentEvaluation of |Elision| with _iteratorRecord_ as the argument.
            1. If _status_ is an abrupt completion, then
              1. Assert: _iteratorRecord_.[[Done]] is *true*.
              1. Return Completion(_status_).
          1. If |AssignmentRestElement| is present, then
            1. Set _status_ to the result of performing IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with _iteratorRecord_ as the argument.
          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).
          1. Return Completion(_status_).
        </emu-alg>
        <emu-grammar>ObjectAssignmentPattern : `{` AssignmentRestProperty `}`</emu-grammar>
        <emu-alg>
          1. Perform ? RequireObjectCoercible(_value_).
          1. Let _excludedNames_ be a new empty List.
          1. Return the result of performing RestDestructuringAssignmentEvaluation of |AssignmentRestProperty| with _value_ and _excludedNames_ as the arguments.
        </emu-alg>

        <emu-grammar>ObjectAssignmentPattern : `{` AssignmentPropertyList `,` AssignmentRestProperty `}`</emu-grammar>
        <emu-alg>
          1. Perform ? RequireObjectCoercible(_value_).
          1. Let _excludedNames_ be the result of performing ? PropertyDestructuringAssignmentEvaluation for |AssignmentPropertyList| using _value_ as the argument.
          1. Return the result of performing RestDestructuringAssignmentEvaluation of |AssignmentRestProperty| with _value_ and _excludedNames_ as the arguments.
        </emu-alg>
      </emu-clause>


      <emu-clause id="sec-runtime-semantics-propertydestructuringassignmentevaluation">
        <h1>Runtime Semantics: PropertyDestructuringAssignmentEvaluation</h1>
        <p>With parameter _value_.</p>

        <emu-note>The following operations collect a list of all destructured property names.</emu-note>

        <emu-grammar>AssignmentPropertyList : AssignmentPropertyList `,` AssignmentProperty</emu-grammar>
        <emu-alg>
          1. Let _propertyNames_ be the result of performing ? PropertyDestructuringAssignmentEvaluation for |AssignmentPropertyList| using _value_ as the argument.
          1. Let _nextNames_ be the result of performing ? PropertyDestructuringAssignmentEvaluation for |AssignmentProperty| using _value_ as the argument.
          1. Append each item in _nextNames_ to the end of _propertyNames_.
          1. Return _propertyNames_.
        </emu-alg>

        <emu-grammar>AssignmentProperty : IdentifierReference Initializer?</emu-grammar>
        <emu-alg>
          1. Let _P_ be StringValue of |IdentifierReference|.
          1. Let _lref_ be ? ResolveBinding(_P_).
          1. Let _v_ be ? GetV(_value_, _P_).
          1. If |Initializer_opt| is present and _v_ is *undefined*, then
            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then
              1. Set _v_ to the result of performing NamedEvaluation for |Initializer| with argument _P_.
            1. Else,
              1. Let _defaultValue_ be the result of evaluating |Initializer|.
              1. Set _v_ to ? GetValue(_defaultValue_).
          1. Perform ? PutValue(_lref_, _v_).
          1. Return a new List containing _P_.
        </emu-alg>

        <emu-grammar>AssignmentProperty : PropertyName `:` AssignmentElement</emu-grammar>
        <emu-alg>
          1. Let _name_ be the result of evaluating |PropertyName|.
          1. ReturnIfAbrupt(_name_).
          1. Perform ? KeyedDestructuringAssignmentEvaluation of |AssignmentElement| with _value_ and _name_ as the arguments.
          1. Return a new List containing _name_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-restdestructuringassignmentevaluation">
        <h1>Runtime Semantics: RestDestructuringAssignmentEvaluation</h1>
        <p>With parameters _value_ and _excludedNames_.</p>

        <emu-grammar>AssignmentRestProperty : `...` DestructuringAssignmentTarget</emu-grammar>
        <emu-alg>
          1. Let _lref_ be the result of evaluating |DestructuringAssignmentTarget|.
          1. ReturnIfAbrupt(_lref_).
          1. Let _restObj_ be ObjectCreate(%ObjectPrototype%).
          1. Perform ? CopyDataProperties(_restObj_, _value_, _excludedNames_).
          1. Return PutValue(_lref_, _restObj_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-iteratordestructuringassignmentevaluation">
        <h1>Runtime Semantics: IteratorDestructuringAssignmentEvaluation</h1>
        <p>With parameter _iteratorRecord_.</p>
        <emu-grammar>AssignmentElementList : AssignmentElisionElement</emu-grammar>
        <emu-alg>
          1. Return the result of performing IteratorDestructuringAssignmentEvaluation of |AssignmentElisionElement| using _iteratorRecord_ as the argument.
        </emu-alg>
        <emu-grammar>AssignmentElementList : AssignmentElementList `,` AssignmentElisionElement</emu-grammar>
        <emu-alg>
          1. Perform ? IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| using _iteratorRecord_ as the argument.
          1. Return the result of performing IteratorDestructuringAssignmentEvaluation of |AssignmentElisionElement| using _iteratorRecord_ as the argument.
        </emu-alg>
        <emu-grammar>AssignmentElisionElement : AssignmentElement</emu-grammar>
        <emu-alg>
          1. Return the result of performing IteratorDestructuringAssignmentEvaluation of |AssignmentElement| with _iteratorRecord_ as the argument.
        </emu-alg>
        <emu-grammar>AssignmentElisionElement : Elision AssignmentElement</emu-grammar>
        <emu-alg>
          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with _iteratorRecord_ as the argument.
          1. Return the result of performing IteratorDestructuringAssignmentEvaluation of |AssignmentElement| with _iteratorRecord_ as the argument.
        </emu-alg>
        <emu-grammar>Elision : `,`</emu-grammar>
        <emu-alg>
          1. If _iteratorRecord_.[[Done]] is *false*, then
            1. Let _next_ be IteratorStep(_iteratorRecord_).
            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
            1. ReturnIfAbrupt(_next_).
            1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.
          1. Return NormalCompletion(~empty~).
        </emu-alg>
        <emu-grammar>Elision : Elision `,`</emu-grammar>
        <emu-alg>
          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with _iteratorRecord_ as the argument.
          1. If _iteratorRecord_.[[Done]] is *false*, then
            1. Let _next_ be IteratorStep(_iteratorRecord_).
            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
            1. ReturnIfAbrupt(_next_).
            1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.
          1. Return NormalCompletion(~empty~).
        </emu-alg>
        <emu-grammar>AssignmentElement : DestructuringAssignmentTarget Initializer?</emu-grammar>
        <emu-alg>
          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then
            1. Let _lref_ be the result of evaluating |DestructuringAssignmentTarget|.
            1. ReturnIfAbrupt(_lref_).
          1. If _iteratorRecord_.[[Done]] is *false*, then
            1. Let _next_ be IteratorStep(_iteratorRecord_).
            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
            1. ReturnIfAbrupt(_next_).
            1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.
            1. Else,
              1. Let _value_ be IteratorValue(_next_).
              1. If _value_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
              1. ReturnIfAbrupt(_value_).
          1. If _iteratorRecord_.[[Done]] is *true*, let _value_ be *undefined*.
          1. If |Initializer| is present and _value_ is *undefined*, then
            1. If IsAnonymousFunctionDefinition(|Initializer|) and IsIdentifierRef of |DestructuringAssignmentTarget| are both *true*, then
              1. Let _v_ be the result of performing NamedEvaluation for |Initializer| with argument GetReferencedName(_lref_).
            1. Else,
              1. Let _defaultValue_ be the result of evaluating |Initializer|.
              1. Let _v_ be ? GetValue(_defaultValue_).
          1. Else, let _v_ be _value_.
          1. If |DestructuringAssignmentTarget| is an |ObjectLiteral| or an |ArrayLiteral|, then
            1. Let _nestedAssignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.
            1. Return the result of performing DestructuringAssignmentEvaluation of _nestedAssignmentPattern_ with _v_ as the argument.
          1. Return ? PutValue(_lref_, _v_).
        </emu-alg>
        <emu-note>
          <p>Left to right evaluation order is maintained by evaluating a |DestructuringAssignmentTarget| that is not a destructuring pattern prior to accessing the iterator or evaluating the |Initializer|.</p>
        </emu-note>
        <emu-grammar>AssignmentRestElement : `...` DestructuringAssignmentTarget</emu-grammar>
        <emu-alg>
          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then
            1. Let _lref_ be the result of evaluating |DestructuringAssignmentTarget|.
            1. ReturnIfAbrupt(_lref_).
          1. Let _A_ be ! ArrayCreate(0).
          1. Let _n_ be 0.
          1. Repeat, while _iteratorRecord_.[[Done]] is *false*,
            1. Let _next_ be IteratorStep(_iteratorRecord_).
            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
            1. ReturnIfAbrupt(_next_).
            1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.
            1. Else,
              1. Let _nextValue_ be IteratorValue(_next_).
              1. If _nextValue_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
              1. ReturnIfAbrupt(_nextValue_).
              1. Let _status_ be CreateDataProperty(_A_, ! ToString(_n_), _nextValue_).
              1. Assert: _status_ is *true*.
              1. Increment _n_ by 1.
          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then
            1. Return ? PutValue(_lref_, _A_).
          1. Let _nestedAssignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.
          1. Return the result of performing DestructuringAssignmentEvaluation of _nestedAssignmentPattern_ with _A_ as the argument.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-keyeddestructuringassignmentevaluation">
        <h1>Runtime Semantics: KeyedDestructuringAssignmentEvaluation</h1>
        <p>With parameters _value_ and _propertyName_.</p>
        <emu-grammar>AssignmentElement : DestructuringAssignmentTarget Initializer?</emu-grammar>
        <emu-alg>
          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then
            1. Let _lref_ be the result of evaluating |DestructuringAssignmentTarget|.
            1. ReturnIfAbrupt(_lref_).
          1. Let _v_ be ? GetV(_value_, _propertyName_).
          1. If |Initializer| is present and _v_ is *undefined*, then
            1. If IsAnonymousFunctionDefinition(|Initializer|) and IsIdentifierRef of |DestructuringAssignmentTarget| are both *true*, then
              1. Let _rhsValue_ be the result of performing NamedEvaluation for |Initializer| with argument GetReferencedName(_lref_).
            1. Else,
              1. Let _defaultValue_ be the result of evaluating |Initializer|.
              1. Let _rhsValue_ be ? GetValue(_defaultValue_).
          1. Else, let _rhsValue_ be _v_.
          1. If |DestructuringAssignmentTarget| is an |ObjectLiteral| or an |ArrayLiteral|, then
            1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.
            1. Return the result of performing DestructuringAssignmentEvaluation of _assignmentPattern_ with _rhsValue_ as the argument.
          1. Return ? PutValue(_lref_, _rhsValue_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-comma-operator">
    <h1>Comma Operator ( `,` )</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      Expression[In, Yield, Await] :
        AssignmentExpression[?In, ?Yield, ?Await]
        Expression[?In, ?Yield, ?Await] `,` AssignmentExpression[?In, ?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-comma-operator-static-semantics-isfunctiondefinition">
      <h1>Static Semantics: IsFunctionDefinition</h1>
      <emu-see-also-para op="IsFunctionDefinition"></emu-see-also-para>
      <emu-grammar>Expression : Expression `,` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-comma-operator-static-semantics-isvalidsimpleassignmenttarget" id="sec-comma-operator-static-semantics-assignmenttargettype">
      <h1>Static Semantics: AssignmentTargetType</h1>
      <emu-see-also-para op="AssignmentTargetType"></emu-see-also-para>
      <emu-grammar>Expression : Expression `,` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Return ~invalid~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-comma-operator-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>Expression : Expression `,` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Let _lref_ be the result of evaluating |Expression|.
        1. Perform ? GetValue(_lref_).
        1. Let _rref_ be the result of evaluating |AssignmentExpression|.
        1. Return ? GetValue(_rref_).
      </emu-alg>
      <emu-note>
        <p>GetValue must be called even though its value is not used because it may have observable side-effects.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-statements-and-declarations">
  <h1>ECMAScript Language: Statements and Declarations</h1>
  <h2>Syntax</h2>
  <emu-grammar type="definition">
    Statement[Yield, Await, Return] :
      BlockStatement[?Yield, ?Await, ?Return]
      VariableStatement[?Yield, ?Await]
      EmptyStatement
      ExpressionStatement[?Yield, ?Await]
      IfStatement[?Yield, ?Await, ?Return]
      BreakableStatement[?Yield, ?Await, ?Return]
      ContinueStatement[?Yield, ?Await]
      BreakStatement[?Yield, ?Await]
      [+Return] ReturnStatement[?Yield, ?Await]
      WithStatement[?Yield, ?Await, ?Return]
      LabelledStatement[?Yield, ?Await, ?Return]
      ThrowStatement[?Yield, ?Await]
      TryStatement[?Yield, ?Await, ?Return]
      DebuggerStatement

    Declaration[Yield, Await] :
      HoistableDeclaration[?Yield, ?Await, ~Default]
      ClassDeclaration[?Yield, ?Await, ~Default]
      LexicalDeclaration[+In, ?Yield, ?Await]

    HoistableDeclaration[Yield, Await, Default] :
      FunctionDeclaration[?Yield, ?Await, ?Default]
      GeneratorDeclaration[?Yield, ?Await, ?Default]
      AsyncFunctionDeclaration[?Yield, ?Await, ?Default]
      AsyncGeneratorDeclaration[?Yield, ?Await, ?Default]

    BreakableStatement[Yield, Await, Return] :
      IterationStatement[?Yield, ?Await, ?Return]
      SwitchStatement[?Yield, ?Await, ?Return]
  </emu-grammar>

  <emu-clause id="sec-statement-semantics">
    <h1>Statement Semantics</h1>

    <emu-clause id="sec-statement-semantics-static-semantics-containsduplicatelabels">
      <h1>Static Semantics: ContainsDuplicateLabels</h1>
      <p>With parameter _labelSet_.</p>
      <emu-see-also-para op="ContainsDuplicateLabels"></emu-see-also-para>
      <emu-grammar>
        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-statement-semantics-static-semantics-containsundefinedbreaktarget">
      <h1>Static Semantics: ContainsUndefinedBreakTarget</h1>
      <p>With parameter _labelSet_.</p>
      <emu-see-also-para op="ContainsUndefinedBreakTarget"></emu-see-also-para>
      <emu-grammar>
        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-statement-semantics-static-semantics-containsundefinedcontinuetarget">
      <h1>Static Semantics: ContainsUndefinedContinueTarget</h1>
      <p>With parameters _iterationSet_ and _labelSet_.</p>
      <emu-see-also-para op="ContainsUndefinedContinueTarget"></emu-see-also-para>
      <emu-grammar>
        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>BreakableStatement : IterationStatement</emu-grammar>
      <emu-alg>
        1. Let _newIterationSet_ be a copy of _iterationSet_ with all the elements of _labelSet_ appended.
        1. Return ContainsUndefinedContinueTarget of |IterationStatement| with arguments _newIterationSet_ and &laquo; &raquo;.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-declarationpart">
      <h1>Static Semantics: DeclarationPart</h1>
      <emu-grammar>HoistableDeclaration : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. Return |FunctionDeclaration|.
      </emu-alg>
      <emu-grammar>HoistableDeclaration : GeneratorDeclaration</emu-grammar>
      <emu-alg>
        1. Return |GeneratorDeclaration|.
      </emu-alg>
      <emu-grammar>HoistableDeclaration : AsyncFunctionDeclaration</emu-grammar>
      <emu-alg>
        1. Return |AsyncFunctionDeclaration|.
      </emu-alg>
      <emu-grammar>HoistableDeclaration : AsyncGeneratorDeclaration</emu-grammar>
      <emu-alg>
        1. Return |AsyncGeneratorDeclaration|.
      </emu-alg>
      <emu-grammar>Declaration : ClassDeclaration</emu-grammar>
      <emu-alg>
        1. Return |ClassDeclaration|.
      </emu-alg>
      <emu-grammar>Declaration : LexicalDeclaration</emu-grammar>
      <emu-alg>
        1. Return |LexicalDeclaration|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-statement-semantics-static-semantics-vardeclarednames">
      <h1>Static Semantics: VarDeclaredNames</h1>
      <emu-see-also-para op="VarDeclaredNames"></emu-see-also-para>
      <emu-grammar>
        Statement :
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement
      </emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-statement-semantics-static-semantics-varscopeddeclarations">
      <h1>Static Semantics: VarScopedDeclarations</h1>
      <emu-see-also-para op="VarScopedDeclarations"></emu-see-also-para>
      <emu-grammar>
        Statement :
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement
      </emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-statement-semantics-runtime-semantics-labelledevaluation">
      <h1>Runtime Semantics: LabelledEvaluation</h1>
      <p>With parameter _labelSet_.</p>
      <emu-see-also-para op="LabelledEvaluation"></emu-see-also-para>
      <emu-grammar>BreakableStatement : IterationStatement</emu-grammar>
      <emu-alg>
        1. Let _stmtResult_ be the result of performing LabelledEvaluation of |IterationStatement| with argument _labelSet_.
        1. If _stmtResult_.[[Type]] is ~break~, then
          1. If _stmtResult_.[[Target]] is ~empty~, then
            1. If _stmtResult_.[[Value]] is ~empty~, set _stmtResult_ to NormalCompletion(*undefined*).
            1. Else, set _stmtResult_ to NormalCompletion(_stmtResult_.[[Value]]).
        1. Return Completion(_stmtResult_).
      </emu-alg>
      <emu-grammar>BreakableStatement : SwitchStatement</emu-grammar>
      <emu-alg>
        1. Let _stmtResult_ be the result of evaluating |SwitchStatement|.
        1. If _stmtResult_.[[Type]] is ~break~, then
          1. If _stmtResult_.[[Target]] is ~empty~, then
            1. If _stmtResult_.[[Value]] is ~empty~, set _stmtResult_ to NormalCompletion(*undefined*).
            1. Else, set _stmtResult_ to NormalCompletion(_stmtResult_.[[Value]]).
        1. Return Completion(_stmtResult_).
      </emu-alg>
      <emu-note>
        <p>A |BreakableStatement| is one that can be exited via an unlabelled |BreakStatement|.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-statement-semantics-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>
        HoistableDeclaration :
          GeneratorDeclaration
          AsyncFunctionDeclaration
          AsyncGeneratorDeclaration
      </emu-grammar>
      <emu-alg>
        1. Return NormalCompletion(~empty~).
      </emu-alg>
      <emu-grammar>
        HoistableDeclaration : FunctionDeclaration
      </emu-grammar>
      <emu-alg>
        1. Return the result of evaluating |FunctionDeclaration|.
      </emu-alg>
      <emu-grammar>
        BreakableStatement :
          IterationStatement
          SwitchStatement
      </emu-grammar>
      <emu-alg>
        1. Let _newLabelSet_ be a new empty List.
        1. Return the result of performing LabelledEvaluation of this |BreakableStatement| with argument _newLabelSet_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-block">
    <h1>Block</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      BlockStatement[Yield, Await, Return] :
        Block[?Yield, ?Await, ?Return]

      Block[Yield, Await, Return] :
        `{` StatementList[?Yield, ?Await, ?Return]? `}`

      StatementList[Yield, Await, Return] :
        StatementListItem[?Yield, ?Await, ?Return]
        StatementList[?Yield, ?Await, ?Return] StatementListItem[?Yield, ?Await, ?Return]

      StatementListItem[Yield, Await, Return] :
        Statement[?Yield, ?Await, ?Return]
        Declaration[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-block-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>Block : `{` StatementList `}`</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if the LexicallyDeclaredNames of |StatementList| contains any duplicate entries.
        </li>
        <li>
          It is a Syntax Error if any element of the LexicallyDeclaredNames of |StatementList| also occurs in the VarDeclaredNames of |StatementList|.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-block-static-semantics-containsduplicatelabels">
      <h1>Static Semantics: ContainsDuplicateLabels</h1>
      <p>With parameter _labelSet_.</p>
      <emu-see-also-para op="ContainsDuplicateLabels"></emu-see-also-para>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |StatementList| with argument _labelSet_.
        1. If _hasDuplicates_ is *true*, return *true*.
        1. Return ContainsDuplicateLabels of |StatementListItem| with argument _labelSet_.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-block-static-semantics-containsundefinedbreaktarget">
      <h1>Static Semantics: ContainsUndefinedBreakTarget</h1>
      <p>With parameter _labelSet_.</p>
      <emu-see-also-para op="ContainsUndefinedBreakTarget"></emu-see-also-para>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |StatementList| with argument _labelSet_.
        1. If _hasUndefinedLabels_ is *true*, return *true*.
        1. Return ContainsUndefinedBreakTarget of |StatementListItem| with argument _labelSet_.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-block-static-semantics-containsundefinedcontinuetarget">
      <h1>Static Semantics: ContainsUndefinedContinueTarget</h1>
      <p>With parameters _iterationSet_ and _labelSet_.</p>
      <emu-see-also-para op="ContainsUndefinedContinueTarget"></emu-see-also-para>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |StatementList| with arguments _iterationSet_ and &laquo; &raquo;.
        1. If _hasUndefinedLabels_ is *true*, return *true*.
        1. Return ContainsUndefinedContinueTarget of |StatementListItem| with arguments _iterationSet_ and &laquo; &raquo;.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-block-static-semantics-lexicallydeclarednames">
      <h1>Static Semantics: LexicallyDeclaredNames</h1>
      <emu-see-also-para op="LexicallyDeclaredNames"></emu-see-also-para>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. Let _names_ be LexicallyDeclaredNames of |StatementList|.
        1. Append to _names_ the elements of the LexicallyDeclaredNames of |StatementListItem|.
        1. Return _names_.
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar> , return LexicallyDeclaredNames of |LabelledStatement|.
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |Declaration|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-block-static-semantics-lexicallyscopeddeclarations">
      <h1>Static Semantics: LexicallyScopedDeclarations</h1>
      <emu-see-also-para op="LexicallyScopedDeclarations"></emu-see-also-para>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. Let _declarations_ be LexicallyScopedDeclarations of |StatementList|.
        1. Append to _declarations_ the elements of the LexicallyScopedDeclarations of |StatementListItem|.
        1. Return _declarations_.
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar> , return LexicallyScopedDeclarations of |LabelledStatement|.
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. Return a new List containing DeclarationPart of |Declaration|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-block-static-semantics-toplevellexicallydeclarednames">
      <h1>Static Semantics: TopLevelLexicallyDeclaredNames</h1>
      <emu-see-also-para op="TopLevelLexicallyDeclaredNames"></emu-see-also-para>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. Let _names_ be TopLevelLexicallyDeclaredNames of |StatementList|.
        1. Append to _names_ the elements of the TopLevelLexicallyDeclaredNames of |StatementListItem|.
        1. Return _names_.
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. If |Declaration| is <emu-grammar>Declaration : HoistableDeclaration</emu-grammar> , then
          1. Return &laquo; &raquo;.
        1. Return the BoundNames of |Declaration|.
      </emu-alg>
      <emu-note>
        <p>At the top level of a function, or script, function declarations are treated like var declarations rather than like lexical declarations.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-block-static-semantics-toplevellexicallyscopeddeclarations">
      <h1>Static Semantics: TopLevelLexicallyScopedDeclarations</h1>
      <emu-see-also-para op="TopLevelLexicallyScopedDeclarations"></emu-see-also-para>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. Let _declarations_ be TopLevelLexicallyScopedDeclarations of |StatementList|.
        1. Append to _declarations_ the elements of the TopLevelLexicallyScopedDeclarations of |StatementListItem|.
        1. Return _declarations_.
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. If |Declaration| is <emu-grammar>Declaration : HoistableDeclaration</emu-grammar> , then
          1. Return &laquo; &raquo;.
        1. Return a new List containing |Declaration|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-block-static-semantics-toplevelvardeclarednames">
      <h1>Static Semantics: TopLevelVarDeclaredNames</h1>
      <emu-see-also-para op="TopLevelVarDeclaredNames"></emu-see-also-para>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. Let _names_ be TopLevelVarDeclaredNames of |StatementList|.
        1. Append to _names_ the elements of the TopLevelVarDeclaredNames of |StatementListItem|.
        1. Return _names_.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. If |Declaration| is <emu-grammar>Declaration : HoistableDeclaration</emu-grammar> , then
          1. Return the BoundNames of |HoistableDeclaration|.
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar> , return TopLevelVarDeclaredNames of |Statement|.
        1. Return VarDeclaredNames of |Statement|.
      </emu-alg>
      <emu-note>
        <p>At the top level of a function or script, inner function declarations are treated like var declarations.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-block-static-semantics-toplevelvarscopeddeclarations">
      <h1>Static Semantics: TopLevelVarScopedDeclarations</h1>
      <emu-see-also-para op="TopLevelVarScopedDeclarations"></emu-see-also-para>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. Let _declarations_ be TopLevelVarScopedDeclarations of |StatementList|.
        1. Append to _declarations_ the elements of the TopLevelVarScopedDeclarations of |StatementListItem|.
        1. Return _declarations_.
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar> , return TopLevelVarScopedDeclarations of |Statement|.
        1. Return VarScopedDeclarations of |Statement|.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. If |Declaration| is <emu-grammar>Declaration : HoistableDeclaration</emu-grammar> , then
          1. Let _declaration_ be DeclarationPart of |HoistableDeclaration|.
          1. Return &laquo; _declaration_ &raquo;.
        1. Return a new empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-block-static-semantics-vardeclarednames">
      <h1>Static Semantics: VarDeclaredNames</h1>
      <emu-see-also-para op="VarDeclaredNames"></emu-see-also-para>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. Let _names_ be VarDeclaredNames of |StatementList|.
        1. Append to _names_ the elements of the VarDeclaredNames of |StatementListItem|.
        1. Return _names_.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-block-static-semantics-varscopeddeclarations">
      <h1>Static Semantics: VarScopedDeclarations</h1>
      <emu-see-also-para op="VarScopedDeclarations"></emu-see-also-para>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. Let _declarations_ be VarScopedDeclarations of |StatementList|.
        1. Append to _declarations_ the elements of the VarScopedDeclarations of |StatementListItem|.
        1. Return _declarations_.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-block-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return NormalCompletion(~empty~).
      </emu-alg>
      <emu-grammar>Block : `{` StatementList `}`</emu-grammar>
      <emu-alg>
        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
        1. Let _blockEnv_ be NewDeclarativeEnvironment(_oldEnv_).
        1. Perform BlockDeclarationInstantiation(|StatementList|, _blockEnv_).
        1. Set the running execution context's LexicalEnvironment to _blockEnv_.
        1. Let _blockValue_ be the result of evaluating |StatementList|.
        1. Set the running execution context's LexicalEnvironment to _oldEnv_.
        1. Return _blockValue_.
      </emu-alg>
      <emu-note>
        <p>No matter how control leaves the |Block| the LexicalEnvironment is always restored to its former state.</p>
      </emu-note>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. Let _sl_ be the result of evaluating |StatementList|.
        1. ReturnIfAbrupt(_sl_).
        1. Let _s_ be the result of evaluating |StatementListItem|.
        1. Return Completion(UpdateEmpty(_s_, _sl_)).
      </emu-alg>
      <emu-note>
        <p>The value of a |StatementList| is the value of the last value-producing item in the |StatementList|. For example, the following calls to the `eval` function all return the value 1:</p>
        <pre><code class="javascript">
          eval("1;;;;;")
          eval("1;{}")
          eval("1;var a;")
        </code></pre>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-blockdeclarationinstantiation" aoid="BlockDeclarationInstantiation">
      <h1>Runtime Semantics: BlockDeclarationInstantiation ( _code_, _env_ )</h1>
      <emu-note>
        <p>When a |Block| or |CaseBlock| is evaluated a new declarative Environment Record is created and bindings for each block scoped variable, constant, function, or class declared in the block are instantiated in the Environment Record.</p>
      </emu-note>
      <p>BlockDeclarationInstantiation is performed as follows using arguments _code_ and _env_. _code_ is the Parse Node corresponding to the body of the block. _env_ is the Lexical Environment in which bindings are to be created.</p>
      <!--
        WARNING: If you add, remove, rename, or repurpose any variable names
                 within this algorithm, you may need to update
                 #sec-web-compat-blockdeclarationinstantiation accordingly.
      -->
      <emu-alg>
        1. Let _envRec_ be _env_'s EnvironmentRecord.
        1. Assert: _envRec_ is a declarative Environment Record.
        1. Let _declarations_ be the LexicallyScopedDeclarations of _code_.
        1. For each element _d_ in _declarations_, do
          1. For each element _dn_ of the BoundNames of _d_, do
            1. If IsConstantDeclaration of _d_ is *true*, then
              1. Perform ! _envRec_.CreateImmutableBinding(_dn_, *true*).
            1. Else,
              1. Perform ! _envRec_.CreateMutableBinding(_dn_, *false*).
          1. If _d_ is a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|, then
            1. Let _fn_ be the sole element of the BoundNames of _d_.
            1. Let _fo_ be the result of performing InstantiateFunctionObject for _d_ with argument _env_.
            1. Perform _envRec_.InitializeBinding(_fn_, _fo_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-declarations-and-the-variable-statement">
    <h1>Declarations and the Variable Statement</h1>

    <emu-clause id="sec-let-and-const-declarations">
      <h1>Let and Const Declarations</h1>
      <emu-note>
        <p>`let` and `const` declarations define variables that are scoped to the running execution context's LexicalEnvironment. The variables are created when their containing Lexical Environment is instantiated but may not be accessed in any way until the variable's |LexicalBinding| is evaluated. A variable defined by a |LexicalBinding| with an |Initializer| is assigned the value of its |Initializer|'s |AssignmentExpression| when the |LexicalBinding| is evaluated, not when the variable is created. If a |LexicalBinding| in a `let` declaration does not have an |Initializer| the variable is assigned the value *undefined* when the |LexicalBinding| is evaluated.</p>
      </emu-note>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        LexicalDeclaration[In, Yield, Await] :
          LetOrConst BindingList[?In, ?Yield, ?Await] `;`

        LetOrConst :
          `let`
          `const`

        BindingList[In, Yield, Await] :
          LexicalBinding[?In, ?Yield, ?Await]
          BindingList[?In, ?Yield, ?Await] `,` LexicalBinding[?In, ?Yield, ?Await]

        LexicalBinding[In, Yield, Await] :
          BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]?
          BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-let-and-const-declarations-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the BoundNames of |BindingList| contains `"let"`.
          </li>
          <li>
            It is a Syntax Error if the BoundNames of |BindingList| contains any duplicate entries.
          </li>
        </ul>
        <emu-grammar>LexicalBinding : BindingIdentifier Initializer?</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if |Initializer| is not present and IsConstantDeclaration of the |LexicalDeclaration| containing this |LexicalBinding| is *true*.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-let-and-const-declarations-static-semantics-boundnames">
        <h1>Static Semantics: BoundNames</h1>
        <emu-see-also-para op="BoundNames"></emu-see-also-para>
        <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |BindingList|.
        </emu-alg>
        <emu-grammar>BindingList : BindingList `,` LexicalBinding</emu-grammar>
        <emu-alg>
          1. Let _names_ be the BoundNames of |BindingList|.
          1. Append to _names_ the elements of the BoundNames of |LexicalBinding|.
          1. Return _names_.
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingIdentifier Initializer?</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |BindingIdentifier|.
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingPattern Initializer</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |BindingPattern|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-let-and-const-declarations-static-semantics-isconstantdeclaration">
        <h1>Static Semantics: IsConstantDeclaration</h1>
        <emu-see-also-para op="IsConstantDeclaration"></emu-see-also-para>
        <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
        <emu-alg>
          1. Return IsConstantDeclaration of |LetOrConst|.
        </emu-alg>
        <emu-grammar>LetOrConst : `let`</emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>LetOrConst : `const`</emu-grammar>
        <emu-alg>
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-let-and-const-declarations-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
        <emu-alg>
          1. Let _next_ be the result of evaluating |BindingList|.
          1. ReturnIfAbrupt(_next_).
          1. Return NormalCompletion(~empty~).
        </emu-alg>
        <emu-grammar>BindingList : BindingList `,` LexicalBinding</emu-grammar>
        <emu-alg>
          1. Let _next_ be the result of evaluating |BindingList|.
          1. ReturnIfAbrupt(_next_).
          1. Return the result of evaluating |LexicalBinding|.
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. Let _lhs_ be ResolveBinding(StringValue of |BindingIdentifier|).
          1. Return InitializeReferencedBinding(_lhs_, *undefined*).
        </emu-alg>
        <emu-note>
          <p>A static semantics rule ensures that this form of |LexicalBinding| never occurs in a `const` declaration.</p>
        </emu-note>
        <emu-grammar>LexicalBinding : BindingIdentifier Initializer</emu-grammar>
        <emu-alg>
          1. Let _bindingId_ be StringValue of |BindingIdentifier|.
          1. Let _lhs_ be ResolveBinding(_bindingId_).
          1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then
            1. Let _value_ be the result of performing NamedEvaluation for |Initializer| with argument _bindingId_.
          1. Else,
            1. Let _rhs_ be the result of evaluating |Initializer|.
            1. Let _value_ be ? GetValue(_rhs_).
          1. Return InitializeReferencedBinding(_lhs_, _value_).
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingPattern Initializer</emu-grammar>
        <emu-alg>
          1. Let _rhs_ be the result of evaluating |Initializer|.
          1. Let _value_ be ? GetValue(_rhs_).
          1. Let _env_ be the running execution context's LexicalEnvironment.
          1. Return the result of performing BindingInitialization for |BindingPattern| using _value_ and _env_ as the arguments.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-variable-statement">
      <h1>Variable Statement</h1>
      <emu-note>
        <p>A `var` statement declares variables that are scoped to the running execution context's VariableEnvironment. Var variables are created when their containing Lexical Environment is instantiated and are initialized to *undefined* when created. Within the scope of any VariableEnvironment a common |BindingIdentifier| may appear in more than one |VariableDeclaration| but those declarations collectively define only one variable. A variable defined by a |VariableDeclaration| with an |Initializer| is assigned the value of its |Initializer|'s |AssignmentExpression| when the |VariableDeclaration| is executed, not when the variable is created.</p>
      </emu-note>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        VariableStatement[Yield, Await] :
          `var` VariableDeclarationList[+In, ?Yield, ?Await] `;`

        VariableDeclarationList[In, Yield, Await] :
          VariableDeclaration[?In, ?Yield, ?Await]
          VariableDeclarationList[?In, ?Yield, ?Await] `,` VariableDeclaration[?In, ?Yield, ?Await]

        VariableDeclaration[In, Yield, Await] :
          BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]?
          BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-variable-statement-static-semantics-boundnames">
        <h1>Static Semantics: BoundNames</h1>
        <emu-see-also-para op="BoundNames"></emu-see-also-para>
        <emu-grammar>VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration</emu-grammar>
        <emu-alg>
          1. Let _names_ be BoundNames of |VariableDeclarationList|.
          1. Append to _names_ the elements of BoundNames of |VariableDeclaration|.
          1. Return _names_.
        </emu-alg>
        <emu-grammar>VariableDeclaration : BindingIdentifier Initializer?</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |BindingIdentifier|.
        </emu-alg>
        <emu-grammar>VariableDeclaration : BindingPattern Initializer</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |BindingPattern|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-variable-statement-static-semantics-vardeclarednames">
        <h1>Static Semantics: VarDeclaredNames</h1>
        <emu-see-also-para op="VarDeclaredNames"></emu-see-also-para>
        <emu-grammar>VariableStatement : `var` VariableDeclarationList `;`</emu-grammar>
        <emu-alg>
          1. Return BoundNames of |VariableDeclarationList|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-variable-statement-static-semantics-varscopeddeclarations">
        <h1>Static Semantics: VarScopedDeclarations</h1>
        <emu-see-also-para op="VarScopedDeclarations"></emu-see-also-para>
        <emu-grammar>VariableDeclarationList : VariableDeclaration</emu-grammar>
        <emu-alg>
          1. Return a new List containing |VariableDeclaration|.
        </emu-alg>
        <emu-grammar>VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration</emu-grammar>
        <emu-alg>
          1. Let _declarations_ be VarScopedDeclarations of |VariableDeclarationList|.
          1. Append |VariableDeclaration| to _declarations_.
          1. Return _declarations_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-variable-statement-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>VariableStatement : `var` VariableDeclarationList `;`</emu-grammar>
        <emu-alg>
          1. Let _next_ be the result of evaluating |VariableDeclarationList|.
          1. ReturnIfAbrupt(_next_).
          1. Return NormalCompletion(~empty~).
        </emu-alg>
        <emu-grammar>VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration</emu-grammar>
        <emu-alg>
          1. Let _next_ be the result of evaluating |VariableDeclarationList|.
          1. ReturnIfAbrupt(_next_).
          1. Return the result of evaluating |VariableDeclaration|.
        </emu-alg>
        <emu-grammar>VariableDeclaration : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. Return NormalCompletion(~empty~).
        </emu-alg>
        <emu-grammar>VariableDeclaration : BindingIdentifier Initializer</emu-grammar>
        <emu-alg>
          1. Let _bindingId_ be StringValue of |BindingIdentifier|.
          1. Let _lhs_ be ? ResolveBinding(_bindingId_).
          1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then
            1. Let _value_ be the result of performing NamedEvaluation for |Initializer| with argument _bindingId_.
          1. Else,
            1. Let _rhs_ be the result of evaluating |Initializer|.
            1. Let _value_ be ? GetValue(_rhs_).
          1. Return ? PutValue(_lhs_, _value_).
        </emu-alg>
        <emu-note>
          <p>If a |VariableDeclaration| is nested within a with statement and the |BindingIdentifier| in the |VariableDeclaration| is the same as a property name of the binding object of the with statement's object Environment Record, then step 6 will assign _value_ to the property instead of assigning to the VariableEnvironment binding of the |Identifier|.</p>
        </emu-note>
        <emu-grammar>VariableDeclaration : BindingPattern Initializer</emu-grammar>
        <emu-alg>
          1. Let _rhs_ be the result of evaluating |Initializer|.
          1. Let _rval_ be ? GetValue(_rhs_).
          1. Return the result of performing BindingInitialization for |BindingPattern| passing _rval_ and *undefined* as arguments.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-destructuring-binding-patterns">
      <h1>Destructuring Binding Patterns</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        BindingPattern[Yield, Await] :
          ObjectBindingPattern[?Yield, ?Await]
          ArrayBindingPattern[?Yield, ?Await]

        ObjectBindingPattern[Yield, Await] :
          `{` `}`
          `{` BindingRestProperty[?Yield, ?Await] `}`
          `{` BindingPropertyList[?Yield, ?Await] `}`
          `{` BindingPropertyList[?Yield, ?Await] `,` BindingRestProperty[?Yield, ?Await]? `}`

        ArrayBindingPattern[Yield, Await] :
          `[` Elision? BindingRestElement[?Yield, ?Await]? `]`
          `[` BindingElementList[?Yield, ?Await] `]`
          `[` BindingElementList[?Yield, ?Await] `,` Elision? BindingRestElement[?Yield, ?Await]? `]`

        BindingRestProperty[Yield, Await] :
          `...` BindingIdentifier[?Yield, ?Await]

        BindingPropertyList[Yield, Await] :
          BindingProperty[?Yield, ?Await]
          BindingPropertyList[?Yield, ?Await] `,` BindingProperty[?Yield, ?Await]

        BindingElementList[Yield, Await] :
          BindingElisionElement[?Yield, ?Await]
          BindingElementList[?Yield, ?Await] `,` BindingElisionElement[?Yield, ?Await]

        BindingElisionElement[Yield, Await] :
          Elision? BindingElement[?Yield, ?Await]

        BindingProperty[Yield, Await] :
          SingleNameBinding[?Yield, ?Await]
          PropertyName[?Yield, ?Await] `:` BindingElement[?Yield, ?Await]

        BindingElement[Yield, Await] :
          SingleNameBinding[?Yield, ?Await]
          BindingPattern[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

        SingleNameBinding[Yield, Await] :
          BindingIdentifier[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

        BindingRestElement[Yield, Await] :
          `...` BindingIdentifier[?Yield, ?Await]
          `...` BindingPattern[?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-destructuring-binding-patterns-static-semantics-boundnames">
        <h1>Static Semantics: BoundNames</h1>
        <emu-see-also-para op="BoundNames"></emu-see-also-para>
        <emu-grammar>ObjectBindingPattern : `{` `}`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ArrayBindingPattern : `[` Elision? `]`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |BindingRestElement|.
        </emu-alg>
        <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? `]`</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |BindingElementList|.
        </emu-alg>
        <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
        <emu-alg>
          1. Let _names_ be BoundNames of |BindingElementList|.
          1. Append to _names_ the elements of BoundNames of |BindingRestElement|.
          1. Return _names_.
        </emu-alg>
        <emu-grammar>BindingPropertyList : BindingPropertyList `,` BindingProperty</emu-grammar>
        <emu-alg>
          1. Let _names_ be BoundNames of |BindingPropertyList|.
          1. Append to _names_ the elements of BoundNames of |BindingProperty|.
          1. Return _names_.
        </emu-alg>
        <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
        <emu-alg>
          1. Let _names_ be BoundNames of |BindingElementList|.
          1. Append to _names_ the elements of BoundNames of |BindingElisionElement|.
          1. Return _names_.
        </emu-alg>
        <emu-grammar>BindingElisionElement : Elision? BindingElement</emu-grammar>
        <emu-alg>
          1. Return BoundNames of |BindingElement|.
        </emu-alg>
        <emu-grammar>BindingProperty : PropertyName `:` BindingElement</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |BindingElement|.
        </emu-alg>
        <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |BindingIdentifier|.
        </emu-alg>
        <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |BindingPattern|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-destructuring-binding-patterns-static-semantics-containsexpression">
        <h1>Static Semantics: ContainsExpression</h1>
        <emu-see-also-para op="ContainsExpression"></emu-see-also-para>
        <emu-grammar>ObjectBindingPattern : `{` `}`</emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>ArrayBindingPattern : `[` Elision? `]`</emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
        <emu-alg>
          1. Return ContainsExpression of |BindingRestElement|.
        </emu-alg>
        <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? `]`</emu-grammar>
        <emu-alg>
          1. Return ContainsExpression of |BindingElementList|.
        </emu-alg>
        <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
        <emu-alg>
          1. Let _has_ be ContainsExpression of |BindingElementList|.
          1. If _has_ is *true*, return *true*.
          1. Return ContainsExpression of |BindingRestElement|.
        </emu-alg>
        <emu-grammar>BindingPropertyList : BindingPropertyList `,` BindingProperty</emu-grammar>
        <emu-alg>
          1. Let _has_ be ContainsExpression of |BindingPropertyList|.
          1. If _has_ is *true*, return *true*.
          1. Return ContainsExpression of |BindingProperty|.
        </emu-alg>
        <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
        <emu-alg>
          1. Let _has_ be ContainsExpression of |BindingElementList|.
          1. If _has_ is *true*, return *true*.
          1. Return ContainsExpression of |BindingElisionElement|.
        </emu-alg>
        <emu-grammar>BindingElisionElement : Elision? BindingElement</emu-grammar>
        <emu-alg>
          1. Return ContainsExpression of |BindingElement|.
        </emu-alg>
        <emu-grammar>BindingProperty : PropertyName `:` BindingElement</emu-grammar>
        <emu-alg>
          1. Let _has_ be IsComputedPropertyKey of |PropertyName|.
          1. If _has_ is *true*, return *true*.
          1. Return ContainsExpression of |BindingElement|.
        </emu-alg>
        <emu-grammar>BindingElement : BindingPattern Initializer</emu-grammar>
        <emu-alg>
          1. Return *true*.
        </emu-alg>
        <emu-grammar>SingleNameBinding : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>SingleNameBinding : BindingIdentifier Initializer</emu-grammar>
        <emu-alg>
          1. Return *true*.
        </emu-alg>
        <emu-grammar>BindingRestElement : `...` BindingIdentifier</emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>BindingRestElement : `...` BindingPattern</emu-grammar>
        <emu-alg>
          1. Return ContainsExpression of |BindingPattern|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-destructuring-binding-patterns-static-semantics-hasinitializer">
        <h1>Static Semantics: HasInitializer</h1>
        <emu-see-also-para op="HasInitializer"></emu-see-also-para>
        <emu-grammar>BindingElement : BindingPattern</emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>BindingElement : BindingPattern Initializer</emu-grammar>
        <emu-alg>
          1. Return *true*.
        </emu-alg>
        <emu-grammar>SingleNameBinding : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>SingleNameBinding : BindingIdentifier Initializer</emu-grammar>
        <emu-alg>
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-destructuring-binding-patterns-static-semantics-issimpleparameterlist">
        <h1>Static Semantics: IsSimpleParameterList</h1>
        <emu-see-also-para op="IsSimpleParameterList"></emu-see-also-para>
        <emu-grammar>BindingElement : BindingPattern</emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>BindingElement : BindingPattern Initializer</emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>SingleNameBinding : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. Return *true*.
        </emu-alg>
        <emu-grammar>SingleNameBinding : BindingIdentifier Initializer</emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-destructuring-binding-patterns-runtime-semantics-bindinginitialization">
        <h1>Runtime Semantics: BindingInitialization</h1>
        <p>With parameters _value_ and _environment_.</p>
        <emu-see-also-para op="BindingInitialization"></emu-see-also-para>
        <emu-note>
          <p>When *undefined* is passed for _environment_ it indicates that a PutValue operation should be used to assign the initialization value. This is the case for formal parameter lists of non-strict functions. In that case the formal parameter bindings are preinitialized in order to deal with the possibility of multiple parameters with the same name.</p>
        </emu-note>
        <emu-grammar>BindingPattern : ObjectBindingPattern</emu-grammar>
        <emu-alg>
          1. Perform ? RequireObjectCoercible(_value_).
          1. Return the result of performing BindingInitialization for |ObjectBindingPattern| using _value_ and _environment_ as arguments.
        </emu-alg>
        <emu-grammar>BindingPattern : ArrayBindingPattern</emu-grammar>
        <emu-alg>
          1. Let _iteratorRecord_ be ? GetIterator(_value_).
          1. Let _result_ be IteratorBindingInitialization for |ArrayBindingPattern| using _iteratorRecord_ and _environment_ as arguments.
          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).
          1. Return _result_.
        </emu-alg>
        <emu-grammar>ObjectBindingPattern : `{` `}`</emu-grammar>
        <emu-alg>
          1. Return NormalCompletion(~empty~).
        </emu-alg>
        <emu-grammar>
          ObjectBindingPattern :
            `{` BindingPropertyList `}`
            `{` BindingPropertyList `,` `}`
        </emu-grammar>
        <emu-alg>
          1. Perform ? PropertyBindingInitialization for |BindingPropertyList| using _value_ and _environment_ as the arguments.
          1. Return NormalCompletion(~empty~).
        </emu-alg>

        <emu-grammar>ObjectBindingPattern : `{` BindingRestProperty `}`</emu-grammar>
        <emu-alg>
          1. Let _excludedNames_ be a new empty List.
          1. Return the result of performing RestBindingInitialization of |BindingRestProperty| with _value_, _environment_, and _excludedNames_ as the arguments.
        </emu-alg>

        <emu-grammar>ObjectBindingPattern : `{` BindingPropertyList `,` BindingRestProperty `}`</emu-grammar>
        <emu-alg>
          1. Let _excludedNames_ be the result of performing ? PropertyBindingInitialization of |BindingPropertyList| using _value_ and _environment_ as arguments.
          1. Return the result of performing RestBindingInitialization of |BindingRestProperty| with _value_, _environment_, and _excludedNames_ as the arguments.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization">
        <h1>Runtime Semantics: PropertyBindingInitialization</h1>
        <p>With parameters _value_ and _environment_.</p>

        <emu-note>These collect a list of all bound property names rather than just empty completion.</emu-note>

        <emu-grammar>BindingPropertyList : BindingPropertyList `,` BindingProperty</emu-grammar>
        <emu-alg>
          1. Let _boundNames_ be the result of performing ? PropertyBindingInitialization for |BindingPropertyList| using _value_ and _environment_ as arguments.
          1. Let _nextNames_ be the result of performing ? PropertyBindingInitialization for |BindingProperty| using _value_ and _environment_ as arguments.
          1. Append each item in _nextNames_ to the end of _boundNames_.
          1. Return _boundNames_.
        </emu-alg>

        <emu-grammar>BindingProperty : SingleNameBinding</emu-grammar>
        <emu-alg>
          1. Let _name_ be the string that is the only element of BoundNames of |SingleNameBinding|.
          1. Perform ? KeyedBindingInitialization for |SingleNameBinding| using _value_, _environment_, and _name_ as the arguments.
          1. Return a new List containing _name_.
        </emu-alg>

        <emu-grammar>BindingProperty : PropertyName `:` BindingElement</emu-grammar>
        <emu-alg>
          1. Let _P_ be the result of evaluating |PropertyName|.
          1. ReturnIfAbrupt(_P_).
          1. Perform ? KeyedBindingInitialization of |BindingElement| with _value_, _environment_, and _P_ as the arguments.
          1. Return a new List containing _P_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-destructuring-binding-patterns-runtime-semantics-restbindinginitialization">
        <h1>Runtime Semantics: RestBindingInitialization</h1>
        <p>With parameters _value_, _environment_, and _excludedNames_.</p>

        <emu-grammar>BindingRestProperty : `...` BindingIdentifier</emu-grammar>
        <emu-alg>
          1. Let _lhs_ be ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_).
          1. Let _restObj_ be ObjectCreate(%ObjectPrototype%).
          1. Perform ? CopyDataProperties(_restObj_, _value_, _excludedNames_).
          1. If _environment_ is *undefined*, return PutValue(_lhs_, _restObj_).
          1. Return InitializeReferencedBinding(_lhs_, _restObj_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization">
        <h1>Runtime Semantics: IteratorBindingInitialization</h1>
        <p>With parameters _iteratorRecord_ and _environment_.</p>
        <emu-see-also-para op="IteratorBindingInitialization"></emu-see-also-para>
        <emu-note>
          <p>When *undefined* is passed for _environment_ it indicates that a PutValue operation should be used to assign the initialization value. This is the case for formal parameter lists of non-strict functions. In that case the formal parameter bindings are preinitialized in order to deal with the possibility of multiple parameters with the same name.</p>
        </emu-note>
        <emu-grammar>ArrayBindingPattern : `[` `]`</emu-grammar>
        <emu-alg>
          1. Return NormalCompletion(~empty~).
        </emu-alg>
        <emu-grammar>ArrayBindingPattern : `[` Elision `]`</emu-grammar>
        <emu-alg>
          1. Return the result of performing IteratorDestructuringAssignmentEvaluation of |Elision| with _iteratorRecord_ as the argument.
        </emu-alg>
        <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
        <emu-alg>
          1. If |Elision| is present, then
            1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with _iteratorRecord_ as the argument.
          1. Return the result of performing IteratorBindingInitialization for |BindingRestElement| with _iteratorRecord_ and _environment_ as arguments.
        </emu-alg>
        <emu-grammar>ArrayBindingPattern : `[` BindingElementList `]`</emu-grammar>
        <emu-alg>
          1. Return the result of performing IteratorBindingInitialization for |BindingElementList| with _iteratorRecord_ and _environment_ as arguments.
        </emu-alg>
        <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` `]`</emu-grammar>
        <emu-alg>
          1. Return the result of performing IteratorBindingInitialization for |BindingElementList| with _iteratorRecord_ and _environment_ as arguments.
        </emu-alg>
        <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision `]`</emu-grammar>
        <emu-alg>
          1. Perform ? IteratorBindingInitialization for |BindingElementList| with _iteratorRecord_ and _environment_ as arguments.
          1. Return the result of performing IteratorDestructuringAssignmentEvaluation of |Elision| with _iteratorRecord_ as the argument.
        </emu-alg>
        <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
        <emu-alg>
          1. Perform ? IteratorBindingInitialization for |BindingElementList| with _iteratorRecord_ and _environment_ as arguments.
          1. If |Elision| is present, then
            1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with _iteratorRecord_ as the argument.
          1. Return the result of performing IteratorBindingInitialization for |BindingRestElement| with _iteratorRecord_ and _environment_ as arguments.
        </emu-alg>
        <emu-grammar>BindingElementList : BindingElisionElement</emu-grammar>
        <emu-alg>
          1. Return the result of performing IteratorBindingInitialization for |BindingElisionElement| with _iteratorRecord_ and _environment_ as arguments.
        </emu-alg>
        <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
        <emu-alg>
          1. Perform ? IteratorBindingInitialization for |BindingElementList| with _iteratorRecord_ and _environment_ as arguments.
          1. Return the result of performing IteratorBindingInitialization for |BindingElisionElement| using _iteratorRecord_ and _environment_ as arguments.
        </emu-alg>
        <emu-grammar>BindingElisionElement : BindingElement</emu-grammar>
        <emu-alg>
          1. Return the result of performing IteratorBindingInitialization of |BindingElement| with _iteratorRecord_ and _environment_ as the arguments.
        </emu-alg>
        <emu-grammar>BindingElisionElement : Elision BindingElement</emu-grammar>
        <emu-alg>
          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with _iteratorRecord_ as the argument.
          1. Return the result of performing IteratorBindingInitialization of |BindingElement| with _iteratorRecord_ and _environment_ as the arguments.
        </emu-alg>
        <emu-grammar>BindingElement : SingleNameBinding</emu-grammar>
        <emu-alg>
          1. Return the result of performing IteratorBindingInitialization for |SingleNameBinding| with _iteratorRecord_ and _environment_ as the arguments.
        </emu-alg>
        <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
        <emu-alg>
          1. Let _bindingId_ be StringValue of |BindingIdentifier|.
          1. Let _lhs_ be ? ResolveBinding(_bindingId_, _environment_).
          1. If _iteratorRecord_.[[Done]] is *false*, then
            1. Let _next_ be IteratorStep(_iteratorRecord_).
            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
            1. ReturnIfAbrupt(_next_).
            1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.
            1. Else,
              1. Let _v_ be IteratorValue(_next_).
              1. If _v_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
              1. ReturnIfAbrupt(_v_).
          1. If _iteratorRecord_.[[Done]] is *true*, let _v_ be *undefined*.
          1. If |Initializer| is present and _v_ is *undefined*, then
            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then
              1. Set _v_ to the result of performing NamedEvaluation for |Initializer| with argument _bindingId_.
            1. Else,
              1. Let _defaultValue_ be the result of evaluating |Initializer|.
              1. Set _v_ to ? GetValue(_defaultValue_).
          1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _v_).
          1. Return InitializeReferencedBinding(_lhs_, _v_).
        </emu-alg>
        <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
        <emu-alg>
          1. If _iteratorRecord_.[[Done]] is *false*, then
            1. Let _next_ be IteratorStep(_iteratorRecord_).
            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
            1. ReturnIfAbrupt(_next_).
            1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.
            1. Else,
              1. Let _v_ be IteratorValue(_next_).
              1. If _v_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
              1. ReturnIfAbrupt(_v_).
          1. If _iteratorRecord_.[[Done]] is *true*, let _v_ be *undefined*.
          1. If |Initializer| is present and _v_ is *undefined*, then
            1. Let _defaultValue_ be the result of evaluating |Initializer|.
            1. Set _v_ to ? GetValue(_defaultValue_).
          1. Return the result of performing BindingInitialization of |BindingPattern| with _v_ and _environment_ as the arguments.
        </emu-alg>
        <emu-grammar>BindingRestElement : `...` BindingIdentifier</emu-grammar>
        <emu-alg>
          1. Let _lhs_ be ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_).
          1. Let _A_ be ! ArrayCreate(0).
          1. Let _n_ be 0.
          1. Repeat,
            1. If _iteratorRecord_.[[Done]] is *false*, then
              1. Let _next_ be IteratorStep(_iteratorRecord_).
              1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
              1. ReturnIfAbrupt(_next_).
              1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.
            1. If _iteratorRecord_.[[Done]] is *true*, then
              1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _A_).
              1. Return InitializeReferencedBinding(_lhs_, _A_).
            1. Let _nextValue_ be IteratorValue(_next_).
            1. If _nextValue_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
            1. ReturnIfAbrupt(_nextValue_).
            1. Let _status_ be CreateDataProperty(_A_, ! ToString(_n_), _nextValue_).
            1. Assert: _status_ is *true*.
            1. Increment _n_ by 1.
        </emu-alg>
        <emu-grammar>BindingRestElement : `...` BindingPattern</emu-grammar>
        <emu-alg>
          1. Let _A_ be ! ArrayCreate(0).
          1. Let _n_ be 0.
          1. Repeat,
            1. If _iteratorRecord_.[[Done]] is *false*, then
              1. Let _next_ be IteratorStep(_iteratorRecord_).
              1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
              1. ReturnIfAbrupt(_next_).
              1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.
            1. If _iteratorRecord_.[[Done]] is *true*, then
              1. Return the result of performing BindingInitialization of |BindingPattern| with _A_ and _environment_ as the arguments.
            1. Let _nextValue_ be IteratorValue(_next_).
            1. If _nextValue_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
            1. ReturnIfAbrupt(_nextValue_).
            1. Let _status_ be CreateDataProperty(_A_, ! ToString(_n_), _nextValue_).
            1. Assert: _status_ is *true*.
            1. Increment _n_ by 1.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-keyedbindinginitialization">
        <h1>Runtime Semantics: KeyedBindingInitialization</h1>
        <p>With parameters _value_, _environment_, and _propertyName_.</p>
        <emu-note>
          <p>When *undefined* is passed for _environment_ it indicates that a PutValue operation should be used to assign the initialization value. This is the case for formal parameter lists of non-strict functions. In that case the formal parameter bindings are preinitialized in order to deal with the possibility of multiple parameters with the same name.</p>
        </emu-note>
        <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
        <emu-alg>
          1. Let _v_ be ? GetV(_value_, _propertyName_).
          1. If |Initializer| is present and _v_ is *undefined*, then
            1. Let _defaultValue_ be the result of evaluating |Initializer|.
            1. Set _v_ to ? GetValue(_defaultValue_).
          1. Return the result of performing BindingInitialization for |BindingPattern| passing _v_ and _environment_ as arguments.
        </emu-alg>
        <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
        <emu-alg>
          1. Let _bindingId_ be StringValue of |BindingIdentifier|.
          1. Let _lhs_ be ? ResolveBinding(_bindingId_, _environment_).
          1. Let _v_ be ? GetV(_value_, _propertyName_).
          1. If |Initializer| is present and _v_ is *undefined*, then
            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then
              1. Set _v_ to the result of performing NamedEvaluation for |Initializer| with argument _bindingId_.
            1. Else,
              1. Let _defaultValue_ be the result of evaluating |Initializer|.
              1. Set _v_ to ? GetValue(_defaultValue_).
          1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _v_).
          1. Return InitializeReferencedBinding(_lhs_, _v_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-empty-statement">
    <h1>Empty Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      EmptyStatement :
        `;`
    </emu-grammar>

    <emu-clause id="sec-empty-statement-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>EmptyStatement : `;`</emu-grammar>
      <emu-alg>
        1. Return NormalCompletion(~empty~).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-expression-statement">
    <h1>Expression Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ExpressionStatement[Yield, Await] :
        [lookahead &lt;! {`{`, `function`, `async` [no |LineTerminator| here] `function`, `class`, `let` `[`}] Expression[+In, ?Yield, ?Await] `;`
    </emu-grammar>
    <emu-note>
      <p>An |ExpressionStatement| cannot start with a U+007B (LEFT CURLY BRACKET) because that might make it ambiguous with a |Block|. An |ExpressionStatement| cannot start with the `function` or `class` keywords because that would make it ambiguous with a |FunctionDeclaration|, a |GeneratorDeclaration|, or a |ClassDeclaration|. An |ExpressionStatement| cannot start with `async function` because that would make it ambiguous with an |AsyncFunctionDeclaration| or a |AsyncGeneratorDeclaration|.  An |ExpressionStatement| cannot start with the two token sequence `let [` because that would make it ambiguous with a `let` |LexicalDeclaration| whose first |LexicalBinding| was an |ArrayBindingPattern|.</p>
    </emu-note>

    <emu-clause id="sec-expression-statement-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>ExpressionStatement : Expression `;`</emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be the result of evaluating |Expression|.
        1. Return ? GetValue(_exprRef_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-if-statement">
    <h1>The `if` Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      IfStatement[Yield, Await, Return] :
        `if` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return] `else` Statement[?Yield, ?Await, ?Return]
        `if` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
    </emu-grammar>
    <p>Each `else` for which the choice of associated `if` is ambiguous shall be associated with the nearest possible `if` that would otherwise have no corresponding `else`.</p>

    <emu-clause id="sec-if-statement-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>
        IfStatement :
          `if` `(` Expression `)` Statement `else` Statement
          `if` `(` Expression `)` Statement
      </emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.
        </li>
      </ul>
      <emu-note>
        <p>It is only necessary to apply this rule if the extension specified in <emu-xref href="#sec-labelled-function-declarations"></emu-xref> is implemented.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-if-statement-static-semantics-containsduplicatelabels">
      <h1>Static Semantics: ContainsDuplicateLabels</h1>
      <p>With parameter _labelSet_.</p>
      <emu-see-also-para op="ContainsDuplicateLabels"></emu-see-also-para>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. Let _hasDuplicate_ be ContainsDuplicateLabels of the first |Statement| with argument _labelSet_.
        1. If _hasDuplicate_ is *true*, return *true*.
        1. Return ContainsDuplicateLabels of the second |Statement| with argument _labelSet_.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-if-statement-static-semantics-containsundefinedbreaktarget">
      <h1>Static Semantics: ContainsUndefinedBreakTarget</h1>
      <p>With parameter _labelSet_.</p>
      <emu-see-also-para op="ContainsUndefinedBreakTarget"></emu-see-also-para>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of the first |Statement| with argument _labelSet_.
        1. If _hasUndefinedLabels_ is *true*, return *true*.
        1. Return ContainsUndefinedBreakTarget of the second |Statement| with argument _labelSet_.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-if-statement-static-semantics-containsundefinedcontinuetarget">
      <h1>Static Semantics: ContainsUndefinedContinueTarget</h1>
      <p>With parameters _iterationSet_ and _labelSet_.</p>
      <emu-see-also-para op="ContainsUndefinedContinueTarget"></emu-see-also-para>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of the first |Statement| with arguments _iterationSet_ and &laquo; &raquo;.
        1. If _hasUndefinedLabels_ is *true*, return *true*.
        1. Return ContainsUndefinedContinueTarget of the second |Statement| with arguments _iterationSet_ and &laquo; &raquo;.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and &laquo; &raquo;.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-if-statement-static-semantics-vardeclarednames">
      <h1>Static Semantics: VarDeclaredNames</h1>
      <emu-see-also-para op="VarDeclaredNames"></emu-see-also-para>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. Let _names_ be VarDeclaredNames of the first |Statement|.
        1. Append to _names_ the elements of the VarDeclaredNames of the second |Statement|.
        1. Return _names_.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Return the VarDeclaredNames of |Statement|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-if-statement-static-semantics-varscopeddeclarations">
      <h1>Static Semantics: VarScopedDeclarations</h1>
      <emu-see-also-para op="VarScopedDeclarations"></emu-see-also-para>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. Let _declarations_ be VarScopedDeclarations of the first |Statement|.
        1. Append to _declarations_ the elements of the VarScopedDeclarations of the second |Statement|.
        1. Return _declarations_.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Return the VarScopedDeclarations of |Statement|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-if-statement-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be the result of evaluating |Expression|.
        1. Let _exprValue_ be ToBoolean(? GetValue(_exprRef_)).
        1. If _exprValue_ is *true*, then
          1. Let _stmtCompletion_ be the result of evaluating the first |Statement|.
        1. Else,
          1. Let _stmtCompletion_ be the result of evaluating the second |Statement|.
        1. Return Completion(UpdateEmpty(_stmtCompletion_, *undefined*)).
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be the result of evaluating |Expression|.
        1. Let _exprValue_ be ToBoolean(? GetValue(_exprRef_)).
        1. If _exprValue_ is *false*, then
          1. Return NormalCompletion(*undefined*).
        1. Else,
          1. Let _stmtCompletion_ be the result of evaluating |Statement|.
          1. Return Completion(UpdateEmpty(_stmtCompletion_, *undefined*)).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-iteration-statements">
    <h1>Iteration Statements</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      IterationStatement[Yield, Await, Return] :
        `do` Statement[?Yield, ?Await, ?Return] `while` `(` Expression[+In, ?Yield, ?Await] `)` `;`
        `while` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
        `for` `(` [lookahead != `let` `[`] Expression[~In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `)` Statement[?Yield, ?Await, ?Return]
        `for` `(` `var` VariableDeclarationList[~In, ?Yield, ?Await] `;` Expression[+In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `)` Statement[?Yield, ?Await, ?Return]
        `for` `(` LexicalDeclaration[~In, ?Yield, ?Await] Expression[+In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `)` Statement[?Yield, ?Await, ?Return]
        `for` `(` [lookahead != `let` `[`] LeftHandSideExpression[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
        `for` `(` `var` ForBinding[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
        `for` `(` ForDeclaration[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
        `for` `(` [lookahead != `let` ] LeftHandSideExpression[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
        `for` `(` `var` ForBinding[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
        `for` `(` ForDeclaration[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
        [+Await] `for` `await` `(` [lookahead != `let` ] LeftHandSideExpression[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
        [+Await] `for` `await` `(` `var` ForBinding[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
        [+Await] `for` `await` `(` ForDeclaration[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]

      ForDeclaration[Yield, Await] :
        LetOrConst ForBinding[?Yield, ?Await]

      ForBinding[Yield, Await] :
        BindingIdentifier[?Yield, ?Await]
        BindingPattern[?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>This section is extended by Annex <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref>.</p>
    </emu-note>

    <emu-clause id="sec-iteration-statements-semantics">
      <h1>Semantics</h1>

      <emu-clause id="sec-semantics-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>
          IterationStatement :
            `do` Statement `while` `(` Expression `)` `;`
            `while` `(` Expression `)` Statement
            `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
            `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
            `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
            `for` `(` LeftHandSideExpression `in` Expression `)` Statement
            `for` `(` `var` ForBinding `in` Expression `)` Statement
            `for` `(` ForDeclaration `in` Expression `)` Statement
            `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
            `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
            `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
            `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.
          </li>
        </ul>
        <emu-note>
          <p>It is only necessary to apply this rule if the extension specified in <emu-xref href="#sec-labelled-function-declarations"></emu-xref> is implemented.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-loopcontinues" aoid="LoopContinues">
        <h1>Runtime Semantics: LoopContinues ( _completion_, _labelSet_ )</h1>
        <p>The abstract operation LoopContinues with arguments _completion_ and _labelSet_ is defined by the following steps:</p>
        <emu-alg>
          1. If _completion_.[[Type]] is ~normal~, return *true*.
          1. If _completion_.[[Type]] is not ~continue~, return *false*.
          1. If _completion_.[[Target]] is ~empty~, return *true*.
          1. If _completion_.[[Target]] is an element of _labelSet_, return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>Within the |Statement| part of an |IterationStatement| a |ContinueStatement| may be used to begin a new iteration.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-do-while-statement">
      <h1>The `do`-`while` Statement</h1>

      <emu-clause id="sec-do-while-statement-static-semantics-containsduplicatelabels">
        <h1>Static Semantics: ContainsDuplicateLabels</h1>
        <p>With parameter _labelSet_.</p>
        <emu-see-also-para op="ContainsDuplicateLabels"></emu-see-also-para>
        <emu-grammar>IterationStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
        <emu-alg>
          1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-do-while-statement-static-semantics-containsundefinedbreaktarget">
        <h1>Static Semantics: ContainsUndefinedBreakTarget</h1>
        <p>With parameter _labelSet_.</p>
        <emu-see-also-para op="ContainsUndefinedBreakTarget"></emu-see-also-para>
        <emu-grammar>IterationStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
        <emu-alg>
          1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-do-while-statement-static-semantics-containsundefinedcontinuetarget">
        <h1>Static Semantics: ContainsUndefinedContinueTarget</h1>
        <p>With parameters _iterationSet_ and _labelSet_.</p>
        <emu-see-also-para op="ContainsUndefinedContinueTarget"></emu-see-also-para>
        <emu-grammar>IterationStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
        <emu-alg>
          1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and &laquo; &raquo;.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-do-while-statement-static-semantics-vardeclarednames">
        <h1>Static Semantics: VarDeclaredNames</h1>
        <emu-see-also-para op="VarDeclaredNames"></emu-see-also-para>
        <emu-grammar>IterationStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
        <emu-alg>
          1. Return the VarDeclaredNames of |Statement|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-do-while-statement-static-semantics-varscopeddeclarations">
        <h1>Static Semantics: VarScopedDeclarations</h1>
        <emu-see-also-para op="VarScopedDeclarations"></emu-see-also-para>
        <emu-grammar>IterationStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
        <emu-alg>
          1. Return the VarScopedDeclarations of |Statement|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-do-while-statement-runtime-semantics-labelledevaluation">
        <h1>Runtime Semantics: LabelledEvaluation</h1>
        <p>With parameter _labelSet_.</p>
        <emu-see-also-para op="LabelledEvaluation"></emu-see-also-para>
        <emu-grammar>IterationStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
        <emu-alg>
          1. Let _V_ be *undefined*.
          1. Repeat,
            1. Let _stmtResult_ be the result of evaluating |Statement|.
            1. If LoopContinues(_stmtResult_, _labelSet_) is *false*, return Completion(UpdateEmpty(_stmtResult_, _V_)).
            1. If _stmtResult_.[[Value]] is not ~empty~, set _V_ to _stmtResult_.[[Value]].
            1. Let _exprRef_ be the result of evaluating |Expression|.
            1. Let _exprValue_ be ? GetValue(_exprRef_).
            1. If ToBoolean(_exprValue_) is *false*, return NormalCompletion(_V_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-while-statement">
      <h1>The `while` Statement</h1>

      <emu-clause id="sec-while-statement-static-semantics-containsduplicatelabels">
        <h1>Static Semantics: ContainsDuplicateLabels</h1>
        <p>With parameter _labelSet_.</p>
        <emu-see-also-para op="ContainsDuplicateLabels"></emu-see-also-para>
        <emu-grammar>IterationStatement : `while` `(` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-while-statement-static-semantics-containsundefinedbreaktarget">
        <h1>Static Semantics: ContainsUndefinedBreakTarget</h1>
        <p>With parameter _labelSet_.</p>
        <emu-see-also-para op="ContainsUndefinedBreakTarget"></emu-see-also-para>
        <emu-grammar>IterationStatement : `while` `(` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-while-statement-static-semantics-containsundefinedcontinuetarget">
        <h1>Static Semantics: ContainsUndefinedContinueTarget</h1>
        <p>With parameters _iterationSet_ and _labelSet_.</p>
        <emu-see-also-para op="ContainsUndefinedContinueTarget"></emu-see-also-para>
        <emu-grammar>IterationStatement : `while` `(` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and &laquo; &raquo;.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-while-statement-static-semantics-vardeclarednames">
        <h1>Static Semantics: VarDeclaredNames</h1>
        <emu-see-also-para op="VarDeclaredNames"></emu-see-also-para>
        <emu-grammar>IterationStatement : `while` `(` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. Return the VarDeclaredNames of |Statement|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-while-statement-static-semantics-varscopeddeclarations">
        <h1>Static Semantics: VarScopedDeclarations</h1>
        <emu-see-also-para op="VarScopedDeclarations"></emu-see-also-para>
        <emu-grammar>IterationStatement : `while` `(` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. Return the VarScopedDeclarations of |Statement|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-while-statement-runtime-semantics-labelledevaluation">
        <h1>Runtime Semantics: LabelledEvaluation</h1>
        <p>With parameter _labelSet_.</p>
        <emu-see-also-para op="LabelledEvaluation"></emu-see-also-para>
        <emu-grammar>IterationStatement : `while` `(` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _V_ be *undefined*.
          1. Repeat,
            1. Let _exprRef_ be the result of evaluating |Expression|.
            1. Let _exprValue_ be ? GetValue(_exprRef_).
            1. If ToBoolean(_exprValue_) is *false*, return NormalCompletion(_V_).
            1. Let _stmtResult_ be the result of evaluating |Statement|.
            1. If LoopContinues(_stmtResult_, _labelSet_) is *false*, return Completion(UpdateEmpty(_stmtResult_, _V_)).
            1. If _stmtResult_.[[Value]] is not ~empty~, set _V_ to _stmtResult_.[[Value]].
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-for-statement">
      <h1>The `for` Statement</h1>

      <emu-clause id="sec-for-statement-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>IterationStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if any element of the BoundNames of |LexicalDeclaration| also occurs in the VarDeclaredNames of |Statement|.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-for-statement-static-semantics-containsduplicatelabels">
        <h1>Static Semantics: ContainsDuplicateLabels</h1>
        <p>With parameter _labelSet_.</p>
        <emu-see-also-para op="ContainsDuplicateLabels"></emu-see-also-para>
        <emu-grammar>
          IterationStatement :
            `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
            `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
            `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
        </emu-grammar>
        <emu-alg>
          1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-for-statement-static-semantics-containsundefinedbreaktarget">
        <h1>Static Semantics: ContainsUndefinedBreakTarget</h1>
        <p>With parameter _labelSet_.</p>
        <emu-see-also-para op="ContainsUndefinedBreakTarget"></emu-see-also-para>
        <emu-grammar>
          IterationStatement :
            `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
            `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
            `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
        </emu-grammar>
        <emu-alg>
          1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-for-statement-static-semantics-containsundefinedcontinuetarget">
        <h1>Static Semantics: ContainsUndefinedContinueTarget</h1>
        <p>With parameters _iterationSet_ and _labelSet_.</p>
        <emu-see-also-para op="ContainsUndefinedContinueTarget"></emu-see-also-para>
        <emu-grammar>
          IterationStatement :
            `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
            `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
            `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
        </emu-grammar>
        <emu-alg>
          1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and &laquo; &raquo;.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-for-statement-static-semantics-vardeclarednames">
        <h1>Static Semantics: VarDeclaredNames</h1>
        <emu-see-also-para op="VarDeclaredNames"></emu-see-also-para>
        <emu-grammar>IterationStatement : `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. Return the VarDeclaredNames of |Statement|.
        </emu-alg>
        <emu-grammar>IterationStatement : `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _names_ be BoundNames of |VariableDeclarationList|.
          1. Append to _names_ the elements of the VarDeclaredNames of |Statement|.
          1. Return _names_.
        </emu-alg>
        <emu-grammar>IterationStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. Return the VarDeclaredNames of |Statement|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-for-statement-static-semantics-varscopeddeclarations">
        <h1>Static Semantics: VarScopedDeclarations</h1>
        <emu-see-also-para op="VarScopedDeclarations"></emu-see-also-para>
        <emu-grammar>IterationStatement : `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. Return the VarScopedDeclarations of |Statement|.
        </emu-alg>
        <emu-grammar>IterationStatement : `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _declarations_ be VarScopedDeclarations of |VariableDeclarationList|.
          1. Append to _declarations_ the elements of the VarScopedDeclarations of |Statement|.
          1. Return _declarations_.
        </emu-alg>
        <emu-grammar>IterationStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. Return the VarScopedDeclarations of |Statement|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-for-statement-runtime-semantics-labelledevaluation">
        <h1>Runtime Semantics: LabelledEvaluation</h1>
        <p>With parameter _labelSet_.</p>
        <emu-see-also-para op="LabelledEvaluation"></emu-see-also-para>
        <emu-grammar>IterationStatement : `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. If the first |Expression| is present, then
            1. Let _exprRef_ be the result of evaluating the first |Expression|.
            1. Perform ? GetValue(_exprRef_).
          1. Return ? ForBodyEvaluation(the second |Expression|, the third |Expression|, |Statement|, &laquo; &raquo;, _labelSet_).
        </emu-alg>
        <emu-grammar>IterationStatement : `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _varDcl_ be the result of evaluating |VariableDeclarationList|.
          1. ReturnIfAbrupt(_varDcl_).
          1. Return ? ForBodyEvaluation(the first |Expression|, the second |Expression|, |Statement|, &laquo; &raquo;, _labelSet_).
        </emu-alg>
        <emu-grammar>IterationStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
          1. Let _loopEnv_ be NewDeclarativeEnvironment(_oldEnv_).
          1. Let _loopEnvRec_ be _loopEnv_'s EnvironmentRecord.
          1. Let _isConst_ be the result of performing IsConstantDeclaration of |LexicalDeclaration|.
          1. Let _boundNames_ be the BoundNames of |LexicalDeclaration|.
          1. For each element _dn_ of _boundNames_, do
            1. If _isConst_ is *true*, then
              1. Perform ! _loopEnvRec_.CreateImmutableBinding(_dn_, *true*).
            1. Else,
              1. Perform ! _loopEnvRec_.CreateMutableBinding(_dn_, *false*).
          1. Set the running execution context's LexicalEnvironment to _loopEnv_.
          1. Let _forDcl_ be the result of evaluating |LexicalDeclaration|.
          1. If _forDcl_ is an abrupt completion, then
            1. Set the running execution context's LexicalEnvironment to _oldEnv_.
            1. Return Completion(_forDcl_).
          1. If _isConst_ is *false*, let _perIterationLets_ be _boundNames_; otherwise let _perIterationLets_ be &laquo; &raquo;.
          1. Let _bodyResult_ be ForBodyEvaluation(the first |Expression|, the second |Expression|, |Statement|, _perIterationLets_, _labelSet_).
          1. Set the running execution context's LexicalEnvironment to _oldEnv_.
          1. Return Completion(_bodyResult_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-forbodyevaluation" aoid="ForBodyEvaluation">
        <h1>Runtime Semantics: ForBodyEvaluation ( _test_, _increment_, _stmt_, _perIterationBindings_, _labelSet_ )</h1>
        <p>The abstract operation ForBodyEvaluation with arguments _test_, _increment_, _stmt_, _perIterationBindings_, and _labelSet_ is performed as follows:</p>
        <emu-alg>
          1. Let _V_ be *undefined*.
          1. Perform ? CreatePerIterationEnvironment(_perIterationBindings_).
          1. Repeat,
            1. If _test_ is not ~[empty]~, then
              1. Let _testRef_ be the result of evaluating _test_.
              1. Let _testValue_ be ? GetValue(_testRef_).
              1. If ToBoolean(_testValue_) is *false*, return NormalCompletion(_V_).
            1. Let _result_ be the result of evaluating _stmt_.
            1. If LoopContinues(_result_, _labelSet_) is *false*, return Completion(UpdateEmpty(_result_, _V_)).
            1. If _result_.[[Value]] is not ~empty~, set _V_ to _result_.[[Value]].
            1. Perform ? CreatePerIterationEnvironment(_perIterationBindings_).
            1. If _increment_ is not ~[empty]~, then
              1. Let _incRef_ be the result of evaluating _increment_.
              1. Perform ? GetValue(_incRef_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createperiterationenvironment" aoid="CreatePerIterationEnvironment">
        <h1>Runtime Semantics: CreatePerIterationEnvironment ( _perIterationBindings_ )</h1>
        <p>The abstract operation CreatePerIterationEnvironment with argument _perIterationBindings_ is performed as follows:</p>
        <emu-alg>
          1. If _perIterationBindings_ has any elements, then
            1. Let _lastIterationEnv_ be the running execution context's LexicalEnvironment.
            1. Let _lastIterationEnvRec_ be _lastIterationEnv_'s EnvironmentRecord.
            1. Let _outer_ be _lastIterationEnv_'s outer environment reference.
            1. Assert: _outer_ is not *null*.
            1. Let _thisIterationEnv_ be NewDeclarativeEnvironment(_outer_).
            1. Let _thisIterationEnvRec_ be _thisIterationEnv_'s EnvironmentRecord.
            1. For each element _bn_ of _perIterationBindings_, do
              1. Perform ! _thisIterationEnvRec_.CreateMutableBinding(_bn_, *false*).
              1. Let _lastValue_ be ? _lastIterationEnvRec_.GetBindingValue(_bn_, *true*).
              1. Perform _thisIterationEnvRec_.InitializeBinding(_bn_, _lastValue_).
            1. Set the running execution context's LexicalEnvironment to _thisIterationEnv_.
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-for-in-and-for-of-statements">
      <h1>The `for`-`in`, `for`-`of`, and `for`-`await`-`of` Statements</h1>

      <emu-clause id="sec-for-in-and-for-of-statements-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>
          IterationStatement :
            `for` `(` LeftHandSideExpression `in` Expression `)` Statement
            `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if |LeftHandSideExpression| is either an |ObjectLiteral| or an |ArrayLiteral| and if |LeftHandSideExpression| is not covering an |AssignmentPattern|.
          </li>
        </ul>
        <p>If |LeftHandSideExpression| is either an |ObjectLiteral| or an |ArrayLiteral| and if |LeftHandSideExpression| is covering an |AssignmentPattern| then the following rules are not applied. Instead, the Early Error rules for |AssignmentPattern| are used.</p>
        <ul>
          <li>
            It is a Syntax Error if AssignmentTargetType of |LeftHandSideExpression| is not ~simple~.
          </li>
          <li>
            It is a Syntax Error if the |LeftHandSideExpression| is <emu-grammar>CoverParenthesizedExpressionAndArrowParameterList : `(` Expression `)`</emu-grammar> and |Expression| derives a phrase that would produce a Syntax Error according to these rules if that phrase were substituted for |LeftHandSideExpression|. This rule is recursively applied.
          </li>
        </ul>
        <emu-note>
          <p>The last rule means that the other rules are applied even if parentheses surround |Expression|.</p>
        </emu-note>
        <emu-grammar>
          IterationStatement :
            `for` `(` ForDeclaration `in` Expression `)` Statement
            `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
            `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the BoundNames of |ForDeclaration| contains `"let"`.
          </li>
          <li>
            It is a Syntax Error if any element of the BoundNames of |ForDeclaration| also occurs in the VarDeclaredNames of |Statement|.
          </li>
          <li>
            It is a Syntax Error if the BoundNames of |ForDeclaration| contains any duplicate entries.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-for-in-and-for-of-statements-static-semantics-boundnames">
        <h1>Static Semantics: BoundNames</h1>
        <emu-see-also-para op="BoundNames"></emu-see-also-para>
        <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |ForBinding|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-for-in-and-for-of-statements-static-semantics-containsduplicatelabels">
        <h1>Static Semantics: ContainsDuplicateLabels</h1>
        <p>With parameter _labelSet_.</p>
        <emu-see-also-para op="ContainsDuplicateLabels"></emu-see-also-para>
        <emu-grammar>
          IterationStatement :
            `for` `(` LeftHandSideExpression `in` Expression `)` Statement
            `for` `(` `var` ForBinding `in` Expression `)` Statement
            `for` `(` ForDeclaration `in` Expression `)` Statement
            `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
            `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
            `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
            `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement

        </emu-grammar>
        <emu-alg>
          1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.
        </emu-alg>
        <emu-note>
          <p>This section is extended by Annex <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref>.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-for-in-and-for-of-statements-static-semantics-containsundefinedbreaktarget">
        <h1>Static Semantics: ContainsUndefinedBreakTarget</h1>
        <p>With parameter _labelSet_.</p>
        <emu-see-also-para op="ContainsUndefinedBreakTarget"></emu-see-also-para>
        <emu-grammar>
          IterationStatement :
            `for` `(` LeftHandSideExpression `in` Expression `)` Statement
            `for` `(` `var` ForBinding `in` Expression `)` Statement
            `for` `(` ForDeclaration `in` Expression `)` Statement
            `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
            `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
            `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
            `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.
        </emu-alg>
        <emu-note>
          <p>This section is extended by Annex <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref>.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-for-in-and-for-of-statements-static-semantics-containsundefinedcontinuetarget">
        <h1>Static Semantics: ContainsUndefinedContinueTarget</h1>
        <p>With parameters _iterationSet_ and _labelSet_.</p>
        <emu-see-also-para op="ContainsUndefinedContinueTarget"></emu-see-also-para>
        <emu-grammar>
          IterationStatement :
            `for` `(` LeftHandSideExpression `in` Expression `)` Statement
            `for` `(` `var` ForBinding `in` Expression `)` Statement
            `for` `(` ForDeclaration `in` Expression `)` Statement
            `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
            `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
            `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
            `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and &laquo; &raquo;.
        </emu-alg>
        <emu-note>
          <p>This section is extended by Annex <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref>.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-for-in-and-for-of-statements-static-semantics-isdestructuring">
        <h1>Static Semantics: IsDestructuring</h1>
        <emu-see-also-para op="IsDestructuring"></emu-see-also-para>
        <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
        <emu-alg>
          1. Return IsDestructuring of |ForBinding|.
        </emu-alg>
        <emu-grammar>ForBinding : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>ForBinding : BindingPattern</emu-grammar>
        <emu-alg>
          1. Return *true*.
        </emu-alg>
        <emu-note>
          <p>This section is extended by Annex <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref>.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-for-in-and-for-of-statements-static-semantics-vardeclarednames">
        <h1>Static Semantics: VarDeclaredNames</h1>
        <emu-see-also-para op="VarDeclaredNames"></emu-see-also-para>
        <emu-grammar>IterationStatement : `for` `(` LeftHandSideExpression `in` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. Return the VarDeclaredNames of |Statement|.
        </emu-alg>
        <emu-grammar>IterationStatement : `for` `(` `var` ForBinding `in` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _names_ be the BoundNames of |ForBinding|.
          1. Append to _names_ the elements of the VarDeclaredNames of |Statement|.
          1. Return _names_.
        </emu-alg>
        <emu-grammar>IterationStatement : `for` `(` ForDeclaration `in` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. Return the VarDeclaredNames of |Statement|.
        </emu-alg>
        <emu-grammar>
          IterationStatement :
            `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. Return the VarDeclaredNames of |Statement|.
        </emu-alg>
        <emu-grammar>
          IterationStatement :
            `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
            `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. Let _names_ be the BoundNames of |ForBinding|.
          1. Append to _names_ the elements of the VarDeclaredNames of |Statement|.
          1. Return _names_.
        </emu-alg>
        <emu-grammar>
          IterationStatement :
            `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
            `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. Return the VarDeclaredNames of |Statement|.
        </emu-alg>
        <emu-note>
          <p>This section is extended by Annex <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref>.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-for-in-and-for-of-statements-static-semantics-varscopeddeclarations">
        <h1>Static Semantics: VarScopedDeclarations</h1>
        <emu-see-also-para op="VarScopedDeclarations"></emu-see-also-para>
        <emu-grammar>IterationStatement : `for` `(` LeftHandSideExpression `in` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. Return the VarScopedDeclarations of |Statement|.
        </emu-alg>
        <emu-grammar>IterationStatement : `for` `(` `var` ForBinding `in` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _declarations_ be a List containing |ForBinding|.
          1. Append to _declarations_ the elements of the VarScopedDeclarations of |Statement|.
          1. Return _declarations_.
        </emu-alg>
        <emu-grammar>
          IterationStatement :
            `for` `(` ForDeclaration `in` Expression `)` Statement
            `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. Return the VarScopedDeclarations of |Statement|.
        </emu-alg>
        <emu-grammar>
          IterationStatement :
            `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. Return the VarScopedDeclarations of |Statement|.
        </emu-alg>
        <emu-grammar>
          IterationStatement :
            `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
            `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. Let _declarations_ be a List containing |ForBinding|.
          1. Append to _declarations_ the elements of the VarScopedDeclarations of |Statement|.
          1. Return _declarations_.
        </emu-alg>
        <emu-grammar>
          IterationStatement :
            `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
            `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. Return the VarScopedDeclarations of |Statement|.
        </emu-alg>
        <emu-note>
          <p>This section is extended by Annex <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref>.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-for-in-and-for-of-statements-runtime-semantics-bindinginitialization">
        <h1>Runtime Semantics: BindingInitialization</h1>
        <p>With parameters _value_ and _environment_.</p>
        <emu-see-also-para op="BindingInitialization"></emu-see-also-para>
        <emu-note>
          <p>*undefined* is passed for _environment_ to indicate that a PutValue operation should be used to assign the initialization value. This is the case for `var` statements and the formal parameter lists of some non-strict functions (see <emu-xref href="#sec-functiondeclarationinstantiation"></emu-xref>). In those cases a lexical binding is hoisted and preinitialized prior to evaluation of its initializer.</p>
        </emu-note>
        <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
        <emu-alg>
          1. Return the result of performing BindingInitialization for |ForBinding| passing _value_ and _environment_ as the arguments.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-bindinginstantiation">
        <h1>Runtime Semantics: BindingInstantiation</h1>
        <p>With parameter _environment_.</p>
        <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
        <emu-alg>
          1. Let _envRec_ be _environment_'s EnvironmentRecord.
          1. Assert: _envRec_ is a declarative Environment Record.
          1. For each element _name_ of the BoundNames of |ForBinding|, do
            1. If IsConstantDeclaration of |LetOrConst| is *true*, then
              1. Perform ! _envRec_.CreateImmutableBinding(_name_, *true*).
            1. Else,
              1. Perform ! _envRec_.CreateMutableBinding(_name_, *false*).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-for-in-and-for-of-statements-runtime-semantics-labelledevaluation">
        <h1>Runtime Semantics: LabelledEvaluation</h1>
        <p>With parameter _labelSet_.</p>
        <emu-see-also-para op="LabelledEvaluation"></emu-see-also-para>
        <emu-grammar>IterationStatement : `for` `(` LeftHandSideExpression `in` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(&laquo; &raquo;, |Expression|, ~enumerate~).
          1. Return ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~enumerate~, ~assignment~, _labelSet_).
        </emu-alg>
        <emu-grammar>IterationStatement : `for` `(` `var` ForBinding `in` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(&laquo; &raquo;, |Expression|, ~enumerate~).
          1. Return ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~enumerate~, ~varBinding~, _labelSet_).
        </emu-alg>
        <emu-grammar>IterationStatement : `for` `(` ForDeclaration `in` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |Expression|, ~enumerate~).
          1. Return ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~enumerate~, ~lexicalBinding~, _labelSet_).
        </emu-alg>
        <emu-grammar>IterationStatement : `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(&laquo; &raquo;, |AssignmentExpression|, ~iterate~).
          1. Return ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~iterate~, ~assignment~, _labelSet_).
        </emu-alg>
        <emu-grammar>IterationStatement : `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(&laquo; &raquo;, |AssignmentExpression|, ~iterate~).
          1. Return ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~iterate~, ~varBinding~, _labelSet_).
        </emu-alg>
        <emu-grammar>IterationStatement : `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |AssignmentExpression|, ~iterate~).
          1. Return ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~iterate~, ~lexicalBinding~, _labelSet_).
        </emu-alg>
        <emu-grammar>
          IterationStatement : `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(&laquo; &raquo;, |AssignmentExpression|, ~async-iterate~).
          1. Return ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~iterate~, ~assignment~, _labelSet_, ~async~).
        </emu-alg>
        <emu-grammar>
          IterationStatement : `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(&laquo; &raquo;, |AssignmentExpression|, ~async-iterate~).
          1. Return ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~iterate~, ~varBinding~, _labelSet_, ~async~).
        </emu-alg>
        <emu-grammar>
          IterationStatement : `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |AssignmentExpression|, ~async-iterate~).
          1. Return ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~iterate~, ~lexicalBinding~, _labelSet_, ~async~).
        </emu-alg>
        <emu-note>
          <p>This section is extended by Annex <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref>.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind" aoid="ForIn/OfHeadEvaluation">
        <h1>Runtime Semantics: ForIn/OfHeadEvaluation ( _TDZnames_, _expr_, _iterationKind_ )</h1>
        <p>The abstract operation ForIn/OfHeadEvaluation is called with arguments _TDZnames_, _expr_, and _iterationKind_. The value of _iterationKind_ is either ~enumerate~, ~iterate~, or ~async-iterate~.</p>
        <emu-alg>
          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
          1. If _TDZnames_ is not an empty List, then
            1. Assert: _TDZnames_ has no duplicate entries.
            1. Let _TDZ_ be NewDeclarativeEnvironment(_oldEnv_).
            1. Let _TDZEnvRec_ be _TDZ_'s EnvironmentRecord.
            1. For each string _name_ in _TDZnames_, do
              1. Perform ! _TDZEnvRec_.CreateMutableBinding(_name_, *false*).
            1. Set the running execution context's LexicalEnvironment to _TDZ_.
          1. Let _exprRef_ be the result of evaluating _expr_.
          1. Set the running execution context's LexicalEnvironment to _oldEnv_.
          1. Let _exprValue_ be ? GetValue(_exprRef_).
          1. If _iterationKind_ is ~enumerate~, then
            1. If _exprValue_ is *undefined* or *null*, then
              1. Return Completion { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: ~empty~ }.
            1. Let _obj_ be ! ToObject(_exprValue_).
            1. Return ? EnumerateObjectProperties(_obj_).
          1. Else,
            1. Assert: _iterationKind_ is ~iterate~.
            1. If _iterationKind_ is ~async-iterate~, let _iteratorHint_ be ~async~.
            1. Else, let _iteratorHint_ be ~sync~.
            1. Return ? GetIterator(_exprValue_, _iteratorHint_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset" aoid="ForIn/OfBodyEvaluation">
        <h1>Runtime Semantics: ForIn/OfBodyEvaluation ( _lhs_, _stmt_, _iteratorRecord_, _iterationKind_, _lhsKind_, _labelSet_ [ , _iteratorKind_ ] )</h1>
        <p>The abstract operation ForIn/OfBodyEvaluation is called with arguments _lhs_, _stmt_, _iteratorRecord_, _iterationKind_, _lhsKind_, _labelSet_, and optional argument _iteratorKind_. The value of _lhsKind_ is either ~assignment~, ~varBinding~ or ~lexicalBinding~. The value of _iteratorKind_ is either ~sync~ or ~async~.</p>
        <emu-alg>
          1. If _iteratorKind_ is not present, set _iteratorKind_ to ~sync~.
          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
          1. Let _V_ be *undefined*.
          1. Let _destructuring_ be IsDestructuring of _lhs_.
          1. If _destructuring_ is *true* and if _lhsKind_ is ~assignment~, then
            1. Assert: _lhs_ is a |LeftHandSideExpression|.
            1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by _lhs_.
          1. Repeat,
            1. Let _nextResult_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]]).
            1. If _iteratorKind_ is ~async~, then set _nextResult_ to ? Await(_nextResult_).
            1. If Type(_nextResult_) is not Object, throw a *TypeError* exception.
            1. Let _done_ be ? IteratorComplete(_nextResult_).
            1. If _done_ is *true*, return NormalCompletion(_V_).
            1. Let _nextValue_ be ? IteratorValue(_nextResult_).
            1. If _lhsKind_ is either ~assignment~ or ~varBinding~, then
              1. If _destructuring_ is *false*, then
                1. Let _lhsRef_ be the result of evaluating _lhs_. (It may be evaluated repeatedly.)
            1. Else,
              1. Assert: _lhsKind_ is ~lexicalBinding~.
              1. Assert: _lhs_ is a |ForDeclaration|.
              1. Let _iterationEnv_ be NewDeclarativeEnvironment(_oldEnv_).
              1. Perform BindingInstantiation for _lhs_ passing _iterationEnv_ as the argument.
              1. Set the running execution context's LexicalEnvironment to _iterationEnv_.
              1. If _destructuring_ is *false*, then
                1. Assert: _lhs_ binds a single name.
                1. Let _lhsName_ be the sole element of BoundNames of _lhs_.
                1. Let _lhsRef_ be ! ResolveBinding(_lhsName_).
            1. If _destructuring_ is *false*, then
              1. If _lhsRef_ is an abrupt completion, then
                1. Let _status_ be _lhsRef_.
              1. Else if _lhsKind_ is ~lexicalBinding~, then
                1. Let _status_ be InitializeReferencedBinding(_lhsRef_, _nextValue_).
              1. Else,
                1. Let _status_ be PutValue(_lhsRef_, _nextValue_).
            1. Else,
              1. If _lhsKind_ is ~assignment~, then
                1. Let _status_ be the result of performing DestructuringAssignmentEvaluation of _assignmentPattern_ using _nextValue_ as the argument.
              1. Else if _lhsKind_ is ~varBinding~, then
                1. Assert: _lhs_ is a |ForBinding|.
                1. Let _status_ be the result of performing BindingInitialization for _lhs_ passing _nextValue_ and *undefined* as the arguments.
              1. Else,
                1. Assert: _lhsKind_ is ~lexicalBinding~.
                1. Assert: _lhs_ is a |ForDeclaration|.
                1. Let _status_ be the result of performing BindingInitialization for _lhs_ passing _nextValue_ and _iterationEnv_ as arguments.
            1. If _status_ is an abrupt completion, then
              1. Set the running execution context's LexicalEnvironment to _oldEnv_.
              1. If _iteratorKind_ is ~async~, return ? AsyncIteratorClose(_iteratorRecord_, _status_).
              1. If _iterationKind_ is ~enumerate~, then
                1. Return _status_.
              1. Else,
                1. Assert: _iterationKind_ is ~iterate~.
                1. Return ? IteratorClose(_iteratorRecord_, _status_).
            1. Let _result_ be the result of evaluating _stmt_.
            1. Set the running execution context's LexicalEnvironment to _oldEnv_.
            1. If LoopContinues(_result_, _labelSet_) is *false*, then
              1. If _iterationKind_ is ~enumerate~, then
                1. Return Completion(UpdateEmpty(_result_, _V_)).
              1. Else,
                1. Assert: _iterationKind_ is ~iterate~.
                1. Set _status_ to UpdateEmpty(_result_, _V_).
                1. If _iteratorKind_ is ~async~, return ? AsyncIteratorClose(_iteratorRecord_, _status_).
                1. Return ? IteratorClose(_iteratorRecord_, _status_).
            1. If _result_.[[Value]] is not ~empty~, set _V_ to _result_.[[Value]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-for-in-and-for-of-statements-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>ForBinding : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. Let _bindingId_ be StringValue of |BindingIdentifier|.
          1. Return ? ResolveBinding(_bindingId_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-enumerate-object-properties" aoid="EnumerateObjectProperties">
        <h1>EnumerateObjectProperties ( _O_ )</h1>
        <p>When the abstract operation EnumerateObjectProperties is called with argument _O_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: Type(_O_) is Object.
          1. Return an Iterator object (<emu-xref href="#sec-iterator-interface"></emu-xref>) whose `next` method iterates over all the String-valued keys of enumerable properties of _O_. The iterator object is never directly accessible to ECMAScript code. The mechanics and order of enumerating the properties is not specified but must conform to the rules specified below.
        </emu-alg>
        <p>The iterator's `throw` and `return` methods are *null* and are never invoked. The iterator's `next` method processes object properties to determine whether the property key should be returned as an iterator value. Returned property keys do not include keys that are Symbols. Properties of the target object may be deleted during enumeration. A property that is deleted before it is processed by the iterator's `next` method is ignored. If new properties are added to the target object during enumeration, the newly added properties are not guaranteed to be processed in the active enumeration. A property name will be returned by the iterator's `next` method at most once in any enumeration.</p>
        <p>Enumerating the properties of the target object includes enumerating properties of its prototype, and the prototype of the prototype, and so on, recursively; but a property of a prototype is not processed if it has the same name as a property that has already been processed by the iterator's `next` method. The values of [[Enumerable]] attributes are not considered when determining if a property of a prototype object has already been processed. The enumerable property names of prototype objects must be obtained by invoking EnumerateObjectProperties passing the prototype object as the argument. EnumerateObjectProperties must obtain the own property keys of the target object by calling its [[OwnPropertyKeys]] internal method. Property attributes of the target object must be obtained by calling its [[GetOwnProperty]] internal method.</p>
        <emu-note>
          <p>The following is an informative definition of an ECMAScript generator function that conforms to these rules:</p>
          <pre><code class="javascript">
            function* EnumerateObjectProperties(obj) {
              const visited = new Set();
              for (const key of Reflect.ownKeys(obj)) {
                if (typeof key === "symbol") continue;
                const desc = Reflect.getOwnPropertyDescriptor(obj, key);
                if (desc) {
                  visited.add(key);
                  if (desc.enumerable) yield key;
                }
              }
              const proto = Reflect.getPrototypeOf(obj);
              if (proto === null) return;
              for (const protoKey of EnumerateObjectProperties(proto)) {
                if (!visited.has(protoKey)) yield protoKey;
              }
            }
          </code></pre>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-continue-statement">
    <h1>The `continue` Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ContinueStatement[Yield, Await] :
        `continue` `;`
        `continue` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`
    </emu-grammar>

    <emu-clause id="sec-continue-statement-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>
        ContinueStatement : `continue` `;`

        ContinueStatement : `continue` LabelIdentifier `;`
      </emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if this |ContinueStatement| is not nested, directly or indirectly (but not crossing function boundaries), within an |IterationStatement|.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-continue-statement-static-semantics-containsundefinedcontinuetarget">
      <h1>Static Semantics: ContainsUndefinedContinueTarget</h1>
      <p>With parameters _iterationSet_ and _labelSet_.</p>
      <emu-see-also-para op="ContainsUndefinedContinueTarget"></emu-see-also-para>
      <emu-grammar>ContinueStatement : `continue` `;`</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>ContinueStatement : `continue` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. If the StringValue of |LabelIdentifier| is not an element of _iterationSet_, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-continue-statement-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>ContinueStatement : `continue` `;`</emu-grammar>
      <emu-alg>
        1. Return Completion { [[Type]]: ~continue~, [[Value]]: ~empty~, [[Target]]: ~empty~ }.
      </emu-alg>
      <emu-grammar>ContinueStatement : `continue` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. Let _label_ be the StringValue of |LabelIdentifier|.
        1. Return Completion { [[Type]]: ~continue~, [[Value]]: ~empty~, [[Target]]: _label_ }.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-break-statement">
    <h1>The `break` Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      BreakStatement[Yield, Await] :
        `break` `;`
        `break` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`
    </emu-grammar>

    <emu-clause id="sec-break-statement-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>BreakStatement : `break` `;`</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if this |BreakStatement| is not nested, directly or indirectly (but not crossing function boundaries), within an |IterationStatement| or a |SwitchStatement|.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-break-statement-static-semantics-containsundefinedbreaktarget">
      <h1>Static Semantics: ContainsUndefinedBreakTarget</h1>
      <p>With parameter _labelSet_.</p>
      <emu-see-also-para op="ContainsUndefinedBreakTarget"></emu-see-also-para>
      <emu-grammar>BreakStatement : `break` `;`</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>BreakStatement : `break` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. If the StringValue of |LabelIdentifier| is not an element of _labelSet_, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-break-statement-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>BreakStatement : `break` `;`</emu-grammar>
      <emu-alg>
        1. Return Completion { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: ~empty~ }.
      </emu-alg>
      <emu-grammar>BreakStatement : `break` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. Let _label_ be the StringValue of |LabelIdentifier|.
        1. Return Completion { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: _label_ }.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-return-statement">
    <h1>The `return` Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ReturnStatement[Yield, Await] :
        `return` `;`
        `return` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`
    </emu-grammar>
    <emu-note>
      <p>A `return` statement causes a function to cease execution and, in most cases, returns a value to the caller. If |Expression| is omitted, the return value is *undefined*. Otherwise, the return value is the value of |Expression|. A `return` statement may not actually return a value to the caller depending on surrounding context. For example, in a `try` block, a `return` statement's completion record may be replaced with another completion record during evaluation of the `finally` block.</p>
    </emu-note>

    <emu-clause id="sec-return-statement-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>ReturnStatement : `return` `;`</emu-grammar>
      <emu-alg>
        1. Return Completion { [[Type]]: ~return~, [[Value]]: *undefined*, [[Target]]: ~empty~ }.
      </emu-alg>
      <emu-grammar>ReturnStatement : `return` Expression `;`</emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be the result of evaluating |Expression|.
        1. Let _exprValue_ be ? GetValue(_exprRef_).
        1. If ! GetGeneratorKind() is ~async~, set _exprValue_ to ? Await(_exprValue_).
        1. Return Completion { [[Type]]: ~return~, [[Value]]: _exprValue_, [[Target]]: ~empty~ }.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-with-statement">
    <h1>The `with` Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      WithStatement[Yield, Await, Return] :
        `with` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
    </emu-grammar>
    <emu-note>
      <p>The `with` statement adds an object Environment Record for a computed object to the lexical environment of the running execution context. It then executes a statement using this augmented lexical environment. Finally, it restores the original lexical environment.</p>
    </emu-note>

    <emu-clause id="sec-with-statement-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if the code that matches this production is contained in strict mode code.
        </li>
        <li>
          It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.
        </li>
      </ul>
      <emu-note>
        <p>It is only necessary to apply the second rule if the extension specified in <emu-xref href="#sec-labelled-function-declarations"></emu-xref> is implemented.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-with-statement-static-semantics-containsduplicatelabels">
      <h1>Static Semantics: ContainsDuplicateLabels</h1>
      <p>With parameter _labelSet_.</p>
      <emu-see-also-para op="ContainsDuplicateLabels"></emu-see-also-para>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-with-statement-static-semantics-containsundefinedbreaktarget">
      <h1>Static Semantics: ContainsUndefinedBreakTarget</h1>
      <p>With parameter _labelSet_.</p>
      <emu-see-also-para op="ContainsUndefinedBreakTarget"></emu-see-also-para>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-with-statement-static-semantics-containsundefinedcontinuetarget">
      <h1>Static Semantics: ContainsUndefinedContinueTarget</h1>
      <p>With parameters _iterationSet_ and _labelSet_.</p>
      <emu-see-also-para op="ContainsUndefinedContinueTarget"></emu-see-also-para>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and &laquo; &raquo;.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-with-statement-static-semantics-vardeclarednames">
      <h1>Static Semantics: VarDeclaredNames</h1>
      <emu-see-also-para op="VarDeclaredNames"></emu-see-also-para>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Return the VarDeclaredNames of |Statement|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-with-statement-static-semantics-varscopeddeclarations">
      <h1>Static Semantics: VarScopedDeclarations</h1>
      <emu-see-also-para op="VarScopedDeclarations"></emu-see-also-para>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Return the VarScopedDeclarations of |Statement|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-with-statement-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Let _val_ be the result of evaluating |Expression|.
        1. Let _obj_ be ? ToObject(? GetValue(_val_)).
        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
        1. Let _newEnv_ be NewObjectEnvironment(_obj_, _oldEnv_).
        1. Set the _withEnvironment_ flag of _newEnv_'s EnvironmentRecord to *true*.
        1. Set the running execution context's LexicalEnvironment to _newEnv_.
        1. Let _C_ be the result of evaluating |Statement|.
        1. Set the running execution context's LexicalEnvironment to _oldEnv_.
        1. Return Completion(UpdateEmpty(_C_, *undefined*)).
      </emu-alg>
      <emu-note>
        <p>No matter how control leaves the embedded |Statement|, whether normally or by some form of abrupt completion or exception, the LexicalEnvironment is always restored to its former state.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-switch-statement">
    <h1>The `switch` Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      SwitchStatement[Yield, Await, Return] :
        `switch` `(` Expression[+In, ?Yield, ?Await] `)` CaseBlock[?Yield, ?Await, ?Return]

      CaseBlock[Yield, Await, Return] :
        `{` CaseClauses[?Yield, ?Await, ?Return]? `}`
        `{` CaseClauses[?Yield, ?Await, ?Return]? DefaultClause[?Yield, ?Await, ?Return] CaseClauses[?Yield, ?Await, ?Return]? `}`

      CaseClauses[Yield, Await, Return] :
        CaseClause[?Yield, ?Await, ?Return]
        CaseClauses[?Yield, ?Await, ?Return] CaseClause[?Yield, ?Await, ?Return]

      CaseClause[Yield, Await, Return] :
        `case` Expression[+In, ?Yield, ?Await] `:` StatementList[?Yield, ?Await, ?Return]?

      DefaultClause[Yield, Await, Return] :
        `default` `:` StatementList[?Yield, ?Await, ?Return]?
    </emu-grammar>

    <emu-clause id="sec-switch-statement-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if the LexicallyDeclaredNames of |CaseBlock| contains any duplicate entries.
        </li>
        <li>
          It is a Syntax Error if any element of the LexicallyDeclaredNames of |CaseBlock| also occurs in the VarDeclaredNames of |CaseBlock|.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-switch-statement-static-semantics-containsduplicatelabels">
      <h1>Static Semantics: ContainsDuplicateLabels</h1>
      <p>With parameter _labelSet_.</p>
      <emu-see-also-para op="ContainsDuplicateLabels"></emu-see-also-para>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. Return ContainsDuplicateLabels of |CaseBlock| with argument _labelSet_.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. If the first |CaseClauses| is present, then
          1. Let _hasDuplicates_ be ContainsDuplicateLabels of the first |CaseClauses| with argument _labelSet_.
          1. If _hasDuplicates_ is *true*, return *true*.
        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |DefaultClause| with argument _labelSet_.
        1. If _hasDuplicates_ is *true*, return *true*.
        1. If the second |CaseClauses| is not present, return *false*.
        1. Return ContainsDuplicateLabels of the second |CaseClauses| with argument _labelSet_.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |CaseClauses| with argument _labelSet_.
        1. If _hasDuplicates_ is *true*, return *true*.
        1. Return ContainsDuplicateLabels of |CaseClause| with argument _labelSet_.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. If the |StatementList| is present, return ContainsDuplicateLabels of |StatementList| with argument _labelSet_.
        1. Return *false*.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. If the |StatementList| is present, return ContainsDuplicateLabels of |StatementList| with argument _labelSet_.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-switch-statement-static-semantics-containsundefinedbreaktarget">
      <h1>Static Semantics: ContainsUndefinedBreakTarget</h1>
      <p>With parameter _labelSet_.</p>
      <emu-see-also-para op="ContainsUndefinedBreakTarget"></emu-see-also-para>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. Return ContainsUndefinedBreakTarget of |CaseBlock| with argument _labelSet_.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. If the first |CaseClauses| is present, then
          1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of the first |CaseClauses| with argument _labelSet_.
          1. If _hasUndefinedLabels_ is *true*, return *true*.
        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |DefaultClause| with argument _labelSet_.
        1. If _hasUndefinedLabels_ is *true*, return *true*.
        1. If the second |CaseClauses| is not present, return *false*.
        1. Return ContainsUndefinedBreakTarget of the second |CaseClauses| with argument _labelSet_.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |CaseClauses| with argument _labelSet_.
        1. If _hasUndefinedLabels_ is *true*, return *true*.
        1. Return ContainsUndefinedBreakTarget of |CaseClause| with argument _labelSet_.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. If the |StatementList| is present, return ContainsUndefinedBreakTarget of |StatementList| with argument _labelSet_.
        1. Return *false*.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. If the |StatementList| is present, return ContainsUndefinedBreakTarget of |StatementList| with argument _labelSet_.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-switch-statement-static-semantics-containsundefinedcontinuetarget">
      <h1>Static Semantics: ContainsUndefinedContinueTarget</h1>
      <p>With parameters _iterationSet_ and _labelSet_.</p>
      <emu-see-also-para op="ContainsUndefinedContinueTarget"></emu-see-also-para>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. Return ContainsUndefinedContinueTarget of |CaseBlock| with arguments _iterationSet_ and &laquo; &raquo;.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. If the first |CaseClauses| is present, then
          1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of the first |CaseClauses| with arguments _iterationSet_ and &laquo; &raquo;.
          1. If _hasUndefinedLabels_ is *true*, return *true*.
        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |DefaultClause| with arguments _iterationSet_ and &laquo; &raquo;.
        1. If _hasUndefinedLabels_ is *true*, return *true*.
        1. If the second |CaseClauses| is not present, return *false*.
        1. Return ContainsUndefinedContinueTarget of the second |CaseClauses| with arguments _iterationSet_ and &laquo; &raquo;.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |CaseClauses| with arguments _iterationSet_ and &laquo; &raquo;.
        1. If _hasUndefinedLabels_ is *true*, return *true*.
        1. Return ContainsUndefinedContinueTarget of |CaseClause| with arguments _iterationSet_ and &laquo; &raquo;.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. If the |StatementList| is present, return ContainsUndefinedContinueTarget of |StatementList| with arguments _iterationSet_ and &laquo; &raquo;.
        1. Return *false*.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. If the |StatementList| is present, return ContainsUndefinedContinueTarget of |StatementList| with arguments _iterationSet_ and &laquo; &raquo;.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-switch-statement-static-semantics-lexicallydeclarednames">
      <h1>Static Semantics: LexicallyDeclaredNames</h1>
      <emu-see-also-para op="LexicallyDeclaredNames"></emu-see-also-para>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. If the first |CaseClauses| is present, let _names_ be the LexicallyDeclaredNames of the first |CaseClauses|.
        1. Else, let _names_ be a new empty List.
        1. Append to _names_ the elements of the LexicallyDeclaredNames of the |DefaultClause|.
        1. If the second |CaseClauses| is not present, return _names_.
        1. Return the result of appending to _names_ the elements of the LexicallyDeclaredNames of the second |CaseClauses|.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. Let _names_ be LexicallyDeclaredNames of |CaseClauses|.
        1. Append to _names_ the elements of the LexicallyDeclaredNames of |CaseClause|.
        1. Return _names_.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. If the |StatementList| is present, return the LexicallyDeclaredNames of |StatementList|.
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. If the |StatementList| is present, return the LexicallyDeclaredNames of |StatementList|.
        1. Return a new empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-switch-statement-static-semantics-lexicallyscopeddeclarations">
      <h1>Static Semantics: LexicallyScopedDeclarations</h1>
      <emu-see-also-para op="LexicallyScopedDeclarations"></emu-see-also-para>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. If the first |CaseClauses| is present, let _declarations_ be the LexicallyScopedDeclarations of the first |CaseClauses|.
        1. Else, let _declarations_ be a new empty List.
        1. Append to _declarations_ the elements of the LexicallyScopedDeclarations of the |DefaultClause|.
        1. If the second |CaseClauses| is not present, return _declarations_.
        1. Return the result of appending to _declarations_ the elements of the LexicallyScopedDeclarations of the second |CaseClauses|.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. Let _declarations_ be LexicallyScopedDeclarations of |CaseClauses|.
        1. Append to _declarations_ the elements of the LexicallyScopedDeclarations of |CaseClause|.
        1. Return _declarations_.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. If the |StatementList| is present, return the LexicallyScopedDeclarations of |StatementList|.
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. If the |StatementList| is present, return the LexicallyScopedDeclarations of |StatementList|.
        1. Return a new empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-switch-statement-static-semantics-vardeclarednames">
      <h1>Static Semantics: VarDeclaredNames</h1>
      <emu-see-also-para op="VarDeclaredNames"></emu-see-also-para>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. Return the VarDeclaredNames of |CaseBlock|.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. If the first |CaseClauses| is present, let _names_ be the VarDeclaredNames of the first |CaseClauses|.
        1. Else, let _names_ be a new empty List.
        1. Append to _names_ the elements of the VarDeclaredNames of the |DefaultClause|.
        1. If the second |CaseClauses| is not present, return _names_.
        1. Return the result of appending to _names_ the elements of the VarDeclaredNames of the second |CaseClauses|.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. Let _names_ be VarDeclaredNames of |CaseClauses|.
        1. Append to _names_ the elements of the VarDeclaredNames of |CaseClause|.
        1. Return _names_.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. If the |StatementList| is present, return the VarDeclaredNames of |StatementList|.
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. If the |StatementList| is present, return the VarDeclaredNames of |StatementList|.
        1. Return a new empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-switch-statement-static-semantics-varscopeddeclarations">
      <h1>Static Semantics: VarScopedDeclarations</h1>
      <emu-see-also-para op="VarScopedDeclarations"></emu-see-also-para>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. Return the VarScopedDeclarations of |CaseBlock|.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. If the first |CaseClauses| is present, let _declarations_ be the VarScopedDeclarations of the first |CaseClauses|.
        1. Else, let _declarations_ be a new empty List.
        1. Append to _declarations_ the elements of the VarScopedDeclarations of the |DefaultClause|.
        1. If the second |CaseClauses| is not present, return _declarations_.
        1. Return the result of appending to _declarations_ the elements of the VarScopedDeclarations of the second |CaseClauses|.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. Let _declarations_ be VarScopedDeclarations of |CaseClauses|.
        1. Append to _declarations_ the elements of the VarScopedDeclarations of |CaseClause|.
        1. Return _declarations_.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. If the |StatementList| is present, return the VarScopedDeclarations of |StatementList|.
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. If the |StatementList| is present, return the VarScopedDeclarations of |StatementList|.
        1. Return a new empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-caseblockevaluation">
      <h1>Runtime Semantics: CaseBlockEvaluation</h1>
      <p>With parameter _input_.</p>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return NormalCompletion(*undefined*).
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses `}`</emu-grammar>
      <emu-alg>
        1. Let _V_ be *undefined*.
        1. Let _A_ be the List of |CaseClause| items in |CaseClauses|, in source text order.
        1. Let _found_ be *false*.
        1. For each |CaseClause| _C_ in _A_, do
          1. If _found_ is *false*, then
            1. Set _found_ to ? CaseClauseIsSelected(_C_, _input_).
          1. If _found_ is *true*, then
            1. Let _R_ be the result of evaluating _C_.
            1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].
            1. If _R_ is an abrupt completion, return Completion(UpdateEmpty(_R_, _V_)).
        1. Return NormalCompletion(_V_).
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. Let _V_ be *undefined*.
        1. If the first |CaseClauses| is present, then
          1. Let _A_ be the List of |CaseClause| items in the first |CaseClauses|, in source text order.
        1. Else,
          1. Let _A_ be &laquo; &raquo;.
        1. Let _found_ be *false*.
        1. For each |CaseClause| _C_ in _A_, do
          1. If _found_ is *false*, then
            1. Set _found_ to ? CaseClauseIsSelected(_C_, _input_).
          1. If _found_ is *true*, then
            1. Let _R_ be the result of evaluating _C_.
            1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].
            1. If _R_ is an abrupt completion, return Completion(UpdateEmpty(_R_, _V_)).
        1. Let _foundInB_ be *false*.
        1. If the second |CaseClauses| is present, then
          1. Let _B_ be the List of |CaseClause| items in the second |CaseClauses|, in source text order.
        1. Else,
          1. Let _B_ be &laquo; &raquo;.
        1. If _found_ is *false*, then
          1. For each |CaseClause| _C_ in _B_, do
            1. If _foundInB_ is *false*, then
              1. Set _foundInB_ to ? CaseClauseIsSelected(_C_, _input_).
            1. If _foundInB_ is *true*, then
              1. Let _R_ be the result of evaluating |CaseClause| _C_.
              1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].
              1. If _R_ is an abrupt completion, return Completion(UpdateEmpty(_R_, _V_)).
        1. If _foundInB_ is *true*, return NormalCompletion(_V_).
        1. Let _R_ be the result of evaluating |DefaultClause|.
        1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].
        1. If _R_ is an abrupt completion, return Completion(UpdateEmpty(_R_, _V_)).
        1. For each |CaseClause| _C_ in _B_ (NOTE: this is another complete iteration of the second |CaseClauses|), do
          1. Let _R_ be the result of evaluating |CaseClause| _C_.
          1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].
          1. If _R_ is an abrupt completion, return Completion(UpdateEmpty(_R_, _V_)).
        1. Return NormalCompletion(_V_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-caseclauseisselected" aoid="CaseClauseIsSelected" oldids="sec-runtime-semantics-caseselectorevaluation">
      <h1>Runtime Semantics: CaseClauseIsSelected ( _C_, _input_ )</h1>
      <p>The abstract operation CaseClauseIsSelected, given |CaseClause| _C_ and value _input_, determines whether _C_ matches _input_.</p>
      <emu-alg>
        1. Assert: _C_ is an instance of the production <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>.
        1. Let _exprRef_ be the result of evaluating the |Expression| of _C_.
        1. Let _clauseSelector_ be ? GetValue(_exprRef_).
        1. Return the result of performing Strict Equality Comparison _input_ === _clauseSelector_.
      </emu-alg>
      <emu-note>
        <p>This operation does not execute _C_'s |StatementList| (if any). The |CaseBlock| algorithm uses its return value to determine which |StatementList| to start executing.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-switch-statement-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be the result of evaluating |Expression|.
        1. Let _switchValue_ be ? GetValue(_exprRef_).
        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
        1. Let _blockEnv_ be NewDeclarativeEnvironment(_oldEnv_).
        1. Perform BlockDeclarationInstantiation(|CaseBlock|, _blockEnv_).
        1. Set the running execution context's LexicalEnvironment to _blockEnv_.
        1. Let _R_ be the result of performing CaseBlockEvaluation of |CaseBlock| with argument _switchValue_.
        1. Set the running execution context's LexicalEnvironment to _oldEnv_.
        1. Return _R_.
      </emu-alg>
      <emu-note>
        <p>No matter how control leaves the |SwitchStatement| the LexicalEnvironment is always restored to its former state.</p>
      </emu-note>
      <emu-grammar>CaseClause : `case` Expression `:`</emu-grammar>
      <emu-alg>
        1. Return NormalCompletion(~empty~).
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList</emu-grammar>
      <emu-alg>
        1. Return the result of evaluating |StatementList|.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:`</emu-grammar>
      <emu-alg>
        1. Return NormalCompletion(~empty~).
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList</emu-grammar>
      <emu-alg>
        1. Return the result of evaluating |StatementList|.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-labelled-statements">
    <h1>Labelled Statements</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      LabelledStatement[Yield, Await, Return] :
        LabelIdentifier[?Yield, ?Await] `:` LabelledItem[?Yield, ?Await, ?Return]

      LabelledItem[Yield, Await, Return] :
        Statement[?Yield, ?Await, ?Return]
        FunctionDeclaration[?Yield, ?Await, ~Default]
    </emu-grammar>
    <emu-note>
      <p>A |Statement| may be prefixed by a label. Labelled statements are only used in conjunction with labelled `break` and `continue` statements. ECMAScript has no `goto` statement. A |Statement| can be part of a |LabelledStatement|, which itself can be part of a |LabelledStatement|, and so on. The labels introduced this way are collectively referred to as the &ldquo;current label set&rdquo; when describing the semantics of individual statements.</p>
    </emu-note>

    <emu-clause id="sec-labelled-statements-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if any source text matches this rule.
        </li>
      </ul>
      <emu-note>
        <p>An alternative definition for this rule is provided in <emu-xref href="#sec-labelled-function-declarations"></emu-xref>.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-labelled-statements-static-semantics-containsduplicatelabels">
      <h1>Static Semantics: ContainsDuplicateLabels</h1>
      <p>With parameter _labelSet_.</p>
      <emu-see-also-para op="ContainsDuplicateLabels"></emu-see-also-para>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. Let _label_ be the StringValue of |LabelIdentifier|.
        1. If _label_ is an element of _labelSet_, return *true*.
        1. Let _newLabelSet_ be a copy of _labelSet_ with _label_ appended.
        1. Return ContainsDuplicateLabels of |LabelledItem| with argument _newLabelSet_.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-labelled-statements-static-semantics-containsundefinedbreaktarget">
      <h1>Static Semantics: ContainsUndefinedBreakTarget</h1>
      <p>With parameter _labelSet_.</p>
      <emu-see-also-para op="ContainsUndefinedBreakTarget"></emu-see-also-para>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. Let _label_ be the StringValue of |LabelIdentifier|.
        1. Let _newLabelSet_ be a copy of _labelSet_ with _label_ appended.
        1. Return ContainsUndefinedBreakTarget of |LabelledItem| with argument _newLabelSet_.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-labelled-statements-static-semantics-containsundefinedcontinuetarget">
      <h1>Static Semantics: ContainsUndefinedContinueTarget</h1>
      <p>With parameters _iterationSet_ and _labelSet_.</p>
      <emu-see-also-para op="ContainsUndefinedContinueTarget"></emu-see-also-para>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. Let _label_ be the StringValue of |LabelIdentifier|.
        1. Let _newLabelSet_ be a copy of _labelSet_ with _label_ appended.
        1. Return ContainsUndefinedContinueTarget of |LabelledItem| with arguments _iterationSet_ and _newLabelSet_.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-islabelledfunction" aoid="IsLabelledFunction">
      <h1>Static Semantics: IsLabelledFunction ( _stmt_ )</h1>
      <p>The abstract operation IsLabelledFunction with argument _stmt_ performs the following steps:</p>
      <emu-alg>
        1. If _stmt_ is not a |LabelledStatement|, return *false*.
        1. Let _item_ be the |LabelledItem| of _stmt_.
        1. If _item_ is <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar> , return *true*.
        1. Let _subStmt_ be the |Statement| of _item_.
        1. Return IsLabelledFunction(_subStmt_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-labelled-statements-static-semantics-lexicallydeclarednames">
      <h1>Static Semantics: LexicallyDeclaredNames</h1>
      <emu-see-also-para op="LexicallyDeclaredNames"></emu-see-also-para>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. Return the LexicallyDeclaredNames of |LabelledItem|.
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. Return BoundNames of |FunctionDeclaration|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-labelled-statements-static-semantics-lexicallyscopeddeclarations">
      <h1>Static Semantics: LexicallyScopedDeclarations</h1>
      <emu-see-also-para op="LexicallyScopedDeclarations"></emu-see-also-para>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. Return the LexicallyScopedDeclarations of |LabelledItem|.
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. Return a new List containing |FunctionDeclaration|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-labelled-statements-static-semantics-toplevellexicallydeclarednames">
      <h1>Static Semantics: TopLevelLexicallyDeclaredNames</h1>
      <emu-see-also-para op="TopLevelLexicallyDeclaredNames"></emu-see-also-para>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-labelled-statements-static-semantics-toplevellexicallyscopeddeclarations">
      <h1>Static Semantics: TopLevelLexicallyScopedDeclarations</h1>
      <emu-see-also-para op="TopLevelLexicallyScopedDeclarations"></emu-see-also-para>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-labelled-statements-static-semantics-toplevelvardeclarednames">
      <h1>Static Semantics: TopLevelVarDeclaredNames</h1>
      <emu-see-also-para op="TopLevelVarDeclaredNames"></emu-see-also-para>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. Return the TopLevelVarDeclaredNames of |LabelledItem|.
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar> , return TopLevelVarDeclaredNames of |Statement|.
        1. Return VarDeclaredNames of |Statement|.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. Return BoundNames of |FunctionDeclaration|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-labelled-statements-static-semantics-toplevelvarscopeddeclarations">
      <h1>Static Semantics: TopLevelVarScopedDeclarations</h1>
      <emu-see-also-para op="TopLevelVarScopedDeclarations"></emu-see-also-para>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. Return the TopLevelVarScopedDeclarations of |LabelledItem|.
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar> , return TopLevelVarScopedDeclarations of |Statement|.
        1. Return VarScopedDeclarations of |Statement|.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. Return a new List containing |FunctionDeclaration|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-labelled-statements-static-semantics-vardeclarednames">
      <h1>Static Semantics: VarDeclaredNames</h1>
      <emu-see-also-para op="VarDeclaredNames"></emu-see-also-para>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. Return the VarDeclaredNames of |LabelledItem|.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-labelled-statements-static-semantics-varscopeddeclarations">
      <h1>Static Semantics: VarScopedDeclarations</h1>
      <emu-see-also-para op="VarScopedDeclarations"></emu-see-also-para>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. Return the VarScopedDeclarations of |LabelledItem|.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-labelled-statements-runtime-semantics-labelledevaluation">
      <h1>Runtime Semantics: LabelledEvaluation</h1>
      <p>With parameter _labelSet_.</p>
      <emu-see-also-para op="LabelledEvaluation"></emu-see-also-para>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. Let _label_ be the StringValue of |LabelIdentifier|.
        1. Append _label_ as an element of _labelSet_.
        1. Let _stmtResult_ be LabelledEvaluation of |LabelledItem| with argument _labelSet_.
        1. If _stmtResult_.[[Type]] is ~break~ and SameValue(_stmtResult_.[[Target]], _label_) is *true*, then
          1. Set _stmtResult_ to NormalCompletion(_stmtResult_.[[Value]]).
        1. Return Completion(_stmtResult_).
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. If |Statement| is either a |LabelledStatement| or a |BreakableStatement|, then
          1. Return LabelledEvaluation of |Statement| with argument _labelSet_.
        1. Else,
          1. Return the result of evaluating |Statement|.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. Return the result of evaluating |FunctionDeclaration|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-labelled-statements-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. Let _newLabelSet_ be a new empty List.
        1. Return LabelledEvaluation of this |LabelledStatement| with argument _newLabelSet_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-throw-statement">
    <h1>The `throw` Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ThrowStatement[Yield, Await] :
        `throw` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`
    </emu-grammar>

    <emu-clause id="sec-throw-statement-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>ThrowStatement : `throw` Expression `;`</emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be the result of evaluating |Expression|.
        1. Let _exprValue_ be ? GetValue(_exprRef_).
        1. Return ThrowCompletion(_exprValue_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-try-statement">
    <h1>The `try` Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      TryStatement[Yield, Await, Return] :
        `try` Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return]
        `try` Block[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]
        `try` Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]

      Catch[Yield, Await, Return] :
        `catch` `(` CatchParameter[?Yield, ?Await] `)` Block[?Yield, ?Await, ?Return]
        `catch` Block[?Yield, ?Await, ?Return]

      Finally[Yield, Await, Return] :
        `finally` Block[?Yield, ?Await, ?Return]

      CatchParameter[Yield, Await] :
        BindingIdentifier[?Yield, ?Await]
        BindingPattern[?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>The `try` statement encloses a block of code in which an exceptional condition can occur, such as a runtime error or a `throw` statement. The `catch` clause provides the exception-handling code. When a catch clause catches an exception, its |CatchParameter| is bound to that exception.</p>
    </emu-note>

    <emu-clause id="sec-try-statement-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if BoundNames of |CatchParameter| contains any duplicate elements.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |CatchParameter| also occurs in the LexicallyDeclaredNames of |Block|.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |CatchParameter| also occurs in the VarDeclaredNames of |Block|.
        </li>
      </ul>
      <emu-note>
        <p>An alternative static semantics for this production is given in <emu-xref href="#sec-variablestatements-in-catch-blocks"></emu-xref>.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-try-statement-static-semantics-containsduplicatelabels">
      <h1>Static Semantics: ContainsDuplicateLabels</h1>
      <p>With parameter _labelSet_.</p>
      <emu-see-also-para op="ContainsDuplicateLabels"></emu-see-also-para>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |Block| with argument _labelSet_.
        1. If _hasDuplicates_ is *true*, return *true*.
        1. Return ContainsDuplicateLabels of |Catch| with argument _labelSet_.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |Block| with argument _labelSet_.
        1. If _hasDuplicates_ is *true*, return *true*.
        1. Return ContainsDuplicateLabels of |Finally| with argument _labelSet_.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |Block| with argument _labelSet_.
        1. If _hasDuplicates_ is *true*, return *true*.
        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |Catch| with argument _labelSet_.
        1. If _hasDuplicates_ is *true*, return *true*.
        1. Return ContainsDuplicateLabels of |Finally| with argument _labelSet_.
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. Return ContainsDuplicateLabels of |Block| with argument _labelSet_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-try-statement-static-semantics-containsundefinedbreaktarget">
      <h1>Static Semantics: ContainsUndefinedBreakTarget</h1>
      <p>With parameter _labelSet_.</p>
      <emu-see-also-para op="ContainsUndefinedBreakTarget"></emu-see-also-para>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |Block| with argument _labelSet_.
        1. If _hasUndefinedLabels_ is *true*, return *true*.
        1. Return ContainsUndefinedBreakTarget of |Catch| with argument _labelSet_.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |Block| with argument _labelSet_.
        1. If _hasUndefinedLabels_ is *true*, return *true*.
        1. Return ContainsUndefinedBreakTarget of |Finally| with argument _labelSet_.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |Block| with argument _labelSet_.
        1. If _hasUndefinedLabels_ is *true*, return *true*.
        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |Catch| with argument _labelSet_.
        1. If _hasUndefinedLabels_ is *true*, return *true*.
        1. Return ContainsUndefinedBreakTarget of |Finally| with argument _labelSet_.
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. Return ContainsUndefinedBreakTarget of |Block| with argument _labelSet_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-try-statement-static-semantics-containsundefinedcontinuetarget">
      <h1>Static Semantics: ContainsUndefinedContinueTarget</h1>
      <p>With parameters _iterationSet_ and _labelSet_.</p>
      <emu-see-also-para op="ContainsUndefinedContinueTarget"></emu-see-also-para>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and &laquo; &raquo;.
        1. If _hasUndefinedLabels_ is *true*, return *true*.
        1. Return ContainsUndefinedContinueTarget of |Catch| with arguments _iterationSet_ and &laquo; &raquo;.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and &laquo; &raquo;.
        1. If _hasUndefinedLabels_ is *true*, return *true*.
        1. Return ContainsUndefinedContinueTarget of |Finally| with arguments _iterationSet_ and &laquo; &raquo;.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and &laquo; &raquo;.
        1. If _hasUndefinedLabels_ is *true*, return *true*.
        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |Catch| with arguments _iterationSet_ and &laquo; &raquo;.
        1. If _hasUndefinedLabels_ is *true*, return *true*.
        1. Return ContainsUndefinedContinueTarget of |Finally| with arguments _iterationSet_ and &laquo; &raquo;.
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. Return ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and &laquo; &raquo;.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-try-statement-static-semantics-vardeclarednames">
      <h1>Static Semantics: VarDeclaredNames</h1>
      <emu-see-also-para op="VarDeclaredNames"></emu-see-also-para>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. Let _names_ be VarDeclaredNames of |Block|.
        1. Append to _names_ the elements of the VarDeclaredNames of |Catch|.
        1. Return _names_.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. Let _names_ be VarDeclaredNames of |Block|.
        1. Append to _names_ the elements of the VarDeclaredNames of |Finally|.
        1. Return _names_.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. Let _names_ be VarDeclaredNames of |Block|.
        1. Append to _names_ the elements of the VarDeclaredNames of |Catch|.
        1. Append to _names_ the elements of the VarDeclaredNames of |Finally|.
        1. Return _names_.
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. Return the VarDeclaredNames of |Block|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-try-statement-static-semantics-varscopeddeclarations">
      <h1>Static Semantics: VarScopedDeclarations</h1>
      <emu-see-also-para op="VarScopedDeclarations"></emu-see-also-para>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. Let _declarations_ be VarScopedDeclarations of |Block|.
        1. Append to _declarations_ the elements of the VarScopedDeclarations of |Catch|.
        1. Return _declarations_.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. Let _declarations_ be VarScopedDeclarations of |Block|.
        1. Append to _declarations_ the elements of the VarScopedDeclarations of |Finally|.
        1. Return _declarations_.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. Let _declarations_ be VarScopedDeclarations of |Block|.
        1. Append to _declarations_ the elements of the VarScopedDeclarations of |Catch|.
        1. Append to _declarations_ the elements of the VarScopedDeclarations of |Finally|.
        1. Return _declarations_.
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. Return the VarScopedDeclarations of |Block|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-catchclauseevaluation">
      <h1>Runtime Semantics: CatchClauseEvaluation</h1>
      <p>With parameter _thrownValue_.</p>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
        1. Let _catchEnv_ be NewDeclarativeEnvironment(_oldEnv_).
        1. Let _catchEnvRec_ be _catchEnv_'s EnvironmentRecord.
        1. For each element _argName_ of the BoundNames of |CatchParameter|, do
          1. Perform ! _catchEnvRec_.CreateMutableBinding(_argName_, *false*).
        1. Set the running execution context's LexicalEnvironment to _catchEnv_.
        1. Let _status_ be the result of performing BindingInitialization for |CatchParameter| passing _thrownValue_ and _catchEnv_ as arguments.
        1. If _status_ is an abrupt completion, then
          1. Set the running execution context's LexicalEnvironment to _oldEnv_.
          1. Return Completion(_status_).
        1. Let _B_ be the result of evaluating |Block|.
        1. Set the running execution context's LexicalEnvironment to _oldEnv_.
        1. Return Completion(_B_).
      </emu-alg>
      <emu-grammar>Catch : `catch` Block</emu-grammar>
      <emu-alg>
        1. Return the result of evaluating |Block|.
      </emu-alg>
      <emu-note>
        <p>No matter how control leaves the |Block| the LexicalEnvironment is always restored to its former state.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-try-statement-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. Let _B_ be the result of evaluating |Block|.
        1. If _B_.[[Type]] is ~throw~, let _C_ be CatchClauseEvaluation of |Catch| with argument _B_.[[Value]].
        1. Else, let _C_ be _B_.
        1. Return Completion(UpdateEmpty(_C_, *undefined*)).
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. Let _B_ be the result of evaluating |Block|.
        1. Let _F_ be the result of evaluating |Finally|.
        1. If _F_.[[Type]] is ~normal~, set _F_ to _B_.
        1. Return Completion(UpdateEmpty(_F_, *undefined*)).
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. Let _B_ be the result of evaluating |Block|.
        1. If _B_.[[Type]] is ~throw~, let _C_ be CatchClauseEvaluation of |Catch| with argument _B_.[[Value]].
        1. Else, let _C_ be _B_.
        1. Let _F_ be the result of evaluating |Finally|.
        1. If _F_.[[Type]] is ~normal~, set _F_ to _C_.
        1. Return Completion(UpdateEmpty(_F_, *undefined*)).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-debugger-statement">
    <h1>The `debugger` Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      DebuggerStatement :
        `debugger` `;`
    </emu-grammar>

    <emu-clause id="sec-debugger-statement-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-note>
        <p>Evaluating a |DebuggerStatement| may allow an implementation to cause a breakpoint when run under a debugger. If a debugger is not present or active this statement has no observable effect.</p>
      </emu-note>
      <emu-grammar>DebuggerStatement : `debugger` `;`</emu-grammar>
      <emu-alg>
        1. If an implementation-defined debugging facility is available and enabled, then
          1. Perform an implementation-defined debugging action.
          1. Let _result_ be an implementation-defined Completion value.
        1. Else,
          1. Let _result_ be NormalCompletion(~empty~).
        1. Return _result_.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-functions-and-classes">
  <h1>ECMAScript Language: Functions and Classes</h1>
  <emu-note>
    <p>Various ECMAScript language elements cause the creation of ECMAScript function objects (<emu-xref href="#sec-ecmascript-function-objects"></emu-xref>). Evaluation of such functions starts with the execution of their [[Call]] internal method (<emu-xref href="#sec-ecmascript-function-objects-call-thisargument-argumentslist"></emu-xref>).</p>
  </emu-note>

  <emu-clause id="sec-function-definitions">
    <h1>Function Definitions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      FunctionDeclaration[Yield, Await, Default] :
        `function` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`
        [+Default] `function` `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`

      FunctionExpression :
        `function` BindingIdentifier[~Yield, ~Await]? `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`

      UniqueFormalParameters[Yield, Await] :
        FormalParameters[?Yield, ?Await]

      FormalParameters[Yield, Await] :
        [empty]
        FunctionRestParameter[?Yield, ?Await]
        FormalParameterList[?Yield, ?Await]
        FormalParameterList[?Yield, ?Await] `,`
        FormalParameterList[?Yield, ?Await] `,` FunctionRestParameter[?Yield, ?Await]

      FormalParameterList[Yield, Await] :
        FormalParameter[?Yield, ?Await]
        FormalParameterList[?Yield, ?Await] `,` FormalParameter[?Yield, ?Await]

      FunctionRestParameter[Yield, Await] :
        BindingRestElement[?Yield, ?Await]

      FormalParameter[Yield, Await] :
        BindingElement[?Yield, ?Await]

      FunctionBody[Yield, Await] :
        FunctionStatementList[?Yield, ?Await]

      FunctionStatementList[Yield, Await] :
        StatementList[?Yield, ?Await, +Return]?
    </emu-grammar>

    <emu-clause id="sec-directive-prologues-and-the-use-strict-directive">
      <h1>Directive Prologues and the Use Strict Directive</h1>
      <p>A <dfn id="directive-prologue">Directive Prologue</dfn> is the longest sequence of |ExpressionStatement|s occurring as the initial |StatementListItem|s or |ModuleItem|s of a |FunctionBody|, a |ScriptBody|, or a |ModuleBody| and where each |ExpressionStatement| in the sequence consists entirely of a |StringLiteral| token followed by a semicolon. The semicolon may appear explicitly or may be inserted by automatic semicolon insertion. A Directive Prologue may be an empty sequence.</p>
      <p>A <dfn id="use-strict-directive">Use Strict Directive</dfn> is an |ExpressionStatement| in a Directive Prologue whose |StringLiteral| is either the exact code unit sequences `"use strict"` or `'use strict'`. A Use Strict Directive may not contain an |EscapeSequence| or |LineContinuation|.</p>
      <p>A Directive Prologue may contain more than one Use Strict Directive. However, an implementation may issue a warning if this occurs.</p>
      <emu-note>
        <p>The |ExpressionStatement|s of a Directive Prologue are evaluated normally during evaluation of the containing production. Implementations may define implementation specific meanings for |ExpressionStatement|s which are not a Use Strict Directive and which occur in a Directive Prologue. If an appropriate notification mechanism exists, an implementation should issue a warning if it encounters in a Directive Prologue an |ExpressionStatement| that is not a Use Strict Directive and which does not have a meaning defined by the implementation.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-function-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>
        FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionExpression : `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <ul>
        <li>
          If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.
        </li>
        <li>
          If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is `"eval"` or `"arguments"`.
        </li>
        <li>
          It is a Syntax Error if ContainsUseStrict of |FunctionBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |FunctionBody|.
        </li>
        <li>
          It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.
        </li>
        <li>
          It is a Syntax Error if |FunctionBody| Contains |SuperProperty| is *true*.
        </li>
        <li>
          It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.
        </li>
        <li>
          It is a Syntax Error if |FunctionBody| Contains |SuperCall| is *true*.
        </li>
      </ul>
      <emu-note>
        <p>The LexicallyDeclaredNames of a |FunctionBody| does not include identifiers bound using var or function declarations.</p>
      </emu-note>
      <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if BoundNames of |FormalParameters| contains any duplicate elements.
        </li>
      </ul>
      <emu-grammar>FormalParameters : FormalParameterList</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if IsSimpleParameterList of |FormalParameterList| is *false* and BoundNames of |FormalParameterList| contains any duplicate elements.
        </li>
      </ul>
      <emu-note>
        <p>Multiple occurrences of the same |BindingIdentifier| in a |FormalParameterList| is only allowed for functions which have simple parameter lists and which are not defined in strict mode code.</p>
      </emu-note>
      <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if the LexicallyDeclaredNames of |FunctionStatementList| contains any duplicate entries.
        </li>
        <li>
          It is a Syntax Error if any element of the LexicallyDeclaredNames of |FunctionStatementList| also occurs in the VarDeclaredNames of |FunctionStatementList|.
        </li>
        <li>
          It is a Syntax Error if ContainsDuplicateLabels of |FunctionStatementList| with argument &laquo; &raquo; is *true*.
        </li>
        <li>
          It is a Syntax Error if ContainsUndefinedBreakTarget of |FunctionStatementList| with argument &laquo; &raquo; is *true*.
        </li>
        <li>
          It is a Syntax Error if ContainsUndefinedContinueTarget of |FunctionStatementList| with arguments &laquo; &raquo; and &laquo; &raquo; is *true*.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-function-definitions-static-semantics-boundnames">
      <h1>Static Semantics: BoundNames</h1>
      <emu-see-also-para op="BoundNames"></emu-see-also-para>
      <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return &laquo; `"*default*"` &raquo;.
      </emu-alg>
      <emu-note>
        <p>`"*default*"` is used within this specification as a synthetic name for hoistable anonymous functions that are defined using export declarations.</p>
      </emu-note>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. Let _names_ be BoundNames of |FormalParameterList|.
        1. Append to _names_ the BoundNames of |FunctionRestParameter|.
        1. Return _names_.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. Let _names_ be BoundNames of |FormalParameterList|.
        1. Append to _names_ the BoundNames of |FormalParameter|.
        1. Return _names_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-function-definitions-static-semantics-contains">
      <h1>Static Semantics: Contains</h1>
      <p>With parameter _symbol_.</p>
      <emu-see-also-para op="Contains"></emu-see-also-para>
      <emu-grammar>
        FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionExpression : `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-note>
        <p>Static semantic rules that depend upon substructure generally do not look into function definitions.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-function-definitions-static-semantics-containsexpression">
      <h1>Static Semantics: ContainsExpression</h1>
      <emu-see-also-para op="ContainsExpression"></emu-see-also-para>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. If ContainsExpression of |FormalParameterList| is *true*, return *true*.
        1. Return ContainsExpression of |FunctionRestParameter|.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. If ContainsExpression of |FormalParameterList| is *true*, return *true*.
        1. Return ContainsExpression of |FormalParameter|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-function-definitions-static-semantics-containsusestrict">
      <h1>Static Semantics: ContainsUseStrict</h1>
      <emu-see-also-para op="ContainsUseStrict"></emu-see-also-para>
      <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
      <emu-alg>
        1. If the Directive Prologue of |FunctionStatementList| contains a Use Strict Directive, return *true*; otherwise, return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-function-definitions-static-semantics-expectedargumentcount">
      <h1>Static Semantics: ExpectedArgumentCount</h1>
      <emu-see-also-para op="ExpectedArgumentCount"></emu-see-also-para>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. Return 0.
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. Return ExpectedArgumentCount of |FormalParameterList|.
      </emu-alg>
      <emu-note>
        <p>The ExpectedArgumentCount of a |FormalParameterList| is the number of |FormalParameters| to the left of either the rest parameter or the first |FormalParameter| with an Initializer. A |FormalParameter| without an initializer is allowed after the first parameter with an initializer but such parameters are considered to be optional with *undefined* as their default value.</p>
      </emu-note>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. Let _count_ be ExpectedArgumentCount of |FormalParameterList|.
        1. If HasInitializer of |FormalParameterList| is *true* or HasInitializer of |FormalParameter| is *true*, return _count_.
        1. Return _count_ + 1.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-function-definitions-static-semantics-hasinitializer">
      <h1>Static Semantics: HasInitializer</h1>
      <emu-see-also-para op="HasInitializer"></emu-see-also-para>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. If HasInitializer of |FormalParameterList| is *true*, return *true*.
        1. Return HasInitializer of |FormalParameter|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-function-definitions-static-semantics-hasname">
      <h1>Static Semantics: HasName</h1>
      <emu-see-also-para op="HasName"></emu-see-also-para>
      <emu-grammar>FunctionExpression : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>FunctionExpression : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isanonymousfunctiondefinition" aoid="IsAnonymousFunctionDefinition">
      <h1>Static Semantics: IsAnonymousFunctionDefinition ( _expr_ )</h1>
      <p>The abstract operation IsAnonymousFunctionDefinition determines if its argument is a function definition that does not bind a name. The argument _expr_ is the result of parsing an |AssignmentExpression| or |Initializer|. The following steps are taken:</p>
      <emu-alg>
        1. If IsFunctionDefinition of _expr_ is *false*, return *false*.
        1. Let _hasName_ be the result of HasName of _expr_.
        1. If _hasName_ is *true*, return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-function-definitions-static-semantics-isconstantdeclaration">
      <h1>Static Semantics: IsConstantDeclaration</h1>
      <emu-see-also-para op="IsConstantDeclaration"></emu-see-also-para>
      <emu-grammar>
        FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-function-definitions-static-semantics-isfunctiondefinition">
      <h1>Static Semantics: IsFunctionDefinition</h1>
      <emu-see-also-para op="IsFunctionDefinition"></emu-see-also-para>
      <emu-grammar>FunctionExpression : `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-function-definitions-static-semantics-issimpleparameterlist">
      <h1>Static Semantics: IsSimpleParameterList</h1>
      <emu-see-also-para op="IsSimpleParameterList"></emu-see-also-para>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. If IsSimpleParameterList of |FormalParameterList| is *false*, return *false*.
        1. Return IsSimpleParameterList of |FormalParameter|.
      </emu-alg>
      <emu-grammar>FormalParameter : BindingElement</emu-grammar>
      <emu-alg>
        1. Return IsSimpleParameterList of |BindingElement|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-function-definitions-static-semantics-lexicallydeclarednames">
      <h1>Static Semantics: LexicallyDeclaredNames</h1>
      <emu-see-also-para op="LexicallyDeclaredNames"></emu-see-also-para>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. Return TopLevelLexicallyDeclaredNames of |StatementList|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-function-definitions-static-semantics-lexicallyscopeddeclarations">
      <h1>Static Semantics: LexicallyScopedDeclarations</h1>
      <emu-see-also-para op="LexicallyScopedDeclarations"></emu-see-also-para>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. Return the TopLevelLexicallyScopedDeclarations of |StatementList|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-function-definitions-static-semantics-vardeclarednames">
      <h1>Static Semantics: VarDeclaredNames</h1>
      <emu-see-also-para op="VarDeclaredNames"></emu-see-also-para>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. Return TopLevelVarDeclaredNames of |StatementList|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-function-definitions-static-semantics-varscopeddeclarations">
      <h1>Static Semantics: VarScopedDeclarations</h1>
      <emu-see-also-para op="VarScopedDeclarations"></emu-see-also-para>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. Return the TopLevelVarScopedDeclarations of |StatementList|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-function-definitions-runtime-semantics-evaluatebody">
      <h1>Runtime Semantics: EvaluateBody</h1>
      <p>With parameters _functionObject_ and List _argumentsList_.</p>
      <emu-see-also-para op="EvaluateBody"></emu-see-also-para>
      <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
      <emu-alg>
        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).
        1. Return the result of evaluating |FunctionStatementList|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-function-definitions-runtime-semantics-iteratorbindinginitialization">
      <h1>Runtime Semantics: IteratorBindingInitialization</h1>
      <p>With parameters _iteratorRecord_ and _environment_.</p>
      <emu-note>
        <p>When *undefined* is passed for _environment_ it indicates that a PutValue operation should be used to assign the initialization value. This is the case for formal parameter lists of non-strict functions. In that case the formal parameter bindings are preinitialized in order to deal with the possibility of multiple parameters with the same name.</p>
      </emu-note>
      <emu-see-also-para op="IteratorBindingInitialization"></emu-see-also-para>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. Return NormalCompletion(~empty~).
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. Perform ? IteratorBindingInitialization for |FormalParameterList| using _iteratorRecord_ and _environment_ as the arguments.
        1. Return the result of performing IteratorBindingInitialization for |FunctionRestParameter| using _iteratorRecord_ and _environment_ as the arguments.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. Perform ? IteratorBindingInitialization for |FormalParameterList| using _iteratorRecord_ and _environment_ as the arguments.
        1. Return the result of performing IteratorBindingInitialization for |FormalParameter| using _iteratorRecord_ and _environment_ as the arguments.
      </emu-alg>
      <emu-grammar>FormalParameter : BindingElement</emu-grammar>
      <emu-alg>
        1. If ContainsExpression of |BindingElement| is *false*, return the result of performing IteratorBindingInitialization for |BindingElement| using _iteratorRecord_ and _environment_ as the arguments.
        1. Let _currentContext_ be the running execution context.
        1. Let _originalEnv_ be the VariableEnvironment of _currentContext_.
        1. Assert: The VariableEnvironment and LexicalEnvironment of _currentContext_ are the same.
        1. Assert: If _environment_ is not *undefined*, then _environment_ and _originalEnv_ are the same.
        1. Let _paramVarEnv_ be NewDeclarativeEnvironment(_originalEnv_).
        1. Set the VariableEnvironment of _currentContext_ to _paramVarEnv_.
        1. Set the LexicalEnvironment of _currentContext_ to _paramVarEnv_.
        1. Let _result_ be the result of performing IteratorBindingInitialization for |BindingElement| using _iteratorRecord_ and _environment_ as the arguments.
        1. Set the VariableEnvironment of _currentContext_ to _originalEnv_.
        1. Set the LexicalEnvironment of _currentContext_ to _originalEnv_.
        1. Return _result_.
      </emu-alg>
      <emu-note>
        <p>The new Environment Record created in step 6 is only used if the |BindingElement| contains a direct eval.</p>
      </emu-note>
      <emu-grammar>FunctionRestParameter : BindingRestElement</emu-grammar>
      <emu-alg>
        1. If ContainsExpression of |BindingRestElement| is *false*, return the result of performing IteratorBindingInitialization for |BindingRestElement| using _iteratorRecord_ and _environment_ as the arguments.
        1. Let _currentContext_ be the running execution context.
        1. Let _originalEnv_ be the VariableEnvironment of _currentContext_.
        1. Assert: The VariableEnvironment and LexicalEnvironment of _currentContext_ are the same.
        1. Assert: If _environment_ is not *undefined*, then _environment_ and _originalEnv_ are the same.
        1. Let _paramVarEnv_ be NewDeclarativeEnvironment(_originalEnv_).
        1. Set the VariableEnvironment of _currentContext_ to _paramVarEnv_.
        1. Set the LexicalEnvironment of _currentContext_ to _paramVarEnv_.
        1. Let _result_ be the result of performing IteratorBindingInitialization for |BindingRestElement| using _iteratorRecord_ and _environment_ as the arguments.
        1. Set the VariableEnvironment of _currentContext_ to _originalEnv_.
        1. Set the LexicalEnvironment of _currentContext_ to _originalEnv_.
        1. Return _result_.
      </emu-alg>
      <emu-note>
        <p>The new Environment Record created in step 6 is only used if the |BindingRestElement| contains a direct eval.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-function-definitions-runtime-semantics-instantiatefunctionobject">
      <h1>Runtime Semantics: InstantiateFunctionObject</h1>
      <p>With parameter _scope_.</p>
      <emu-see-also-para op="InstantiateFunctionObject"></emu-see-also-para>
      <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. If the function code for |FunctionDeclaration| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
        1. Let _name_ be StringValue of |BindingIdentifier|.
        1. Let _F_ be FunctionCreate(~Normal~, |FormalParameters|, |FunctionBody|, _scope_, _strict_).
        1. Perform MakeConstructor(_F_).
        1. Perform SetFunctionName(_F_, _name_).
        1. Set _F_.[[SourceText]] to the source text matched by |FunctionDeclaration|.
        1. Return _F_.
      </emu-alg>
      <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Let _F_ be FunctionCreate(~Normal~, |FormalParameters|, |FunctionBody|, _scope_, *true*).
        1. Perform MakeConstructor(_F_).
        1. Perform SetFunctionName(_F_, `"default"`).
        1. Set _F_.[[SourceText]] to the source text matched by |FunctionDeclaration|.
        1. Return _F_.
      </emu-alg>
      <emu-note>
        <p>An anonymous |FunctionDeclaration| can only occur as part of an `export default` declaration, and its function code is therefore always strict mode code.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-function-definitions-runtime-semantics-namedevaluation">
      <h1>Runtime Semantics: NamedEvaluation</h1>
      <p>With parameter _name_.</p>
      <emu-grammar>FunctionExpression : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Let _closure_ be the result of evaluating this |FunctionExpression|.
        1. Perform SetFunctionName(_closure_, _name_).
        1. Return _closure_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-function-definitions-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return NormalCompletion(~empty~).
      </emu-alg>
      <emu-note>
        <p>An alternative semantics is provided in <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics"></emu-xref>.</p>
      </emu-note>
      <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return NormalCompletion(~empty~).
      </emu-alg>
      <emu-grammar>FunctionExpression : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. If the function code for |FunctionExpression| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
        1. Let _scope_ be the LexicalEnvironment of the running execution context.
        1. Let _closure_ be FunctionCreate(~Normal~, |FormalParameters|, |FunctionBody|, _scope_, _strict_).
        1. Perform MakeConstructor(_closure_).
        1. Set _closure_.[[SourceText]] to the source text matched by |FunctionExpression|.
        1. Return _closure_.
      </emu-alg>
      <emu-grammar>FunctionExpression : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. If the function code for |FunctionExpression| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
        1. Let _scope_ be the running execution context's LexicalEnvironment.
        1. Let _funcEnv_ be NewDeclarativeEnvironment(_scope_).
        1. Let _envRec_ be _funcEnv_'s EnvironmentRecord.
        1. Let _name_ be StringValue of |BindingIdentifier|.
        1. Perform _envRec_.CreateImmutableBinding(_name_, *false*).
        1. Let _closure_ be FunctionCreate(~Normal~, |FormalParameters|, |FunctionBody|, _funcEnv_, _strict_).
        1. Perform MakeConstructor(_closure_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Set _closure_.[[SourceText]] to the source text matched by |FunctionExpression|.
        1. Perform _envRec_.InitializeBinding(_name_, _closure_).
        1. Return _closure_.
      </emu-alg>
      <emu-note>
        <p>The |BindingIdentifier| in a |FunctionExpression| can be referenced from inside the |FunctionExpression|'s |FunctionBody| to allow the function to call itself recursively. However, unlike in a |FunctionDeclaration|, the |BindingIdentifier| in a |FunctionExpression| cannot be referenced from and does not affect the scope enclosing the |FunctionExpression|.</p>
      </emu-note>
      <emu-note>
        <p>A `prototype` property is automatically created for every function defined using a |FunctionDeclaration| or |FunctionExpression|, to allow for the possibility that the function will be used as a constructor.</p>
      </emu-note>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. Return NormalCompletion(*undefined*).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-arrow-function-definitions">
    <h1>Arrow Function Definitions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ArrowFunction[In, Yield, Await] :
        ArrowParameters[?Yield, ?Await] [no LineTerminator here] `=&gt;` ConciseBody[?In]

      ArrowParameters[Yield, Await] :
        BindingIdentifier[?Yield, ?Await]
        CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await] #parencover

      ConciseBody[In] :
        [lookahead != `{` ] AssignmentExpression[?In, ~Yield, ~Await]
        `{` FunctionBody[~Yield, ~Await] `}`
    </emu-grammar>
    <h2>Supplemental Syntax</h2>
    <p>When the production
      <br>
      <emu-grammar>ArrowParameters[Yield, Await] : CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]</emu-grammar>
      <br>
      is recognized the following grammar is used to refine the interpretation of |CoverParenthesizedExpressionAndArrowParameterList|:</p>
    <emu-grammar type="definition">
      ArrowFormalParameters[Yield, Await] :
        `(` UniqueFormalParameters[?Yield, ?Await] `)`
    </emu-grammar>

    <emu-clause id="sec-arrow-function-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>ArrowFunction : ArrowParameters `=&gt;` ConciseBody</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if |ArrowParameters| Contains |YieldExpression| is *true*.
        </li>
        <li>
          It is a Syntax Error if |ArrowParameters| Contains |AwaitExpression| is *true*.
        </li>
        <li>
          It is a Syntax Error if ContainsUseStrict of |ConciseBody| is *true* and IsSimpleParameterList of |ArrowParameters| is *false*.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |ArrowParameters| also occurs in the LexicallyDeclaredNames of |ConciseBody|.
        </li>
      </ul>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if |CoverParenthesizedExpressionAndArrowParameterList| is not covering an |ArrowFormalParameters|.
        </li>
        <li>
          All early error rules for |ArrowFormalParameters| and its derived productions also apply to CoveredFormalsList of |CoverParenthesizedExpressionAndArrowParameterList|.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-arrow-function-definitions-static-semantics-boundnames">
      <h1>Static Semantics: BoundNames</h1>
      <emu-see-also-para op="BoundNames"></emu-see-also-para>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. Let _formals_ be CoveredFormalsList of |CoverParenthesizedExpressionAndArrowParameterList|.
        1. Return the BoundNames of _formals_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-arrow-function-definitions-static-semantics-contains">
      <h1>Static Semantics: Contains</h1>
      <p>With parameter _symbol_.</p>
      <emu-see-also-para op="Contains"></emu-see-also-para>
      <emu-grammar>ArrowFunction : ArrowParameters `=&gt;` ConciseBody</emu-grammar>
      <emu-alg>
        1. If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, `super` or `this`, return *false*.
        1. If |ArrowParameters| Contains _symbol_ is *true*, return *true*.
        1. Return |ConciseBody| Contains _symbol_.
      </emu-alg>
      <emu-note>
        <p>Normally, Contains does not look inside most function forms. However, Contains is used to detect `new.target`, `this`, and `super` usage within an |ArrowFunction|.</p>
      </emu-note>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. Let _formals_ be CoveredFormalsList of |CoverParenthesizedExpressionAndArrowParameterList|.
        1. Return _formals_ Contains _symbol_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-arrow-function-definitions-static-semantics-containsexpression">
      <h1>Static Semantics: ContainsExpression</h1>
      <emu-see-also-para op="ContainsExpression"></emu-see-also-para>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-arrow-function-definitions-static-semantics-containsusestrict">
      <h1>Static Semantics: ContainsUseStrict</h1>
      <emu-see-also-para op="ContainsUseStrict"></emu-see-also-para>
      <emu-grammar>ConciseBody : AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-arrow-function-definitions-static-semantics-expectedargumentcount">
      <h1>Static Semantics: ExpectedArgumentCount</h1>
      <emu-see-also-para op="ExpectedArgumentCount"></emu-see-also-para>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. Return 1.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-arrow-function-definitions-static-semantics-hasname">
      <h1>Static Semantics: HasName</h1>
      <emu-see-also-para op="HasName"></emu-see-also-para>
      <emu-grammar>ArrowFunction : ArrowParameters `=&gt;` ConciseBody</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-arrow-function-definitions-static-semantics-issimpleparameterlist">
      <h1>Static Semantics: IsSimpleParameterList</h1>
      <emu-see-also-para op="IsSimpleParameterList"></emu-see-also-para>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. Let _formals_ be CoveredFormalsList of |CoverParenthesizedExpressionAndArrowParameterList|.
        1. Return IsSimpleParameterList of _formals_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-coveredformalslist">
      <h1>Static Semantics: CoveredFormalsList</h1>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. Return this |ArrowParameters|.
      </emu-alg>
      <emu-grammar>
        CoverParenthesizedExpressionAndArrowParameterList :
          `(` Expression `)`
          `(` `)`
          `(` `...` BindingIdentifier `)`
          `(` `...` BindingPattern `)`
          `(` Expression `,` `...` BindingIdentifier `)`
          `(` Expression `,` `...` BindingPattern `)`
      </emu-grammar>
      <emu-alg>
        1. Return the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-arrow-function-definitions-static-semantics-lexicallydeclarednames">
      <h1>Static Semantics: LexicallyDeclaredNames</h1>
      <emu-see-also-para op="LexicallyDeclaredNames"></emu-see-also-para>
      <emu-grammar>ConciseBody : AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-arrow-function-definitions-static-semantics-lexicallyscopeddeclarations">
      <h1>Static Semantics: LexicallyScopedDeclarations</h1>
      <emu-see-also-para op="LexicallyScopedDeclarations"></emu-see-also-para>
      <emu-grammar>ConciseBody : AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-arrow-function-definitions-static-semantics-vardeclarednames">
      <h1>Static Semantics: VarDeclaredNames</h1>
      <emu-see-also-para op="VarDeclaredNames"></emu-see-also-para>
      <emu-grammar>ConciseBody : AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-arrow-function-definitions-static-semantics-varscopeddeclarations">
      <h1>Static Semantics: VarScopedDeclarations</h1>
      <emu-see-also-para op="VarScopedDeclarations"></emu-see-also-para>
      <emu-grammar>ConciseBody : AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-arrow-function-definitions-runtime-semantics-iteratorbindinginitialization">
      <h1>Runtime Semantics: IteratorBindingInitialization</h1>
      <p>With parameters _iteratorRecord_ and _environment_.</p>
      <emu-see-also-para op="IteratorBindingInitialization"></emu-see-also-para>
      <emu-note>
        <p>When *undefined* is passed for _environment_ it indicates that a PutValue operation should be used to assign the initialization value. This is the case for formal parameter lists of non-strict functions. In that case the formal parameter bindings are preinitialized in order to deal with the possibility of multiple parameters with the same name.</p>
      </emu-note>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. Assert: _iteratorRecord_.[[Done]] is *false*.
        1. Let _next_ be IteratorStep(_iteratorRecord_).
        1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
        1. ReturnIfAbrupt(_next_).
        1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.
        1. Else,
          1. Let _v_ be IteratorValue(_next_).
          1. If _v_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
          1. ReturnIfAbrupt(_v_).
        1. If _iteratorRecord_.[[Done]] is *true*, let _v_ be *undefined*.
        1. Return the result of performing BindingInitialization for |BindingIdentifier| using _v_ and _environment_ as the arguments.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-arrow-function-definitions-runtime-semantics-evaluatebody">
      <h1>Runtime Semantics: EvaluateBody</h1>
      <p>With parameters _functionObject_ and List _argumentsList_.</p>
      <emu-see-also-para op="EvaluateBody"></emu-see-also-para>
      <emu-grammar>ConciseBody : AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).
        1. Let _exprRef_ be the result of evaluating |AssignmentExpression|.
        1. Let _exprValue_ be ? GetValue(_exprRef_).
        1. Return Completion { [[Type]]: ~return~, [[Value]]: _exprValue_, [[Target]]: ~empty~ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-arrow-function-definitions-runtime-semantics-namedevaluation">
      <h1>Runtime Semantics: NamedEvaluation</h1>
      <p>With parameter _name_.</p>
      <emu-grammar>ArrowFunction : ArrowParameters `=&gt;` ConciseBody</emu-grammar>
      <emu-alg>
        1. Let _closure_ be the result of evaluating this |ArrowFunction|.
        1. Perform SetFunctionName(_closure_, _name_).
        1. Return _closure_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-arrow-function-definitions-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>ArrowFunction : ArrowParameters `=&gt;` ConciseBody</emu-grammar>
      <emu-alg>
        1. If the function code for this |ArrowFunction| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
        1. Let _scope_ be the LexicalEnvironment of the running execution context.
        1. Let _parameters_ be CoveredFormalsList of |ArrowParameters|.
        1. Let _closure_ be FunctionCreate(~Arrow~, _parameters_, |ConciseBody|, _scope_, _strict_).
        1. Set _closure_.[[SourceText]] to the source text matched by |ArrowFunction|.
        1. Return _closure_.
      </emu-alg>
      <emu-note>
        <p>An |ArrowFunction| does not define local bindings for `arguments`, `super`, `this`, or `new.target`. Any reference to `arguments`, `super`, `this`, or `new.target` within an |ArrowFunction| must resolve to a binding in a lexically enclosing environment. Typically this will be the Function Environment of an immediately enclosing function. Even though an |ArrowFunction| may contain references to `super`, the function object created in step 4 is not made into a method by performing MakeMethod. An |ArrowFunction| that references `super` is always contained within a non-|ArrowFunction| and the necessary state to implement `super` is accessible via the _scope_ that is captured by the function object of the |ArrowFunction|.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-method-definitions">
    <h1>Method Definitions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      MethodDefinition[Yield, Await] :
        PropertyName[?Yield, ?Await] `(` UniqueFormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`
        GeneratorMethod[?Yield, ?Await]
        AsyncMethod[?Yield, ?Await]
        AsyncGeneratorMethod[?Yield, ?Await]
        `get` PropertyName[?Yield, ?Await] `(` `)` `{` FunctionBody[~Yield, ~Await] `}`
        `set` PropertyName[?Yield, ?Await] `(` PropertySetParameterList `)` `{` FunctionBody[~Yield, ~Await] `}`

      PropertySetParameterList :
        FormalParameter[~Yield, ~Await]
    </emu-grammar>

    <emu-clause id="sec-method-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>MethodDefinition : PropertyName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if ContainsUseStrict of |FunctionBody| is *true* and IsSimpleParameterList of |UniqueFormalParameters| is *false*.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |UniqueFormalParameters| also occurs in the LexicallyDeclaredNames of |FunctionBody|.
        </li>
      </ul>
      <emu-grammar>MethodDefinition : `set` PropertyName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if BoundNames of |PropertySetParameterList| contains any duplicate elements.
        </li>
        <li>
          It is a Syntax Error if ContainsUseStrict of |FunctionBody| is *true* and IsSimpleParameterList of |PropertySetParameterList| is *false*.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |PropertySetParameterList| also occurs in the LexicallyDeclaredNames of |FunctionBody|.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-method-definitions-static-semantics-computedpropertycontains">
      <h1>Static Semantics: ComputedPropertyContains</h1>
      <p>With parameter _symbol_.</p>
      <emu-see-also-para op="ComputedPropertyContains"></emu-see-also-para>
      <emu-grammar>
        MethodDefinition :
          PropertyName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
          `get` PropertyName `(` `)` `{` FunctionBody `}`
          `set` PropertyName `(` PropertySetParameterList `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return the result of ComputedPropertyContains for |PropertyName| with argument _symbol_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-method-definitions-static-semantics-expectedargumentcount">
      <h1>Static Semantics: ExpectedArgumentCount</h1>
      <emu-see-also-para op="ExpectedArgumentCount"></emu-see-also-para>
      <emu-grammar>PropertySetParameterList : FormalParameter</emu-grammar>
      <emu-alg>
        1. If HasInitializer of |FormalParameter| is *true*, return 0.
        1. Return 1.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-method-definitions-static-semantics-hasdirectsuper">
      <h1>Static Semantics: HasDirectSuper</h1>
      <emu-see-also-para op="HasDirectSuper"></emu-see-also-para>
      <emu-grammar>MethodDefinition : PropertyName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.
        1. Return |FunctionBody| Contains |SuperCall|.
      </emu-alg>
      <emu-grammar>MethodDefinition : `get` PropertyName `(` `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return |FunctionBody| Contains |SuperCall|.
      </emu-alg>
      <emu-grammar>MethodDefinition : `set` PropertyName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. If |PropertySetParameterList| Contains |SuperCall| is *true*, return *true*.
        1. Return |FunctionBody| Contains |SuperCall|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-method-definitions-static-semantics-propname">
      <h1>Static Semantics: PropName</h1>
      <emu-see-also-para op="PropName"></emu-see-also-para>
      <emu-grammar>
        MethodDefinition :
          PropertyName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
          `get` PropertyName `(` `)` `{` FunctionBody `}`
          `set` PropertyName `(` PropertySetParameterList `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return PropName of |PropertyName|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-specialmethod">
      <h1>Static Semantics: SpecialMethod</h1>
      <emu-grammar>MethodDefinition : PropertyName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        MethodDefinition :
          GeneratorMethod
          AsyncMethod
          AsyncGeneratorMethod
          `get` PropertyName `(` `)` `{` FunctionBody `}`
          `set` PropertyName `(` PropertySetParameterList `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-definemethod">
      <h1>Runtime Semantics: DefineMethod</h1>
      <p>With parameters _object_ and optional parameter _functionPrototype_.</p>
      <emu-grammar>MethodDefinition : PropertyName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Let _propKey_ be the result of evaluating |PropertyName|.
        1. ReturnIfAbrupt(_propKey_).
        1. If the function code for this |MethodDefinition| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
        1. Let _scope_ be the running execution context's LexicalEnvironment.
        1. If _functionPrototype_ is present as a parameter, then
          1. Let _kind_ be ~Normal~.
          1. Let _prototype_ be _functionPrototype_.
        1. Else,
          1. Let _kind_ be ~Method~.
          1. Let _prototype_ be the intrinsic object %FunctionPrototype%.
        1. Let _closure_ be FunctionCreate(_kind_, |UniqueFormalParameters|, |FunctionBody|, _scope_, _strict_, _prototype_).
        1. Perform MakeMethod(_closure_, _object_).
        1. Set _closure_.[[SourceText]] to the source text matched by |MethodDefinition|.
        1. Return the Record { [[Key]]: _propKey_, [[Closure]]: _closure_ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-method-definitions-runtime-semantics-propertydefinitionevaluation">
      <h1>Runtime Semantics: PropertyDefinitionEvaluation</h1>
      <p>With parameters _object_ and _enumerable_.</p>
      <emu-see-also-para op="PropertyDefinitionEvaluation"></emu-see-also-para>
      <emu-grammar>MethodDefinition : PropertyName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Let _methodDef_ be DefineMethod of |MethodDefinition| with argument _object_.
        1. ReturnIfAbrupt(_methodDef_).
        1. Perform SetFunctionName(_methodDef_.[[Closure]], _methodDef_.[[Key]]).
        1. Let _desc_ be the PropertyDescriptor { [[Value]]: _methodDef_.[[Closure]], [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.
        1. Return ? DefinePropertyOrThrow(_object_, _methodDef_.[[Key]], _desc_).
      </emu-alg>
      <emu-grammar>MethodDefinition : `get` PropertyName `(` `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Let _propKey_ be the result of evaluating |PropertyName|.
        1. ReturnIfAbrupt(_propKey_).
        1. If the function code for this |MethodDefinition| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
        1. Let _scope_ be the running execution context's LexicalEnvironment.
        1. Let _formalParameterList_ be an instance of the production <emu-grammar>FormalParameters : [empty]</emu-grammar>.
        1. Let _closure_ be FunctionCreate(~Method~, _formalParameterList_, |FunctionBody|, _scope_, _strict_).
        1. Perform MakeMethod(_closure_, _object_).
        1. Perform SetFunctionName(_closure_, _propKey_, `"get"`).
        1. Set _closure_.[[SourceText]] to the source text matched by |MethodDefinition|.
        1. Let _desc_ be the PropertyDescriptor { [[Get]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.
        1. Return ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).
      </emu-alg>
      <emu-grammar>MethodDefinition : `set` PropertyName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Let _propKey_ be the result of evaluating |PropertyName|.
        1. ReturnIfAbrupt(_propKey_).
        1. If the function code for this |MethodDefinition| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
        1. Let _scope_ be the running execution context's LexicalEnvironment.
        1. Let _closure_ be FunctionCreate(~Method~, |PropertySetParameterList|, |FunctionBody|, _scope_, _strict_).
        1. Perform MakeMethod(_closure_, _object_).
        1. Perform SetFunctionName(_closure_, _propKey_, `"set"`).
        1. Set _closure_.[[SourceText]] to the source text matched by |MethodDefinition|.
        1. Let _desc_ be the PropertyDescriptor { [[Set]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.
        1. Return ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-generator-function-definitions">
    <h1>Generator Function Definitions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      GeneratorMethod[Yield, Await] :
        `*` PropertyName[?Yield, ?Await] `(` UniqueFormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`

      GeneratorDeclaration[Yield, Await, Default] :
        `function` `*` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`
        [+Default] `function` `*` `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`

      GeneratorExpression :
        `function` `*` BindingIdentifier[+Yield, ~Await]? `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`

      GeneratorBody :
        FunctionBody[+Yield, ~Await]

      YieldExpression[In, Await] :
        `yield`
        `yield` [no LineTerminator here] AssignmentExpression[?In, +Yield, ?Await]
        `yield` [no LineTerminator here] `*` AssignmentExpression[?In, +Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>The syntactic context immediately following `yield` requires use of the |InputElementRegExpOrTemplateTail| lexical goal.</p>
    </emu-note>
    <emu-note>
      <p>|YieldExpression| cannot be used within the |FormalParameters| of a generator function because any expressions that are part of |FormalParameters| are evaluated before the resulting generator object is in a resumable state.</p>
    </emu-note>
    <emu-note>
      <p>Abstract operations relating to generator objects are defined in <emu-xref href="#sec-generator-abstract-operations"></emu-xref>.</p>
    </emu-note>

    <emu-clause id="sec-generator-function-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>GeneratorMethod : `*` PropertyName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if HasDirectSuper of |GeneratorMethod| is *true*.
        </li>
        <li>
          It is a Syntax Error if |UniqueFormalParameters| Contains |YieldExpression| is *true*.
        </li>
        <li>
          It is a Syntax Error if ContainsUseStrict of |GeneratorBody| is *true* and IsSimpleParameterList of |UniqueFormalParameters| is *false*.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |UniqueFormalParameters| also occurs in the LexicallyDeclaredNames of |GeneratorBody|.
        </li>
      </ul>
      <emu-grammar>
        GeneratorDeclaration : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorDeclaration : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorExpression : `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`
      </emu-grammar>
      <ul>
        <li>
          If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.
        </li>
        <li>
          If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is `"eval"` or `"arguments"`.
        </li>
        <li>
          It is a Syntax Error if ContainsUseStrict of |GeneratorBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |GeneratorBody|.
        </li>
        <li>
          It is a Syntax Error if |FormalParameters| Contains |YieldExpression| is *true*.
        </li>
        <li>
          It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.
        </li>
        <li>
          It is a Syntax Error if |GeneratorBody| Contains |SuperProperty| is *true*.
        </li>
        <li>
          It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.
        </li>
        <li>
          It is a Syntax Error if |GeneratorBody| Contains |SuperCall| is *true*.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-generator-function-definitions-static-semantics-boundnames">
      <h1>Static Semantics: BoundNames</h1>
      <emu-see-also-para op="BoundNames"></emu-see-also-para>
      <emu-grammar>GeneratorDeclaration : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>GeneratorDeclaration : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return &laquo; `"*default*"` &raquo;.
      </emu-alg>
      <emu-note>
        <p>`"*default*"` is used within this specification as a synthetic name for hoistable anonymous functions that are defined using export declarations.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-generator-function-definitions-static-semantics-computedpropertycontains">
      <h1>Static Semantics: ComputedPropertyContains</h1>
      <p>With parameter _symbol_.</p>
      <emu-see-also-para op="ComputedPropertyContains"></emu-see-also-para>
      <emu-grammar>GeneratorMethod : `*` PropertyName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return the result of ComputedPropertyContains for |PropertyName| with argument _symbol_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-generator-function-definitions-static-semantics-contains">
      <h1>Static Semantics: Contains</h1>
      <p>With parameter _symbol_.</p>
      <emu-see-also-para op="Contains"></emu-see-also-para>
      <emu-grammar>
        GeneratorDeclaration : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorDeclaration : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorExpression : `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-note>
        <p>Static semantic rules that depend upon substructure generally do not look into function definitions.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-generator-function-definitions-static-semantics-hasdirectsuper">
      <h1>Static Semantics: HasDirectSuper</h1>
      <emu-see-also-para op="HasDirectSuper"></emu-see-also-para>
      <emu-grammar>GeneratorMethod : `*` PropertyName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.
        1. Return |GeneratorBody| Contains |SuperCall|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-generator-function-definitions-static-semantics-hasname">
      <h1>Static Semantics: HasName</h1>
      <emu-see-also-para op="HasName"></emu-see-also-para>
      <emu-grammar>GeneratorExpression : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>GeneratorExpression : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-generator-function-definitions-static-semantics-isconstantdeclaration">
      <h1>Static Semantics: IsConstantDeclaration</h1>
      <emu-see-also-para op="IsConstantDeclaration"></emu-see-also-para>
      <emu-grammar>
        GeneratorDeclaration : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorDeclaration : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-generator-function-definitions-static-semantics-isfunctiondefinition">
      <h1>Static Semantics: IsFunctionDefinition</h1>
      <emu-see-also-para op="IsFunctionDefinition"></emu-see-also-para>
      <emu-grammar>GeneratorExpression : `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-generator-function-definitions-static-semantics-propname">
      <h1>Static Semantics: PropName</h1>
      <emu-see-also-para op="PropName"></emu-see-also-para>
      <emu-grammar>GeneratorMethod : `*` PropertyName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return PropName of |PropertyName|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-generator-function-definitions-runtime-semantics-evaluatebody">
      <h1>Runtime Semantics: EvaluateBody</h1>
      <p>With parameters _functionObject_ and List _argumentsList_.</p>
      <emu-see-also-para op="EvaluateBody"></emu-see-also-para>
      <emu-grammar>GeneratorBody : FunctionBody</emu-grammar>
      <emu-alg>
        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).
        1. Let _G_ be ? OrdinaryCreateFromConstructor(_functionObject_, `"%GeneratorPrototype%"`, &laquo; [[GeneratorState]], [[GeneratorContext]] &raquo;).
        1. Perform GeneratorStart(_G_, |FunctionBody|).
        1. Return Completion { [[Type]]: ~return~, [[Value]]: _G_, [[Target]]: ~empty~ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-generator-function-definitions-runtime-semantics-instantiatefunctionobject">
      <h1>Runtime Semantics: InstantiateFunctionObject</h1>
      <p>With parameter _scope_.</p>
      <emu-see-also-para op="InstantiateFunctionObject"></emu-see-also-para>
      <emu-grammar>GeneratorDeclaration : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. If the function code for |GeneratorDeclaration| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
        1. Let _name_ be StringValue of |BindingIdentifier|.
        1. Let _F_ be GeneratorFunctionCreate(~Normal~, |FormalParameters|, |GeneratorBody|, _scope_, _strict_).
        1. Let _prototype_ be ObjectCreate(%GeneratorPrototype%).
        1. Perform DefinePropertyOrThrow(_F_, `"prototype"`, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Perform SetFunctionName(_F_, _name_).
        1. Set _F_.[[SourceText]] to the source text matched by |GeneratorDeclaration|.
        1. Return _F_.
      </emu-alg>
      <emu-grammar>GeneratorDeclaration : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Let _F_ be GeneratorFunctionCreate(~Normal~, |FormalParameters|, |GeneratorBody|, _scope_, *true*).
        1. Let _prototype_ be ObjectCreate(%GeneratorPrototype%).
        1. Perform DefinePropertyOrThrow(_F_, `"prototype"`, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Perform SetFunctionName(_F_, `"default"`).
        1. Set _F_.[[SourceText]] to the source text matched by |GeneratorDeclaration|.
        1. Return _F_.
      </emu-alg>
      <emu-note>
        <p>An anonymous |GeneratorDeclaration| can only occur as part of an `export default` declaration, and its function code is therefore always strict mode code.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-generator-function-definitions-runtime-semantics-propertydefinitionevaluation">
      <h1>Runtime Semantics: PropertyDefinitionEvaluation</h1>
      <p>With parameters _object_ and _enumerable_.</p>
      <emu-see-also-para op="PropertyDefinitionEvaluation"></emu-see-also-para>
      <emu-grammar>GeneratorMethod : `*` PropertyName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Let _propKey_ be the result of evaluating |PropertyName|.
        1. ReturnIfAbrupt(_propKey_).
        1. If the function code for this |GeneratorMethod| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
        1. Let _scope_ be the running execution context's LexicalEnvironment.
        1. Let _closure_ be GeneratorFunctionCreate(~Method~, |UniqueFormalParameters|, |GeneratorBody|, _scope_, _strict_).
        1. Perform MakeMethod(_closure_, _object_).
        1. Let _prototype_ be ObjectCreate(%GeneratorPrototype%).
        1. Perform DefinePropertyOrThrow(_closure_, `"prototype"`, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Perform SetFunctionName(_closure_, _propKey_).
        1. Set _closure_.[[SourceText]] to the source text matched by |GeneratorMethod|.
        1. Let _desc_ be the PropertyDescriptor { [[Value]]: _closure_, [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.
        1. Return ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-generator-function-definitions-runtime-semantics-namedevaluation">
      <h1>Runtime Semantics: NamedEvaluation</h1>
      <p>With parameter _name_.</p>
      <emu-grammar>GeneratorExpression : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Let _closure_ be the result of evaluating this |GeneratorExpression|.
        1. Perform SetFunctionName(_closure_, _name_).
        1. Return _closure_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-generator-function-definitions-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>GeneratorExpression : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. If the function code for this |GeneratorExpression| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
        1. Let _scope_ be the LexicalEnvironment of the running execution context.
        1. Let _closure_ be GeneratorFunctionCreate(~Normal~, |FormalParameters|, |GeneratorBody|, _scope_, _strict_).
        1. Let _prototype_ be ObjectCreate(%GeneratorPrototype%).
        1. Perform DefinePropertyOrThrow(_closure_, `"prototype"`, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Set _closure_.[[SourceText]] to the source text matched by |GeneratorExpression|.
        1. Return _closure_.
      </emu-alg>
      <emu-grammar>GeneratorExpression : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. If the function code for this |GeneratorExpression| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
        1. Let _scope_ be the running execution context's LexicalEnvironment.
        1. Let _funcEnv_ be NewDeclarativeEnvironment(_scope_).
        1. Let _envRec_ be _funcEnv_'s EnvironmentRecord.
        1. Let _name_ be StringValue of |BindingIdentifier|.
        1. Perform _envRec_.CreateImmutableBinding(_name_, *false*).
        1. Let _closure_ be GeneratorFunctionCreate(~Normal~, |FormalParameters|, |GeneratorBody|, _funcEnv_, _strict_).
        1. Let _prototype_ be ObjectCreate(%GeneratorPrototype%).
        1. Perform DefinePropertyOrThrow(_closure_, `"prototype"`, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Perform _envRec_.InitializeBinding(_name_, _closure_).
        1. Set _closure_.[[SourceText]] to the source text matched by |GeneratorExpression|.
        1. Return _closure_.
      </emu-alg>
      <emu-note>
        <p>The |BindingIdentifier| in a |GeneratorExpression| can be referenced from inside the |GeneratorExpression|'s |FunctionBody| to allow the generator code to call itself recursively. However, unlike in a |GeneratorDeclaration|, the |BindingIdentifier| in a |GeneratorExpression| cannot be referenced from and does not affect the scope enclosing the |GeneratorExpression|.</p>
      </emu-note>
      <emu-grammar>YieldExpression : `yield`</emu-grammar>
      <emu-alg>
        1. Let _generatorKind_ be ! GetGeneratorKind().
        1. If _generatorKind_ is ~async~, then return ? AsyncGeneratorYield(*undefined*).
        1. Otherwise, return ? GeneratorYield(CreateIterResultObject(*undefined*, *false*)).
      </emu-alg>
      <emu-grammar>YieldExpression : `yield` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Let _generatorKind_ be ! GetGeneratorKind().
        1. Let _exprRef_ be the result of evaluating |AssignmentExpression|.
        1. Let _value_ be ? GetValue(_exprRef_).
        1. If _generatorKind_ is ~async~, then return ? AsyncGeneratorYield(_value_).
        1. Otherwise, return ? GeneratorYield(CreateIterResultObject(_value_, *false*)).
      </emu-alg>
      <emu-grammar>YieldExpression : `yield` `*` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Let _generatorKind_ be ! GetGeneratorKind().
        1. Let _exprRef_ be the result of evaluating |AssignmentExpression|.
        1. Let _value_ be ? GetValue(_exprRef_).
        1. Let _iteratorRecord_ be ? GetIterator(_value_, _generatorKind_).
        1. Let _iterator_ be _iteratorRecord_.[[Iterator]].
        1. Let _received_ be NormalCompletion(*undefined*).
        1. Repeat,
          1. If _received_.[[Type]] is ~normal~, then
            1. Let _innerResult_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]], &laquo; _received_.[[Value]] &raquo;).
            1. If _generatorKind_ is ~async~, then set _innerResult_ to ? Await(_innerResult_).
            1. If Type(_innerResult_) is not Object, throw a *TypeError* exception.
            1. Let _done_ be ? IteratorComplete(_innerResult_).
            1. If _done_ is *true*, then
              1. Return ? IteratorValue(_innerResult_).
            1. If _generatorKind_ is ~async~, then set _received_ to AsyncGeneratorYield(? IteratorValue(_innerResult_)).
            1. Else, set _received_ to GeneratorYield(_innerResult_).
          1. Else if _received_.[[Type]] is ~throw~, then
            1. Let _throw_ be ? GetMethod(_iterator_, `"throw"`).
            1. If _throw_ is not *undefined*, then
              1. Let _innerResult_ be ? Call(_throw_, _iterator_, &laquo; _received_.[[Value]] &raquo;).
              1. If _generatorKind_ is ~async~, then set _innerResult_ to ? Await(_innerResult_).
              1. NOTE: Exceptions from the inner iterator `throw` method are propagated. Normal completions from an inner `throw` method are processed similarly to an inner `next`.
              1. If Type(_innerResult_) is not Object, throw a *TypeError* exception.
              1. Let _done_ be ? IteratorComplete(_innerResult_).
              1. If _done_ is *true*, then
                1. Return ? IteratorValue(_innerResult_).
              1. If _generatorKind_ is ~async~, then set _received_ to AsyncGeneratorYield(? IteratorValue(_innerResult_)).
              1. Else, set _received_ to GeneratorYield(_innerResult_).
            1. Else,
              1. NOTE: If _iterator_ does not have a `throw` method, this throw is going to terminate the `yield*` loop. But first we need to give _iterator_ a chance to clean up.
              1. Let _closeCompletion_ be Completion { [[Type]]: ~normal~, [[Value]]: ~empty~, [[Target]]: ~empty~ }.
              1. If _generatorKind_ is ~async~, perform ? AsyncIteratorClose(_iteratorRecord_, _closeCompletion_).
              1. Else, perform ? IteratorClose(_iteratorRecord_, _closeCompletion_).
              1. NOTE: The next step throws a *TypeError* to indicate that there was a `yield*` protocol violation: _iterator_ does not have a `throw` method.
              1. Throw a *TypeError* exception.
          1. Else,
            1. Assert: _received_.[[Type]] is ~return~.
            1. Let _return_ be ? GetMethod(_iterator_, `"return"`).
            1. If _return_ is *undefined*, then
              1. If _generatorKind_ is ~async~, then set _received_.[[Value]] to ? Await(_received_.[[Value]]).
              1. Return Completion(_received_).
            1. Let _innerReturnResult_ be ? Call(_return_, _iterator_, &laquo; _received_.[[Value]] &raquo;).
            1. If _generatorKind_ is ~async~, then set _innerReturnResult_ to ? Await(_innerReturnResult_).
            1. If Type(_innerReturnResult_) is not Object, throw a *TypeError* exception.
            1. Let _done_ be ? IteratorComplete(_innerReturnResult_).
            1. If _done_ is *true*, then
              1. Let _value_ be ? IteratorValue(_innerReturnResult_).
              1. Return Completion { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }.
            1. If _generatorKind_ is ~async~, then set _received_ to AsyncGeneratorYield(? IteratorValue(_innerReturnResult_)).
            1. Else, set _received_ to GeneratorYield(_innerReturnResult_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-generator-function-definitions">
    <h1>Async Generator Function Definitions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      AsyncGeneratorMethod[Yield, Await] :
        `async` [no LineTerminator here] `*` PropertyName[?Yield, ?Await] `(` UniqueFormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

      AsyncGeneratorDeclaration[Yield, Await, Default] :
        `async` [no LineTerminator here] `function` `*` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`
        [+Default] `async` [no LineTerminator here] `function` `*` `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

      AsyncGeneratorExpression :
        `async` [no LineTerminator here] `function` `*` BindingIdentifier[+Yield, +Await]? `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

      AsyncGeneratorBody :
        FunctionBody[+Yield, +Await]
    </emu-grammar>
    <emu-note>
      <p>|YieldExpression| and |AwaitExpression| cannot be used within the |FormalParameters| of an async generator function because any expressions that are part of |FormalParameters| are evaluated before the resulting async generator object is in a resumable state.</p>
    </emu-note>
    <emu-note>
      <p>Abstract operations relating to async generator objects are defined in <emu-xref href="#sec-asyncgenerator-abstract-operations"></emu-xref>.</p>
    </emu-note>

    <emu-clause id="sec-async-generator-function-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` PropertyName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <ul>
        <li>It is a Syntax Error if HasDirectSuper of |AsyncGeneratorMethod| is *true*.</li>
        <li>It is a Syntax Error if |UniqueFormalParameters| Contains |YieldExpression| is *true*.</li>
        <li>It is a Syntax Error if |UniqueFormalParameters| Contains |AwaitExpression| is *true*.</li>
        <li>It is a Syntax Error if ContainsUseStrict of |AsyncGeneratorBody| is *true* and IsSimpleParameterList of |UniqueFormalParameters| is *false*.</li>
        <li>It is a Syntax Error if any element of the BoundNames of |UniqueFormalParameters| also occurs in the LexicallyDeclaredNames of |AsyncGeneratorBody|.</li>
      </ul>
      <emu-grammar>
        AsyncGeneratorDeclaration : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorDeclaration : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorExpression : `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <ul>
        <li>If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.</li>
        <li>If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is `"eval"` or `"arguments"`.</li>
        <li>It is a Syntax Error if ContainsUseStrict of |AsyncGeneratorBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.</li>
        <li>It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |AsyncGeneratorBody|.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |YieldExpression| is *true*.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |AwaitExpression| is *true*.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.</li>
        <li>It is a Syntax Error if |AsyncGeneratorBody| Contains |SuperProperty| is *true*.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.</li>
        <li>It is a Syntax Error if |AsyncGeneratorBody| Contains |SuperCall| is *true*.</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-async-generator-function-definitions-static-semantics-boundnames">
      <h1>Static Semantics: BoundNames</h1>
      <emu-see-also-para op="BoundNames"></emu-see-also-para>
      <emu-grammar>AsyncGeneratorDeclaration : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>AsyncGeneratorDeclaration : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return &laquo; `"*default*"` &raquo;.
      </emu-alg>
      <emu-note>
        <p>`"*default*"` is used within this specification as a synthetic name for hoistable anonymous functions that are defined using export declarations.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-async-generator-function-definitions-static-semantics-computedpropertycontains">
      <h1>Static Semantics: ComputedPropertyContains</h1>
      <p>With parameter _symbol_.</p>
      <emu-see-also-para op="ComputedPropertyContains"></emu-see-also-para>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` PropertyName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return the result of ComputedPropertyContains for |PropertyName| with argument _symbol_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-generator-function-definitions-static-semantics-contains">
      <h1>Static Semantics: Contains</h1>
      <p>With parameter _symbol_.</p>
      <emu-see-also-para op="Contains"></emu-see-also-para>
      <emu-grammar>
        AsyncGeneratorDeclaration : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorDeclaration : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorExpression : `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-note>
        <p>Static semantic rules that depend upon substructure generally do not look into function definitions.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-async-generator-function-definitions-static-semantics-hasdirectsuper">
      <h1>Static Semantics: HasDirectSuper</h1>
      <emu-see-also-para op="HasDirectSuper"></emu-see-also-para>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` PropertyName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.
        1. Return |AsyncGeneratorBody| Contains |SuperCall|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-generator-function-definitions-static-semantics-hasname">
      <h1>Static Semantics: HasName</h1>
      <emu-see-also-para op="HasName"></emu-see-also-para>
      <emu-grammar>AsyncGeneratorExpression : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>AsyncGeneratorExpression : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-generator-function-definitions-static-semantics-isconstantdeclaration">
      <h1>Static Semantics: IsConstantDeclaration</h1>
      <emu-see-also-para op="IsConstantDeclaration"></emu-see-also-para>
      <emu-grammar>
        AsyncGeneratorDeclaration : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorDeclaration : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-generator-function-definitions-static-semantics-isfunctiondefinition">
      <h1>Static Semantics: IsFunctionDefinition</h1>
      <emu-see-also-para op="IsFunctionDefinition"></emu-see-also-para>
      <emu-grammar>AsyncGeneratorExpression : `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-generator-function-definitions-static-semantics-propname">
      <h1>Static Semantics: PropName</h1>
      <emu-see-also-para op="PropName"></emu-see-also-para>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` PropertyName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return PropName of |PropertyName|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-asyncgenerator-definitions-evaluatebody">
      <h1>Runtime Semantics: EvaluateBody</h1>
      <p>With parameters _functionObject_ and List _argumentsList_.</p>
      <emu-grammar>
        AsyncGeneratorBody : FunctionBody
      </emu-grammar>
      <emu-alg>
        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).
        1. Let _generator_ be ? OrdinaryCreateFromConstructor(_functionObject_, `"%AsyncGeneratorPrototype%"`, &laquo; [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]] &raquo;).
        1. Perform ! AsyncGeneratorStart(_generator_, |FunctionBody|).
        1. Return Completion { [[Type]]: ~return~, [[Value]]: _generator_, [[Target]]: ~empty~ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-asyncgenerator-definitions-instantiatefunctionobject">
      <h1>Runtime Semantics: InstantiateFunctionObject</h1>
      <p>With parameter _scope_.</p>
      <emu-grammar>
        AsyncGeneratorDeclaration : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. If the function code for |AsyncGeneratorDeclaration| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
        1. Let _name_ be StringValue of |BindingIdentifier|.
        1. Let _F_ be ! AsyncGeneratorFunctionCreate(~Normal~, |FormalParameters|, |AsyncGeneratorBody|, _scope_, _strict_).
        1. Let _prototype_ be ! ObjectCreate(%AsyncGeneratorPrototype%).
        1. Perform ! DefinePropertyOrThrow(_F_, `"prototype"`, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Perform ! SetFunctionName(_F_, _name_).
        1. Set _F_.[[SourceText]] to the source text matched by |AsyncGeneratorDeclaration|.
        1. Return _F_.
      </emu-alg>

      <emu-grammar>
        AsyncGeneratorDeclaration : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. If the function code for |AsyncGeneratorDeclaration| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
        1. Let _F_ be AsyncGeneratorFunctionCreate(~Normal~, |FormalParameters|, |AsyncGeneratorBody|, _scope_, _strict_).
        1. Let _prototype_ be ObjectCreate(%AsyncGeneratorPrototype%).
        1. Perform DefinePropertyOrThrow(_F_, `"prototype"`, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Perform SetFunctionName(_F_, `"default"`).
        1. Set _F_.[[SourceText]] to the source text matched by |AsyncGeneratorDeclaration|.
        1. Return _F_.
      </emu-alg>
      <emu-note>
        <p>An anonymous |AsyncGeneratorDeclaration| can only occur as part of an `export default` declaration.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-asyncgenerator-definitions-propertydefinitionevaluation">
      <h1>Runtime Semantics: PropertyDefinitionEvaluation</h1>
      <p>With parameter _object_ and _enumerable_.</p>
      <emu-grammar>
        AsyncGeneratorMethod : `async` `*` PropertyName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. Let _propKey_ be the result of evaluating |PropertyName|.
        1. ReturnIfAbrupt(_propKey_).
        1. If the function code for this |AsyncGeneratorMethod| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
        1. Let _scope_ be the running execution context's LexicalEnvironment.
        1. Let _closure_ be ! AsyncGeneratorFunctionCreate(~Method~, |UniqueFormalParameters|, |AsyncGeneratorBody|, _scope_, _strict_).
        1. Perform ! MakeMethod(_closure_, _object_).
        1. Let _prototype_ be ! ObjectCreate(%AsyncGeneratorPrototype%).
        1. Perform ! DefinePropertyOrThrow(_closure_, `"prototype"`, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Perform ! SetFunctionName(_closure_, _propKey_).
        1. Set _closure_.[[SourceText]] to the source text matched by |AsyncGeneratorMethod|.
        1. Let _desc_ be PropertyDescriptor { [[Value]]: _closure_, [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.
        1. Return ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-asyncgenerator-definitions-namedevaluation">
      <h1>Runtime Semantics: NamedEvaluation</h1>
      <p>With parameter _name_.</p>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. Let _closure_ be the result of evaluating this |AsyncGeneratorExpression|.
        1. Perform SetFunctionName(_closure_, _name_).
        1. Return _closure_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-asyncgenerator-definitions-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>

      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. If the function code for this |AsyncGeneratorExpression| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
        1. Let _scope_ be the LexicalEnvironment of the running execution context.
        1. Let _closure_ be ! AsyncGeneratorFunctionCreate(~Normal~, |FormalParameters|, |AsyncGeneratorBody|, _scope_, _strict_).
        1. Let _prototype_ be ! ObjectCreate(%AsyncGeneratorPrototype%).
        1. Perform ! DefinePropertyOrThrow(_closure_, `"prototype"`, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Set _closure_.[[SourceText]] to the source text matched by |AsyncGeneratorExpression|.
        1. Return _closure_.
      </emu-alg>

      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. If the function code for this |AsyncGeneratorExpression| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
        1. Let _scope_ be the running execution context's LexicalEnvironment.
        1. Let _funcEnv_ be ! NewDeclarativeEnvironment(_scope_).
        1. Let _envRec_ be _funcEnv_'s EnvironmentRecord.
        1. Let _name_ be StringValue of |BindingIdentifier|.
        1. Perform ! _envRec_.CreateImmutableBinding(_name_).
        1. Let _closure_ be ! AsyncGeneratorFunctionCreate(~Normal~, |FormalParameters|, |AsyncGeneratorBody|, _funcEnv_, _strict_).
        1. Let _prototype_ be ! ObjectCreate(%AsyncGeneratorPrototype%).
        1. Perform ! DefinePropertyOrThrow(_closure_, `"prototype"`, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Perform ! SetFunctionName(_closure_, _name_).
        1. Perform ! _envRec_.InitializeBinding(_name_, _closure_).
        1. Set _closure_.[[SourceText]] to the source text matched by |AsyncGeneratorExpression|.
        1. Return _closure_.
      </emu-alg>
      <emu-note>
        <p>The |BindingIdentifier| in an |AsyncGeneratorExpression| can be referenced from inside the |AsyncGeneratorExpression|'s |AsyncGeneratorBody| to allow the generator code to call itself recursively. However, unlike in an |AsyncGeneratorDeclaration|, the |BindingIdentifier| in an |AsyncGeneratorExpression| cannot be referenced from and does not affect the scope enclosing the |AsyncGeneratorExpression|.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-class-definitions">
    <h1>Class Definitions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ClassDeclaration[Yield, Await, Default] :
        `class` BindingIdentifier[?Yield, ?Await] ClassTail[?Yield, ?Await]
        [+Default] `class` ClassTail[?Yield, ?Await]

      ClassExpression[Yield, Await] :
        `class` BindingIdentifier[?Yield, ?Await]? ClassTail[?Yield, ?Await]

      ClassTail[Yield, Await] :
        ClassHeritage[?Yield, ?Await]? `{` ClassBody[?Yield, ?Await]? `}`

      ClassHeritage[Yield, Await] :
        `extends` LeftHandSideExpression[?Yield, ?Await]

      ClassBody[Yield, Await] :
        ClassElementList[?Yield, ?Await]

      ClassElementList[Yield, Await] :
        ClassElement[?Yield, ?Await]
        ClassElementList[?Yield, ?Await] ClassElement[?Yield, ?Await]

      ClassElement[Yield, Await] :
        MethodDefinition[?Yield, ?Await]
        `static` MethodDefinition[?Yield, ?Await]
        `;`
    </emu-grammar>
    <emu-note>
      <p>A class definition is always strict mode code.</p>
    </emu-note>

    <emu-clause id="sec-class-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody `}`</emu-grammar>
      <ul>
        <li>
          <p>It is a Syntax Error if |ClassHeritage| is not present and the following algorithm evaluates to *true*:</p>
          <emu-alg>
            1. Let _constructor_ be ConstructorMethod of |ClassBody|.
            1. If _constructor_ is ~empty~, return *false*.
            1. Return HasDirectSuper of _constructor_.
          </emu-alg>
        </li>
      </ul>
      <emu-grammar>ClassBody : ClassElementList</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if PrototypePropertyNameList of |ClassElementList| contains more than one occurrence of `"constructor"`.
        </li>
      </ul>
      <emu-grammar>ClassElement : MethodDefinition</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if PropName of |MethodDefinition| is not `"constructor"` and HasDirectSuper of |MethodDefinition| is *true*.
        </li>
        <li>
          It is a Syntax Error if PropName of |MethodDefinition| is `"constructor"` and SpecialMethod of |MethodDefinition| is *true*.
        </li>
      </ul>
      <emu-grammar>ClassElement : `static` MethodDefinition</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if HasDirectSuper of |MethodDefinition| is *true*.
        </li>
        <li>
          It is a Syntax Error if PropName of |MethodDefinition| is `"prototype"`.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-class-definitions-static-semantics-boundnames">
      <h1>Static Semantics: BoundNames</h1>
      <emu-see-also-para op="BoundNames"></emu-see-also-para>
      <emu-grammar>ClassDeclaration : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. Return &laquo; `"*default*"` &raquo;.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-constructormethod">
      <h1>Static Semantics: ConstructorMethod</h1>
      <emu-grammar>ClassElementList : ClassElement</emu-grammar>
      <emu-alg>
        1. If |ClassElement| is <emu-grammar>ClassElement : `;`</emu-grammar> , return ~empty~.
        1. If IsStatic of |ClassElement| is *true*, return ~empty~.
        1. If PropName of |ClassElement| is not `"constructor"`, return ~empty~.
        1. Return |ClassElement|.
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. Let _head_ be ConstructorMethod of |ClassElementList|.
        1. If _head_ is not ~empty~, return _head_.
        1. If |ClassElement| is <emu-grammar>ClassElement : `;`</emu-grammar> , return ~empty~.
        1. If IsStatic of |ClassElement| is *true*, return ~empty~.
        1. If PropName of |ClassElement| is not `"constructor"`, return ~empty~.
        1. Return |ClassElement|.
      </emu-alg>
      <emu-note>
        <p>Early Error rules ensure that there is only one method definition named `"constructor"` and that it is not an accessor property or generator definition.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-class-definitions-static-semantics-contains">
      <h1>Static Semantics: Contains</h1>
      <p>With parameter _symbol_.</p>
      <emu-see-also-para op="Contains"></emu-see-also-para>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody `}`</emu-grammar>
      <emu-alg>
        1. If _symbol_ is |ClassBody|, return *true*.
        1. If _symbol_ is |ClassHeritage|, then
          1. If |ClassHeritage| is present, return *true*; otherwise return *false*.
        1. Let _inHeritage_ be |ClassHeritage| Contains _symbol_.
        1. If _inHeritage_ is *true*, return *true*.
        1. Return the result of ComputedPropertyContains for |ClassBody| with argument _symbol_.
      </emu-alg>
      <emu-note>
        <p>Static semantic rules that depend upon substructure generally do not look into class bodies except for |PropertyName|s.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-class-definitions-static-semantics-computedpropertycontains">
      <h1>Static Semantics: ComputedPropertyContains</h1>
      <p>With parameter _symbol_.</p>
      <emu-see-also-para op="ComputedPropertyContains"></emu-see-also-para>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. Let _inList_ be the result of ComputedPropertyContains for |ClassElementList| with argument _symbol_.
        1. If _inList_ is *true*, return *true*.
        1. Return the result of ComputedPropertyContains for |ClassElement| with argument _symbol_.
      </emu-alg>
      <emu-grammar>ClassElement : MethodDefinition</emu-grammar>
      <emu-alg>
        1. Return the result of ComputedPropertyContains for |MethodDefinition| with argument _symbol_.
      </emu-alg>
      <emu-grammar>ClassElement : `static` MethodDefinition</emu-grammar>
      <emu-alg>
        1. Return the result of ComputedPropertyContains for |MethodDefinition| with argument _symbol_.
      </emu-alg>
      <emu-grammar>ClassElement : `;`</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-class-definitions-static-semantics-hasname">
      <h1>Static Semantics: HasName</h1>
      <emu-see-also-para op="HasName"></emu-see-also-para>
      <emu-grammar>ClassExpression : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>ClassExpression : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-class-definitions-static-semantics-isconstantdeclaration">
      <h1>Static Semantics: IsConstantDeclaration</h1>
      <emu-see-also-para op="IsConstantDeclaration"></emu-see-also-para>
      <emu-grammar>
        ClassDeclaration : `class` BindingIdentifier ClassTail

        ClassDeclaration : `class` ClassTail
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-class-definitions-static-semantics-isfunctiondefinition">
      <h1>Static Semantics: IsFunctionDefinition</h1>
      <emu-see-also-para op="IsFunctionDefinition"></emu-see-also-para>
      <emu-grammar>ClassExpression : `class` BindingIdentifier? ClassTail</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isstatic">
      <h1>Static Semantics: IsStatic</h1>
      <emu-grammar>ClassElement : MethodDefinition</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>ClassElement : `static` MethodDefinition</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      <emu-grammar>ClassElement : `;`</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-nonconstructormethoddefinitions">
      <h1>Static Semantics: NonConstructorMethodDefinitions</h1>
      <emu-grammar>ClassElementList : ClassElement</emu-grammar>
      <emu-alg>
        1. If |ClassElement| is <emu-grammar>ClassElement : `;`</emu-grammar> , return a new empty List.
        1. If IsStatic of |ClassElement| is *false* and PropName of |ClassElement| is `"constructor"`, return a new empty List.
        1. Return a List containing |ClassElement|.
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. Let _list_ be NonConstructorMethodDefinitions of |ClassElementList|.
        1. If |ClassElement| is <emu-grammar>ClassElement : `;`</emu-grammar> , return _list_.
        1. If IsStatic of |ClassElement| is *false* and PropName of |ClassElement| is `"constructor"`, return _list_.
        1. Append |ClassElement| to the end of _list_.
        1. Return _list_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-prototypepropertynamelist">
      <h1>Static Semantics: PrototypePropertyNameList</h1>
      <emu-grammar>ClassElementList : ClassElement</emu-grammar>
      <emu-alg>
        1. If PropName of |ClassElement| is ~empty~, return a new empty List.
        1. If IsStatic of |ClassElement| is *true*, return a new empty List.
        1. Return a List containing PropName of |ClassElement|.
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. Let _list_ be PrototypePropertyNameList of |ClassElementList|.
        1. If PropName of |ClassElement| is ~empty~, return _list_.
        1. If IsStatic of |ClassElement| is *true*, return _list_.
        1. Append PropName of |ClassElement| to the end of _list_.
        1. Return _list_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-class-definitions-static-semantics-propname">
      <h1>Static Semantics: PropName</h1>
      <emu-see-also-para op="PropName"></emu-see-also-para>
      <emu-grammar>ClassElement : `;`</emu-grammar>
      <emu-alg>
        1. Return ~empty~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-classdefinitionevaluation">
      <h1>Runtime Semantics: ClassDefinitionEvaluation</h1>
      <p>With parameters _classBinding_ and _className_.</p>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody? `}`</emu-grammar>
      <emu-alg>
        1. Let _lex_ be the LexicalEnvironment of the running execution context.
        1. Let _classScope_ be NewDeclarativeEnvironment(_lex_).
        1. Let _classScopeEnvRec_ be _classScope_'s EnvironmentRecord.
        1. If _classBinding_ is not *undefined*, then
          1. Perform _classScopeEnvRec_.CreateImmutableBinding(_classBinding_, *true*).
        1. If |ClassHeritage_opt| is not present, then
          1. Let _protoParent_ be the intrinsic object %ObjectPrototype%.
          1. Let _constructorParent_ be the intrinsic object %FunctionPrototype%.
        1. Else,
          1. Set the running execution context's LexicalEnvironment to _classScope_.
          1. Let _superclassRef_ be the result of evaluating |ClassHeritage|.
          1. Set the running execution context's LexicalEnvironment to _lex_.
          1. Let _superclass_ be ? GetValue(_superclassRef_).
          1. If _superclass_ is *null*, then
            1. Let _protoParent_ be *null*.
            1. Let _constructorParent_ be the intrinsic object %FunctionPrototype%.
          1. Else if IsConstructor(_superclass_) is *false*, throw a *TypeError* exception.
          1. Else,
            1. Let _protoParent_ be ? Get(_superclass_, `"prototype"`).
            1. If Type(_protoParent_) is neither Object nor Null, throw a *TypeError* exception.
            1. Let _constructorParent_ be _superclass_.
        1. Let _proto_ be ObjectCreate(_protoParent_).
        1. If |ClassBody_opt| is not present, let _constructor_ be ~empty~.
        1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.
        1. If _constructor_ is ~empty~, then
          1. If |ClassHeritage_opt| is present, then
            1. Set _constructor_ to the result of parsing the source text
              <pre><code class="javascript">constructor(... args){ super (...args);}</code></pre>
              using the syntactic grammar with the goal symbol |MethodDefinition[~Yield, ~Await]|.
          1. Else,
            1. Set _constructor_ to the result of parsing the source text
              <pre><code class="javascript">constructor(){ }</code></pre>
              using the syntactic grammar with the goal symbol |MethodDefinition[~Yield, ~Await]|.
        1. Set the running execution context's LexicalEnvironment to _classScope_.
        1. Let _constructorInfo_ be the result of performing DefineMethod for _constructor_ with arguments _proto_ and _constructorParent_ as the optional _functionPrototype_ argument.
        1. Assert: _constructorInfo_ is not an abrupt completion.
        1. Let _F_ be _constructorInfo_.[[Closure]].
        1. If |ClassHeritage_opt| is present, set _F_.[[ConstructorKind]] to `"derived"`.
        1. Perform MakeConstructor(_F_, *false*, _proto_).
        1. Perform MakeClassConstructor(_F_).
        1. If _className_ is not *undefined*, then
          1. Perform SetFunctionName(_F_, _className_).
        1. Perform CreateMethodProperty(_proto_, `"constructor"`, _F_).
        1. If |ClassBody_opt| is not present, let _methods_ be a new empty List.
        1. Else, let _methods_ be NonConstructorMethodDefinitions of |ClassBody|.
        1. For each |ClassElement| _m_ in order from _methods_, do
          1. If IsStatic of _m_ is *false*, then
            1. Let _status_ be the result of performing PropertyDefinitionEvaluation for _m_ with arguments _proto_ and *false*.
          1. Else,
            1. Let _status_ be the result of performing PropertyDefinitionEvaluation for _m_ with arguments _F_ and *false*.
          1. If _status_ is an abrupt completion, then
            1. Set the running execution context's LexicalEnvironment to _lex_.
            1. Return Completion(_status_).
        1. Set the running execution context's LexicalEnvironment to _lex_.
        1. If _classBinding_ is not *undefined*, then
          1. Perform _classScopeEnvRec_.InitializeBinding(_classBinding_, _F_).
        1. Return _F_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-bindingclassdeclarationevaluation">
      <h1>Runtime Semantics: BindingClassDeclarationEvaluation</h1>
      <emu-grammar>ClassDeclaration : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. Let _className_ be StringValue of |BindingIdentifier|.
        1. Let _value_ be the result of ClassDefinitionEvaluation of |ClassTail| with arguments _className_ and _className_.
        1. ReturnIfAbrupt(_value_).
        1. Set _value_.[[SourceText]] to the source text matched by |ClassDeclaration|.
        1. Let _env_ be the running execution context's LexicalEnvironment.
        1. Perform ? InitializeBoundName(_className_, _value_, _env_).
        1. Return _value_.
      </emu-alg>
      <emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. Let _value_ be the result of ClassDefinitionEvaluation of |ClassTail| with arguments *undefined* and `"default"`.
        1. ReturnIfAbrupt(_value_).
        1. Set _value_.[[SourceText]] to the source text matched by |ClassDeclaration|.
        1. Return _value_.
      </emu-alg>
      <emu-note>
        <p><emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar> only occurs as part of an |ExportDeclaration| and establishing its binding is handled as part of the evaluation action for that production. See <emu-xref href="#sec-exports-runtime-semantics-evaluation"></emu-xref>.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-class-definitions-runtime-semantics-namedevaluation">
      <h1>Runtime Semantics: NamedEvaluation</h1>
      <p>With parameter _name_.</p>
      <emu-grammar>ClassExpression : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. Return the result of ClassDefinitionEvaluation of |ClassTail| with arguments *undefined* and _name_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-class-definitions-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>ClassDeclaration : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. Perform ? BindingClassDeclarationEvaluation of this |ClassDeclaration|.
        1. Return NormalCompletion(~empty~).
      </emu-alg>
      <emu-note>
        <p><emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar> only occurs as part of an |ExportDeclaration| and is never directly evaluated.</p>
      </emu-note>
      <emu-grammar>ClassExpression : `class` BindingIdentifier? ClassTail</emu-grammar>
      <emu-alg>
        1. If |BindingIdentifier_opt| is not present, let _className_ be *undefined*.
        1. Else, let _className_ be StringValue of |BindingIdentifier|.
        1. Let _value_ be the result of ClassDefinitionEvaluation of |ClassTail| with arguments _className_ and _className_.
        1. ReturnIfAbrupt(_value_).
        1. Set _value_.[[SourceText]] to the source text matched by |ClassExpression|.
        1. Return _value_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-function-definitions">
    <h1>Async Function Definitions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      AsyncFunctionDeclaration[Yield, Await, Default] :
        `async` [no LineTerminator here] `function` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`
        [+Default] `async` [no LineTerminator here] `function` `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

      AsyncFunctionExpression :
        `async` [no LineTerminator here] `function` `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`
        `async` [no LineTerminator here] `function` BindingIdentifier[~Yield, +Await] `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

      AsyncMethod[Yield, Await] :
        `async` [no LineTerminator here] PropertyName[?Yield, ?Await] `(` UniqueFormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

      AsyncFunctionBody :
        FunctionBody[~Yield, +Await]

      AwaitExpression[Yield] :
        `await` UnaryExpression[?Yield, +Await]
    </emu-grammar>

    <emu-note>
      <p>`await` is parsed as an |AwaitExpression| when the <sub>[Await]</sub> parameter is present. The <sub>[Await]</sub> parameter is present in the following contexts:</p>
      <ul>
        <li>In an |AsyncFunctionBody|.</li>
        <li>In the |FormalParameters| of an |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, or |AsyncGeneratorExpression|. |AwaitExpression| in this position is a Syntax error via static semantics.</li>
      </ul>
      <p>When |Module| is the syntactic goal symbol and the <sub>[Await]</sub> parameter is absent, `await` is parsed as a keyword and will be a Syntax error. When |Script| is the syntactic goal symbol, `await` may be parsed as an identifier when the <sub>[Await]</sub> parameter is absent. This includes the following contexts:</p>
      <ul>
        <li>Anywhere outside of an |AsyncFunctionBody| or |FormalParameters| of an |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, or |AsyncGeneratorExpression|.</li>
        <li>In the |BindingIdentifier| of a |FunctionExpression|, |GeneratorExpression|, or |AsyncGeneratorExpression|.</li>
      </ul>
    </emu-note>

    <emu-note>
      <p>Unlike |YieldExpression|, it is a Syntax Error to omit the operand of an |AwaitExpression|. You must await something.</p>
    </emu-note>

    <emu-clause id="sec-async-function-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>
        AsyncMethod : `async` PropertyName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <ul>
        <li>It is a Syntax Error if ContainsUseStrict of |AsyncFunctionBody| is *true* and IsSimpleParameterList of |UniqueFormalParameters| is *false*.</li>
        <li>It is a Syntax Error if HasDirectSuper of |AsyncMethod| is *true*.</li>
        <li>It is a Syntax Error if |UniqueFormalParameters| Contains |AwaitExpression| is *true*.</li>
        <li>It is a Syntax Error if any element of the BoundNames of |UniqueFormalParameters| also occurs in the LexicallyDeclaredNames of |AsyncFunctionBody|.</li>
      </ul>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionDeclaration : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <ul>
        <li>It is a Syntax Error if ContainsUseStrict of |AsyncFunctionBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |AwaitExpression| is *true*.</li>
        <li>If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.</li>
        <li>If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is `"eval"` or `"arguments"`.</li>
        <li>It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |AsyncFunctionBody|.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.</li>
        <li>It is a Syntax Error if |AsyncFunctionBody| Contains |SuperProperty| is *true*.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.</li>
        <li>It is a Syntax Error if |AsyncFunctionBody| Contains |SuperCall| is *true*.</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-async-function-definitions-static-semantics-BoundNames">
      <h1>Static Semantics: BoundNames</h1>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return &laquo; `"*default*"` &raquo;.
      </emu-alg>
      <emu-note>"`*default*`" is used within this specification as a synthetic name for hoistable anonymous functions that are defined using export declarations.</emu-note>
    </emu-clause>

    <emu-clause id="sec-async-function-definitions-static-semantics-ComputedPropertyContains">
      <h1>Static Semantics: ComputedPropertyContains</h1>
      <p>With parameter _symbol_.</p>
      <emu-grammar>
        AsyncMethod : `async` PropertyName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return the result of ComputedPropertyContains for |PropertyName| with argument _symbol_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-function-definitions-static-semantics-Contains">
      <h1>Static Semantics: Contains</h1>
      <p>With parameter _symbol_.</p>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionDeclaration : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-function-definitions-static-semantics-HasDirectSuper">
      <h1>Static Semantics: HasDirectSuper</h1>
      <emu-grammar>
        AsyncMethod : `async` PropertyName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.
        2. Return |AsyncFunctionBody| Contains |SuperCall|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-function-definitions-static-semantics-HasName">
      <h1>Static Semantics: HasName</h1>
      <emu-grammar>
        AsyncFunctionExpression : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionExpression : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-function-definitions-static-semantics-IsConstantDeclaration">
      <h1>Static Semantics: IsConstantDeclaration</h1>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionDeclaration : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-function-definitions-static-semantics-IsFunctionDefinition">
      <h1>Static Semantics: IsFunctionDefinition</h1>
      <emu-grammar>
        AsyncFunctionExpression : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-function-definitions-static-semantics-PropName">
      <h1>Static Semantics: PropName</h1>
      <emu-grammar>
        AsyncMethod : `async` PropertyName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return PropName of |PropertyName|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-function-definitions-InstantiateFunctionObject">
      <h1>Runtime Semantics: InstantiateFunctionObject</h1>
      <p>With parameter _scope_.</p>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. If the function code for |AsyncFunctionDeclaration| is strict mode code, let _strict_ be *true*. Otherwise, let _strict_ be *false*.
        1. Let _name_ be StringValue of |BindingIdentifier|.
        1. Let _F_ be ! AsyncFunctionCreate(~Normal~, |FormalParameters|, |AsyncFunctionBody|, _scope_, _strict_).
        1. Perform ! SetFunctionName(_F_, _name_).
        1. Set _F_.[[SourceText]] to the source text matched by |AsyncFunctionDeclaration|.
        1. Return _F_.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. If the function code for |AsyncFunctionDeclaration| is strict mode code, let _strict_ be *true*. Otherwise, let _strict_ be *false*.
        1. Let _F_ be ! AsyncFunctionCreate(~Normal~, |FormalParameters|, |AsyncFunctionBody|, _scope_, _strict_).
        1. Perform ! SetFunctionName(_F_, `"default"`).
        1. Set _F_.[[SourceText]] to the source text matched by |AsyncFunctionDeclaration|.
        1. Return _F_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-function-definitions-EvaluateBody">
      <h1>Runtime Semantics: EvaluateBody</h1>
      <p>With parameters _functionObject_ and List _argumentsList_.</p>
      <emu-grammar>
        AsyncFunctionBody : FunctionBody
      </emu-grammar>
      <emu-alg>
        1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
        1. Let _declResult_ be FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).
        1. If _declResult_ is not an abrupt completion, then
          1. Perform ! AsyncFunctionStart(_promiseCapability_, |FunctionBody|).
        1. Else _declResult_ is an abrupt completion,
          1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _declResult_.[[Value]] &raquo;).
        1. Return Completion { [[Type]]: ~return~, [[Value]]: _promiseCapability_.[[Promise]], [[Target]]: ~empty~ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-function-definitions-PropertyDefinitionEvaluation">
      <h1>Runtime Semantics: PropertyDefinitionEvaluation</h1>
      <p>With parameters _object_ and _enumerable_.</p>
      <emu-grammar>
        AsyncMethod : `async` PropertyName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Let _propKey_ be the result of evaluating |PropertyName|.
        1. ReturnIfAbrupt(_propKey_).
        1. If the function code for this |AsyncMethod| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
        1. Let _scope_ be the LexicalEnvironment of the running execution context.
        1. Let _closure_ be ! AsyncFunctionCreate(~Method~, |UniqueFormalParameters|, |AsyncFunctionBody|, _scope_, _strict_).
        1. Perform ! MakeMethod(_closure_, _object_).
        1. Perform ! SetFunctionName(_closure_, _propKey_).
        1. Set _closure_.[[SourceText]] to the source text matched by |AsyncMethod|.
        1. Let _desc_ be the PropertyDescriptor { [[Value]]: _closure_, [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.
        1. Return ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-function-definitions-runtime-semantics-namedevaluation">
      <h1>Runtime Semantics: NamedEvaluation</h1>
      <p>With parameter _name_.</p>
      <emu-grammar>
        AsyncFunctionExpression : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Let _closure_ be the result of evaluating this |AsyncFunctionExpression|.
        1. Perform SetFunctionName(_closure_, _name_).
        1. Return _closure_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-function-definitions-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return NormalCompletion(~empty~).
      </emu-alg>

      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return NormalCompletion(~empty~).
      </emu-alg>

      <emu-grammar>
        AsyncFunctionExpression : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. If the function code for |AsyncFunctionExpression| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
        1. Let _scope_ be the LexicalEnvironment of the running execution context.
        1. Let _closure_ be ! AsyncFunctionCreate(~Normal~, |FormalParameters|, |AsyncFunctionBody|, _scope_, _strict_).
        1. Set _closure_.[[SourceText]] to the source text matched by |AsyncFunctionExpression|.
        1. Return _closure_.
      </emu-alg>

      <emu-grammar>
        AsyncFunctionExpression : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. If the function code for |AsyncFunctionExpression| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
        1. Let _scope_ be the LexicalEnvironment of the running execution context.
        1. Let _funcEnv_ be ! NewDeclarativeEnvironment(_scope_).
        1. Let _envRec_ be _funcEnv_'s EnvironmentRecord.
        1. Let _name_ be StringValue of |BindingIdentifier|.
        1. Perform ! _envRec_.CreateImmutableBinding(_name_).
        1. Let _closure_ be ! AsyncFunctionCreate(~Normal~, |FormalParameters|, |AsyncFunctionBody|, _funcEnv_, _strict_).
        1. Perform ! SetFunctionName(_closure_, _name_).
        1. Perform ! _envRec_.InitializeBinding(_name_, _closure_).
        1. Set _closure_.[[SourceText]] to the source text matched by |AsyncFunctionExpression|.
        1. Return _closure_.
      </emu-alg>

      <emu-grammar>
        AwaitExpression : `await` UnaryExpression
      </emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be the result of evaluating |UnaryExpression|.
        1. Let _value_ be ? GetValue(_exprRef_).
        1. Return ? Await(_value_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-arrow-function-definitions">
    <h1>Async Arrow Function Definitions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      AsyncArrowFunction[In, Yield, Await] :
        `async` [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] `=>` AsyncConciseBody[?In]
        CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] [no LineTerminator here] `=>` AsyncConciseBody[?In] #callcover

      AsyncConciseBody[In] :
        [lookahead != `{`] AssignmentExpression[?In, ~Yield, +Await]
        `{` AsyncFunctionBody `}`

      AsyncArrowBindingIdentifier[Yield] :
        BindingIdentifier[?Yield, +Await]

      CoverCallExpressionAndAsyncArrowHead[Yield, Await] :
        MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
    </emu-grammar>
    <h2>Supplemental Syntax</h2>
    <p>When processing an instance of the production <emu-grammar>AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody</emu-grammar> the interpretation of |CoverCallExpressionAndAsyncArrowHead| is refined using the following grammar:</p>

    <emu-grammar type="definition">
      AsyncArrowHead :
        `async` [no LineTerminator here] ArrowFormalParameters[~Yield, +Await]
    </emu-grammar>

    <emu-clause id="sec-async-arrow-function-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
      </emu-grammar>
      <ul>
        <li>It is a Syntax Error if any element of the BoundNames of |AsyncArrowBindingIdentifier| also occurs in the LexicallyDeclaredNames of |AsyncConciseBody|.</li>
      </ul>
      <emu-grammar>
        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <ul>
        <li>It is a Syntax Error if |CoverCallExpressionAndAsyncArrowHead| Contains |YieldExpression| is *true*.</li>
        <li>It is a Syntax Error if |CoverCallExpressionAndAsyncArrowHead| Contains |AwaitExpression| is *true*.</li>
        <li>It is a Syntax Error if |CoverCallExpressionAndAsyncArrowHead| is not covering an |AsyncArrowHead|.</li>
        <li>It is a Syntax Error if any element of the BoundNames of |CoverCallExpressionAndAsyncArrowHead| also occurs in the LexicallyDeclaredNames of |AsyncConciseBody|.</li>
        <li>It is a Syntax Error if ContainsUseStrict of |AsyncConciseBody| is *true* and IsSimpleParameterList of |CoverCallExpressionAndAsyncArrowHead| is *false*.</li>
        <li>All Early Error rules for |AsyncArrowHead| and its derived productions apply to CoveredAsyncArrowHead of |CoverCallExpressionAndAsyncArrowHead|.</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-async-arrow-function-definitions-static-semantics-CoveredAsyncArrowHead">
      <h1>Static Semantics: CoveredAsyncArrowHead</h1>
      <emu-grammar>
        CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments
      </emu-grammar>
      <emu-alg>
        1. Return the |AsyncArrowHead| that is covered by |CoverCallExpressionAndAsyncArrowHead|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-arrow-function-definitions-static-semantics-BoundNames">
      <h1>Static Semantics: BoundNames</h1>
      <emu-grammar>
        CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments
      </emu-grammar>
      <emu-alg>
        1. Let _head_ be CoveredAsyncArrowHead of |CoverCallExpressionAndAsyncArrowHead|.
        1. Return the BoundNames of _head_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-arrow-function-definitions-static-semantics-Contains">
      <h1>Static Semantics: Contains</h1>
      <p>With parameter _symbol_.</p>
      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, `super`, or `this`, return *false*.
        1. Return |AsyncConciseBody| Contains _symbol_.
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, `super`, or `this`, return *false*.
        2. Let _head_ be CoveredAsyncArrowHead of |CoverCallExpressionAndAsyncArrowHead|.
        3. If _head_ Contains _symbol_ is *true*, return *true*.
        4. Return |AsyncConciseBody| Contains _symbol_.
      </emu-alg>
      <emu-note>Normally, Contains does not look inside most function forms. However, Contains is used to detect `new.target`, `this`, and `super` usage within an AsyncArrowFunction.</emu-note>
    </emu-clause>

    <emu-clause id="sec-async-arrow-function-definitions-static-semantics-ContainsExpression">
      <h1>Static Semantics: ContainsExpression</h1>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-arrow-function-definitions-static-semantics-ExpectedArgumentCount">
      <h1>Static Semantics: ExpectedArgumentCount</h1>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. Return 1.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-arrow-function-definitions-static-semantics-HasName">
      <h1>Static Semantics: HasName</h1>
      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody

        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-arrow-function-definitions-static-semantics-IsSimpleParameterList">
      <h1>Static Semantics: IsSimpleParameterList</h1>
      <emu-grammar>
        AsyncArrowBindingIdentifier[Yield] : BindingIdentifier[?Yield, +Await]
      </emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      <emu-grammar>
        CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments
      </emu-grammar>
      <emu-alg>
        1. Let _head_ be CoveredAsyncArrowHead of |CoverCallExpressionAndAsyncArrowHead|.
        1. Return IsSimpleParameterList of _head_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-arrow-function-definitions-static-semantics-LexicallyDeclaredNames">
      <h1>Static Semantics: LexicallyDeclaredNames</h1>
      <emu-grammar>
        AsyncConciseBody : AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-arrow-function-definitions-static-semantics-LexicallyScopedDeclarations">
      <h1>Static Semantics: LexicallyScopedDeclarations</h1>
      <emu-grammar>
        AsyncConciseBody : AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-arrow-function-definitions-static-semantics-VarDeclaredNames">
      <h1>Static Semantics: VarDeclaredNames</h1>
      <emu-grammar>
        AsyncConciseBody : AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-arrow-function-definitions-static-semantics-VarScopedDeclarations">
      <h1>Static Semantics: VarScopedDeclarations</h1>
      <emu-grammar>
        AsyncConciseBody : AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-arrow-function-definitions-IteratorBindingInitialization">
      <h1>Runtime Semantics: IteratorBindingInitialization</h1>
      <p>With parameters _iteratorRecord_ and _environment_.</p>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. Assert: _iteratorRecord_.[[Done]] is *false*.
        1. Let _next_ be IteratorStep(_iteratorRecord_).
        1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
        1. ReturnIfAbrupt(_next_).
        1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.
        1. Else,
          1. Let _v_ be IteratorValue(_next_).
          1. If _v_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
          1. ReturnIfAbrupt(_v_).
        1. If _iteratorRecord_.[[Done]] is *true*, let _v_ be *undefined*.
        1. Return the result of performing BindingInitialization for |BindingIdentifier| using _v_ and _environment_ as the arguments.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-arrow-function-definitions-EvaluateBody">
      <h1>Runtime Semantics: EvaluateBody</h1>
      <p>With parameters _functionObject_ and List _argumentsList_.</p>
      <emu-grammar>
        AsyncConciseBody : AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
        1. Let _declResult_ be FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).
        1. If _declResult_ is not an abrupt completion, then
          1. Perform ! AsyncFunctionStart(_promiseCapability_, |AssignmentExpression|).
        1. Else _declResult_ is an abrupt completion,
          1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _declResult_.[[Value]] &raquo;).
        1. Return Completion { [[Type]]: ~return~, [[Value]]: _promiseCapability_.[[Promise]], [[Target]]: ~empty~ }.
      </emu-alg>
      <emu-grammar>
        AsyncConciseBody : `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return the result of EvaluateBody of |AsyncFunctionBody| passing _functionObject_ and _argumentsList_ as the arguments.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-arrow-function-definitions-runtime-semantics-namedevaluation">
      <h1>Runtime Semantics: NamedEvaluation</h1>
      <p>With parameter _name_.</p>
      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody

        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. Let _closure_ be the result of evaluating this |AsyncArrowFunction|.
        1. Perform SetFunctionName(_closure_, _name_).
        1. Return _closure_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-arrow-function-definitions-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. If the function code for this |AsyncArrowFunction| is strict mode code, let _strict_ be *true*. Otherwise, let _strict_ be *false*.
        1. Let _scope_ be the LexicalEnvironment of the running execution context.
        1. Let _parameters_ be |AsyncArrowBindingIdentifier|.
        1. Let _closure_ be ! AsyncFunctionCreate(~Arrow~, _parameters_, |AsyncConciseBody|, _scope_, _strict_).
        1. Return _closure_.
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. If the function code for this |AsyncArrowFunction| is strict mode code, let _strict_ be *true*. Otherwise, let _strict_ be *false*.
        1. Let _scope_ be the LexicalEnvironment of the running execution context.
        1. Let _head_ be CoveredAsyncArrowHead of |CoverCallExpressionAndAsyncArrowHead|.
        1. Let _parameters_ be the |ArrowFormalParameters| of _head_.
        1. Let _closure_ be ! AsyncFunctionCreate(~Arrow~, _parameters_, |AsyncConciseBody|, _scope_, _strict_).
        1. Return _closure_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-tail-position-calls">
    <h1>Tail Position Calls</h1>

    <emu-clause id="sec-isintailposition" aoid="IsInTailPosition">
      <h1>Static Semantics: IsInTailPosition ( _call_ )</h1>
      <p>The abstract operation IsInTailPosition with argument _call_ performs the following steps:</p>
      <emu-alg>
        1. Assert: _call_ is a Parse Node.
        1. If the source code matching _call_ is non-strict code, return *false*.
        1. If _call_ is not contained within a |FunctionBody|, |ConciseBody|, or |AsyncConciseBody|, return *false*.
        1. Let _body_ be the |FunctionBody|, |ConciseBody|, or |AsyncConciseBody| that most closely contains _call_.
        1. If _body_ is the |FunctionBody| of a |GeneratorBody|, return *false*.
        1. If _body_ is the |FunctionBody| of an |AsyncFunctionBody|, return *false*.
        1. If _body_ is the |FunctionBody| of an |AsyncGeneratorBody|, return *false*.
        1. If _body_ is an |AsyncConciseBody|, return *false*.
        1. Return the result of HasCallInTailPosition of _body_ with argument _call_.
      </emu-alg>
      <emu-note>
        <p>Tail Position calls are only defined in strict mode code because of a common non-standard language extension (see <emu-xref href="#sec-addrestrictedfunctionproperties"></emu-xref>) that enables observation of the chain of caller contexts.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-hascallintailposition">
      <h1>Static Semantics: HasCallInTailPosition</h1>
      <p>With parameter _call_.</p>
      <emu-note>
        <p>_call_ is a Parse Node that represents a specific range of source text. When the following algorithms compare _call_ to another Parse Node, it is a test of whether they represent the same source text.</p>
      </emu-note>

      <emu-clause id="sec-statement-rules">
        <h1>Statement Rules</h1>
        <emu-grammar>ConciseBody : AssignmentExpression</emu-grammar>
        <emu-alg>
          1. Return HasCallInTailPosition of |AssignmentExpression| with argument _call_.
        </emu-alg>
        <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
        <emu-alg>
          1. Let _has_ be HasCallInTailPosition of |StatementList| with argument _call_.
          1. If _has_ is *true*, return *true*.
          1. Return HasCallInTailPosition of |StatementListItem| with argument _call_.
        </emu-alg>
        <emu-grammar>
          FunctionStatementList : [empty]

          StatementListItem : Declaration

          Statement :
            VariableStatement
            EmptyStatement
            ExpressionStatement
            ContinueStatement
            BreakStatement
            ThrowStatement
            DebuggerStatement

          Block : `{` `}`

          ReturnStatement : `return` `;`

          LabelledItem : FunctionDeclaration

          IterationStatement :
            `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
            `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement

          CaseBlock : `{` `}`
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
        <emu-alg>
          1. Let _has_ be HasCallInTailPosition of the first |Statement| with argument _call_.
          1. If _has_ is *true*, return *true*.
          1. Return HasCallInTailPosition of the second |Statement| with argument _call_.
        </emu-alg>
        <emu-grammar>
          IfStatement : `if` `(` Expression `)` Statement

          IterationStatement :
            `do` Statement `while` `(` Expression `)` `;`
            `while` `(` Expression `)` Statement
            `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
            `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
            `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
            `for` `(` LeftHandSideExpression `in` Expression `)` Statement
            `for` `(` `var` ForBinding `in` Expression `)` Statement
            `for` `(` ForDeclaration `in` Expression `)` Statement

          WithStatement : `with` `(` Expression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. Return HasCallInTailPosition of |Statement| with argument _call_.
        </emu-alg>
        <emu-grammar>
          LabelledStatement :
            LabelIdentifier `:` LabelledItem
        </emu-grammar>
        <emu-alg>
          1. Return HasCallInTailPosition of |LabelledItem| with argument _call_.
        </emu-alg>
        <emu-grammar>ReturnStatement : `return` Expression `;`</emu-grammar>
        <emu-alg>
          1. Return HasCallInTailPosition of |Expression| with argument _call_.
        </emu-alg>
        <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
        <emu-alg>
          1. Return HasCallInTailPosition of |CaseBlock| with argument _call_.
        </emu-alg>
        <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
        <emu-alg>
          1. Let _has_ be *false*.
          1. If the first |CaseClauses| is present, let _has_ be HasCallInTailPosition of the first |CaseClauses| with argument _call_.
          1. If _has_ is *true*, return *true*.
          1. Let _has_ be HasCallInTailPosition of the |DefaultClause| with argument _call_.
          1. If _has_ is *true*, return *true*.
          1. If the second |CaseClauses| is present, let _has_ be HasCallInTailPosition of the second |CaseClauses| with argument _call_.
          1. Return _has_.
        </emu-alg>
        <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
        <emu-alg>
          1. Let _has_ be HasCallInTailPosition of |CaseClauses| with argument _call_.
          1. If _has_ is *true*, return *true*.
          1. Return HasCallInTailPosition of |CaseClause| with argument _call_.
        </emu-alg>
        <emu-grammar>
          CaseClause : `case` Expression `:` StatementList?

          DefaultClause : `default` `:` StatementList?
        </emu-grammar>
        <emu-alg>
          1. If |StatementList| is present, return HasCallInTailPosition of |StatementList| with argument _call_.
          1. Return *false*.
        </emu-alg>
        <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
        <emu-alg>
          1. Return HasCallInTailPosition of |Catch| with argument _call_.
        </emu-alg>
        <emu-grammar>
          TryStatement : `try` Block Finally

          TryStatement : `try` Block Catch Finally
        </emu-grammar>
        <emu-alg>
          1. Return HasCallInTailPosition of |Finally| with argument _call_.
        </emu-alg>
        <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
        <emu-alg>
          1. Return HasCallInTailPosition of |Block| with argument _call_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-expression-rules">
        <h1>Expression Rules</h1>
        <emu-note>
          <p>A potential tail position call that is immediately followed by return GetValue of the call result is also a possible tail position call. Function calls cannot return reference values, so such a GetValue operation will always return the same value as the actual function call result.</p>
        </emu-note>
        <emu-grammar>
          AssignmentExpression :
            YieldExpression
            ArrowFunction
            AsyncArrowFunction
            LeftHandSideExpression `=` AssignmentExpression
            LeftHandSideExpression AssignmentOperator AssignmentExpression

          BitwiseANDExpression : BitwiseANDExpression `&amp;` EqualityExpression

          BitwiseXORExpression : BitwiseXORExpression `^` BitwiseANDExpression

          BitwiseORExpression : BitwiseORExpression `|` BitwiseXORExpression

          EqualityExpression :
            EqualityExpression `==` RelationalExpression
            EqualityExpression `!=` RelationalExpression
            EqualityExpression `===` RelationalExpression
            EqualityExpression `!==` RelationalExpression

          RelationalExpression :
            RelationalExpression `&lt;` ShiftExpression
            RelationalExpression `&gt;` ShiftExpression
            RelationalExpression `&lt;=` ShiftExpression
            RelationalExpression `&gt;=` ShiftExpression
            RelationalExpression `instanceof` ShiftExpression
            RelationalExpression `in` ShiftExpression

          ShiftExpression :
            ShiftExpression `&lt;&lt;` AdditiveExpression
            ShiftExpression `&gt;&gt;` AdditiveExpression
            ShiftExpression `&gt;&gt;&gt;` AdditiveExpression

          AdditiveExpression :
            AdditiveExpression `+` MultiplicativeExpression
            AdditiveExpression `-` MultiplicativeExpression

          MultiplicativeExpression :
            MultiplicativeExpression MultiplicativeOperator ExponentiationExpression

          ExponentiationExpression :
            UpdateExpression `**` ExponentiationExpression

          UpdateExpression :
            LeftHandSideExpression `++`
            LeftHandSideExpression `--`
            `++` UnaryExpression
            `--` UnaryExpression

          UnaryExpression :
            `delete` UnaryExpression
            `void` UnaryExpression
            `typeof` UnaryExpression
            `+` UnaryExpression
            `-` UnaryExpression
            `~` UnaryExpression
            `!` UnaryExpression
            AwaitExpression

          CallExpression :
            SuperCall
            CallExpression `[` Expression `]`
            CallExpression `.` IdentifierName

          NewExpression : `new` NewExpression

          MemberExpression :
            MemberExpression `[` Expression `]`
            MemberExpression `.` IdentifierName
            SuperProperty
            MetaProperty
            `new` MemberExpression Arguments

          PrimaryExpression :
            `this`
            IdentifierReference
            Literal
            ArrayLiteral
            ObjectLiteral
            FunctionExpression
            ClassExpression
            GeneratorExpression
            AsyncFunctionExpression
            AsyncGeneratorExpression
            RegularExpressionLiteral
            TemplateLiteral
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>
          Expression :
            AssignmentExpression
            Expression `,` AssignmentExpression
        </emu-grammar>
        <emu-alg>
          1. Return HasCallInTailPosition of |AssignmentExpression| with argument _call_.
        </emu-alg>
        <emu-grammar>ConditionalExpression : LogicalORExpression `?` AssignmentExpression `:` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. Let _has_ be HasCallInTailPosition of the first |AssignmentExpression| with argument _call_.
          1. If _has_ is *true*, return *true*.
          1. Return HasCallInTailPosition of the second |AssignmentExpression| with argument _call_.
        </emu-alg>
        <emu-grammar>LogicalANDExpression : LogicalANDExpression `&amp;&amp;` BitwiseORExpression</emu-grammar>
        <emu-alg>
          1. Return HasCallInTailPosition of |BitwiseORExpression| with argument _call_.
        </emu-alg>
        <emu-grammar>LogicalORExpression : LogicalORExpression `||` LogicalANDExpression</emu-grammar>
        <emu-alg>
          1. Return HasCallInTailPosition of |LogicalANDExpression| with argument _call_.
        </emu-alg>
        <emu-grammar>
          CallExpression :
            CoverCallExpressionAndAsyncArrowHead
            CallExpression Arguments
            CallExpression TemplateLiteral
        </emu-grammar>
        <emu-alg>
          1. If this |CallExpression| is _call_, return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-grammar>
          MemberExpression :
            MemberExpression TemplateLiteral
        </emu-grammar>
        <emu-alg>
          1. If this |MemberExpression| is _call_, return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
        <emu-alg>
          1. Let _expr_ be CoveredParenthesizedExpression of |CoverParenthesizedExpressionAndArrowParameterList|.
          1. Return HasCallInTailPosition of _expr_ with argument _call_.
        </emu-alg>
        <emu-grammar>
          ParenthesizedExpression :
            `(` Expression `)`
        </emu-grammar>
        <emu-alg>
          1. Return HasCallInTailPosition of |Expression| with argument _call_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-preparefortailcall" aoid="PrepareForTailCall">
      <h1>Runtime Semantics: PrepareForTailCall ( )</h1>
      <p>The abstract operation PrepareForTailCall performs the following steps:</p>
      <emu-alg>
        1. Let _leafContext_ be the running execution context.
        1. Suspend _leafContext_.
        1. Pop _leafContext_ from the execution context stack. The execution context now on the top of the stack becomes the running execution context.
        1. Assert: _leafContext_ has no further use. It will never be activated as the running execution context.
      </emu-alg>
      <p>A tail position call must either release any transient internal resources associated with the currently executing function execution context before invoking the target function or reuse those resources in support of the target function.</p>
      <emu-note>
        <p>For example, a tail position call should only grow an implementation's activation record stack by the amount that the size of the target function's activation record exceeds the size of the calling function's activation record. If the target function's activation record is smaller, then the total size of the stack should decrease.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules">
  <h1>ECMAScript Language: Scripts and Modules</h1>

  <emu-clause id="sec-scripts">
    <h1>Scripts</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      Script :
        ScriptBody?

      ScriptBody :
        StatementList[~Yield, ~Await, ~Return]
    </emu-grammar>

    <emu-clause id="sec-scripts-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>Script : ScriptBody</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if the LexicallyDeclaredNames of |ScriptBody| contains any duplicate entries.
        </li>
        <li>
          It is a Syntax Error if any element of the LexicallyDeclaredNames of |ScriptBody| also occurs in the VarDeclaredNames of |ScriptBody|.
        </li>
      </ul>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if |StatementList| Contains `super` unless the source code containing `super` is eval code that is being processed by a direct eval. Additional early error rules for `super` within direct eval are defined in <emu-xref href="#sec-performeval"></emu-xref>.
        </li>
        <li>
          It is a Syntax Error if |StatementList| Contains |NewTarget| unless the source code containing |NewTarget| is eval code that is being processed by a direct eval. Additional early error rules for |NewTarget| in direct eval are defined in <emu-xref href="#sec-performeval"></emu-xref>.
        </li>
        <li>
          It is a Syntax Error if ContainsDuplicateLabels of |StatementList| with argument &laquo; &raquo; is *true*.
        </li>
        <li>
          It is a Syntax Error if ContainsUndefinedBreakTarget of |StatementList| with argument &laquo; &raquo; is *true*.
        </li>
        <li>
          It is a Syntax Error if ContainsUndefinedContinueTarget of |StatementList| with arguments &laquo; &raquo; and &laquo; &raquo; is *true*.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isstrict">
      <h1>Static Semantics: IsStrict</h1>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. If the Directive Prologue of |StatementList| contains a Use Strict Directive, return *true*; otherwise, return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-scripts-static-semantics-lexicallydeclarednames">
      <h1>Static Semantics: LexicallyDeclaredNames</h1>
      <emu-see-also-para op="LexicallyDeclaredNames"></emu-see-also-para>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. Return TopLevelLexicallyDeclaredNames of |StatementList|.
      </emu-alg>
      <emu-note>
        <p>At the top level of a |Script|, function declarations are treated like var declarations rather than like lexical declarations.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-scripts-static-semantics-lexicallyscopeddeclarations">
      <h1>Static Semantics: LexicallyScopedDeclarations</h1>
      <emu-see-also-para op="LexicallyScopedDeclarations"></emu-see-also-para>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. Return TopLevelLexicallyScopedDeclarations of |StatementList|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-scripts-static-semantics-vardeclarednames">
      <h1>Static Semantics: VarDeclaredNames</h1>
      <emu-see-also-para op="VarDeclaredNames"></emu-see-also-para>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. Return TopLevelVarDeclaredNames of |StatementList|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-scripts-static-semantics-varscopeddeclarations">
      <h1>Static Semantics: VarScopedDeclarations</h1>
      <emu-see-also-para op="VarScopedDeclarations"></emu-see-also-para>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. Return TopLevelVarScopedDeclarations of |StatementList|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-script-semantics-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. Return NormalCompletion(*undefined*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-script-records">
      <h1>Script Records</h1>

      <p>A <dfn id="script-record">Script Record</dfn> encapsulates information about a script being evaluated. Each script record contains the fields listed in <emu-xref href="#table-script-records"></emu-xref>.</p>

      <emu-table id="table-script-records" caption="Script Record Fields">
        <table>
          <thead>
          <tr>
            <th>
              Field Name
            </th>
            <th>
              Value Type
            </th>
            <th>
              Meaning
            </th>
          </tr>
          </thead>
          <tbody>
          <tr>
            <td>
              [[Realm]]
            </td>
            <td>
              Realm Record | *undefined*
            </td>
            <td>
              The realm within which this script was created. *undefined* if not yet assigned.
            </td>
          </tr>
          <tr>
            <td>
              [[Environment]]
            </td>
            <td>
              Lexical Environment | *undefined*
            </td>
            <td>
              The Lexical Environment containing the top level bindings for this script. This field is set when the script is instantiated.
            </td>
          </tr>
          <tr>
            <td>
              [[ECMAScriptCode]]
            </td>
            <td>
              a Parse Node
            </td>
            <td>
              The result of parsing the source text of this module using |Script| as the goal symbol.
            </td>
          </tr>
          <tr>
            <td>
              [[HostDefined]]
            </td>
            <td>
              Any, default value is *undefined*.
            </td>
            <td>
              Field reserved for use by host environments that need to associate additional information with a script.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-parse-script" aoid="ParseScript">
      <h1>ParseScript ( _sourceText_, _realm_, _hostDefined_ )</h1>

      <p>The abstract operation ParseScript with arguments _sourceText_, _realm_, and _hostDefined_ creates a Script Record based upon the result of parsing _sourceText_ as a |Script|. ParseScript performs the following steps:</p>

      <emu-alg>
        1. Assert: _sourceText_ is an ECMAScript source text (see clause <emu-xref href="#sec-ecmascript-language-source-code"></emu-xref>).
        1. Parse _sourceText_ using |Script| as the goal symbol and analyse the parse result for any Early Error conditions. If the parse was successful and no early errors were found, let _body_ be the resulting parse tree. Otherwise, let _body_ be a List of one or more *SyntaxError* or *ReferenceError* objects representing the parsing errors and/or early errors. Parsing and early error detection may be interweaved in an implementation-dependent manner. If more than one parsing error or early error is present, the number and ordering of error objects in the list is implementation-dependent, but at least one must be present.
        1. If _body_ is a List of errors, return _body_.
        1. Return Script Record { [[Realm]]: _realm_, [[Environment]]: *undefined*, [[ECMAScriptCode]]: _body_, [[HostDefined]]: _hostDefined_ }.
      </emu-alg>
      <emu-note>
        <p>An implementation may parse script source text and analyse it for Early Error conditions prior to evaluation of ParseScript for that script source text. However, the reporting of any errors must be deferred until the point where this specification actually performs ParseScript upon that source text.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-scriptevaluation" aoid="ScriptEvaluation">
      <h1>ScriptEvaluation ( _scriptRecord_ )</h1>

      <emu-alg>
        1. Let _globalEnv_ be _scriptRecord_.[[Realm]].[[GlobalEnv]].
        1. Let _scriptCxt_ be a new ECMAScript code execution context.
        1. Set the Function of _scriptCxt_ to *null*.
        1. Set the Realm of _scriptCxt_ to _scriptRecord_.[[Realm]].
        1. Set the ScriptOrModule of _scriptCxt_ to _scriptRecord_.
        1. Set the VariableEnvironment of _scriptCxt_ to _globalEnv_.
        1. Set the LexicalEnvironment of _scriptCxt_ to _globalEnv_.
        1. Suspend the currently running execution context.
        1. Push _scriptCxt_ on to the execution context stack; _scriptCxt_ is now the running execution context.
        1. Let _scriptBody_ be _scriptRecord_.[[ECMAScriptCode]].
        1. Let _result_ be GlobalDeclarationInstantiation(_scriptBody_, _globalEnv_).
        1. If _result_.[[Type]] is ~normal~, then
          1. Set _result_ to the result of evaluating _scriptBody_.
        1. If _result_.[[Type]] is ~normal~ and _result_.[[Value]] is ~empty~, then
          1. Set _result_ to NormalCompletion(*undefined*).
        1. Suspend _scriptCxt_ and remove it from the execution context stack.
        1. Assert: The execution context stack is not empty.
        1. Resume the context that is now on the top of the execution context stack as the running execution context.
        1. Return Completion(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-globaldeclarationinstantiation" aoid="GlobalDeclarationInstantiation">
      <h1>Runtime Semantics: GlobalDeclarationInstantiation ( _script_, _env_ )</h1>
      <emu-note>
        <p>When an execution context is established for evaluating scripts, declarations are instantiated in the current global environment. Each global binding declared in the code is instantiated.</p>
      </emu-note>
      <p>GlobalDeclarationInstantiation is performed as follows using arguments _script_ and _env_. _script_ is the |ScriptBody| for which the execution context is being established. _env_ is the global lexical environment in which bindings are to be created.</p>
      <!--
        WARNING: If you add, remove, rename, or repurpose any variable names
                 within this algorithm, you may need to update
                 #sec-web-compat-globaldeclarationinstantiation accordingly.
      -->
      <emu-alg>
        1. Let _envRec_ be _env_'s EnvironmentRecord.
        1. Assert: _envRec_ is a global Environment Record.
        1. Let _lexNames_ be the LexicallyDeclaredNames of _script_.
        1. Let _varNames_ be the VarDeclaredNames of _script_.
        1. For each _name_ in _lexNames_, do
          1. If _envRec_.HasVarDeclaration(_name_) is *true*, throw a *SyntaxError* exception.
          1. If _envRec_.HasLexicalDeclaration(_name_) is *true*, throw a *SyntaxError* exception.
          1. Let _hasRestrictedGlobal_ be ? _envRec_.HasRestrictedGlobalProperty(_name_).
          1. If _hasRestrictedGlobal_ is *true*, throw a *SyntaxError* exception.
        1. For each _name_ in _varNames_, do
          1. If _envRec_.HasLexicalDeclaration(_name_) is *true*, throw a *SyntaxError* exception.
        1. Let _varDeclarations_ be the VarScopedDeclarations of _script_.
        1. Let _functionsToInitialize_ be a new empty List.
        1. Let _declaredFunctionNames_ be a new empty List.
        1. For each _d_ in _varDeclarations_, in reverse list order, do
          1. If _d_ is neither a |VariableDeclaration| nor a |ForBinding| nor a |BindingIdentifier|, then
            1. Assert: _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|.
            1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.
            1. Let _fn_ be the sole element of the BoundNames of _d_.
            1. If _fn_ is not an element of _declaredFunctionNames_, then
              1. Let _fnDefinable_ be ? _envRec_.CanDeclareGlobalFunction(_fn_).
              1. If _fnDefinable_ is *false*, throw a *TypeError* exception.
              1. Append _fn_ to _declaredFunctionNames_.
              1. Insert _d_ as the first element of _functionsToInitialize_.
        1. Let _declaredVarNames_ be a new empty List.
        1. For each _d_ in _varDeclarations_, do
          1. If _d_ is a |VariableDeclaration|, a |ForBinding|, or a |BindingIdentifier|, then
            1. For each String _vn_ in the BoundNames of _d_, do
              1. If _vn_ is not an element of _declaredFunctionNames_, then
                1. Let _vnDefinable_ be ? _envRec_.CanDeclareGlobalVar(_vn_).
                1. If _vnDefinable_ is *false*, throw a *TypeError* exception.
                1. If _vn_ is not an element of _declaredVarNames_, then
                  1. Append _vn_ to _declaredVarNames_.
        1. NOTE: No abnormal terminations occur after this algorithm step if the global object is an ordinary object. However, if the global object is a Proxy exotic object it may exhibit behaviours that cause abnormal terminations in some of the following steps.
        1. NOTE: Annex <emu-xref href="#sec-web-compat-globaldeclarationinstantiation"></emu-xref> adds additional steps at this point.
        1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _script_.
        1. For each element _d_ in _lexDeclarations_, do
          1. NOTE: Lexically declared names are only instantiated here but not initialized.
          1. For each element _dn_ of the BoundNames of _d_, do
            1. If IsConstantDeclaration of _d_ is *true*, then
              1. Perform ? _envRec_.CreateImmutableBinding(_dn_, *true*).
            1. Else,
              1. Perform ? _envRec_.CreateMutableBinding(_dn_, *false*).
        1. For each Parse Node _f_ in _functionsToInitialize_, do
          1. Let _fn_ be the sole element of the BoundNames of _f_.
          1. Let _fo_ be the result of performing InstantiateFunctionObject for _f_ with argument _env_.
          1. Perform ? _envRec_.CreateGlobalFunctionBinding(_fn_, _fo_, *false*).
        1. For each String _vn_ in _declaredVarNames_, in list order, do
          1. Perform ? _envRec_.CreateGlobalVarBinding(_vn_, *false*).
        1. Return NormalCompletion(~empty~).
      </emu-alg>
      <emu-note>
        <p>Early errors specified in <emu-xref href="#sec-scripts-static-semantics-early-errors"></emu-xref> prevent name conflicts between function/var declarations and let/const/class declarations as well as redeclaration of let/const/class bindings for declaration contained within a single |Script|. However, such conflicts and redeclarations that span more than one |Script| are detected as runtime errors during GlobalDeclarationInstantiation. If any such errors are detected, no bindings are instantiated for the script. However, if the global object is defined using Proxy exotic objects then the runtime tests for conflicting declarations may be unreliable resulting in an abrupt completion and some global declarations not being instantiated. If this occurs, the code for the |Script| is not evaluated.</p>
        <p>Unlike explicit var or function declarations, properties that are directly created on the global object result in global bindings that may be shadowed by let/const/class declarations.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-scriptevaluationjob" aoid="ScriptEvaluationJob">
      <h1>Runtime Semantics: ScriptEvaluationJob ( _sourceText_, _hostDefined_ )</h1>
      <p>The job ScriptEvaluationJob with parameters _sourceText_ and _hostDefined_ parses, validates, and evaluates _sourceText_ as a |Script|.</p>
      <emu-alg>
        1. Assert: _sourceText_ is an ECMAScript source text (see clause <emu-xref href="#sec-ecmascript-language-source-code"></emu-xref>).
        1. Let _realm_ be the current Realm Record.
        1. Let _s_ be ParseScript(_sourceText_, _realm_, _hostDefined_).
        1. If _s_ is a List of errors, then
          1. Perform HostReportErrors(_s_).
          1. Return NormalCompletion(*undefined*).
        1. Return ? ScriptEvaluation(_s_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-modules">
    <h1>Modules</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      Module :
        ModuleBody?

      ModuleBody :
        ModuleItemList

      ModuleItemList :
        ModuleItem
        ModuleItemList ModuleItem

      ModuleItem :
        ImportDeclaration
        ExportDeclaration
        StatementListItem[~Yield, ~Await, ~Return]
    </emu-grammar>

    <emu-clause id="sec-module-semantics">
      <h1>Module Semantics</h1>

      <emu-clause id="sec-module-semantics-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>ModuleBody : ModuleItemList</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the LexicallyDeclaredNames of |ModuleItemList| contains any duplicate entries.
          </li>
          <li>
            It is a Syntax Error if any element of the LexicallyDeclaredNames of |ModuleItemList| also occurs in the VarDeclaredNames of |ModuleItemList|.
          </li>
          <li>
            It is a Syntax Error if the ExportedNames of |ModuleItemList| contains any duplicate entries.
          </li>
          <li>
            It is a Syntax Error if any element of the ExportedBindings of |ModuleItemList| does not also occur in either the VarDeclaredNames of |ModuleItemList|, or the LexicallyDeclaredNames of |ModuleItemList|.
          </li>
          <li>
            It is a Syntax Error if |ModuleItemList| Contains `super`.
          </li>
          <li>
            It is a Syntax Error if |ModuleItemList| Contains |NewTarget|.
          </li>
          <li>
            It is a Syntax Error if ContainsDuplicateLabels of |ModuleItemList| with argument &laquo; &raquo; is *true*.
          </li>
          <li>
            It is a Syntax Error if ContainsUndefinedBreakTarget of |ModuleItemList| with argument &laquo; &raquo; is *true*.
          </li>
          <li>
            It is a Syntax Error if ContainsUndefinedContinueTarget of |ModuleItemList| with arguments &laquo; &raquo; and &laquo; &raquo; is *true*.
          </li>
        </ul>
        <emu-note>
          <p>The duplicate ExportedNames rule implies that multiple `export default` |ExportDeclaration| items within a |ModuleBody| is a Syntax Error. Additional error conditions relating to conflicting or duplicate declarations are checked during module linking prior to evaluation of a |Module|. If any such errors are detected the |Module| is not evaluated.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-module-semantics-static-semantics-containsduplicatelabels">
        <h1>Static Semantics: ContainsDuplicateLabels</h1>
        <p>With parameter _labelSet_.</p>
        <emu-see-also-para op="ContainsDuplicateLabels"></emu-see-also-para>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _hasDuplicates_ be ContainsDuplicateLabels of |ModuleItemList| with argument _labelSet_.
          1. If _hasDuplicates_ is *true*, return *true*.
          1. Return ContainsDuplicateLabels of |ModuleItem| with argument _labelSet_.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            ExportDeclaration
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-semantics-static-semantics-containsundefinedbreaktarget">
        <h1>Static Semantics: ContainsUndefinedBreakTarget</h1>
        <p>With parameter _labelSet_.</p>
        <emu-see-also-para op="ContainsUndefinedBreakTarget"></emu-see-also-para>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |ModuleItemList| with argument _labelSet_.
          1. If _hasUndefinedLabels_ is *true*, return *true*.
          1. Return ContainsUndefinedBreakTarget of |ModuleItem| with argument _labelSet_.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            ExportDeclaration
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-semantics-static-semantics-containsundefinedcontinuetarget">
        <h1>Static Semantics: ContainsUndefinedContinueTarget</h1>
        <p>With parameters _iterationSet_ and _labelSet_.</p>
        <emu-see-also-para op="ContainsUndefinedContinueTarget"></emu-see-also-para>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |ModuleItemList| with arguments _iterationSet_ and &laquo; &raquo;.
          1. If _hasUndefinedLabels_ is *true*, return *true*.
          1. Return ContainsUndefinedContinueTarget of |ModuleItem| with arguments _iterationSet_ and &laquo; &raquo;.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            ExportDeclaration
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-semantics-static-semantics-exportedbindings">
        <h1>Static Semantics: ExportedBindings</h1>
        <emu-see-also-para op="ExportedBindings"></emu-see-also-para>
        <emu-note>
          <p>ExportedBindings are the locally bound names that are explicitly associated with a |Module|'s ExportedNames.</p>
        </emu-note>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _names_ be ExportedBindings of |ModuleItemList|.
          1. Append to _names_ the elements of the ExportedBindings of |ModuleItem|.
          1. Return _names_.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-semantics-static-semantics-exportednames">
        <h1>Static Semantics: ExportedNames</h1>
        <emu-see-also-para op="ExportedNames"></emu-see-also-para>
        <emu-note>
          <p>ExportedNames are the externally visible names that a |Module| explicitly maps to one of its local name bindings.</p>
        </emu-note>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _names_ be ExportedNames of |ModuleItemList|.
          1. Append to _names_ the elements of the ExportedNames of |ModuleItem|.
          1. Return _names_.
        </emu-alg>
        <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
        <emu-alg>
          1. Return the ExportedNames of |ExportDeclaration|.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-semantics-static-semantics-exportentries">
        <h1>Static Semantics: ExportEntries</h1>
        <emu-see-also-para op="ExportEntries"></emu-see-also-para>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _entries_ be ExportEntries of |ModuleItemList|.
          1. Append to _entries_ the elements of the ExportEntries of |ModuleItem|.
          1. Return _entries_.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-semantics-static-semantics-importentries">
        <h1>Static Semantics: ImportEntries</h1>
        <emu-see-also-para op="ImportEntries"></emu-see-also-para>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _entries_ be ImportEntries of |ModuleItemList|.
          1. Append to _entries_ the elements of the ImportEntries of |ModuleItem|.
          1. Return _entries_.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ExportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-importedlocalnames" aoid="ImportedLocalNames">
        <h1>Static Semantics: ImportedLocalNames ( _importEntries_ )</h1>
        <p>The abstract operation ImportedLocalNames with argument _importEntries_ creates a List of all of the local name bindings defined by a List of ImportEntry Records (see <emu-xref href="#table-39"></emu-xref>). ImportedLocalNames performs the following steps:</p>
        <emu-alg>
          1. Let _localNames_ be a new empty List.
          1. For each ImportEntry Record _i_ in _importEntries_, do
            1. Append _i_.[[LocalName]] to _localNames_.
          1. Return _localNames_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-semantics-static-semantics-modulerequests">
        <h1>Static Semantics: ModuleRequests</h1>
        <emu-see-also-para op="ModuleRequests"></emu-see-also-para>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItem</emu-grammar>
        <emu-alg>
          1. Return ModuleRequests of |ModuleItem|.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _moduleNames_ be ModuleRequests of |ModuleItemList|.
          1. Let _additionalNames_ be ModuleRequests of |ModuleItem|.
          1. Append to _moduleNames_ each element of _additionalNames_ that is not already an element of _moduleNames_.
          1. Return _moduleNames_.
        </emu-alg>
        <emu-grammar>ModuleItem : StatementListItem</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-semantics-static-semantics-lexicallydeclarednames">
        <h1>Static Semantics: LexicallyDeclaredNames</h1>
        <emu-see-also-para op="LexicallyDeclaredNames"></emu-see-also-para>
        <emu-note>
          <p>The LexicallyDeclaredNames of a |Module| includes the names of all of its imported bindings.</p>
        </emu-note>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _names_ be LexicallyDeclaredNames of |ModuleItemList|.
          1. Append to _names_ the elements of the LexicallyDeclaredNames of |ModuleItem|.
          1. Return _names_.
        </emu-alg>
        <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |ImportDeclaration|.
        </emu-alg>
        <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
        <emu-alg>
          1. If |ExportDeclaration| is `export` |VariableStatement|, return a new empty List.
          1. Return the BoundNames of |ExportDeclaration|.
        </emu-alg>
        <emu-grammar>ModuleItem : StatementListItem</emu-grammar>
        <emu-alg>
          1. Return LexicallyDeclaredNames of |StatementListItem|.
        </emu-alg>
        <emu-note>
          <p>At the top level of a |Module|, function declarations are treated like lexical declarations rather than like var declarations.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-module-semantics-static-semantics-lexicallyscopeddeclarations">
        <h1>Static Semantics: LexicallyScopedDeclarations</h1>
        <emu-see-also-para op="LexicallyScopedDeclarations"></emu-see-also-para>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _declarations_ be LexicallyScopedDeclarations of |ModuleItemList|.
          1. Append to _declarations_ the elements of the LexicallyScopedDeclarations of |ModuleItem|.
          1. Return _declarations_.
        </emu-alg>
        <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-semantics-static-semantics-vardeclarednames">
        <h1>Static Semantics: VarDeclaredNames</h1>
        <emu-see-also-para op="VarDeclaredNames"></emu-see-also-para>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _names_ be VarDeclaredNames of |ModuleItemList|.
          1. Append to _names_ the elements of the VarDeclaredNames of |ModuleItem|.
          1. Return _names_.
        </emu-alg>
        <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
        <emu-alg>
          1. If |ExportDeclaration| is `export` |VariableStatement|, return BoundNames of |ExportDeclaration|.
          1. Return a new empty List.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-semantics-static-semantics-varscopeddeclarations">
        <h1>Static Semantics: VarScopedDeclarations</h1>
        <emu-see-also-para op="VarScopedDeclarations"></emu-see-also-para>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _declarations_ be VarScopedDeclarations of |ModuleItemList|.
          1. Append to _declarations_ the elements of the VarScopedDeclarations of |ModuleItem|.
          1. Return _declarations_.
        </emu-alg>
        <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
        <emu-alg>
          1. If |ExportDeclaration| is `export` |VariableStatement|, return VarScopedDeclarations of |VariableStatement|.
          1. Return a new empty List.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-abstract-module-records">
        <h1>Abstract Module Records</h1>
        <p>A <dfn>Module Record</dfn> encapsulates structural information about the imports and exports of a single module. This information is used to link the imports and exports of sets of connected modules. A Module Record includes four fields that are only used when evaluating a module.</p>
        <p>For specification purposes Module Record values are values of the Record specification type and can be thought of as existing in a simple object-oriented hierarchy where Module Record is an abstract class with both abstract and concrete subclasses. This specification defines the abstract subclass named Cyclic Module Record and its concrete subclass named Source Text Module Record. Other specifications and implementations may define additional Module Record subclasses corresponding to alternative module definition facilities that they defined.</p>
        <p>Module Record defines the fields listed in <emu-xref href="#table-36"></emu-xref>. All Module Definition subclasses include at least those fields. Module Record also defines the abstract method list in <emu-xref href="#table-37"></emu-xref>. All Module definition subclasses must provide concrete implementations of these abstract methods.</p>
        <emu-table id="table-36" caption="Module Record Fields">
          <table>
            <thead>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            </thead>
            <tbody>
            <tr>
              <td>
                [[Realm]]
              </td>
              <td>
                Realm Record | *undefined*
              </td>
              <td>
                The Realm within which this module was created. *undefined* if not yet assigned.
              </td>
            </tr>
            <tr>
              <td>
                [[Environment]]
              </td>
              <td>
                Lexical Environment | *undefined*
              </td>
              <td>
                The Lexical Environment containing the top level bindings for this module. This field is set when the module is instantiated.
              </td>
            </tr>
            <tr>
              <td>
                [[Namespace]]
              </td>
              <td>
                Object | *undefined*
              </td>
              <td>
                The Module Namespace Object (<emu-xref href="#sec-module-namespace-objects"></emu-xref>) if one has been created for this module. Otherwise *undefined*.
              </td>
            </tr>
            <tr>
              <td>
                [[HostDefined]]
              </td>
              <td>
                Any, default value is *undefined*.
              </td>
              <td>
                Field reserved for use by host environments that need to associate additional information with a module.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
        <emu-table id="table-37" caption="Abstract Methods of Module Records">
          <table>
            <tbody>
            <tr>
              <th>
                Method
              </th>
              <th>
                Purpose
              </th>
            </tr>
            <tr>
              <td>
                GetExportedNames([_exportStarSet_])
              </td>
              <td>
                Return a list of all names that are either directly or indirectly exported from this module.
              </td>
            </tr>
            <tr>
              <td>
                ResolveExport(_exportName_ [, _resolveSet_])
              </td>
              <td>
                <p>Return the binding of a name exported by this module. Bindings are represented by a <dfn id="resolvedbinding-record">ResolvedBinding Record</dfn>, of the form { [[Module]]: Module Record, [[BindingName]]: String }. Return *null* if the name cannot be resolved, or `"ambiguous"` if multiple bindings were found.</p>
                <p>This operation must be idempotent if it completes normally. Each time it is called with a specific _exportName_, _resolveSet_ pair as arguments it must return the same result.</p>
              </td>
            </tr>
            <tr>
              <td>
                Instantiate()
              </td>
              <td>
                <p>Prepare the module for evaluation by transitively resolving all module dependencies and creating a module Environment Record.</p>
              </td>
            </tr>
            <tr>
              <td>
                Evaluate()
              </td>
              <td>
                <p>If this module has already been evaluated successfully, return *undefined*; if it has already been evaluated unsuccessfully, throw the exception that was produced. Otherwise, transitively evaluate all module dependencies of this module and then evaluate this module.</p>
                <p>Instantiate must have completed successfully prior to invoking this method.</p>
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-cyclic-module-records">
        <h1>Cyclic Module Records</h1>
        <p>A <dfn id="cyclic-module-record">Cyclic Module Record</dfn> is used to represent information about a module that can participate in dependency cycles with other modules that are subclasses of the Cyclic Module Record type. Module Records that are not subclasses of the Cyclic Module Record type must not participate in dependency cycles with Source Text Module Records.</p>
        <p>In addition to the fields defined in <emu-xref href="#table-36"></emu-xref> Cyclic Module Records have the additional fields listed in <emu-xref href="#table-cyclic-module-fields"></emu-xref></p>
        <emu-table id="table-cyclic-module-fields" caption="Additional Fields of Cyclic Module Records">
          <table>
            <tbody>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
              <tr>
                <td>
                  [[Status]]
                </td>
                <td>
                  String
                </td>
                <td>
                  Initially `"uninstantiated"`. Transitions to `"instantiating"`, `"instantiated"`, `"evaluating"`, `"evaluated"` (in that order) as the module progresses throughout its lifecycle.
                </td>
              </tr>
              <tr>
                <td>
                  [[EvaluationError]]
                </td>
                <td>
                  An abrupt completion | *undefined*
                </td>
                <td>
                  A completion of type ~throw~ representing the exception that occurred during evaluation.  *undefined* if no exception occurred or if [[Status]] is not `"evaluated"`.
                </td>
              </tr>
              <tr>
                <td>
                  [[DFSIndex]]
                </td>
                <td>
                  Integer | *undefined*
                </td>
                <td>
                  Auxiliary field used during Instantiate and Evaluate only.
                  If [[Status]] is `"instantiating"` or `"evaluating"`, this nonnegative number records the point at which the module was first visited during the ongoing depth-first traversal of the dependency graph.
                </td>
              </tr>
              <tr>
                <td>
                  [[DFSAncestorIndex]]
                </td>
                <td>
                  Integer | *undefined*
                </td>
                <td>
                  Auxiliary field used during Instantiate and Evaluate only. If [[Status]] is `"instantiating"` or `"evaluating"`, this is either the module's own [[DFSIndex]] or that of an "earlier" module in the same strongly connected component.
                </td>
              </tr>
              <tr>
                <td>
                  [[RequestedModules]]
                </td>
                <td>
                  List of String
                </td>
                <td>
                  A List of all the |ModuleSpecifier| strings used by the module represented by this record to request the importation of a module. The List is source code occurrence ordered.
                </td>
              </tr>
            </tbody>
          </table>
        </emu-table>
        <p>In addition to the methods defined in <emu-xref href="#table-37"></emu-xref> Cyclic Module Records have the additional methods listed in <emu-xref href="#table-cyclic-module-methods"></emu-xref></p>
        <emu-table id="table-cyclic-module-methods" caption="Additional Abstract Methods of Cyclic Module Records">
          <table>
            <tbody>
              <tr>
                <th>
                  Method
                </th>
                <th>
                  Purpose
                </th>
              </tr>
              <tr>
                <td>
                  InitializeEnvironment()
                </td>
                <td>
                  Initialize the Lexical Environment of the module, including resolving all imported bindings.
                </td>
              </tr>
              <tr>
                <td>
                  ExecuteModule()
                </td>
                <td>
                  Initialize the execution context of the module and evaluate the module's code within it.
                </td>
              </tr>
            </tbody>
          </table>
        </emu-table>

        <emu-clause id="sec-moduledeclarationinstantiation">
          <h1>Instantiate ( ) Concrete Method</h1>

          <p>The Instantiate concrete method of a Cyclic Module Record implements the corresponding Module Record abstract method.</p>
          <p>On success, Instantiate transitions this module's [[Status]] from `"uninstantiated"` to `"instantiated"`. On failure, an exception is thrown and this module's [[Status]] remains `"uninstantiated"`.</p>

          <p>This abstract method performs the following steps (most of the work is done by the auxiliary function InnerModuleInstantiation):</p>

          <emu-alg>
            1. Let _module_ be this Cyclic Module Record.
            1. Assert: _module_.[[Status]] is not `"instantiating"` or `"evaluating"`.
            1. Let _stack_ be a new empty List.
            1. Let _result_ be InnerModuleInstantiation(_module_, _stack_, 0).
            1. If _result_ is an abrupt completion, then
              1. For each Cyclic Module Record _m_ in _stack_, do
                1. Assert: _m_.[[Status]] is `"instantiating"`.
                1. Set _m_.[[Status]] to `"uninstantiated"`.
                1. Set _m_.[[Environment]] to *undefined*.
                1. Set _m_.[[DFSIndex]] to *undefined*.
                1. Set _m_.[[DFSAncestorIndex]] to *undefined*.
              1. Assert: _module_.[[Status]] is `"uninstantiated"`.
              1. Return _result_.
            1. Assert: _module_.[[Status]] is `"instantiated"` or `"evaluated"`.
            1. Assert: _stack_ is empty.
            1. Return *undefined*.
          </emu-alg>

          <emu-clause id="sec-innermoduleinstantiation" aoid="InnerModuleInstantiation">
            <h1>InnerModuleInstantiation ( _module_, _stack_, _index_ )</h1>

            <p>The InnerModuleInstantiation abstract operation is used by Instantiate to perform the actual instantiation process for the Cyclic Module Record _module_, as well as recursively on all other modules in the dependency graph. The _stack_ and _index_ parameters, as well as a module's [[DFSIndex]] and [[DFSAncestorIndex]] fields, keep track of the depth-first search (DFS) traversal. In particular, [[DFSAncestorIndex]] is used to discover strongly connected components (SCCs), such that all modules in an SCC transition to `"instantiated"` together.</p>

            <p>This abstract operation performs the following steps:</p>

            <emu-alg>
              1. If _module_ is not a Cyclic Module Record, then
                1. Perform ? _module_.Instantiate().
                1. Return _index_.
              1. If _module_.[[Status]] is `"instantiating"`, `"instantiated"`, or `"evaluated"`, then
                1. Return _index_.
              1. Assert: _module_.[[Status]] is `"uninstantiated"`.
              1. Set _module_.[[Status]] to `"instantiating"`.
              1. Set _module_.[[DFSIndex]] to _index_.
              1. Set _module_.[[DFSAncestorIndex]] to _index_.
              1. Increase _index_ by 1.
              1. Append _module_ to _stack_.
              1. For each String _required_ that is an element of _module_.[[RequestedModules]], do
                1. Let _requiredModule_ be ? HostResolveImportedModule(_module_, _required_).
                1. Set _index_ to ? InnerModuleInstantiation(_requiredModule_, _stack_, _index_).
                1. If _requiredModule_ is a Cyclic Module Record, then
                  1. Assert: _requiredModule_.[[Status]] is either `"instantiating"`, `"instantiated"`, or `"evaluated"`.
                  1. Assert: _requiredModule_.[[Status]] is `"instantiating"` if and only if _requiredModule_ is in _stack_.
                  1. If _requiredModule_.[[Status]] is `"instantiating"`, then
                    1. Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).
              1. Perform ? _module_.InitializeEnvironment().
              1. Assert: _module_ occurs exactly once in _stack_.
              1. Assert: _module_.[[DFSAncestorIndex]] is less than or equal to _module_.[[DFSIndex]].
              1. If _module_.[[DFSAncestorIndex]] equals _module_.[[DFSIndex]], then
                1. Let _done_ be *false*.
                1. Repeat, while _done_ is *false*,
                  1. Let _requiredModule_ be the last element in _stack_.
                  1. Remove the last element of _stack_.
                  1. Assert: _requiredModule_ is a Cyclic Module Record.
                  1. Set _requiredModule_.[[Status]] to `"instantiated"`.
                  1. If _requiredModule_ and _module_ are the same Module Record, set _done_ to *true*.
              1. Return _index_.
            </emu-alg>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-moduleevaluation">
          <h1>Evaluate ( ) Concrete Method</h1>

          <p>The Evaluate concrete method of a Cyclic Module Record implements the corresponding Module Record abstract method.</p>
          <p>Evaluate transitions this module's [[Status]] from `"instantiated"` to `"evaluated"`.</p>

          <p>If execution results in an exception, that exception is recorded in the [[EvaluationError]] field and rethrown by future invocations of Evaluate.</p>

          <p>This abstract method performs the following steps (most of the work is done by the auxiliary function InnerModuleEvaluation):</p>

          <emu-alg>
            1. Let _module_ be this Cyclic Module Record.
            1. Assert: _module_.[[Status]] is `"instantiated"` or `"evaluated"`.
            1. Let _stack_ be a new empty List.
            1. Let _result_ be InnerModuleEvaluation(_module_, _stack_, 0).
            1. If _result_ is an abrupt completion, then
              1. For each Cyclic Module Record _m_ in _stack_, do
                1. Assert: _m_.[[Status]] is `"evaluating"`.
                1. Set _m_.[[Status]] to `"evaluated"`.
                1. Set _m_.[[EvaluationError]] to _result_.
              1. Assert: _module_.[[Status]] is `"evaluated"` and _module_.[[EvaluationError]] is _result_.
              1. Return _result_.
            1. Assert: _module_.[[Status]] is `"evaluated"` and _module_.[[EvaluationError]] is *undefined*.
            1. Assert: _stack_ is empty.
            1. Return *undefined*.
          </emu-alg>

          <emu-clause id="sec-innermoduleevaluation" aoid="InnerModuleEvaluation">
            <h1>InnerModuleEvaluation ( _module_, _stack_, _index_ )</h1>

            <p>The InnerModuleEvaluation abstract operation is used by Evaluate to perform the actual evaluation process for the Source Text Module Record _module_, as well as recursively on all other modules in the dependency graph. The _stack_ and _index_ parameters, as well as _module_'s [[DFSIndex]] and [[DFSAncestorIndex]] fields, are used the same way as in InnerModuleInstantiation.</p>

            <p>This abstract operation performs the following steps:</p>

            <emu-alg>
              1. If _module_ is not a Cyclic Module Record, then
                1. Perform ? _module_.Evaluate().
                1. Return _index_.
              1. If _module_.[[Status]] is `"evaluated"`, then
                1. If _module_.[[EvaluationError]] is *undefined*, return _index_.
                1. Otherwise return _module_.[[EvaluationError]].
              1. If _module_.[[Status]] is `"evaluating"`, return _index_.
              1. Assert: _module_.[[Status]] is `"instantiated"`.
              1. Set _module_.[[Status]] to `"evaluating"`.
              1. Set _module_.[[DFSIndex]] to _index_.
              1. Set _module_.[[DFSAncestorIndex]] to _index_.
              1. Increase _index_ by 1.
              1. Append _module_ to _stack_.
              1. For each String _required_ that is an element of _module_.[[RequestedModules]], do
                1. Let _requiredModule_ be ! HostResolveImportedModule(_module_, _required_).
                1. NOTE: Instantiate must be completed successfully prior to invoking this method, so every requested module is guaranteed to resolve successfully.
                1. Set _index_ to ? InnerModuleEvaluation(_requiredModule_, _stack_, _index_).
                1. If _requiredModule_ is a Cyclic Module Record,
                  1. Assert: _requiredModule_.[[Status]] is either `"evaluating"` or `"evaluated"`.
                  1. Assert: _requiredModule_.[[Status]] is `"evaluating"` if and only if _requiredModule_ is in _stack_.
                  1. If _requiredModule_.[[Status]] is `"evaluating"`, then
                    1. Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).
              1. Perform ? _module_.ExecuteModule().
              1. Assert: _module_ occurs exactly once in _stack_.
              1. Assert: _module_.[[DFSAncestorIndex]] is less than or equal to _module_.[[DFSIndex]].
              1. If _module_.[[DFSAncestorIndex]] equals _module_.[[DFSIndex]], then
                1. Let _done_ be *false*.
                1. Repeat, while _done_ is *false*,
                  1. Let _requiredModule_ be the last element in _stack_.
                  1. Remove the last element of _stack_.
                  1. Assert: _requiredModule_ is a Cyclic Module Record.
                  1. Set _requiredModule_.[[Status]] to `"evaluated"`.
                  1. If _requiredModule_ and _module_ are the same Module Record, set _done_ to *true*.
              1. Return _index_.
            </emu-alg>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-example-cyclic-module-record-graphs">
          <h1>Example Cyclic Module Record Graphs</h1>

          <p>This non-normative section gives a series of examples of the instantiation and evaluation of a few common module graphs, with a specific focus on how errors can occur.</p>

          <p>First consider the following simple module graph:</p>

          <emu-figure id="figure-module-graph-simple" caption="A simple module graph">
            <img alt="A module graph in which module A depends on module B" width="121" height="211" src="img/module-graph-simple.svg">
          </emu-figure>

          <p>Let's first assume that there are no error conditions. When a host first calls _A_.Instantiate(), this will complete successfully by assumption, and recursively instantiate modules _B_ and _C_ as well, such that _A_.[[Status]] = _B_.[[Status]] = _C_.[[Status]] = `"instantiated"`. This preparatory step can be performed at any time. Later, when the host is ready to incur any possible side effects of the modules, it can call _A_.Evaluate(), which will complete successfully (again by assumption), recursively having evaluated first _C_ and then _B_. Each module's [[Status]] at this point will be `"evaluated`".</p>

          <p>Consider then cases involving instantiation errors. If InnerModuleInstantiation of _C_ succeeds but, thereafter, fails for _B_, for example because it imports something that _C_ does not provide, then the original _A_.Instantiate() will fail, and both _A_ and _B_'s [[Status]] remain `"uninstantiated"`. _C_'s [[Status]] has become `"instantiated"`, though.</p>

          <p>Finally, consider a case involving evaluation errors. If InnerModuleEvaluation of _C_ succeeds but, thereafter, fails for _B_, for example because _B_ contains code that throws an exception, then the original _A_.Evaluate() will fail. The resulting exception will be recorded in both _A_ and _B_'s [[EvaluationError]] fields, and their [[Status]] will become `"evaluated"`. _C_ will also become `"evaluated"` but, in contrast to _A_ and _B_, will remain without an [[EvaluationError]], as it successfully completed evaluation. Storing the exception ensures that any time a host tries to reuse _A_ or _B_ by calling their Evaluate() method, it will encounter the same exception. (Hosts are not required to reuse Cyclic Module Records; similarly, hosts are not required to expose the exception objects thrown by these  methods. However, the specification enables such uses.)</p>

          <p>The difference here between instantiation and evaluation errors is due to how evaluation must be only performed once, as it can cause side effects; it is thus important to remember whether evaluation has already been performed, even if unsuccessfully. (In the error case, it makes sense to also remember the exception because otherwise subsequent Evaluate() calls would have to synthesize a new one.) Instantiation, on the other hand, is side-effect-free, and thus even if it fails, it can be retried at a later time with no issues.</p>

          <p>Now consider a different type of error condition:</p>

          <emu-figure id="figure-module-graph-missing" caption="A module graph with an unresolvable module">
            <img alt="A module graph in which module A depends on a missing (unresolvable) module, represented by ???" width="121" height="121" src="img/module-graph-missing.svg">
          </emu-figure>

          <p>In this scenario, module _A_ declares a dependency on some other module, but no Module Record exists for that module, i.e. HostResolveImportedModule throws an exception when asked for it. This could occur for a variety of reasons, such as the corresponding resource not existing, or the resource existing but ParseModule throwing an exception when trying to parse the resulting source text. Hosts can choose to expose the cause of failure via the exception they throw from HostResolveImportedModule. In any case, this exception causes an instantiation failure, which as before results in _A_'s [[Status]] remaining `"uninstantiated"`.</p>

          <p>Lastly, consider a module graph with a cycle:</p>

          <emu-figure id="figure-module-graph-cycle" caption="A cyclic module graph">
            <img alt="A module graph in which module A depends on module B and C, but module B also depends on module A" width="181" height="121" src="img/module-graph-cycle.svg">
          </emu-figure>

          <p>Here we assume that the entry point is module _A_, so that the host proceeds by calling _A_.Instantiate(), which performs InnerModuleInstantiation on _A_. This in turn calls InnerModuleInstantiation on _B_. Because of the cycle, this again triggers InnerModuleInstantiation on _A_, but at this point it is a no-op since _A_.[[Status]] is already `"instantiating"`. _B_.[[Status]] itself remains `"instantiating"` when control gets back to _A_ and InnerModuleInstantiation is triggered on _C_. After this returns with _C_.[[Status]] being `"instantiated"` , both _A_ and _B_ transition from `"instantiating"` to `"instantiated"` together; this is by design, since they form a strongly connected component.</p>

          <p>An analogous story occurs for the evaluation phase of a cyclic module graph, in the success case.</p>

          <p>Now consider a case where _A_ has an instantiation error; for example, it tries to import a binding from _C_ that does not exist. In that case, the above steps still occur, including the early return from the second call to InnerModuleInstantiation on _A_. However, once we unwind back to the original InnerModuleInstantiation on _A_, it fails during InitializeEnvironment, namely right after _C_.ResolveExport(). The thrown *SyntaxError* exception propagates up to _A_.Instantiate, which resets all modules that are currently on its _stack_ (these are always exactly the modules that are still `"instantiating"`). Hence both _A_ and _B_ become `"uninstantiated"`. Note that _C_ is left as `"instantiated"`.</p>

          <p>Finally, consider a case where _A_ has an evaluation error; for example, its source code throws an exception. In that case, the evaluation-time analog of the above steps still occurs, including the early return from the second call to InnerModuleEvaluation on _A_. However, once we unwind back to the original InnerModuleEvaluation on _A_, it fails by assumption. The exception thrown propagates up to _A_.Evaluate(), which records the error in all modules that are currently on its _stack_ (i.e., the modules that are still `"evaluating"`). Hence both _A_ and _B_ become `"evaluated"` and the exception is recorded in both _A_ and _B_'s [[EvaluationError]] fields, while _C_ is left as `"evaluated"` with no [[EvaluationError]].</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-source-text-module-records">
        <h1>Source Text Module Records</h1>

        <p>A <dfn id="sourctextmodule-record">Source Text Module Record</dfn> is used to represent information about a module that was defined from ECMAScript source text (<emu-xref href="#sec-ecmascript-language-source-code"></emu-xref>) that was parsed using the goal symbol |Module|. Its fields contain digested information about the names that are imported by the module and its concrete methods use this digest to link, instantiate, and evaluate the module.</p>

        <p>A Source Text Module Record can exist in a module graph with other subclasses of the abstract Module Record type, and can participate in cycles with other subclasses of the Cyclic Module Record type.</p>

        <p>In addition to the fields defined in <emu-xref href="#table-cyclic-module-fields"></emu-xref>, Source Text Module Records have the additional fields listed in <emu-xref href="#table-38"></emu-xref>. Each of these fields is initially set in ParseModule.</p>
        <emu-table id="table-38" caption="Additional Fields of Source Text Module Records">
          <table>
            <tbody>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[ECMAScriptCode]]
              </td>
              <td>
                a Parse Node
              </td>
              <td>
                The result of parsing the source text of this module using |Module| as the goal symbol.
              </td>
            </tr>
            <tr>
              <td>
                [[ImportEntries]]
              </td>
              <td>
                List of ImportEntry Records
              </td>
              <td>
                A List of ImportEntry records derived from the code of this module.
              </td>
            </tr>
            <tr>
              <td>
                [[LocalExportEntries]]
              </td>
              <td>
                List of ExportEntry Records
              </td>
              <td>
                A List of ExportEntry records derived from the code of this module that correspond to declarations that occur within the module.
              </td>
            </tr>
            <tr>
              <td>
                [[IndirectExportEntries]]
              </td>
              <td>
                List of ExportEntry Records
              </td>
              <td>
                A List of ExportEntry records derived from the code of this module that correspond to reexported imports that occur within the module.
              </td>
            </tr>
            <tr>
              <td>
                [[StarExportEntries]]
              </td>
              <td>
                List of ExportEntry Records
              </td>
              <td>
                A List of ExportEntry records derived from the code of this module that correspond to export * declarations that occur within the module.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
        <p>An <dfn id="importentry-record">ImportEntry Record</dfn> is a Record that digests information about a single declarative import. Each ImportEntry Record has the fields defined in <emu-xref href="#table-39"></emu-xref>:</p>
        <emu-table id="table-39" caption="ImportEntry Record Fields">
          <table>
            <tbody>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[ModuleRequest]]
              </td>
              <td>
                String
              </td>
              <td>
                String value of the |ModuleSpecifier| of the |ImportDeclaration|.
              </td>
            </tr>
            <tr>
              <td>
                [[ImportName]]
              </td>
              <td>
                String
              </td>
              <td>
                The name under which the desired binding is exported by the module identified by [[ModuleRequest]]. The value `"*"` indicates that the import request is for the target module's namespace object.
              </td>
            </tr>
            <tr>
              <td>
                [[LocalName]]
              </td>
              <td>
                String
              </td>
              <td>
                The name that is used to locally access the imported value from within the importing module.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
        <emu-note>
          <p><emu-xref href="#table-40"></emu-xref> gives examples of ImportEntry records fields used to represent the syntactic import forms:</p>
          <emu-table id="table-40" caption="Import Forms Mappings to ImportEntry Records" informative>
            <table>
              <tbody>
              <tr>
                <th>
                  Import Statement Form
                </th>
                <th>
                  [[ModuleRequest]]
                </th>
                <th>
                  [[ImportName]]
                </th>
                <th>
                  [[LocalName]]
                </th>
              </tr>
              <tr>
                <td>
                  `import v from "mod";`
                </td>
                <td>
                  `"mod"`
                </td>
                <td>
                  `"default"`
                </td>
                <td>
                  `"v"`
                </td>
              </tr>
              <tr>
                <td>
                  `import * as ns from "mod";`
                </td>
                <td>
                  `"mod"`
                </td>
                <td>
                  `"*"`
                </td>
                <td>
                  `"ns"`
                </td>
              </tr>
              <tr>
                <td>
                  `import {x} from "mod";`
                </td>
                <td>
                  `"mod"`
                </td>
                <td>
                  `"x"`
                </td>
                <td>
                  `"x"`
                </td>
              </tr>
              <tr>
                <td>
                  `import {x as v} from "mod";`
                </td>
                <td>
                  `"mod"`
                </td>
                <td>
                  `"x"`
                </td>
                <td>
                  `"v"`
                </td>
              </tr>
              <tr>
                <td>
                  `import "mod";`
                </td>
                <td colspan="3">
                  An ImportEntry Record is not created.
                </td>
              </tr>
              </tbody>
            </table>
          </emu-table>
        </emu-note>
        <p>An <dfn id="exportentry-record">ExportEntry Record</dfn> is a Record that digests information about a single declarative export. Each ExportEntry Record has the fields defined in <emu-xref href="#table-41"></emu-xref>:</p>
        <emu-table id="table-41" caption="ExportEntry Record Fields">
          <table>
            <tbody>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[ExportName]]
              </td>
              <td>
                String | null
              </td>
              <td>
                The name used to export this binding by this module.
              </td>
            </tr>
            <tr>
              <td>
                [[ModuleRequest]]
              </td>
              <td>
                String | null
              </td>
              <td>
                The String value of the |ModuleSpecifier| of the |ExportDeclaration|. *null* if the |ExportDeclaration| does not have a |ModuleSpecifier|.
              </td>
            </tr>
            <tr>
              <td>
                [[ImportName]]
              </td>
              <td>
                String | null
              </td>
              <td>
                The name under which the desired binding is exported by the module identified by [[ModuleRequest]]. *null* if the |ExportDeclaration| does not have a |ModuleSpecifier|. `"*"` indicates that the export request is for all exported bindings.
              </td>
            </tr>
            <tr>
              <td>
                [[LocalName]]
              </td>
              <td>
                String | null
              </td>
              <td>
                The name that is used to locally access the exported value from within the importing module. *null* if the exported value is not locally accessible from within the module.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
        <emu-note>
          <p><emu-xref href="#table-42"></emu-xref> gives examples of the ExportEntry record fields used to represent the syntactic export forms:</p>
          <emu-table id="table-42" caption="Export Forms Mappings to ExportEntry Records" informative>
            <table>
              <tbody>
              <tr>
                <th>
                  Export Statement Form
                </th>
                <th>
                  [[ExportName]]
                </th>
                <th>
                  [[ModuleRequest]]
                </th>
                <th>
                  [[ImportName]]
                </th>
                <th>
                  [[LocalName]]
                </th>
              </tr>
              <tr>
                <td>
                  `export var v;`
                </td>
                <td>
                  `"v"`
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  `"v"`
                </td>
              </tr>
              <tr>
                <td>
                  `export default function f(){}`
                </td>
                <td>
                  `"default"`
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  `"f"`
                </td>
              </tr>
              <tr>
                <td>
                  `export default function(){}`
                </td>
                <td>
                  `"default"`
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  `"*default*"`
                </td>
              </tr>
              <tr>
                <td>
                  `export default 42;`
                </td>
                <td>
                  `"default"`
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  `"*default*"`
                </td>
              </tr>
              <tr>
                <td>
                  `export {x};`
                </td>
                <td>
                  `"x"`
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  `"x"`
                </td>
              </tr>
              <tr>
                <td>
                  `export {v as x};`
                </td>
                <td>
                  `"x"`
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  `"v"`
                </td>
              </tr>
              <tr>
                <td>
                  `export {x} from "mod";`
                </td>
                <td>
                  `"x"`
                </td>
                <td>
                  `"mod"`
                </td>
                <td>
                  `"x"`
                </td>
                <td>
                  *null*
                </td>
              </tr>
              <tr>
                <td>
                  `export {v as x} from "mod";`
                </td>
                <td>
                  `"x"`
                </td>
                <td>
                  `"mod"`
                </td>
                <td>
                  `"v"`
                </td>
                <td>
                  *null*
                </td>
              </tr>
              <tr>
                <td>
                  `export * from "mod";`
                </td>
                <td>
                  *null*
                </td>
                <td>
                  `"mod"`
                </td>
                <td>
                  `"*"`
                </td>
                <td>
                  *null*
                </td>
              </tr>
              </tbody>
            </table>
          </emu-table>
        </emu-note>
        <p>The following definitions specify the required concrete methods and other abstract operations for Source Text Module Records</p>

        <emu-clause id="sec-parsemodule" aoid="ParseModule">
          <h1>ParseModule ( _sourceText_, _realm_, _hostDefined_ )</h1>
          <p>The abstract operation ParseModule with arguments _sourceText_, _realm_, and _hostDefined_ creates a Source Text Module Record based upon the result of parsing _sourceText_ as a |Module|. ParseModule performs the following steps:</p>
          <emu-alg>
            1. Assert: _sourceText_ is an ECMAScript source text (see clause <emu-xref href="#sec-ecmascript-language-source-code"></emu-xref>).
            1. Parse _sourceText_ using |Module| as the goal symbol and analyse the parse result for any Early Error conditions. If the parse was successful and no early errors were found, let _body_ be the resulting parse tree. Otherwise, let _body_ be a List of one or more *SyntaxError* or *ReferenceError* objects representing the parsing errors and/or early errors. Parsing and early error detection may be interweaved in an implementation-dependent manner. If more than one parsing error or early error is present, the number and ordering of error objects in the list is implementation-dependent, but at least one must be present.
            1. If _body_ is a List of errors, return _body_.
            1. Let _requestedModules_ be the ModuleRequests of _body_.
            1. Let _importEntries_ be ImportEntries of _body_.
            1. Let _importedBoundNames_ be ImportedLocalNames(_importEntries_).
            1. Let _indirectExportEntries_ be a new empty List.
            1. Let _localExportEntries_ be a new empty List.
            1. Let _starExportEntries_ be a new empty List.
            1. Let _exportEntries_ be ExportEntries of _body_.
            1. For each ExportEntry Record _ee_ in _exportEntries_, do
              1. If _ee_.[[ModuleRequest]] is *null*, then
                1. If _ee_.[[LocalName]] is not an element of _importedBoundNames_, then
                  1. Append _ee_ to _localExportEntries_.
                1. Else,
                  1. Let _ie_ be the element of _importEntries_ whose [[LocalName]] is the same as _ee_.[[LocalName]].
                  1. If _ie_.[[ImportName]] is `"*"`, then
                    1. Assert: This is a re-export of an imported module namespace object.
                    1. Append _ee_ to _localExportEntries_.
                  1. Else this is a re-export of a single name,
                    1. Append the ExportEntry Record { [[ModuleRequest]]: _ie_.[[ModuleRequest]], [[ImportName]]: _ie_.[[ImportName]], [[LocalName]]: *null*, [[ExportName]]: _ee_.[[ExportName]] } to _indirectExportEntries_.
              1. Else if _ee_.[[ImportName]] is `"*"`, then
                1. Append _ee_ to _starExportEntries_.
              1. Else,
                1. Append _ee_ to _indirectExportEntries_.
            1. Return Source Text Module Record { [[Realm]]: _realm_, [[Environment]]: *undefined*, [[Namespace]]: *undefined*, [[Status]]: `"uninstantiated"`, [[EvaluationError]]: *undefined*, [[HostDefined]]: _hostDefined_, [[ECMAScriptCode]]: _body_, [[RequestedModules]]: _requestedModules_, [[ImportEntries]]: _importEntries_, [[LocalExportEntries]]: _localExportEntries_, [[IndirectExportEntries]]: _indirectExportEntries_, [[StarExportEntries]]: _starExportEntries_, [[DFSIndex]]: *undefined*, [[DFSAncestorIndex]]: *undefined* }.
          </emu-alg>
          <emu-note>
            <p>An implementation may parse module source text and analyse it for Early Error conditions prior to the evaluation of ParseModule for that module source text. However, the reporting of any errors must be deferred until the point where this specification actually performs ParseModule upon that source text.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-getexportednames">
          <h1>GetExportedNames ( [ _exportStarSet_ ] ) Concrete Method</h1>
          <p>The GetExportedNames concrete method of a Source Text Module Record implements the corresponding Module Record abstract method.</p>
          <p>It performs the following steps:</p>
          <emu-alg>
            1. If _exportStarSet_ is not present, let _exportStarSet_ be a new empty List.
            1. Assert: _exportStarSet_ is a List of Source Text Module Records.
            1. Let _module_ be this Source Text Module Record.
            1. If _exportStarSet_ contains _module_, then
              1. Assert: We've reached the starting point of an `import *` circularity.
              1. Return a new empty List.
            1. Append _module_ to _exportStarSet_.
            1. Let _exportedNames_ be a new empty List.
            1. For each ExportEntry Record _e_ in _module_.[[LocalExportEntries]], do
              1. Assert: _module_ provides the direct binding for this export.
              1. Append _e_.[[ExportName]] to _exportedNames_.
            1. For each ExportEntry Record _e_ in _module_.[[IndirectExportEntries]], do
              1. Assert: _module_ imports a specific binding for this export.
              1. Append _e_.[[ExportName]] to _exportedNames_.
            1. For each ExportEntry Record _e_ in _module_.[[StarExportEntries]], do
              1. Let _requestedModule_ be ? HostResolveImportedModule(_module_, _e_.[[ModuleRequest]]).
              1. Let _starNames_ be ? _requestedModule_.GetExportedNames(_exportStarSet_).
              1. For each element _n_ of _starNames_, do
                1. If SameValue(_n_, `"default"`) is *false*, then
                  1. If _n_ is not an element of _exportedNames_, then
                    1. Append _n_ to _exportedNames_.
            1. Return _exportedNames_.
          </emu-alg>
          <emu-note>
            <p>GetExportedNames does not filter out or throw an exception for names that have ambiguous star export bindings.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-resolveexport">
          <h1>ResolveExport ( _exportName_ [ , _resolveSet_ ] ) Concrete Method</h1>
          <p>The ResolveExport concrete method of a Source Text Module Record implements the corresponding Module Record abstract method.</p>

          <p>ResolveExport attempts to resolve an imported binding to the actual defining module and local binding name. The defining module may be the module represented by the Module Record this method was invoked on or some other module that is imported by that module. The parameter _resolveSet_ is used to detect unresolved circular import/export paths. If a pair consisting of specific Module Record and _exportName_ is reached that is already in _resolveSet_, an import circularity has been encountered. Before recursively calling ResolveExport, a pair consisting of _module_ and _exportName_ is added to _resolveSet_.</p>

          <p>If a defining module is found, a ResolvedBinding Record { [[Module]], [[BindingName]] } is returned. This record identifies the resolved binding of the originally requested export. If no definition was found or the request is found to be circular, *null* is returned. If the request is found to be ambiguous, the string `"ambiguous"` is returned.</p>

          <p>This abstract method performs the following steps:</p>

          <emu-alg>
            1. If _resolveSet_ is not present, let _resolveSet_ be a new empty List.
            1. Assert: _resolveSet_ is a List of Record { [[Module]], [[ExportName]] }.
            1. Let _module_ be this Source Text Module Record.
            1. For each Record { [[Module]], [[ExportName]] } _r_ in _resolveSet_, do
              1. If _module_ and _r_.[[Module]] are the same Module Record and SameValue(_exportName_, _r_.[[ExportName]]) is *true*, then
                1. Assert: This is a circular import request.
                1. Return *null*.
            1. Append the Record { [[Module]]: _module_, [[ExportName]]: _exportName_ } to _resolveSet_.
            1. For each ExportEntry Record _e_ in _module_.[[LocalExportEntries]], do
              1. If SameValue(_exportName_, _e_.[[ExportName]]) is *true*, then
                1. Assert: _module_ provides the direct binding for this export.
                1. Return ResolvedBinding Record { [[Module]]: _module_, [[BindingName]]: _e_.[[LocalName]] }.
            1. For each ExportEntry Record _e_ in _module_.[[IndirectExportEntries]], do
              1. If SameValue(_exportName_, _e_.[[ExportName]]) is *true*, then
                1. Assert: _module_ imports a specific binding for this export.
                1. Let _importedModule_ be ? HostResolveImportedModule(_module_, _e_.[[ModuleRequest]]).
                1. Return _importedModule_.ResolveExport(_e_.[[ImportName]], _resolveSet_).
            1. If SameValue(_exportName_, `"default"`) is *true*, then
              1. Assert: A `default` export was not explicitly defined by this module.
              1. Return *null*.
              1. NOTE: A `default` export cannot be provided by an `export *`.
            1. Let _starResolution_ be *null*.
            1. For each ExportEntry Record _e_ in _module_.[[StarExportEntries]], do
              1. Let _importedModule_ be ? HostResolveImportedModule(_module_, _e_.[[ModuleRequest]]).
              1. Let _resolution_ be ? _importedModule_.ResolveExport(_exportName_, _resolveSet_).
              1. If _resolution_ is `"ambiguous"`, return `"ambiguous"`.
              1. If _resolution_ is not *null*, then
                1. Assert: _resolution_ is a ResolvedBinding Record.
                1. If _starResolution_ is *null*, set _starResolution_ to _resolution_.
                1. Else,
                  1. Assert: There is more than one `*` import that includes the requested name.
                  1. If _resolution_.[[Module]] and _starResolution_.[[Module]] are not the same Module Record or SameValue(_resolution_.[[BindingName]], _starResolution_.[[BindingName]]) is *false*, return `"ambiguous"`.
            1. Return _starResolution_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-initialize-environment" aoid="InitializeEnvironment">
          <h1>InitializeEnvironment ( ) Concrete Method</h1>

          <p>The InitializeEnvironment concrete method of a Source Text Module Record implements the corresponding Cyclic Module Record abstract method.</p>

          <p>This abstract method performs the following steps:</p>

          <emu-alg>
            1. Let _module_ be this Source Text Module Record.
            1. For each ExportEntry Record _e_ in _module_.[[IndirectExportEntries]], do
              1. Let _resolution_ be ? _module_.ResolveExport(_e_.[[ExportName]]).
              1. If _resolution_ is *null* or `"ambiguous"`, throw a *SyntaxError* exception.
              1. Assert: _resolution_ is a ResolvedBinding Record.
            1. Assert: All named exports from _module_ are resolvable.
            1. Let _realm_ be _module_.[[Realm]].
            1. Assert: _realm_ is not *undefined*.
            1. Let _env_ be NewModuleEnvironment(_realm_.[[GlobalEnv]]).
            1. Set _module_.[[Environment]] to _env_.
            1. Let _envRec_ be _env_'s EnvironmentRecord.
            1. For each ImportEntry Record _in_ in _module_.[[ImportEntries]], do
              1. Let _importedModule_ be ! HostResolveImportedModule(_module_, _in_.[[ModuleRequest]]).
              1. NOTE: The above call cannot fail because imported module requests are a subset of _module_.[[RequestedModules]], and these have been resolved earlier in this algorithm.
              1. If _in_.[[ImportName]] is `"*"`, then
                1. Let _namespace_ be ? GetModuleNamespace(_importedModule_).
                1. Perform ! _envRec_.CreateImmutableBinding(_in_.[[LocalName]], *true*).
                1. Call _envRec_.InitializeBinding(_in_.[[LocalName]], _namespace_).
              1. Else,
                1. Let _resolution_ be ? _importedModule_.ResolveExport(_in_.[[ImportName]]).
                1. If _resolution_ is *null* or `"ambiguous"`, throw a *SyntaxError* exception.
                1. Call _envRec_.CreateImportBinding(_in_.[[LocalName]], _resolution_.[[Module]], _resolution_.[[BindingName]]).
            1. Let _code_ be _module_.[[ECMAScriptCode]].
            1. Let _varDeclarations_ be the VarScopedDeclarations of _code_.
            1. Let _declaredVarNames_ be a new empty List.
            1. For each element _d_ in _varDeclarations_, do
              1. For each element _dn_ of the BoundNames of _d_, do
                1. If _dn_ is not an element of _declaredVarNames_, then
                  1. Perform ! _envRec_.CreateMutableBinding(_dn_, *false*).
                  1. Call _envRec_.InitializeBinding(_dn_, *undefined*).
                  1. Append _dn_ to _declaredVarNames_.
            1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _code_.
            1. For each element _d_ in _lexDeclarations_, do
              1. For each element _dn_ of the BoundNames of _d_, do
                1. If IsConstantDeclaration of _d_ is *true*, then
                  1. Perform ! _envRec_.CreateImmutableBinding(_dn_, *true*).
                1. Else,
                  1. Perform ! _envRec_.CreateMutableBinding(_dn_, *false*).
                1. If _d_ is a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|, then
                  1. Let _fo_ be the result of performing InstantiateFunctionObject for _d_ with argument _env_.
                  1. Call _envRec_.InitializeBinding(_dn_, _fo_).
            1. Return NormalCompletion(~empty~).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-execute-module" aoid="ExecuteModule">
          <h1>ExecuteModule ( ) Concrete Method</h1>

          <p>The ExecuteModule concrete method of a Source Text Module Record implements the corresponding Cyclic Module Record abstract method.</p>

          <p>This abstract method performs the following steps:</p>

          <emu-alg>
            1. Let _module_ be this Source Text Module Record.
            1. Let _moduleCxt_ be a new ECMAScript code execution context.
            1. Set the Function of _moduleCxt_ to *null*.
            1. Assert: _module_.[[Realm]] is not *undefined*.
            1. Set the Realm of _moduleCxt_ to _module_.[[Realm]].
            1. Set the ScriptOrModule of _moduleCxt_ to _module_.
            1. Assert: _module_ has been linked and declarations in its module environment have been instantiated.
            1. Set the VariableEnvironment of _moduleCxt_ to _module_.[[Environment]].
            1. Set the LexicalEnvironment of _moduleCxt_ to _module_.[[Environment]].
            1. Suspend the currently running execution context.
            1. Push _moduleCxt_ on to the execution context stack; _moduleCxt_ is now the running execution context.
            1. Let _result_ be the result of evaluating _module_.[[ECMAScriptCode]].
            1. Suspend _moduleCxt_ and remove it from the execution context stack.
            1. Resume the context that is now on the top of the execution context stack as the running execution context.
            1. Return Completion(_result_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-hostresolveimportedmodule" aoid="HostResolveImportedModule">
        <h1>Runtime Semantics: HostResolveImportedModule ( _referencingModule_, _specifier_ )</h1>
        <p>HostResolveImportedModule is an implementation-defined abstract operation that provides the concrete Module Record subclass instance that corresponds to the |ModuleSpecifier| String, _specifier_, occurring within the context of the module represented by the Module Record _referencingModule_.</p>
        <p>The implementation of HostResolveImportedModule must conform to the following requirements:</p>
        <ul>
          <li>
            The normal return value must be an instance of a concrete subclass of Module Record.
          </li>
          <li>
            If a Module Record corresponding to the pair _referencingModule_, _specifier_ does not exist or cannot be created, an exception must be thrown.
          </li>
          <li>
            This operation must be idempotent if it completes normally. Each time it is called with a specific _referencingModule_, _specifier_ pair as arguments it must return the same Module Record instance.
          </li>
        </ul>
        <p>Multiple different _referencingModule_, _specifier_ pairs may map to the same Module Record instance. The actual mapping semantic is implementation-defined but typically a normalization process is applied to _specifier_ as part of the mapping process. A typical normalization process would include actions such as alphabetic case folding and expansion of relative and abbreviated path specifiers.</p>
      </emu-clause>

      <emu-clause id="sec-getmodulenamespace" aoid="GetModuleNamespace">
        <h1>Runtime Semantics: GetModuleNamespace ( _module_ )</h1>

        <p>The GetModuleNamespace abstract operation retrieves the Module Namespace Exotic object representing _module_'s exports, lazily creating it the first time it was requested, and storing it in _module_.[[Namespace]] for future retrieval.</p>

        <p>This abstract operation performs the following steps:</p>

        <emu-alg>
          1. Assert: _module_ is an instance of a concrete subclass of Module Record.
          1. Assert: If _module_ is a Cyclic Module Record, then _module_.[[Status]] is not `"uninstantiated"`.
          1. Let _namespace_ be _module_.[[Namespace]].
          1. If _namespace_ is *undefined*, then
            1. Let _exportedNames_ be ? _module_.GetExportedNames().
            1. Let _unambiguousNames_ be a new empty List.
            1. For each _name_ that is an element of _exportedNames_, do
              1. Let _resolution_ be ? _module_.ResolveExport(_name_).
              1. If _resolution_ is a ResolvedBinding Record, append _name_ to _unambiguousNames_.
            1. Set _namespace_ to ModuleNamespaceCreate(_module_, _unambiguousNames_).
          1. Return _namespace_.
        </emu-alg>
        <emu-note>
          <p>The only way GetModuleNamespace can throw is via one of the triggered HostResolveImportedModule calls. Unresolvable names are simply excluded from the namespace at this point. They will lead to a real instantiation error later unless they are all ambiguous star exports that are not explicitly requested anywhere.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-toplevelmoduleevaluationjob" aoid="TopLevelModuleEvaluationJob">
        <h1>Runtime Semantics: TopLevelModuleEvaluationJob ( _sourceText_, _hostDefined_ )</h1>
        <p>A TopLevelModuleEvaluationJob with parameters _sourceText_ and _hostDefined_ is a job that parses, validates, and evaluates _sourceText_ as a |Module|.</p>
        <emu-alg>
          1. Assert: _sourceText_ is an ECMAScript source text (see clause <emu-xref href="#sec-ecmascript-language-source-code"></emu-xref>).
          1. Let _realm_ be the current Realm Record.
          1. Let _m_ be ParseModule(_sourceText_, _realm_, _hostDefined_).
          1. If _m_ is a List of errors, then
            1. Perform HostReportErrors(_m_).
            1. Return NormalCompletion(*undefined*).
          1. Perform ? _m_.Instantiate().
          1. Assert: All dependencies of _m_ have been transitively resolved and _m_ is ready for evaluation.
          1. Return ? _m_.Evaluate().
        </emu-alg>
        <emu-note>
          <p>An implementation may parse a _sourceText_ as a |Module|, analyse it for Early Error conditions, and instantiate it prior to the execution of the TopLevelModuleEvaluationJob for that _sourceText_. An implementation may also resolve, pre-parse and pre-analyse, and pre-instantiate module dependencies of _sourceText_. However, the reporting of any errors detected by these actions must be deferred until the TopLevelModuleEvaluationJob is actually executed.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-module-semantics-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. Return NormalCompletion(*undefined*).
        </emu-alg>
        <emu-grammar>ModuleBody : ModuleItemList</emu-grammar>
        <emu-alg>
          1. Let _result_ be the result of evaluating |ModuleItemList|.
          1. If _result_.[[Type]] is ~normal~ and _result_.[[Value]] is ~empty~, then
            1. Return NormalCompletion(*undefined*).
          1. Return Completion(_result_).
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _sl_ be the result of evaluating |ModuleItemList|.
          1. ReturnIfAbrupt(_sl_).
          1. Let _s_ be the result of evaluating |ModuleItem|.
          1. Return Completion(UpdateEmpty(_s_, _sl_)).
        </emu-alg>
        <emu-note>
          <p>The value of a |ModuleItemList| is the value of the last value-producing item in the |ModuleItemList|.</p>
        </emu-note>
        <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
        <emu-alg>
          1. Return NormalCompletion(~empty~).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-imports">
      <h1>Imports</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ImportDeclaration :
          `import` ImportClause FromClause `;`
          `import` ModuleSpecifier `;`

        ImportClause :
          ImportedDefaultBinding
          NameSpaceImport
          NamedImports
          ImportedDefaultBinding `,` NameSpaceImport
          ImportedDefaultBinding `,` NamedImports

        ImportedDefaultBinding :
          ImportedBinding

        NameSpaceImport :
          `*` `as` ImportedBinding

        NamedImports :
          `{` `}`
          `{` ImportsList `}`
          `{` ImportsList `,` `}`

        FromClause :
          `from` ModuleSpecifier

        ImportsList :
          ImportSpecifier
          ImportsList `,` ImportSpecifier

        ImportSpecifier :
          ImportedBinding
          IdentifierName `as` ImportedBinding

        ModuleSpecifier :
          StringLiteral

        ImportedBinding :
          BindingIdentifier[~Yield, ~Await]
      </emu-grammar>

      <emu-clause id="sec-imports-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the BoundNames of |ImportDeclaration| contains any duplicate entries.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-imports-static-semantics-boundnames">
        <h1>Static Semantics: BoundNames</h1>
        <emu-see-also-para op="BoundNames"></emu-see-also-para>
        <emu-grammar>ImportDeclaration : `import` ImportClause FromClause `;`</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |ImportClause|.
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ModuleSpecifier `;`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ImportClause : ImportedDefaultBinding `,` NameSpaceImport</emu-grammar>
        <emu-alg>
          1. Let _names_ be the BoundNames of |ImportedDefaultBinding|.
          1. Append to _names_ the elements of the BoundNames of |NameSpaceImport|.
          1. Return _names_.
        </emu-alg>
        <emu-grammar>ImportClause : ImportedDefaultBinding `,` NamedImports</emu-grammar>
        <emu-alg>
          1. Let _names_ be the BoundNames of |ImportedDefaultBinding|.
          1. Append to _names_ the elements of the BoundNames of |NamedImports|.
          1. Return _names_.
        </emu-alg>
        <emu-grammar>NamedImports : `{` `}`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ImportsList : ImportsList `,` ImportSpecifier</emu-grammar>
        <emu-alg>
          1. Let _names_ be the BoundNames of |ImportsList|.
          1. Append to _names_ the elements of the BoundNames of |ImportSpecifier|.
          1. Return _names_.
        </emu-alg>
        <emu-grammar>ImportSpecifier : IdentifierName `as` ImportedBinding</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |ImportedBinding|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-imports-static-semantics-importentries">
        <h1>Static Semantics: ImportEntries</h1>
        <emu-see-also-para op="ImportEntries"></emu-see-also-para>
        <emu-grammar>ImportDeclaration : `import` ImportClause FromClause `;`</emu-grammar>
        <emu-alg>
          1. Let _module_ be the sole element of ModuleRequests of |FromClause|.
          1. Return ImportEntriesForModule of |ImportClause| with argument _module_.
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ModuleSpecifier `;`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-importentriesformodule">
        <h1>Static Semantics: ImportEntriesForModule</h1>
        <p>With parameter _module_.</p>
        <emu-grammar>ImportClause : ImportedDefaultBinding `,` NameSpaceImport</emu-grammar>
        <emu-alg>
          1. Let _entries_ be ImportEntriesForModule of |ImportedDefaultBinding| with argument _module_.
          1. Append to _entries_ the elements of the ImportEntriesForModule of |NameSpaceImport| with argument _module_.
          1. Return _entries_.
        </emu-alg>
        <emu-grammar>ImportClause : ImportedDefaultBinding `,` NamedImports</emu-grammar>
        <emu-alg>
          1. Let _entries_ be ImportEntriesForModule of |ImportedDefaultBinding| with argument _module_.
          1. Append to _entries_ the elements of the ImportEntriesForModule of |NamedImports| with argument _module_.
          1. Return _entries_.
        </emu-alg>
        <emu-grammar>ImportedDefaultBinding : ImportedBinding</emu-grammar>
        <emu-alg>
          1. Let _localName_ be the sole element of BoundNames of |ImportedBinding|.
          1. Let _defaultEntry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: `"default"`, [[LocalName]]: _localName_ }.
          1. Return a new List containing _defaultEntry_.
        </emu-alg>
        <emu-grammar>NameSpaceImport : `*` `as` ImportedBinding</emu-grammar>
        <emu-alg>
          1. Let _localName_ be the StringValue of |ImportedBinding|.
          1. Let _entry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: `"*"`, [[LocalName]]: _localName_ }.
          1. Return a new List containing _entry_.
        </emu-alg>
        <emu-grammar>NamedImports : `{` `}`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ImportsList : ImportsList `,` ImportSpecifier</emu-grammar>
        <emu-alg>
          1. Let _specs_ be the ImportEntriesForModule of |ImportsList| with argument _module_.
          1. Append to _specs_ the elements of the ImportEntriesForModule of |ImportSpecifier| with argument _module_.
          1. Return _specs_.
        </emu-alg>
        <emu-grammar>ImportSpecifier : ImportedBinding</emu-grammar>
        <emu-alg>
          1. Let _localName_ be the sole element of BoundNames of |ImportedBinding|.
          1. Let _entry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _localName_, [[LocalName]]: _localName_ }.
          1. Return a new List containing _entry_.
        </emu-alg>
        <emu-grammar>ImportSpecifier : IdentifierName `as` ImportedBinding</emu-grammar>
        <emu-alg>
          1. Let _importName_ be the StringValue of |IdentifierName|.
          1. Let _localName_ be the StringValue of |ImportedBinding|.
          1. Let _entry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_ }.
          1. Return a new List containing _entry_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-imports-static-semantics-modulerequests">
        <h1>Static Semantics: ModuleRequests</h1>
        <emu-see-also-para op="ModuleRequests"></emu-see-also-para>
        <emu-grammar>ImportDeclaration : `import` ImportClause FromClause `;`</emu-grammar>
        <emu-alg>
          1. Return ModuleRequests of |FromClause|.
        </emu-alg>
        <emu-grammar>ModuleSpecifier : StringLiteral</emu-grammar>
        <emu-alg>
          1. Return a List containing the StringValue of |StringLiteral|.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-exports">
      <h1>Exports</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ExportDeclaration :
          `export` `*` FromClause `;`
          `export` ExportClause FromClause `;`
          `export` ExportClause `;`
          `export` VariableStatement[~Yield, ~Await]
          `export` Declaration[~Yield, ~Await]
          `export` `default` HoistableDeclaration[~Yield, ~Await, +Default]
          `export` `default` ClassDeclaration[~Yield, ~Await, +Default]
          `export` `default` [lookahead &lt;! {`function`, `async` [no |LineTerminator| here] `function`, `class`}] AssignmentExpression[+In, ~Yield, ~Await] `;`

        ExportClause :
          `{` `}`
          `{` ExportsList `}`
          `{` ExportsList `,` `}`

        ExportsList :
          ExportSpecifier
          ExportsList `,` ExportSpecifier

        ExportSpecifier :
          IdentifierName
          IdentifierName `as` IdentifierName
      </emu-grammar>

      <emu-clause id="sec-exports-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>ExportDeclaration : `export` ExportClause `;`</emu-grammar>
        <ul>
          <li>
            For each |IdentifierName| _n_ in ReferencedBindings of |ExportClause|: It is a Syntax Error if StringValue of _n_ is a |ReservedWord| or if the StringValue of _n_ is one of: `"implements"`, `"interface"`, `"let"`, `"package"`, `"private"`, `"protected"`, `"public"`, or `"static"`.
          </li>
        </ul>
        <emu-note>
          <p>The above rule means that each ReferencedBindings of |ExportClause| is treated as an |IdentifierReference|.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-exports-static-semantics-boundnames">
        <h1>Static Semantics: BoundNames</h1>
        <emu-see-also-para op="BoundNames"></emu-see-also-para>
        <emu-grammar>
          ExportDeclaration :
            `export` `*` FromClause `;`
            `export` ExportClause FromClause `;`
            `export` ExportClause `;`
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |VariableStatement|.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |Declaration|.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
        <emu-alg>
          1. Let _declarationNames_ be the BoundNames of |HoistableDeclaration|.
          1. If _declarationNames_ does not include the element `"*default*"`, append `"*default*"` to _declarationNames_.
          1. Return _declarationNames_.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
        <emu-alg>
          1. Let _declarationNames_ be the BoundNames of |ClassDeclaration|.
          1. If _declarationNames_ does not include the element `"*default*"`, append `"*default*"` to _declarationNames_.
          1. Return _declarationNames_.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
        <emu-alg>
          1. Return &laquo; `"*default*"` &raquo;.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-exports-static-semantics-exportedbindings">
        <h1>Static Semantics: ExportedBindings</h1>
        <emu-see-also-para op="ExportedBindings"></emu-see-also-para>
        <emu-grammar>
          ExportDeclaration :
            `export` `*` FromClause `;`
            `export` ExportClause FromClause `;`
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` ExportClause `;`</emu-grammar>
        <emu-alg>
          1. Return the ExportedBindings of |ExportClause|.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |VariableStatement|.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |Declaration|.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration : `export` `default` HoistableDeclaration

          ExportDeclaration : `export` `default` ClassDeclaration

          ExportDeclaration : `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. Return the BoundNames of this |ExportDeclaration|.
        </emu-alg>
        <emu-grammar>ExportClause : `{` `}`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. Let _names_ be the ExportedBindings of |ExportsList|.
          1. Append to _names_ the elements of the ExportedBindings of |ExportSpecifier|.
          1. Return _names_.
        </emu-alg>
        <emu-grammar>ExportSpecifier : IdentifierName</emu-grammar>
        <emu-alg>
          1. Return a List containing the StringValue of |IdentifierName|.
        </emu-alg>
        <emu-grammar>ExportSpecifier : IdentifierName `as` IdentifierName</emu-grammar>
        <emu-alg>
          1. Return a List containing the StringValue of the first |IdentifierName|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-exports-static-semantics-exportednames">
        <h1>Static Semantics: ExportedNames</h1>
        <emu-see-also-para op="ExportedNames"></emu-see-also-para>
        <emu-grammar>ExportDeclaration : `export` `*` FromClause `;`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration : `export` ExportClause FromClause `;`

          ExportDeclaration : `export` ExportClause `;`
        </emu-grammar>
        <emu-alg>
          1. Return the ExportedNames of |ExportClause|.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |VariableStatement|.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |Declaration|.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration : `export` `default` HoistableDeclaration

          ExportDeclaration : `export` `default` ClassDeclaration

          ExportDeclaration : `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. Return &laquo; `"default"` &raquo;.
        </emu-alg>
        <emu-grammar>ExportClause : `{` `}`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. Let _names_ be the ExportedNames of |ExportsList|.
          1. Append to _names_ the elements of the ExportedNames of |ExportSpecifier|.
          1. Return _names_.
        </emu-alg>
        <emu-grammar>ExportSpecifier : IdentifierName</emu-grammar>
        <emu-alg>
          1. Return a List containing the StringValue of |IdentifierName|.
        </emu-alg>
        <emu-grammar>ExportSpecifier : IdentifierName `as` IdentifierName</emu-grammar>
        <emu-alg>
          1. Return a List containing the StringValue of the second |IdentifierName|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-exports-static-semantics-exportentries">
        <h1>Static Semantics: ExportEntries</h1>
        <emu-see-also-para op="ExportEntries"></emu-see-also-para>
        <emu-grammar>ExportDeclaration : `export` `*` FromClause `;`</emu-grammar>
        <emu-alg>
          1. Let _module_ be the sole element of ModuleRequests of |FromClause|.
          1. Let _entry_ be the ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: `"*"`, [[LocalName]]: *null*, [[ExportName]]: *null* }.
          1. Return a new List containing _entry_.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` ExportClause FromClause `;`</emu-grammar>
        <emu-alg>
          1. Let _module_ be the sole element of ModuleRequests of |FromClause|.
          1. Return ExportEntriesForModule of |ExportClause| with argument _module_.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` ExportClause `;`</emu-grammar>
        <emu-alg>
          1. Return ExportEntriesForModule of |ExportClause| with argument *null*.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. Let _entries_ be a new empty List.
          1. Let _names_ be the BoundNames of |VariableStatement|.
          1. For each _name_ in _names_, do
            1. Append the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } to _entries_.
          1. Return _entries_.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. Let _entries_ be a new empty List.
          1. Let _names_ be the BoundNames of |Declaration|.
          1. For each _name_ in _names_, do
            1. Append the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } to _entries_.
          1. Return _entries_.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
        <emu-alg>
          1. Let _names_ be BoundNames of |HoistableDeclaration|.
          1. Let _localName_ be the sole element of _names_.
          1. Return a new List containing the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: `"default"` }.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
        <emu-alg>
          1. Let _names_ be BoundNames of |ClassDeclaration|.
          1. Let _localName_ be the sole element of _names_.
          1. Return a new List containing the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: `"default"` }.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
        <emu-alg>
          1. Let _entry_ be the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: `"*default*"`, [[ExportName]]: `"default"` }.
          1. Return a new List containing _entry_.
        </emu-alg>
        <emu-note>
          <p>`"*default*"` is used within this specification as a synthetic name for anonymous default export values.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportentriesformodule">
        <h1>Static Semantics: ExportEntriesForModule</h1>
        <p>With parameter _module_.</p>
        <emu-grammar>ExportClause : `{` `}`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. Let _specs_ be the ExportEntriesForModule of |ExportsList| with argument _module_.
          1. Append to _specs_ the elements of the ExportEntriesForModule of |ExportSpecifier| with argument _module_.
          1. Return _specs_.
        </emu-alg>
        <emu-grammar>ExportSpecifier : IdentifierName</emu-grammar>
        <emu-alg>
          1. Let _sourceName_ be the StringValue of |IdentifierName|.
          1. If _module_ is *null*, then
            1. Let _localName_ be _sourceName_.
            1. Let _importName_ be *null*.
          1. Else,
            1. Let _localName_ be *null*.
            1. Let _importName_ be _sourceName_.
          1. Return a new List containing the ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_, [[ExportName]]: _sourceName_ }.
        </emu-alg>
        <emu-grammar>ExportSpecifier : IdentifierName `as` IdentifierName</emu-grammar>
        <emu-alg>
          1. Let _sourceName_ be the StringValue of the first |IdentifierName|.
          1. Let _exportName_ be the StringValue of the second |IdentifierName|.
          1. If _module_ is *null*, then
            1. Let _localName_ be _sourceName_.
            1. Let _importName_ be *null*.
          1. Else,
            1. Let _localName_ be *null*.
            1. Let _importName_ be _sourceName_.
          1. Return a new List containing the ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_, [[ExportName]]: _exportName_ }.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-exports-static-semantics-isconstantdeclaration">
        <h1>Static Semantics: IsConstantDeclaration</h1>
        <emu-see-also-para op="IsConstantDeclaration"></emu-see-also-para>
        <emu-grammar>
          ExportDeclaration :
            `export` `*` FromClause `;`
            `export` ExportClause FromClause `;`
            `export` ExportClause `;`
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>It is not necessary to treat `export default` |AssignmentExpression| as a constant declaration because there is no syntax that permits assignment to the internal bound name used to reference a module's default object.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-exports-static-semantics-lexicallyscopeddeclarations">
        <h1>Static Semantics: LexicallyScopedDeclarations</h1>
        <emu-see-also-para op="LexicallyScopedDeclarations"></emu-see-also-para>
        <emu-grammar>
          ExportDeclaration :
            `export` `*` FromClause `;`
            `export` ExportClause FromClause `;`
            `export` ExportClause `;`
            `export` VariableStatement
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. Return a new List containing DeclarationPart of |Declaration|.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
        <emu-alg>
          1. Return a new List containing DeclarationPart of |HoistableDeclaration|.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
        <emu-alg>
          1. Return a new List containing |ClassDeclaration|.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
        <emu-alg>
          1. Return a new List containing this |ExportDeclaration|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-exports-static-semantics-modulerequests">
        <h1>Static Semantics: ModuleRequests</h1>
        <emu-see-also-para op="ModuleRequests"></emu-see-also-para>
        <emu-grammar>
          ExportDeclaration : `export` `*` FromClause `;`

          ExportDeclaration : `export` ExportClause FromClause `;`
        </emu-grammar>
        <emu-alg>
          1. Return the ModuleRequests of |FromClause|.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` ExportClause `;`
            `export` VariableStatement
            `export` Declaration
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-referencedbindings">
        <h1>Static Semantics: ReferencedBindings</h1>
        <emu-grammar>ExportClause : `{` `}`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. Let _names_ be the ReferencedBindings of |ExportsList|.
          1. Append to _names_ the elements of the ReferencedBindings of |ExportSpecifier|.
          1. Return _names_.
        </emu-alg>
        <emu-grammar>ExportSpecifier : IdentifierName</emu-grammar>
        <emu-alg>
          1. Return a List containing the |IdentifierName|.
        </emu-alg>
        <emu-grammar>ExportSpecifier : IdentifierName `as` IdentifierName</emu-grammar>
        <emu-alg>
          1. Return a List containing the first |IdentifierName|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-exports-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>
          ExportDeclaration :
            `export` `*` FromClause `;`
            `export` ExportClause FromClause `;`
            `export` ExportClause `;`
        </emu-grammar>
        <emu-alg>
          1. Return NormalCompletion(~empty~).
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. Return the result of evaluating |VariableStatement|.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. Return the result of evaluating |Declaration|.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
        <emu-alg>
          1. Return the result of evaluating |HoistableDeclaration|.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
        <emu-alg>
          1. Let _value_ be the result of BindingClassDeclarationEvaluation of |ClassDeclaration|.
          1. ReturnIfAbrupt(_value_).
          1. Let _className_ be the sole element of BoundNames of |ClassDeclaration|.
          1. If _className_ is `"*default*"`, then
            1. Let _env_ be the running execution context's LexicalEnvironment.
            1. Perform ? InitializeBoundName(`"*default*"`, _value_, _env_).
          1. Return NormalCompletion(~empty~).
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
        <emu-alg>
          1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true*, then
            1. Let _value_ be the result of performing NamedEvaluation for |AssignmentExpression| with argument `"default"`.
          1. Else,
            1. Let _rhs_ be the result of evaluating |AssignmentExpression|.
            1. Let _value_ be ? GetValue(_rhs_).
          1. Let _env_ be the running execution context's LexicalEnvironment.
          1. Perform ? InitializeBoundName(`"*default*"`, _value_, _env_).
          1. Return NormalCompletion(~empty~).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-error-handling-and-language-extensions">
  <h1>Error Handling and Language Extensions</h1>
  <p>An implementation must report most errors at the time the relevant ECMAScript language construct is evaluated. An <dfn id="early-error">early error</dfn> is an error that can be detected and reported prior to the evaluation of any construct in the |Script| containing the error. The presence of an early error prevents the evaluation of the construct. An implementation must report early errors in a |Script| as part of parsing that |Script| in ParseScript. Early errors in a |Module| are reported at the point when the |Module| would be evaluated and the |Module| is never initialized. Early errors in <b>eval</b> code are reported at the time `eval` is called and prevent evaluation of the <b>eval</b> code. All errors that are not early errors are runtime errors.</p>
  <p>An implementation must report as an early error any occurrence of a condition that is listed in a &ldquo;Static Semantics: Early Errors&rdquo; subclause of this specification.</p>
  <p>An implementation shall not treat other kinds of errors as early errors even if the compiler can prove that a construct cannot execute without error under any circumstances. An implementation may issue an early warning in such a case, but it should not report the error until the relevant construct is actually executed.</p>
  <p>An implementation shall report all errors as specified, except for the following:</p>
  <ul>
    <li>
      Except as restricted in <emu-xref href="#sec-forbidden-extensions"></emu-xref>, an implementation may extend |Script| syntax, |Module| syntax, and regular expression pattern or flag syntax. To permit this, all operations (such as calling `eval`, using a regular expression literal, or using the `Function` or `RegExp` constructor) that are allowed to throw *SyntaxError* are permitted to exhibit implementation-defined behaviour instead of throwing *SyntaxError* when they encounter an implementation-defined extension to the script syntax or regular expression pattern or flag syntax.
    </li>
    <li>
      Except as restricted in <emu-xref href="#sec-forbidden-extensions"></emu-xref>, an implementation may provide additional types, values, objects, properties, and functions beyond those described in this specification. This may cause constructs (such as looking up a variable in the global scope) to have implementation-defined behaviour instead of throwing an error (such as *ReferenceError*).
    </li>
  </ul>

  <emu-clause id="sec-host-report-errors" aoid="HostReportErrors">
    <h1>HostReportErrors ( _errorList_ )</h1>

    <p>HostReportErrors is an implementation-defined abstract operation that allows host environments to report parsing errors, early errors, and runtime errors.</p>

    <p>An implementation of HostReportErrors must complete normally in all cases. The default implementation of HostReportErrors is to unconditionally return an empty normal completion.</p>

    <emu-note>
      <p>_errorList_ will be a List of ECMAScript language values. If the errors are parsing errors or early errors, these will always be *SyntaxError* or *ReferenceError* objects. Runtime errors, however, can be any ECMAScript value.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-forbidden-extensions">
    <h1>Forbidden Extensions</h1>
    <p>An implementation must not extend this specification in the following ways:</p>
    <ul>
      <li>
        ECMAScript function objects defined using syntactic constructors in strict mode code must not be created with own properties named `"caller"` or `"arguments"`. Such own properties also must not be created for function objects defined using an |ArrowFunction|, |MethodDefinition|, |GeneratorDeclaration|, |GeneratorExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, |ClassDeclaration|, |ClassExpression|, |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, or |AsyncArrowFunction| regardless of whether the definition is contained in strict mode code. Built-in functions, strict functions created using the `Function` constructor, generator functions created using the `Generator` constructor, async functions created using the `AsyncFunction` constructor, and functions created using the `bind` method also must not be created with such own properties.
      </li>
      <li>
        If an implementation extends any function object with an own property named `"caller"` the value of that property, as observed using [[Get]] or [[GetOwnProperty]], must not be a strict function object. If it is an accessor property, the function that is the value of the property's [[Get]] attribute must never return a strict function when called.
      </li>
      <li>
        Neither mapped nor unmapped arguments objects may be created with an own property named `"caller"`.
      </li>
      <li>
        The behaviour of the following methods must not be extended except as specified in ECMA-402: `Object.prototype.toLocaleString`, `Array.prototype.toLocaleString`, `Number.prototype.toLocaleString`, `Date.prototype.toLocaleDateString`, `Date.prototype.toLocaleString`, `Date.prototype.toLocaleTimeString`, `String.prototype.localeCompare`, %TypedArray%`.prototype.toLocaleString`.
      </li>
      <li>
        The RegExp pattern grammars in <emu-xref href="#sec-patterns"></emu-xref> and <emu-xref href="#sec-regular-expressions-patterns"></emu-xref> must not be extended to recognize any of the source characters A-Z or a-z as |IdentityEscape[+U]| when the <sub>[U]</sub> grammar parameter is present.
      </li>
      <li>
        The Syntactic Grammar must not be extended in any manner that allows the token `:` to immediately follow source text that matches the |BindingIdentifier| nonterminal symbol.
      </li>
      <li>
        When processing strict mode code, the syntax of |NumericLiteral| must not be extended to include <emu-xref href="#prod-annexB-LegacyOctalIntegerLiteral"></emu-xref> and the syntax of |DecimalIntegerLiteral| must not be extended to include <emu-xref href="#prod-annexB-NonOctalDecimalIntegerLiteral"></emu-xref> as described in <emu-xref href="#sec-additional-syntax-numeric-literals"></emu-xref>.
      </li>
      <li>
        |TemplateCharacter| must not be extended to include <emu-xref href="#prod-annexB-LegacyOctalEscapeSequence"></emu-xref> as defined in <emu-xref href="#sec-additional-syntax-string-literals"></emu-xref>.
      </li>
      <li>
        When processing strict mode code, the extensions defined in <emu-xref href="#sec-labelled-function-declarations"></emu-xref>, <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics"></emu-xref>, <emu-xref href="#sec-functiondeclarations-in-ifstatement-statement-clauses"></emu-xref>, and <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> must not be supported.
      </li>
      <li>
        When parsing for the |Module| goal symbol, the lexical grammar extensions defined in <emu-xref href="#sec-html-like-comments"></emu-xref> must not be supported.
      </li>
    </ul>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-standard-built-in-objects">
  <h1>ECMAScript Standard Built-in Objects</h1>
  <p>There are certain built-in objects available whenever an ECMAScript |Script| or |Module| begins execution. One, the global object, is part of the lexical environment of the executing program. Others are accessible as initial properties of the global object or indirectly as properties of accessible built-in objects.</p>
  <p>Unless specified otherwise, a built-in object that is callable as a function is a built-in function object with the characteristics described in <emu-xref href="#sec-built-in-function-objects"></emu-xref>. Unless specified otherwise, the [[Extensible]] internal slot of a built-in object initially has the value *true*. Every built-in function object has a [[Realm]] internal slot whose value is the Realm Record of the realm for which the object was initially created.</p>
  <p>Many built-in objects are functions: they can be invoked with arguments. Some of them furthermore are constructors: they are functions intended for use with the `new` operator. For each built-in function, this specification describes the arguments required by that function and the properties of that function object. For each built-in constructor, this specification furthermore describes properties of the prototype object of that constructor and properties of specific object instances returned by a `new` expression that invokes that constructor.</p>
  <p>Unless otherwise specified in the description of a particular function, if a built-in function or constructor is given fewer arguments than the function is specified to require, the function or constructor shall behave exactly as if it had been given sufficient additional arguments, each such argument being the *undefined* value. Such missing arguments are considered to be &ldquo;not present&rdquo; and may be identified in that manner by specification algorithms. In the description of a particular function, the terms &ldquo;`this` value&rdquo; and &ldquo;NewTarget&rdquo; have the meanings given in <emu-xref href="#sec-built-in-function-objects"></emu-xref>.</p>
  <p>Unless otherwise specified in the description of a particular function, if a built-in function or constructor described is given more arguments than the function is specified to allow, the extra arguments are evaluated by the call and then ignored by the function. However, an implementation may define implementation specific behaviour relating to such arguments as long as the behaviour is not the throwing of a *TypeError* exception that is predicated simply on the presence of an extra argument.</p>
  <emu-note>
    <p>Implementations that add additional capabilities to the set of built-in functions are encouraged to do so by adding new functions rather than adding new parameters to existing functions.</p>
  </emu-note>
  <p>Unless otherwise specified every built-in function and every built-in constructor has the Function prototype object, which is the initial value of the expression `Function.prototype` (<emu-xref href="#sec-properties-of-the-function-prototype-object"></emu-xref>), as the value of its [[Prototype]] internal slot.</p>
  <p>Unless otherwise specified every built-in prototype object has the Object prototype object, which is the initial value of the expression `Object.prototype` (<emu-xref href="#sec-properties-of-the-object-prototype-object"></emu-xref>), as the value of its [[Prototype]] internal slot, except the Object prototype object itself.</p>
  <p>Built-in function objects that are not identified as constructors do not implement the [[Construct]] internal method unless otherwise specified in the description of a particular function.</p>
  <p>Each built-in function defined in this specification is created by calling the CreateBuiltinFunction abstract operation (<emu-xref href="#sec-createbuiltinfunction"></emu-xref>).</p>
  <p>Every built-in function object, including constructors, has a `"length"` property whose value is an integer. Unless otherwise specified, this value is equal to the largest number of named arguments shown in the subclause headings for the function description. Optional parameters (which are indicated with brackets: `[` `]`) or rest parameters (which are shown using the form &laquo;...name&raquo;) are not included in the default argument count.</p>
  <emu-note>
    <p>For example, the function object that is the initial value of the `map` property of the Array prototype object is described under the subclause heading &laquo;Array.prototype.map (callbackFn [ , thisArg])&raquo; which shows the two named arguments callbackFn and thisArg, the latter being optional; therefore the value of the `"length"` property of that function object is 1.</p>
  </emu-note>
  <p>Unless otherwise specified, the `"length"` property of a built-in function object has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
  <p>Every built-in function object, including constructors, that is not identified as an anonymous function has a `name` property whose value is a String. Unless otherwise specified, this value is the name that is given to the function in this specification. For functions that are specified as properties of objects, the name value is the property name string used to access the function. Functions that are specified as get or set accessor functions of built-in properties have `"get "` or `"set "` prepended to the property name string. The value of the `name` property is explicitly specified for each built-in functions whose property key is a Symbol value.</p>
  <p>Unless otherwise specified, the `name` property of a built-in function object, if it exists, has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
  <p>Every other data property described in clauses 18 through 26 and in Annex <emu-xref href="#sec-additional-built-in-properties"></emu-xref> has the attributes { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* } unless otherwise specified.</p>
  <p>Every accessor property described in clauses 18 through 26 and in Annex <emu-xref href="#sec-additional-built-in-properties"></emu-xref> has the attributes { [[Enumerable]]: *false*, [[Configurable]]: *true* } unless otherwise specified. If only a get accessor function is described, the set accessor function is the default value, *undefined*. If only a set accessor is described the get accessor is the default value, *undefined*.</p>
</emu-clause>

<emu-clause id="sec-global-object">
  <h1>The Global Object</h1>
  <p>The <dfn>global object</dfn>:</p>
  <ul>
    <li>is created before control enters any execution context.</li>
    <li>does not have a [[Construct]] internal method; it cannot be used as a constructor with the `new` operator.</li>
    <li>does not have a [[Call]] internal method; it cannot be invoked as a function.</li>
    <li>has a [[Prototype]] internal slot whose value is implementation-dependent.</li>
    <li>may have host defined properties in addition to the properties defined in this specification. This may include a property whose value is the global object itself.</li>
  </ul>

  <emu-clause id="sec-value-properties-of-the-global-object">
    <h1>Value Properties of the Global Object</h1>

    <emu-clause id="sec-value-properties-of-the-global-object-infinity">
      <h1>Infinity</h1>
      <p>The value of `Infinity` is *+&infin;* (see <emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref>). This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-value-properties-of-the-global-object-nan">
      <h1>NaN</h1>
      <p>The value of `NaN` is *NaN* (see <emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref>). This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-undefined">
      <h1>undefined</h1>
      <p>The value of `undefined` is *undefined* (see <emu-xref href="#sec-ecmascript-language-types-undefined-type"></emu-xref>). This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-function-properties-of-the-global-object">
    <h1>Function Properties of the Global Object</h1>

    <emu-clause id="sec-eval-x">
      <h1>eval ( _x_ )</h1>
      <p>The `eval` function is the <dfn>%eval%</dfn> intrinsic object. When the `eval` function is called with one argument _x_, the following steps are taken:</p>
      <emu-alg>
        1. Assert: The execution context stack has at least two elements.
        1. Let _callerContext_ be the second to top element of the execution context stack.
        1. Let _callerRealm_ be _callerContext_'s Realm.
        1. Let _calleeRealm_ be the current Realm Record.
        1. Perform ? HostEnsureCanCompileStrings(_callerRealm_, _calleeRealm_).
        1. Return ? PerformEval(_x_, _calleeRealm_, *false*, *false*).
      </emu-alg>

      <emu-clause id="sec-performeval" aoid="PerformEval">
        <h1>Runtime Semantics: PerformEval ( _x_, _evalRealm_, _strictCaller_, _direct_ )</h1>
        <p>The abstract operation PerformEval with arguments _x_, _evalRealm_, _strictCaller_, and _direct_ performs the following steps:</p>
        <emu-alg>
          1. Assert: If _direct_ is *false*, then _strictCaller_ is also *false*.
          1. If Type(_x_) is not String, return _x_.
          1. Let _thisEnvRec_ be ! GetThisEnvironment().
          1. If _thisEnvRec_ is a function Environment Record, then
            1. Let _F_ be _thisEnvRec_.[[FunctionObject]].
            1. Let _inFunction_ be *true*.
            1. Let _inMethod_ be _thisEnvRec_.HasSuperBinding().
            1. If _F_.[[ConstructorKind]] is `"derived"`, let _inDerivedConstructor_ be *true*; otherwise, let _inDerivedConstructor_ be *false*.
          1. Else,
            1. Let _inFunction_ be *false*.
            1. Let _inMethod_ be *false*.
            1. Let _inDerivedConstructor_ be *false*.
          1. Let _script_ be the ECMAScript code that is the result of parsing _x_, interpreted as UTF-16 encoded Unicode text as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>, for the goal symbol |Script|. If _inFunction_ is *false*, additional early error rules from <emu-xref href="#sec-performeval-rules-outside-functions"></emu-xref> are applied. If _inMethod_ is *false*, additional early error rules from <emu-xref href="#sec-performeval-rules-outside-methods"></emu-xref> are applied. If _inDerivedConstructor_ is *false*, additional early error rules from <emu-xref href="#sec-performeval-rules-outside-constructors"></emu-xref> are applied. If the parse fails, throw a *SyntaxError* exception. If any early errors are detected, throw a *SyntaxError* or a *ReferenceError* exception, depending on the type of the error (but see also clause <emu-xref href="#sec-error-handling-and-language-extensions"></emu-xref>). Parsing and early error detection may be interweaved in an implementation-dependent manner.
          1. If _script_ Contains |ScriptBody| is *false*, return *undefined*.
          1. Let _body_ be the |ScriptBody| of _script_.
          1. If _strictCaller_ is *true*, let _strictEval_ be *true*.
          1. Else, let _strictEval_ be IsStrict of _script_.
          1. Let _ctx_ be the running execution context.
          1. NOTE: If _direct_ is *true*, _ctx_ will be the execution context that performed the direct eval. If _direct_ is *false*, _ctx_ will be the execution context for the invocation of the `eval` function.
          1. If _direct_ is *true*, then
            1. Let _lexEnv_ be NewDeclarativeEnvironment(_ctx_'s LexicalEnvironment).
            1. Let _varEnv_ be _ctx_'s VariableEnvironment.
          1. Else,
            1. Let _lexEnv_ be NewDeclarativeEnvironment(_evalRealm_.[[GlobalEnv]]).
            1. Let _varEnv_ be _evalRealm_.[[GlobalEnv]].
          1. If _strictEval_ is *true*, set _varEnv_ to _lexEnv_.
          1. If _ctx_ is not already suspended, suspend _ctx_.
          1. Let _evalCxt_ be a new ECMAScript code execution context.
          1. Set the _evalCxt_'s Function to *null*.
          1. Set the _evalCxt_'s Realm to _evalRealm_.
          1. Set the _evalCxt_'s ScriptOrModule to _ctx_'s ScriptOrModule.
          1. Set the _evalCxt_'s VariableEnvironment to _varEnv_.
          1. Set the _evalCxt_'s LexicalEnvironment to _lexEnv_.
          1. Push _evalCxt_ on to the execution context stack; _evalCxt_ is now the running execution context.
          1. Let _result_ be EvalDeclarationInstantiation(_body_, _varEnv_, _lexEnv_, _strictEval_).
          1. If _result_.[[Type]] is ~normal~, then
            1. Set _result_ to the result of evaluating _body_.
          1. If _result_.[[Type]] is ~normal~ and _result_.[[Value]] is ~empty~, then
            1. Set _result_ to NormalCompletion(*undefined*).
          1. Suspend _evalCxt_ and remove it from the execution context stack.
          1. Resume the context that is now on the top of the execution context stack as the running execution context.
          1. Return Completion(_result_).
        </emu-alg>
        <emu-note>
          <p>The eval code cannot instantiate variable or function bindings in the variable environment of the calling context that invoked the eval if the calling context is evaluating formal parameter initializers or if either the code of the calling context or the eval code is strict mode code. Instead such bindings are instantiated in a new VariableEnvironment that is only accessible to the eval code. Bindings introduced by `let`, `const`, or `class` declarations are always instantiated in a new LexicalEnvironment.</p>
        </emu-note>

        <emu-clause id="sec-performeval-rules-outside-functions">
          <h1>Additional Early Error Rules for Eval Outside Functions</h1>
          <p>These static semantics are applied by PerformEval when a direct eval call occurs outside of any function.</p>
          <emu-grammar>ScriptBody : StatementList</emu-grammar>
          <ul>
            <li>It is a Syntax Error if |StatementList| Contains |NewTarget|.</li>
          </ul>
        </emu-clause>

        <emu-clause id="sec-performeval-rules-outside-methods">
          <h1>Additional Early Error Rules for Eval Outside Methods</h1>
          <p>These static semantics are applied by PerformEval when a direct eval call occurs outside of a |MethodDefinition|.</p>
          <emu-grammar>ScriptBody : StatementList</emu-grammar>
          <ul>
            <li>It is a Syntax Error if |StatementList| Contains |SuperProperty|.</li>
          </ul>
        </emu-clause>

        <emu-clause id="sec-performeval-rules-outside-constructors">
          <h1>Additional Early Error Rules for Eval Outside Constructor Methods</h1>
          <p>These static semantics are applied by PerformEval when a direct eval call occurs outside of the <emu-xref href="#sec-static-semantics-constructormethod">constructor method</emu-xref> of a |ClassDeclaration| or |ClassExpression|.</p>
          <emu-grammar>ScriptBody : StatementList</emu-grammar>
          <ul>
            <li>It is a Syntax Error if |StatementList| Contains |SuperCall|.</li>
          </ul>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-hostensurecancompilestrings" aoid="HostEnsureCanCompileStrings">
        <h1>HostEnsureCanCompileStrings ( _callerRealm_, _calleeRealm_ )</h1>

        <p>HostEnsureCanCompileStrings is an implementation-defined abstract operation that allows host environments to block certain ECMAScript functions which allow developers to compile strings into ECMAScript code.</p>

        <p>An implementation of HostEnsureCanCompileStrings may complete normally or abruptly. Any abrupt completions will be propagated to its callers. The default implementation of HostEnsureCanCompileStrings is to unconditionally return an empty normal completion.</p>
      </emu-clause>

      <emu-clause id="sec-evaldeclarationinstantiation" aoid="EvalDeclarationInstantiation">
        <h1>Runtime Semantics: EvalDeclarationInstantiation ( _body_, _varEnv_, _lexEnv_, _strict_ )</h1>
        <p>When the abstract operation EvalDeclarationInstantiation is called with arguments _body_, _varEnv_, _lexEnv_, and _strict_, the following steps are taken:</p>
        <!--
          WARNING: If you add, remove, rename, or repurpose any variable names
                   within this algorithm, you may need to update
                   #sec-web-compat-evaldeclarationinstantiation and
                   #sec-variablestatements-in-catch-blocks accordingly.
        -->
        <emu-alg>
          1. Let _varNames_ be the VarDeclaredNames of _body_.
          1. Let _varDeclarations_ be the VarScopedDeclarations of _body_.
          1. Let _lexEnvRec_ be _lexEnv_'s EnvironmentRecord.
          1. Let _varEnvRec_ be _varEnv_'s EnvironmentRecord.
          1. If _strict_ is *false*, then
            1. If _varEnvRec_ is a global Environment Record, then
              1. For each _name_ in _varNames_, do
                1. If _varEnvRec_.HasLexicalDeclaration(_name_) is *true*, throw a *SyntaxError* exception.
                1. NOTE: `eval` will not create a global var declaration that would be shadowed by a global lexical declaration.
            1. Let _thisLex_ be _lexEnv_.
            1. Assert: The following loop will terminate.
            1. Repeat, while _thisLex_ is not the same as _varEnv_,
              1. Let _thisEnvRec_ be _thisLex_'s EnvironmentRecord.
              1. If _thisEnvRec_ is not an object Environment Record, then
                1. NOTE: The environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts.
                1. For each _name_ in _varNames_, do
                  1. If _thisEnvRec_.HasBinding(_name_) is *true*, then
                    1. Throw a *SyntaxError* exception.
                    1. NOTE: Annex <emu-xref href="#sec-variablestatements-in-catch-blocks"></emu-xref> defines alternate semantics for the above step.
                  1. NOTE: A direct eval will not hoist var declaration over a like-named lexical declaration.
              1. Set _thisLex_ to _thisLex_'s outer environment reference.
          1. Let _functionsToInitialize_ be a new empty List.
          1. Let _declaredFunctionNames_ be a new empty List.
          1. For each _d_ in _varDeclarations_, in reverse list order, do
            1. If _d_ is neither a |VariableDeclaration| nor a |ForBinding| nor a |BindingIdentifier|, then
              1. Assert: _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|.
              1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.
              1. Let _fn_ be the sole element of the BoundNames of _d_.
              1. If _fn_ is not an element of _declaredFunctionNames_, then
                1. If _varEnvRec_ is a global Environment Record, then
                  1. Let _fnDefinable_ be ? _varEnvRec_.CanDeclareGlobalFunction(_fn_).
                  1. If _fnDefinable_ is *false*, throw a *TypeError* exception.
                1. Append _fn_ to _declaredFunctionNames_.
                1. Insert _d_ as the first element of _functionsToInitialize_.
          1. NOTE: Annex <emu-xref href="#sec-web-compat-evaldeclarationinstantiation"></emu-xref> adds additional steps at this point.
          1. Let _declaredVarNames_ be a new empty List.
          1. For each _d_ in _varDeclarations_, do
            1. If _d_ is a |VariableDeclaration|, a |ForBinding|, or a |BindingIdentifier|, then
              1. For each String _vn_ in the BoundNames of _d_, do
                1. If _vn_ is not an element of _declaredFunctionNames_, then
                  1. If _varEnvRec_ is a global Environment Record, then
                    1. Let _vnDefinable_ be ? _varEnvRec_.CanDeclareGlobalVar(_vn_).
                    1. If _vnDefinable_ is *false*, throw a *TypeError* exception.
                  1. If _vn_ is not an element of _declaredVarNames_, then
                    1. Append _vn_ to _declaredVarNames_.
          1. NOTE: No abnormal terminations occur after this algorithm step unless _varEnvRec_ is a global Environment Record and the global object is a Proxy exotic object.
          1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _body_.
          1. For each element _d_ in _lexDeclarations_, do
            1. NOTE: Lexically declared names are only instantiated here but not initialized.
            1. For each element _dn_ of the BoundNames of _d_, do
              1. If IsConstantDeclaration of _d_ is *true*, then
                1. Perform ? _lexEnvRec_.CreateImmutableBinding(_dn_, *true*).
              1. Else,
                1. Perform ? _lexEnvRec_.CreateMutableBinding(_dn_, *false*).
          1. For each Parse Node _f_ in _functionsToInitialize_, do
            1. Let _fn_ be the sole element of the BoundNames of _f_.
            1. Let _fo_ be the result of performing InstantiateFunctionObject for _f_ with argument _lexEnv_.
            1. If _varEnvRec_ is a global Environment Record, then
              1. Perform ? _varEnvRec_.CreateGlobalFunctionBinding(_fn_, _fo_, *true*).
            1. Else,
              1. Let _bindingExists_ be _varEnvRec_.HasBinding(_fn_).
              1. If _bindingExists_ is *false*, then
                1. Let _status_ be ! _varEnvRec_.CreateMutableBinding(_fn_, *true*).
                1. Assert: _status_ is not an abrupt completion because of validation preceding step 12.
                1. Perform ! _varEnvRec_.InitializeBinding(_fn_, _fo_).
              1. Else,
                1. Perform ! _varEnvRec_.SetMutableBinding(_fn_, _fo_, *false*).
          1. For each String _vn_ in _declaredVarNames_, in list order, do
            1. If _varEnvRec_ is a global Environment Record, then
              1. Perform ? _varEnvRec_.CreateGlobalVarBinding(_vn_, *true*).
            1. Else,
              1. Let _bindingExists_ be _varEnvRec_.HasBinding(_vn_).
              1. If _bindingExists_ is *false*, then
                1. Let _status_ be ! _varEnvRec_.CreateMutableBinding(_vn_, *true*).
                1. Assert: _status_ is not an abrupt completion because of validation preceding step 12.
                1. Perform ! _varEnvRec_.InitializeBinding(_vn_, *undefined*).
          1. Return NormalCompletion(~empty~).
        </emu-alg>
        <emu-note>
          <p>An alternative version of this algorithm is described in <emu-xref href="#sec-variablestatements-in-catch-blocks"></emu-xref>.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-isfinite-number">
      <h1>isFinite ( _number_ )</h1>
      <p>The `isFinite` function is the <dfn>%isFinite%</dfn> intrinsic object. When the `isFinite` function is called with one argument _number_, the following steps are taken:</p>
      <emu-alg>
        1. Let _num_ be ? ToNumber(_number_).
        1. If _num_ is *NaN*, *+&infin;*, or *-&infin;*, return *false*.
        1. Otherwise, return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isnan-number">
      <h1>isNaN ( _number_ )</h1>
      <p>The `isNaN` function is the <dfn>%isNaN%</dfn> intrinsic object. When the `isNaN` function is called with one argument _number_, the following steps are taken:</p>
      <emu-alg>
        1. Let _num_ be ? ToNumber(_number_).
        1. If _num_ is *NaN*, return *true*.
        1. Otherwise, return *false*.
      </emu-alg>
      <emu-note>
        <p>A reliable way for ECMAScript code to test if a value `X` is a *NaN* is an expression of the form `X !== X`. The result will be *true* if and only if `X` is a *NaN*.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-parsefloat-string">
      <h1>parseFloat ( _string_ )</h1>
      <p>The `parseFloat` function produces a Number value dictated by interpretation of the contents of the _string_ argument as a decimal literal.</p>
      <p>The `parseFloat` function is the <dfn>%parseFloat%</dfn> intrinsic object. When the `parseFloat` function is called with one argument _string_, the following steps are taken:</p>
      <emu-alg>
        1. Let _inputString_ be ? ToString(_string_).
        1. Let _trimmedString_ be a substring of _inputString_ consisting of the leftmost code unit that is not a |StrWhiteSpaceChar| and all code units to the right of that code unit. (In other words, remove leading white space.) If _inputString_ does not contain any such code units, let _trimmedString_ be the empty string.
        1. If neither _trimmedString_ nor any prefix of _trimmedString_ satisfies the syntax of a |StrDecimalLiteral| (see <emu-xref href="#sec-tonumber-applied-to-the-string-type"></emu-xref>), return *NaN*.
        1. Let _numberString_ be the longest prefix of _trimmedString_, which might be _trimmedString_ itself, that satisfies the syntax of a |StrDecimalLiteral|.
        1. Let _mathFloat_ be MV of _numberString_.
        1. If _mathFloat_ = 0, then
          1. If the first code unit of _trimmedString_ is the code unit 0x002D (HYPHEN-MINUS), return *-0*.
          1. Return *+0*.
        1. Return the Number value for _mathFloat_.
      </emu-alg>
      <emu-note>
        <p>`parseFloat` may interpret only a leading portion of _string_ as a Number value; it ignores any code units that cannot be interpreted as part of the notation of a decimal literal, and no indication is given that any such code units were ignored.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-parseint-string-radix">
      <h1>parseInt ( _string_, _radix_ )</h1>
      <p>The `parseInt` function produces an integer value dictated by interpretation of the contents of the _string_ argument according to the specified _radix_. Leading white space in _string_ is ignored. If _radix_ is *undefined* or 0, it is assumed to be 10 except when the number begins with the code unit pairs `0x` or `0X`, in which case a radix of 16 is assumed. If _radix_ is 16, the number may also optionally begin with the code unit pairs `0x` or `0X`.</p>
      <p>The `parseInt` function is the <dfn>%parseInt%</dfn> intrinsic object. When the `parseInt` function is called, the following steps are taken:</p>
      <emu-alg>
        1. Let _inputString_ be ? ToString(_string_).
        1. Let _S_ be a newly created substring of _inputString_ consisting of the first code unit that is not a |StrWhiteSpaceChar| and all code units following that code unit. (In other words, remove leading white space.) If _inputString_ does not contain any such code unit, let _S_ be the empty string.
        1. Let _sign_ be 1.
        1. If _S_ is not empty and the first code unit of _S_ is the code unit 0x002D (HYPHEN-MINUS), set _sign_ to -1.
        1. If _S_ is not empty and the first code unit of _S_ is the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS), remove the first code unit from _S_.
        1. Let _R_ be ? ToInt32(_radix_).
        1. Let _stripPrefix_ be *true*.
        1. If _R_ &ne; 0, then
          1. If _R_ &lt; 2 or _R_ &gt; 36, return *NaN*.
          1. If _R_ &ne; 16, set _stripPrefix_ to *false*.
        1. Else _R_ = 0,
          1. Set _R_ to 10.
        1. If _stripPrefix_ is *true*, then
          1. If the length of _S_ is at least 2 and the first two code units of _S_ are either `"0x"` or `"0X"`, then
            1. Remove the first two code units from _S_.
            1. Set _R_ to 16.
        1. If _S_ contains a code unit that is not a radix-_R_ digit, let _Z_ be the substring of _S_ consisting of all code units before the first such code unit; otherwise, let _Z_ be _S_.
        1. If _Z_ is empty, return *NaN*.
        1. Let _mathInt_ be the mathematical integer value that is represented by _Z_ in radix-_R_ notation, using the letters <b>A</b>-<b>Z</b> and <b>a</b>-<b>z</b> for digits with values 10 through 35. (However, if _R_ is 10 and _Z_ contains more than 20 significant digits, every significant digit after the 20th may be replaced by a 0 digit, at the option of the implementation; and if _R_ is not 2, 4, 8, 10, 16, or 32, then _mathInt_ may be an implementation-dependent approximation to the mathematical integer value that is represented by _Z_ in radix-_R_ notation.)
        1. If _mathInt_ = 0, then
          1. If _sign_ = -1, return *-0*.
          1. Return *+0*.
        1. Let _number_ be the Number value for _mathInt_.
        1. Return _sign_ &times; _number_.
      </emu-alg>
      <emu-note>
        <p>`parseInt` may interpret only a leading portion of _string_ as an integer value; it ignores any code units that cannot be interpreted as part of the notation of an integer, and no indication is given that any such code units were ignored.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-uri-handling-functions">
      <h1>URI Handling Functions</h1>
      <p>Uniform Resource Identifiers, or URIs, are Strings that identify resources (e.g. web pages or files) and transport protocols by which to access them (e.g. HTTP or FTP) on the Internet. The ECMAScript language itself does not provide any support for using URIs except for functions that encode and decode URIs as described in <emu-xref href="#sec-decodeuri-encodeduri"></emu-xref>, <emu-xref href="#sec-decodeuricomponent-encodeduricomponent"></emu-xref>, <emu-xref href="#sec-encodeuri-uri"></emu-xref> and <emu-xref href="#sec-encodeuricomponent-uricomponent"></emu-xref></p>
      <emu-note>
        <p>Many implementations of ECMAScript provide additional functions and methods that manipulate web pages; these functions are beyond the scope of this standard.</p>
      </emu-note>

      <emu-clause id="sec-uri-syntax-and-semantics">
        <h1>URI Syntax and Semantics</h1>
        <p>A URI is composed of a sequence of components separated by component separators. The general form is:</p>
        <div class="rhs">
          |Scheme| `:` |First| `/` |Second| `;` |Third| `?` |Fourth|
        </div>
        <p>where the italicized names represent components and &ldquo;`:`&rdquo;, &ldquo;`/`&rdquo;, &ldquo;`;`&rdquo; and &ldquo;`?`&rdquo; are reserved for use as separators. The `encodeURI` and `decodeURI` functions are intended to work with complete URIs; they assume that any reserved code units in the URI are intended to have special meaning and so are not encoded. The `encodeURIComponent` and `decodeURIComponent` functions are intended to work with the individual component parts of a URI; they assume that any reserved code units represent text and so must be encoded so that they are not interpreted as reserved code units when the component is part of a complete URI.</p>
        <p>The following lexical grammar specifies the form of encoded URIs.</p>
        <h2>Syntax</h2>
        <emu-grammar type="definition">
          uri :::
            uriCharacters?

          uriCharacters :::
            uriCharacter uriCharacters?

          uriCharacter :::
            uriReserved
            uriUnescaped
            uriEscaped

          uriReserved ::: one of
            `;` `/` `?` `:` `@` `&amp;` `=` `+` `$` `,`

          uriUnescaped :::
            uriAlpha
            DecimalDigit
            uriMark

          uriEscaped :::
            `%` HexDigit HexDigit

          uriAlpha ::: one of
            `a` `b` `c` `d` `e` `f` `g` `h` `i` `j` `k` `l` `m` `n` `o` `p` `q` `r` `s` `t` `u` `v` `w` `x` `y` `z`
            `A` `B` `C` `D` `E` `F` `G` `H` `I` `J` `K` `L` `M` `N` `O` `P` `Q` `R` `S` `T` `U` `V` `W` `X` `Y` `Z`

          uriMark ::: one of
            `-` `_` `.` `!` `~` `*` `'` `(` `)`
        </emu-grammar>
        <emu-note>
          <p>The above syntax is based upon RFC 2396 and does not reflect changes introduced by the more recent RFC 3986.</p>
        </emu-note>
        <h2>Runtime Semantics</h2>
        <p>When a code unit to be included in a URI is not listed above or is not intended to have the special meaning sometimes given to the reserved code units, that code unit must be encoded. The code unit is transformed into its UTF-8 encoding, with <emu-xref href="#surrogate-pair">surrogate pairs</emu-xref> first converted from UTF-16 to the corresponding code point value. (Note that for code units in the range [0, 127] this results in a single octet with the same value.) The resulting sequence of octets is then transformed into a String with each octet represented by an escape sequence of the form `"%xx"`.</p>

        <emu-clause id="sec-encode" aoid="Encode">
          <h1>Runtime Semantics: Encode ( _string_, _unescapedSet_ )</h1>
          <p>The encoding and escaping process is described by the abstract operation Encode taking two String arguments _string_ and _unescapedSet_.</p>
          <emu-alg>
            1. Let _strLen_ be the number of code units in _string_.
            1. Let _R_ be the empty String.
            1. Let _k_ be 0.
            1. Repeat,
              1. If _k_ equals _strLen_, return _R_.
              1. Let _C_ be the code unit at index _k_ within _string_.
              1. If _C_ is in _unescapedSet_, then
                1. Let _S_ be the String value containing only the code unit _C_.
                1. Set _R_ to the string-concatenation of the previous value of _R_ and _S_.
              1. Else _C_ is not in _unescapedSet_,
                1. If _C_ is a <emu-xref href="#trailing-surrogate"></emu-xref>, throw a *URIError* exception.
                1. If _C_ is not a <emu-xref href="#leading-surrogate"></emu-xref>, then
                  1. Let _V_ be the code point with the same numeric value as code unit _C_.
                1. Else,
                  1. Increase _k_ by 1.
                  1. If _k_ equals _strLen_, throw a *URIError* exception.
                  1. Let _kChar_ be the code unit at index _k_ within _string_.
                  1. If _kChar_ is not a <emu-xref href="#trailing-surrogate"></emu-xref>, throw a *URIError* exception.
                  1. Let _V_ be UTF16Decode(_C_, _kChar_).
                1. Let _Octets_ be the List of octets resulting by applying the UTF-8 transformation to _V_.
                1. For each element _octet_ of _Octets_ in List order, do
                  1. Let _S_ be the string-concatenation of:
                    * `"%"`
                    * the String representation of _octet_, formatted as a two-digit uppercase hexadecimal number, padded to the left with a zero if necessary
                  1. Set _R_ to the string-concatenation of the previous value of _R_ and _S_.
              1. Increase _k_ by 1.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-decode" aoid="Decode">
          <h1>Runtime Semantics: Decode ( _string_, _reservedSet_ )</h1>
          <p>The unescaping and decoding process is described by the abstract operation Decode taking two String arguments _string_ and _reservedSet_.</p>
          <emu-alg>
            1. Let _strLen_ be the number of code units in _string_.
            1. Let _R_ be the empty String.
            1. Let _k_ be 0.
            1. Repeat,
              1. If _k_ equals _strLen_, return _R_.
              1. Let _C_ be the code unit at index _k_ within _string_.
              1. If _C_ is not the code unit 0x0025 (PERCENT SIGN), then
                1. Let _S_ be the String value containing only the code unit _C_.
              1. Else _C_ is the code unit 0x0025 (PERCENT SIGN),
                1. Let _start_ be _k_.
                1. If _k_ + 2 is greater than or equal to _strLen_, throw a *URIError* exception.
                1. If the code units at index (_k_ + 1) and (_k_ + 2) within _string_ do not represent hexadecimal digits, throw a *URIError* exception.
                1. Let _B_ be the 8-bit value represented by the two hexadecimal digits at index (_k_ + 1) and (_k_ + 2).
                1. Increment _k_ by 2.
                1. If the most significant bit in _B_ is 0, then
                  1. Let _C_ be the code unit whose value is _B_.
                  1. If _C_ is not in _reservedSet_, then
                    1. Let _S_ be the String value containing only the code unit _C_.
                  1. Else _C_ is in _reservedSet_,
                    1. Let _S_ be the substring of _string_ from index _start_ to index _k_ inclusive.
                1. Else the most significant bit in _B_ is 1,
                  1. Let _n_ be the smallest nonnegative integer such that (_B_ &lt;&lt; _n_) &amp; 0x80 is equal to 0.
                  1. If _n_ equals 1 or _n_ is greater than 4, throw a *URIError* exception.
                  1. Let _Octets_ be a List of 8-bit integers of size _n_.
                  1. Set _Octets_[0] to _B_.
                  1. If _k_ + (3 &times; (_n_ - 1)) is greater than or equal to _strLen_, throw a *URIError* exception.
                  1. Let _j_ be 1.
                  1. Repeat, while _j_ &lt; _n_
                    1. Increment _k_ by 1.
                    1. If the code unit at index _k_ within _string_ is not the code unit 0x0025 (PERCENT SIGN), throw a *URIError* exception.
                    1. If the code units at index (_k_ + 1) and (_k_ + 2) within _string_ do not represent hexadecimal digits, throw a *URIError* exception.
                    1. Let _B_ be the 8-bit value represented by the two hexadecimal digits at index (_k_ + 1) and (_k_ + 2).
                    1. If the two most significant bits in _B_ are not 10, throw a *URIError* exception.
                    1. Increment _k_ by 2.
                    1. Set _Octets_[_j_] to _B_.
                    1. Increment _j_ by 1.
                  1. If _Octets_ does not contain a valid UTF-8 encoding of a Unicode code point, throw a *URIError* exception.
                  1. Let _V_ be the value obtained by applying the UTF-8 transformation to _Octets_, that is, from a List of octets into a 21-bit value.
                  1. Let _S_ be the String value whose code units are, in order, the elements in UTF16Encoding(_V_).
              1. Set _R_ to the string-concatenation of the previous value of _R_ and _S_.
              1. Increase _k_ by 1.
          </emu-alg>
          <emu-note>
            <p>This syntax of Uniform Resource Identifiers is based upon RFC 2396 and does not reflect the more recent RFC 3986 which replaces RFC 2396. A formal description and implementation of UTF-8 is given in RFC 3629.</p>
            <p>In UTF-8, characters are encoded using sequences of 1 to 6 octets. The only octet of a sequence of one has the higher-order bit set to 0, the remaining 7 bits being used to encode the character value. In a sequence of n octets, n &gt; 1, the initial octet has the n higher-order bits set to 1, followed by a bit set to 0. The remaining bits of that octet contain bits from the value of the character to be encoded. The following octets all have the higher-order bit set to 1 and the following bit set to 0, leaving 6 bits in each to contain bits from the character to be encoded. The possible UTF-8 encodings of ECMAScript characters are specified in <emu-xref href="#table-43"></emu-xref>.</p>
            <emu-table id="table-43" caption="UTF-8 Encodings" informative>
              <table>
                <tbody>
                <tr>
                  <th>
                    Code Unit Value
                  </th>
                  <th>
                    Representation
                  </th>
                  <th>
                    1<sup>st</sup> Octet
                  </th>
                  <th>
                    2<sup>nd</sup> Octet
                  </th>
                  <th>
                    3<sup>rd</sup> Octet
                  </th>
                  <th>
                    4<sup>th</sup> Octet
                  </th>
                </tr>
                <tr>
                  <td>
                    `0x0000 - 0x007F`
                  </td>
                  <td>
                    <code>00000000 0<i>zzzzzzz</i></code>
                  </td>
                  <td>
                    <code>0<i>zzzzzzz</i></code>
                  </td>
                  <td>
                  </td>
                  <td>
                  </td>
                  <td>
                  </td>
                </tr>
                <tr>
                  <td>
                    `0x0080 - 0x07FF`
                  </td>
                  <td>
                    <code>00000<i>yyy yyzzzzzz</i></code>
                  </td>
                  <td>
                    <code>110<i>yyyyy</i></code>
                  </td>
                  <td>
                    <code>10<i>zzzzzz</i></code>
                  </td>
                  <td>
                  </td>
                  <td>
                  </td>
                </tr>
                <tr>
                  <td>
                    `0x0800 - 0xD7FF`
                  </td>
                  <td>
                    <code><i>xxxxyyyy yyzzzzzz</i></code>
                  </td>
                  <td>
                    <code>1110<i>xxxx</i></code>
                  </td>
                  <td>
                    <code>10<i>yyyyyy</i></code>
                  </td>
                  <td>
                    <code>10<i>zzzzzz</i></code>
                  </td>
                  <td>
                  </td>
                </tr>
                <tr>
                  <td>
                    `0xD800 - 0xDBFF`
                    <br>
                    followed by
                    <br>
                    `0xDC00 - 0xDFFF`
                  </td>
                  <td>
                    <code>110110<i>vv vvwwwwxx</i></code>
                    <br>
                    followed by
                    <br>
                    <code>110111<i>yy yyzzzzzz</i></code>
                  </td>
                  <td>
                    <code>11110<i>uuu</i></code>
                  </td>
                  <td>
                    <code>10<i>uuwwww</i></code>
                  </td>
                  <td>
                    <code>10<i>xxyyyy</i></code>
                  </td>
                  <td>
                    <code>10<i>zzzzzz</i></code>
                  </td>
                </tr>
                <tr>
                  <td>
                    `0xD800 - 0xDBFF`
                    <br>
                    not followed by
                    <br>
                    `0xDC00 - 0xDFFF`
                  </td>
                  <td>
                    causes `URIError`
                  </td>
                  <td>
                  </td>
                  <td>
                  </td>
                  <td>
                  </td>
                  <td>
                  </td>
                </tr>
                <tr>
                  <td>
                    `0xDC00 - 0xDFFF`
                  </td>
                  <td>
                    causes `URIError`
                  </td>
                  <td>
                  </td>
                  <td>
                  </td>
                  <td>
                  </td>
                  <td>
                  </td>
                </tr>
                <tr>
                  <td>
                    `0xE000 - 0xFFFF`
                  </td>
                  <td>
                    <code><i>xxxxyyyy yyzzzzzz</i></code>
                  </td>
                  <td>
                    <code>1110<i>xxxx</i></code>
                  </td>
                  <td>
                    <code>10<i>yyyyyy</i></code>
                  </td>
                  <td>
                    <code>10<i>zzzzzz</i></code>
                  </td>
                  <td>
                  </td>
                </tr>
                </tbody>
              </table>
            </emu-table>
            <p>Where
              <br>
                _uuuuu_ = _vvvv_ + 1
              <br>
              to account for the addition of 0x10000 as in section 3.8 of the Unicode Standard (Surrogates).</p>
            <p>The above transformation combines each <emu-xref href="#surrogate-pair"></emu-xref> (for which code unit values in the inclusive range 0xD800 to 0xDFFF are reserved) into a UTF-32 representation and encodes the resulting 21-bit value into UTF-8. Decoding reconstructs the surrogate pair.</p>
            <p>RFC 3629 prohibits the decoding of invalid UTF-8 octet sequences. For example, the invalid sequence C0 80 must not decode into the code unit 0x0000. Implementations of the Decode algorithm are required to throw a *URIError* when encountering such invalid sequences.</p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-decodeuri-encodeduri">
        <h1>decodeURI ( _encodedURI_ )</h1>
        <p>The `decodeURI` function computes a new version of a URI in which each escape sequence and UTF-8 encoding of the sort that might be introduced by the `encodeURI` function is replaced with the UTF-16 encoding of the code points that it represents. Escape sequences that could not have been introduced by `encodeURI` are not replaced.</p>
        <p>The `decodeURI` function is the <dfn>%decodeURI%</dfn> intrinsic object. When the `decodeURI` function is called with one argument _encodedURI_, the following steps are taken:</p>
        <emu-alg>
          1. Let _uriString_ be ? ToString(_encodedURI_).
          1. Let _reservedURISet_ be a String containing one instance of each code unit valid in |uriReserved| plus `"#"`.
          1. Return ? Decode(_uriString_, _reservedURISet_).
        </emu-alg>
        <emu-note>
          <p>The code point `"#"` is not decoded from escape sequences even though it is not a reserved URI code point.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-decodeuricomponent-encodeduricomponent">
        <h1>decodeURIComponent ( _encodedURIComponent_ )</h1>
        <p>The `decodeURIComponent` function computes a new version of a URI in which each escape sequence and UTF-8 encoding of the sort that might be introduced by the `encodeURIComponent` function is replaced with the UTF-16 encoding of the code points that it represents.</p>
        <p>The `decodeURIComponent` function is the <dfn>%decodeURIComponent%</dfn> intrinsic object. When the `decodeURIComponent` function is called with one argument _encodedURIComponent_, the following steps are taken:</p>
        <emu-alg>
          1. Let _componentString_ be ? ToString(_encodedURIComponent_).
          1. Let _reservedURIComponentSet_ be the empty String.
          1. Return ? Decode(_componentString_, _reservedURIComponentSet_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-encodeuri-uri">
        <h1>encodeURI ( _uri_ )</h1>
        <p>The `encodeURI` function computes a new version of a UTF-16 encoded (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>) URI in which each instance of certain code points is replaced by one, two, three, or four escape sequences representing the UTF-8 encoding of the code points.</p>
        <p>The `encodeURI` function is the <dfn>%encodeURI%</dfn> intrinsic object. When the `encodeURI` function is called with one argument _uri_, the following steps are taken:</p>
        <emu-alg>
          1. Let _uriString_ be ? ToString(_uri_).
          1. Let _unescapedURISet_ be a String containing one instance of each code unit valid in |uriReserved| and |uriUnescaped| plus `"#"`.
          1. Return ? Encode(_uriString_, _unescapedURISet_).
        </emu-alg>
        <emu-note>
          <p>The code unit `"#"` is not encoded to an escape sequence even though it is not a reserved or unescaped URI code point.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-encodeuricomponent-uricomponent">
        <h1>encodeURIComponent ( _uriComponent_ )</h1>
        <p>The `encodeURIComponent` function computes a new version of a UTF-16 encoded (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>) URI in which each instance of certain code points is replaced by one, two, three, or four escape sequences representing the UTF-8 encoding of the code point.</p>
        <p>The `encodeURIComponent` function is the <dfn>%encodeURIComponent%</dfn> intrinsic object. When the `encodeURIComponent` function is called with one argument _uriComponent_, the following steps are taken:</p>
        <emu-alg>
          1. Let _componentString_ be ? ToString(_uriComponent_).
          1. Let _unescapedURIComponentSet_ be a String containing one instance of each code unit valid in |uriUnescaped|.
          1. Return ? Encode(_componentString_, _unescapedURIComponentSet_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-constructor-properties-of-the-global-object">
    <h1>Constructor Properties of the Global Object</h1>

    <emu-clause id="sec-constructor-properties-of-the-global-object-array">
      <h1>Array ( . . . )</h1>
      <p>See <emu-xref href="#sec-array-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-arraybuffer">
      <h1>ArrayBuffer ( . . . )</h1>
      <p>See <emu-xref href="#sec-arraybuffer-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-boolean">
      <h1>Boolean ( . . . )</h1>
      <p>See <emu-xref href="#sec-boolean-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-dataview">
      <h1>DataView ( . . . )</h1>
      <p>See <emu-xref href="#sec-dataview-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-date">
      <h1>Date ( . . . )</h1>
      <p>See <emu-xref href="#sec-date-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-error">
      <h1>Error ( . . . )</h1>
      <p>See <emu-xref href="#sec-error-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-evalerror">
      <h1>EvalError ( . . . )</h1>
      <p>See <emu-xref href="#sec-native-error-types-used-in-this-standard-evalerror"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-float32array">
      <h1>Float32Array ( . . . )</h1>
      <p>See <emu-xref href="#sec-typedarray-constructors"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-float64array">
      <h1>Float64Array ( . . . )</h1>
      <p>See <emu-xref href="#sec-typedarray-constructors"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-function">
      <h1>Function ( . . . )</h1>
      <p>See <emu-xref href="#sec-function-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-int8array">
      <h1>Int8Array ( . . . )</h1>
      <p>See <emu-xref href="#sec-typedarray-constructors"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-int16array">
      <h1>Int16Array ( . . . )</h1>
      <p>See <emu-xref href="#sec-typedarray-constructors"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-int32array">
      <h1>Int32Array ( . . . )</h1>
      <p>See <emu-xref href="#sec-typedarray-constructors"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-map">
      <h1>Map ( . . . )</h1>
      <p>See <emu-xref href="#sec-map-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-number">
      <h1>Number ( . . . )</h1>
      <p>See <emu-xref href="#sec-number-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-object">
      <h1>Object ( . . . )</h1>
      <p>See <emu-xref href="#sec-object-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-promise">
      <h1>Promise ( . . . )</h1>
      <p>See <emu-xref href="#sec-promise-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-proxy">
      <h1>Proxy ( . . . )</h1>
      <p>See <emu-xref href="#sec-proxy-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-rangeerror">
      <h1>RangeError ( . . . )</h1>
      <p>See <emu-xref href="#sec-native-error-types-used-in-this-standard-rangeerror"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-referenceerror">
      <h1>ReferenceError ( . . . )</h1>
      <p>See <emu-xref href="#sec-native-error-types-used-in-this-standard-referenceerror"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-regexp">
      <h1>RegExp ( . . . )</h1>
      <p>See <emu-xref href="#sec-regexp-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-set">
      <h1>Set ( . . . )</h1>
      <p>See <emu-xref href="#sec-set-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-sharedarraybuffer">
      <h1>SharedArrayBuffer ( . . . )</h1>
      <p>See <emu-xref href="#sec-sharedarraybuffer-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-string">
      <h1>String ( . . . )</h1>
      <p>See <emu-xref href="#sec-string-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-symbol">
      <h1>Symbol ( . . . )</h1>
      <p>See <emu-xref href="#sec-symbol-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-syntaxerror">
      <h1>SyntaxError ( . . . )</h1>
      <p>See <emu-xref href="#sec-native-error-types-used-in-this-standard-syntaxerror"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-typeerror">
      <h1>TypeError ( . . . )</h1>
      <p>See <emu-xref href="#sec-native-error-types-used-in-this-standard-typeerror"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-uint8array">
      <h1>Uint8Array ( . . . )</h1>
      <p>See <emu-xref href="#sec-typedarray-constructors"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-uint8clampedarray">
      <h1>Uint8ClampedArray ( . . . )</h1>
      <p>See <emu-xref href="#sec-typedarray-constructors"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-uint16array">
      <h1>Uint16Array ( . . . )</h1>
      <p>See <emu-xref href="#sec-typedarray-constructors"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-uint32array">
      <h1>Uint32Array ( . . . )</h1>
      <p>See <emu-xref href="#sec-typedarray-constructors"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-urierror">
      <h1>URIError ( . . . )</h1>
      <p>See <emu-xref href="#sec-native-error-types-used-in-this-standard-urierror"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-weakmap">
      <h1>WeakMap ( . . . )</h1>
      <p>See <emu-xref href="#sec-weakmap-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-weakset">
      <h1>WeakSet ( . . . )</h1>
      <p>See <emu-xref href="#sec-weakset-objects"></emu-xref>.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-other-properties-of-the-global-object">
    <h1>Other Properties of the Global Object</h1>

    <emu-clause id="sec-atomics">
      <h1>Atomics</h1>
      <p>See <emu-xref href="#sec-atomics-object"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-json">
      <h1>JSON</h1>
      <p>See <emu-xref href="#sec-json-object"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-math">
      <h1>Math</h1>
      <p>See <emu-xref href="#sec-math-object"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-reflect">
      <h1>Reflect</h1>
      <p>See <emu-xref href="#sec-reflect-object"></emu-xref>.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-fundamental-objects">
  <h1>Fundamental Objects</h1>

  <emu-clause id="sec-object-objects">
    <h1>Object Objects</h1>

    <emu-clause id="sec-object-constructor">
      <h1>The Object Constructor</h1>
      <p>The Object constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%Object%</dfn>.</li>
        <li>is the initial value of the `Object` property of the global object.</li>
        <li>creates a new ordinary object when called as a constructor.</li>
        <li>performs a type conversion when called as a function rather than as a constructor.</li>
        <li>is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition.</li>
      </ul>

      <emu-clause id="sec-object-value">
        <h1>Object ( [ _value_ ] )</h1>
        <p>When the `Object` function is called with optional argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If NewTarget is neither *undefined* nor the active function, then
            1. Return ? OrdinaryCreateFromConstructor(NewTarget, `"%ObjectPrototype%"`).
          1. If _value_ is *null*, *undefined* or not supplied, return ObjectCreate(%ObjectPrototype%).
          1. Return ! ToObject(_value_).
        </emu-alg>
        <p>The `"length"` property of the `Object` constructor function is 1.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-object-constructor">
      <h1>Properties of the Object Constructor</h1>
      <p>The Object constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.</li>
        <li>has a `"length"` property.</li>
        <li>has the following additional properties:</li>
      </ul>

      <emu-clause id="sec-object.assign">
        <h1>Object.assign ( _target_, ..._sources_ )</h1>
        <p>The `assign` function is used to copy the values of all of the enumerable own properties from one or more source objects to a _target_ object. When the `assign` function is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _to_ be ? ToObject(_target_).
          1. If only one argument was passed, return _to_.
          1. Let _sources_ be the List of argument values starting with the second argument.
          1. For each element _nextSource_ of _sources_, in ascending index order, do
            1. If _nextSource_ is neither *undefined* nor *null*, then
              1. Let _from_ be ! ToObject(_nextSource_).
              1. Let _keys_ be ? _from_.[[OwnPropertyKeys]]().
              1. For each element _nextKey_ of _keys_ in List order, do
                1. Let _desc_ be ? _from_.[[GetOwnProperty]](_nextKey_).
                1. If _desc_ is not *undefined* and _desc_.[[Enumerable]] is *true*, then
                  1. Let _propValue_ be ? Get(_from_, _nextKey_).
                  1. Perform ? Set(_to_, _nextKey_, _propValue_, *true*).
          1. Return _to_.
        </emu-alg>
        <p>The `"length"` property of the `assign` function is 2.</p>
      </emu-clause>

      <emu-clause id="sec-object.create">
        <h1>Object.create ( _O_, _Properties_ )</h1>
        <p>The `create` function creates a new object with a specified prototype. When the `create` function is called, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_O_) is neither Object nor Null, throw a *TypeError* exception.
          1. Let _obj_ be ObjectCreate(_O_).
          1. If _Properties_ is not *undefined*, then
            1. Return ? ObjectDefineProperties(_obj_, _Properties_).
          1. Return _obj_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.defineproperties">
        <h1>Object.defineProperties ( _O_, _Properties_ )</h1>
        <p>The `defineProperties` function is used to add own properties and/or update the attributes of existing own properties of an object. When the `defineProperties` function is called, the following steps are taken:</p>
        <emu-alg>
          1. Return ? ObjectDefineProperties(_O_, _Properties_).
        </emu-alg>

        <emu-clause id="sec-objectdefineproperties" aoid="ObjectDefineProperties">
          <h1>Runtime Semantics: ObjectDefineProperties ( _O_, _Properties_ )</h1>
          <p>The abstract operation ObjectDefineProperties with arguments _O_ and _Properties_ performs the following steps:</p>
          <emu-alg>
            1. If Type(_O_) is not Object, throw a *TypeError* exception.
            1. Let _props_ be ? ToObject(_Properties_).
            1. Let _keys_ be ? _props_.[[OwnPropertyKeys]]().
            1. Let _descriptors_ be a new empty List.
            1. For each element _nextKey_ of _keys_ in List order, do
              1. Let _propDesc_ be ? _props_.[[GetOwnProperty]](_nextKey_).
              1. If _propDesc_ is not *undefined* and _propDesc_.[[Enumerable]] is *true*, then
                1. Let _descObj_ be ? Get(_props_, _nextKey_).
                1. Let _desc_ be ? ToPropertyDescriptor(_descObj_).
                1. Append the pair (a two element List) consisting of _nextKey_ and _desc_ to the end of _descriptors_.
            1. For each _pair_ from _descriptors_ in list order, do
              1. Let _P_ be the first element of _pair_.
              1. Let _desc_ be the second element of _pair_.
              1. Perform ? DefinePropertyOrThrow(_O_, _P_, _desc_).
            1. Return _O_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object.defineproperty">
        <h1>Object.defineProperty ( _O_, _P_, _Attributes_ )</h1>
        <p>The `defineProperty` function is used to add an own property and/or update the attributes of an existing own property of an object. When the `defineProperty` function is called, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_O_) is not Object, throw a *TypeError* exception.
          1. Let _key_ be ? ToPropertyKey(_P_).
          1. Let _desc_ be ? ToPropertyDescriptor(_Attributes_).
          1. Perform ? DefinePropertyOrThrow(_O_, _key_, _desc_).
          1. Return _O_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.entries">
        <h1>Object.entries ( _O_ )</h1>
        <p>When the `entries` function is called with argument _O_, the following steps are taken:</p>
        <emu-alg>
          1. Let _obj_ be ? ToObject(_O_).
          1. Let _nameList_ be ? EnumerableOwnPropertyNames(_obj_, *"key+value"*).
          1. Return CreateArrayFromList(_nameList_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.freeze">
        <h1>Object.freeze ( _O_ )</h1>
        <p>When the `freeze` function is called, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_O_) is not Object, return _O_.
          1. Let _status_ be ? SetIntegrityLevel(_O_, `"frozen"`).
          1. If _status_ is *false*, throw a *TypeError* exception.
          1. Return _O_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.fromentries">
        <h1>Object.fromEntries ( _iterable_ )</h1>
        <p>When the `fromEntries` method is called with argument _iterable_, the following steps are taken:</p>
        <emu-alg>
          1. Perform ? RequireObjectCoercible(_iterable_).
          1. Let _obj_ be ObjectCreate(%ObjectPrototype%).
          1. Assert: _obj_ is an extensible ordinary object with no own properties.
          1. Let _stepsDefine_ be the algorithm steps defined in <emu-xref href="#sec-create-data-property-on-object-functions" title></emu-xref>.
          1. Let _adder_ be CreateBuiltinFunction(_stepsDefine_, &laquo; &raquo;).
          1. Return ? AddEntriesFromIterable(_obj_, _iterable_, _adder_).
        </emu-alg>
        <emu-note>
          The function created for _adder_ is never directly accessible to ECMAScript code.
        </emu-note>

        <emu-clause id="sec-create-data-property-on-object-functions">
          <h1>CreateDataPropertyOnObject Functions</h1>
          <p>A CreateDataPropertyOnObject function is an anonymous built-in function. When a CreateDataPropertyOnObject function is called with arguments _key_ and _value_, the following steps are taken:</p>
          <emu-alg>
            1. Let _O_ be the *this* value.
            1. Assert: Type(_O_) is Object.
            1. Assert: _O_ is an extensible ordinary object.
            1. Let _propertyKey_ be ? ToPropertyKey(_key_).
            1. Perform ! CreateDataPropertyOrThrow(_O_, _propertyKey_, _value_).
            1. Return *undefined*.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertydescriptor">
        <h1>Object.getOwnPropertyDescriptor ( _O_, _P_ )</h1>
        <p>When the `getOwnPropertyDescriptor` function is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _obj_ be ? ToObject(_O_).
          1. Let _key_ be ? ToPropertyKey(_P_).
          1. Let _desc_ be ? _obj_.[[GetOwnProperty]](_key_).
          1. Return FromPropertyDescriptor(_desc_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertydescriptors">
        <h1>Object.getOwnPropertyDescriptors ( _O_ )</h1>
        <p>When the `getOwnPropertyDescriptors` function is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _obj_ be ? ToObject(_O_).
          1. Let _ownKeys_ be ? _obj_.[[OwnPropertyKeys]]().
          1. Let _descriptors_ be ! ObjectCreate(%ObjectPrototype%).
          1. For each element _key_ of _ownKeys_ in List order, do
            1. Let _desc_ be ? _obj_.[[GetOwnProperty]](_key_).
            1. Let _descriptor_ be ! FromPropertyDescriptor(_desc_).
            1. If _descriptor_ is not *undefined*, perform ! CreateDataProperty(_descriptors_, _key_, _descriptor_).
          1. Return _descriptors_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertynames">
        <h1>Object.getOwnPropertyNames ( _O_ )</h1>
        <p>When the `getOwnPropertyNames` function is called, the following steps are taken:</p>
        <emu-alg>
          1. Return ? GetOwnPropertyKeys(_O_, String).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertysymbols">
        <h1>Object.getOwnPropertySymbols ( _O_ )</h1>
        <p>When the `getOwnPropertySymbols` function is called with argument _O_, the following steps are taken:</p>
        <emu-alg>
          1. Return ? GetOwnPropertyKeys(_O_, Symbol).
        </emu-alg>

        <emu-clause id="sec-getownpropertykeys" aoid="GetOwnPropertyKeys">
          <h1>Runtime Semantics: GetOwnPropertyKeys ( _O_, _type_ )</h1>
          <p>The abstract operation GetOwnPropertyKeys is called with arguments _O_ and _type_ where _O_ is an Object and _type_ is one of the ECMAScript specification types String or Symbol. The following steps are taken:</p>
          <emu-alg>
            1. Let _obj_ be ? ToObject(_O_).
            1. Let _keys_ be ? _obj_.[[OwnPropertyKeys]]().
            1. Let _nameList_ be a new empty List.
            1. For each element _nextKey_ of _keys_ in List order, do
              1. If Type(_nextKey_) is _type_, then
                1. Append _nextKey_ as the last element of _nameList_.
            1. Return CreateArrayFromList(_nameList_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object.getprototypeof">
        <h1>Object.getPrototypeOf ( _O_ )</h1>
        <p>When the `getPrototypeOf` function is called with argument _O_, the following steps are taken:</p>
        <emu-alg>
          1. Let _obj_ be ? ToObject(_O_).
          1. Return ? _obj_.[[GetPrototypeOf]]().
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.is">
        <h1>Object.is ( _value1_, _value2_ )</h1>
        <p>When the `is` function is called with arguments _value1_ and _value2_, the following steps are taken:</p>
        <emu-alg>
          1. Return SameValue(_value1_, _value2_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.isextensible">
        <h1>Object.isExtensible ( _O_ )</h1>
        <p>When the `isExtensible` function is called with argument _O_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_O_) is not Object, return *false*.
          1. Return ? IsExtensible(_O_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.isfrozen">
        <h1>Object.isFrozen ( _O_ )</h1>
        <p>When the `isFrozen` function is called with argument _O_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_O_) is not Object, return *true*.
          1. Return ? TestIntegrityLevel(_O_, `"frozen"`).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.issealed">
        <h1>Object.isSealed ( _O_ )</h1>
        <p>When the `isSealed` function is called with argument _O_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_O_) is not Object, return *true*.
          1. Return ? TestIntegrityLevel(_O_, `"sealed"`).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.keys">
        <h1>Object.keys ( _O_ )</h1>
        <p>When the `keys` function is called with argument _O_, the following steps are taken:</p>
        <emu-alg>
          1. Let _obj_ be ? ToObject(_O_).
          1. Let _nameList_ be ? EnumerableOwnPropertyNames(_obj_, *"key"*).
          1. Return CreateArrayFromList(_nameList_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.preventextensions">
        <h1>Object.preventExtensions ( _O_ )</h1>
        <p>When the `preventExtensions` function is called, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_O_) is not Object, return _O_.
          1. Let _status_ be ? _O_.[[PreventExtensions]]().
          1. If _status_ is *false*, throw a *TypeError* exception.
          1. Return _O_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.prototype">
        <h1>Object.prototype</h1>
        <p>The initial value of `Object.prototype` is the intrinsic object %ObjectPrototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-object.seal">
        <h1>Object.seal ( _O_ )</h1>
        <p>When the `seal` function is called, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_O_) is not Object, return _O_.
          1. Let _status_ be ? SetIntegrityLevel(_O_, `"sealed"`).
          1. If _status_ is *false*, throw a *TypeError* exception.
          1. Return _O_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.setprototypeof">
        <h1>Object.setPrototypeOf ( _O_, _proto_ )</h1>
        <p>When the `setPrototypeOf` function is called with arguments _O_ and _proto_, the following steps are taken:</p>
        <emu-alg>
          1. Set _O_ to ? RequireObjectCoercible(_O_).
          1. If Type(_proto_) is neither Object nor Null, throw a *TypeError* exception.
          1. If Type(_O_) is not Object, return _O_.
          1. Let _status_ be ? _O_.[[SetPrototypeOf]](_proto_).
          1. If _status_ is *false*, throw a *TypeError* exception.
          1. Return _O_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.values">
        <h1>Object.values ( _O_ )</h1>
        <p>When the `values` function is called with argument _O_, the following steps are taken:</p>
        <emu-alg>
          1. Let _obj_ be ? ToObject(_O_).
          1. Let _nameList_ be ? EnumerableOwnPropertyNames(_obj_, *"value"*).
          1. Return CreateArrayFromList(_nameList_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-object-prototype-object">
      <h1>Properties of the Object Prototype Object</h1>
      <p>The Object prototype object:</p>
      <ul>
        <li>is the intrinsic object <dfn>%ObjectPrototype%</dfn>.</li>
        <li>is an immutable prototype exotic object.</li>
        <li>has a [[Prototype]] internal slot whose value is *null*.</li>
      </ul>

      <emu-clause id="sec-object.prototype.constructor">
        <h1>Object.prototype.constructor</h1>
        <p>The initial value of `Object.prototype.constructor` is the intrinsic object %Object%.</p>
      </emu-clause>

      <emu-clause id="sec-object.prototype.hasownproperty">
        <h1>Object.prototype.hasOwnProperty ( _V_ )</h1>
        <p>When the `hasOwnProperty` method is called with argument _V_, the following steps are taken:</p>
        <emu-alg>
          1. Let _P_ be ? ToPropertyKey(_V_).
          1. Let _O_ be ? ToObject(*this* value).
          1. Return ? HasOwnProperty(_O_, _P_).
        </emu-alg>
        <emu-note>
          <p>The ordering of steps 1 and 2 is chosen to ensure that any exception that would have been thrown by step 1 in previous editions of this specification will continue to be thrown even if the *this* value is *undefined* or *null*.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.isprototypeof">
        <h1>Object.prototype.isPrototypeOf ( _V_ )</h1>
        <p>When the `isPrototypeOf` method is called with argument _V_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_V_) is not Object, return *false*.
          1. Let _O_ be ? ToObject(*this* value).
          1. Repeat,
            1. Set _V_ to ? _V_.[[GetPrototypeOf]]().
            1. If _V_ is *null*, return *false*.
            1. If SameValue(_O_, _V_) is *true*, return *true*.
        </emu-alg>
        <emu-note>
          <p>The ordering of steps 1 and 2 preserves the behaviour specified by previous editions of this specification for the case where _V_ is not an object and the *this* value is *undefined* or *null*.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.propertyisenumerable">
        <h1>Object.prototype.propertyIsEnumerable ( _V_ )</h1>
        <p>When the `propertyIsEnumerable` method is called with argument _V_, the following steps are taken:</p>
        <emu-alg>
          1. Let _P_ be ? ToPropertyKey(_V_).
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _desc_ be ? _O_.[[GetOwnProperty]](_P_).
          1. If _desc_ is *undefined*, return *false*.
          1. Return _desc_.[[Enumerable]].
        </emu-alg>
        <emu-note>
          <p>This method does not consider objects in the prototype chain.</p>
        </emu-note>
        <emu-note>
          <p>The ordering of steps 1 and 2 is chosen to ensure that any exception that would have been thrown by step 1 in previous editions of this specification will continue to be thrown even if the *this* value is *undefined* or *null*.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.tolocalestring">
        <h1>Object.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>When the `toLocaleString` method is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Return ? Invoke(_O_, `"toString"`).
        </emu-alg>
        <p>The optional parameters to this function are not used but are intended to correspond to the parameter pattern used by ECMA-402 `toLocaleString` functions. Implementations that do not include ECMA-402 support must not use those parameter positions for other purposes.</p>
        <emu-note>
          <p>This function provides a generic `toLocaleString` implementation for objects that have no locale-specific `toString` behaviour. `Array`, `Number`, `Date`, and `Typed Arrays` provide their own locale-sensitive `toLocaleString` methods.</p>
        </emu-note>
        <emu-note>
          <p>ECMA-402 intentionally does not provide an alternative to this default implementation.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.tostring">
        <h1>Object.prototype.toString ( )</h1>
        <p>When the `toString` method is called, the following steps are taken:</p>
        <emu-alg>
          1. If the *this* value is *undefined*, return `"[object Undefined]"`.
          1. If the *this* value is *null*, return `"[object Null]"`.
          1. Let _O_ be ! ToObject(*this* value).
          1. Let _isArray_ be ? IsArray(_O_).
          1. If _isArray_ is *true*, let _builtinTag_ be `"Array"`.
          1. Else if _O_ has a [[ParameterMap]] internal slot, let _builtinTag_ be `"Arguments"`.
          1. Else if _O_ has a [[Call]] internal method, let _builtinTag_ be `"Function"`.
          1. Else if _O_ has an [[ErrorData]] internal slot, let _builtinTag_ be `"Error"`.
          1. Else if _O_ has a [[BooleanData]] internal slot, let _builtinTag_ be `"Boolean"`.
          1. Else if _O_ has a [[NumberData]] internal slot, let _builtinTag_ be `"Number"`.
          1. Else if _O_ has a [[StringData]] internal slot, let _builtinTag_ be `"String"`.
          1. Else if _O_ has a [[DateValue]] internal slot, let _builtinTag_ be `"Date"`.
          1. Else if _O_ has a [[RegExpMatcher]] internal slot, let _builtinTag_ be `"RegExp"`.
          1. Else, let _builtinTag_ be `"Object"`.
          1. Let _tag_ be ? Get(_O_, @@toStringTag).
          1. If Type(_tag_) is not String, set _tag_ to _builtinTag_.
          1. Return the string-concatenation of `"[object "`, _tag_, and `"]"`.
        </emu-alg>
        <p>This function is the <dfn>%ObjProto_toString%</dfn> intrinsic object.</p>
        <emu-note>
          <p>Historically, this function was occasionally used to access the String value of the [[Class]] internal slot that was used in previous editions of this specification as a nominal type tag for various built-in objects. The above definition of `toString` preserves compatibility for legacy code that uses `toString` as a test for those specific kinds of built-in objects. It does not provide a reliable type testing mechanism for other kinds of built-in or program defined objects. In addition, programs can use @@toStringTag in ways that will invalidate the reliability of such legacy type tests.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.valueof">
        <h1>Object.prototype.valueOf ( )</h1>
        <p>When the `valueOf` method is called, the following steps are taken:</p>
        <emu-alg>
          1. Return ? ToObject(*this* value).
        </emu-alg>
        <p>This function is the <dfn>%ObjProto_valueOf%</dfn> intrinsic object.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-object-instances">
      <h1>Properties of Object Instances</h1>
      <p>Object instances have no special properties beyond those inherited from the Object prototype object.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-function-objects">
    <h1>Function Objects</h1>

    <emu-clause id="sec-function-constructor">
      <h1>The Function Constructor</h1>
      <p>The Function constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%Function%</dfn>.</li>
        <li>is the initial value of the `Function` property of the global object.</li>
        <li>creates and initializes a new function object when called as a function rather than as a constructor. Thus the function call `Function(&hellip;)` is equivalent to the object creation expression `new Function(&hellip;)` with the same arguments.</li>
        <li>is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `Function` behaviour must include a `super` call to the `Function` constructor to create and initialize a subclass instance with the internal slots necessary for built-in function behaviour. All ECMAScript syntactic forms for defining function objects create instances of `Function`. There is no syntactic means to create instances of `Function` subclasses except for the built-in `GeneratorFunction`, `AsyncFunction`, and `AsyncGeneratorFunction` subclasses.</li>
      </ul>

      <emu-clause id="sec-function-p1-p2-pn-body">
        <h1>Function ( _p1_, _p2_, &hellip; , _pn_, _body_ )</h1>
        <p>The last argument specifies the body (executable code) of a function; any preceding arguments specify formal parameters.</p>
        <p>When the `Function` function is called with some arguments _p1_, _p2_, &hellip; , _pn_, _body_ (where _n_ might be 0, that is, there are no &ldquo; _p_ &rdquo; arguments, and where _body_ might also not be provided), the following steps are taken:</p>
        <emu-alg>
          1. Let _C_ be the active function object.
          1. Let _args_ be the _argumentsList_ that was passed to this function by [[Call]] or [[Construct]].
          1. Return ? CreateDynamicFunction(_C_, NewTarget, `"normal"`, _args_).
        </emu-alg>
        <emu-note>
          <p>It is permissible but not necessary to have one argument for each formal parameter to be specified. For example, all three of the following expressions produce the same result:</p>
          <pre><code class="javascript">
            new Function("a", "b", "c", "return a+b+c")
            new Function("a, b, c", "return a+b+c")
            new Function("a,b", "c", "return a+b+c")
          </code></pre>
        </emu-note>

        <emu-clause id="sec-createdynamicfunction" aoid="CreateDynamicFunction">
          <h1>Runtime Semantics: CreateDynamicFunction ( _constructor_, _newTarget_, _kind_, _args_ )</h1>
          <p>The abstract operation CreateDynamicFunction is called with arguments _constructor_, _newTarget_, _kind_, and _args_. _constructor_ is the constructor function that is performing this action, _newTarget_ is the constructor that `new` was initially applied to, _kind_ is either `"normal"`, `"generator"`, `"async"`, or `"async generator"`, and _args_ is a List containing the actual argument values that were passed to _constructor_. The following steps are taken:</p>
          <emu-alg>
            1. Assert: The execution context stack has at least two elements.
            1. Let _callerContext_ be the second to top element of the execution context stack.
            1. Let _callerRealm_ be _callerContext_'s Realm.
            1. Let _calleeRealm_ be the current Realm Record.
            1. Perform ? HostEnsureCanCompileStrings(_callerRealm_, _calleeRealm_).
            1. If _newTarget_ is *undefined*, set _newTarget_ to _constructor_.
            1. If _kind_ is `"normal"`, then
              1. Let _goal_ be the grammar symbol |FunctionBody[~Yield, ~Await]|.
              1. Let _parameterGoal_ be the grammar symbol |FormalParameters[~Yield, ~Await]|.
              1. Let _fallbackProto_ be `"%FunctionPrototype%"`.
            1. Else if _kind_ is `"generator"`, then
              1. Let _goal_ be the grammar symbol |GeneratorBody|.
              1. Let _parameterGoal_ be the grammar symbol |FormalParameters[+Yield, ~Await]|.
              1. Let _fallbackProto_ be `"%Generator%"`.
            1. Else if _kind_ is `"async"`, then
              1. Let _goal_ be the grammar symbol |AsyncFunctionBody|.
              1. Let _parameterGoal_ be the grammar symbol |FormalParameters[~Yield, +Await]|.
              1. Let _fallbackProto_ be `"%AsyncFunctionPrototype%"`.
            1. Else,
              1. Assert: _kind_ is `"async generator"`.
              1. Let _goal_ be the grammar symbol |AsyncGeneratorBody|.
              1. Let _parameterGoal_ be the grammar symbol |FormalParameters[+Yield, +Await]|.
              1. Let _fallbackProto_ be `"%AsyncGenerator%"`.
            1. Let _argCount_ be the number of elements in _args_.
            1. Let _P_ be the empty String.
            1. If _argCount_ = 0, let _bodyText_ be the empty String.
            1. Else if _argCount_ = 1, let _bodyText_ be _args_[0].
            1. Else _argCount_ &gt; 1,
              1. Let _firstArg_ be _args_[0].
              1. Set _P_ to ? ToString(_firstArg_).
              1. Let _k_ be 1.
              1. Repeat, while _k_ &lt; _argCount_ - 1
                1. Let _nextArg_ be _args_[_k_].
                1. Let _nextArgString_ be ? ToString(_nextArg_).
                1. Set _P_ to the string-concatenation of the previous value of _P_, `","` (a comma), and _nextArgString_.
                1. Increase _k_ by 1.
              1. Let _bodyText_ be _args_[_k_].
            1. Set _bodyText_ to ? ToString(_bodyText_).
            1. Let _parameters_ be the result of parsing _P_, interpreted as UTF-16 encoded Unicode text as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>, using _parameterGoal_ as the goal symbol. Throw a *SyntaxError* exception if the parse fails.
            1. Let _body_ be the result of parsing _bodyText_, interpreted as UTF-16 encoded Unicode text as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>, using _goal_ as the goal symbol. Throw a *SyntaxError* exception if the parse fails.
            1. Let _strict_ be ContainsUseStrict of _body_.
            1. If any static semantics errors are detected for _parameters_ or _body_, throw a *SyntaxError* or a *ReferenceError* exception, depending on the type of the error. If _strict_ is *true*, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied. Parsing and early error detection may be interweaved in an implementation-dependent manner.
            1. If _strict_ is *true* and IsSimpleParameterList of _parameters_ is *false*, throw a *SyntaxError* exception.
            1. If any element of the BoundNames of _parameters_ also occurs in the LexicallyDeclaredNames of _body_, throw a *SyntaxError* exception.
            1. If _body_ Contains |SuperCall| is *true*, throw a *SyntaxError* exception.
            1. If _parameters_ Contains |SuperCall| is *true*, throw a *SyntaxError* exception.
            1. If _body_ Contains |SuperProperty| is *true*, throw a *SyntaxError* exception.
            1. If _parameters_ Contains |SuperProperty| is *true*, throw a *SyntaxError* exception.
            1. If _kind_ is `"generator"` or `"async generator"`, then
              1. If _parameters_ Contains |YieldExpression| is *true*, throw a *SyntaxError* exception.
            1. If _kind_ is `"async"` or `"async generator"`, then
              1. If _parameters_ Contains |AwaitExpression| is *true*, throw a *SyntaxError* exception.
            1. If _strict_ is *true*, then
              1. If BoundNames of _parameters_ contains any duplicate elements, throw a *SyntaxError* exception.
            1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, _fallbackProto_).
            1. Let _F_ be FunctionAllocate(_proto_, _strict_, _kind_).
            1. Let _realmF_ be _F_.[[Realm]].
            1. Let _scope_ be _realmF_.[[GlobalEnv]].
            1. Perform FunctionInitialize(_F_, ~Normal~, _parameters_, _body_, _scope_).
            1. If _kind_ is `"generator"`, then
              1. Let _prototype_ be ObjectCreate(%GeneratorPrototype%).
              1. Perform DefinePropertyOrThrow(_F_, `"prototype"`, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
            1. Else if _kind_ is `"async generator"`, then
              1. Let _prototype_ be ObjectCreate(%AsyncGeneratorPrototype%).
              1. Perform DefinePropertyOrThrow(_F_, `"prototype"`, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
            1. Else if _kind_ is `"normal"`, perform MakeConstructor(_F_).
            1. NOTE: Async functions are not constructable and do not have a [[Construct]] internal method or a `"prototype"` property.
            1. Perform SetFunctionName(_F_, `"anonymous"`).
            1. Let _prefix_ be the prefix associated with _kind_ in <emu-xref href="#table-dynamic-function-sourcetext-prefixes"></emu-xref>.
            1. Let _sourceText_ be the string-concatenation of _prefix_, `" anonymous("`, _P_, 0x000A (LINE FEED), `") {"`, 0x000A (LINE FEED), _bodyText_, 0x000A (LINE FEED), and `"}"`.
            1. Set _F_.[[SourceText]] to _sourceText_.
            1. Return _F_.
          </emu-alg>
          <emu-note>
            <p>A `prototype` property is created for every non-async function created using CreateDynamicFunction to provide for the possibility that the function will be used as a constructor.</p>
          </emu-note>

          <emu-table id="table-dynamic-function-sourcetext-prefixes" caption="Dynamic Function SourceText Prefixes">
            <table>
              <tbody>
                <tr><th>Kind</th><th>Prefix</th></tr>
                <tr><td>`"normal"`</td><td>`"function"`</td></tr>
                <tr><td>`"generator"`</td><td>`"function*"`</td></tr>
                <tr><td>`"async"`</td><td>`"async function"`</td></tr>
                <tr><td>`"async generator"`</td><td>`"async function*"`</td></tr>
              </tbody>
            </table>
          </emu-table>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-function-constructor">
      <h1>Properties of the Function Constructor</h1>
      <p>The Function constructor:</p>
      <ul>
        <li>is itself a built-in function object.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-function.length">
        <h1>Function.length</h1>
        <p>This is a data property with a value of 1. This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-function.prototype">
        <h1>Function.prototype</h1>
        <p>The value of `Function.prototype` is %FunctionPrototype%, the intrinsic Function prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-function-prototype-object">
      <h1>Properties of the Function Prototype Object</h1>
      <p>The Function prototype object:</p>
      <ul>
        <li>is the intrinsic object <dfn>%FunctionPrototype%</dfn>.</li>
        <li>is itself a built-in function object.</li>
        <li>accepts any arguments and returns *undefined* when invoked.</li>
        <li>does not have a [[Construct]] internal method; it cannot be used as a constructor with the `new` operator.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
        <li>does not have a `prototype` property.</li>
        <li>has a `"length"` property whose value is 0.</li>
        <li>has a `name` property whose value is the empty String.</li>
      </ul>
      <emu-note>
        <p>The Function prototype object is specified to be a function object to ensure compatibility with ECMAScript code that was created prior to the ECMAScript 2015 specification.</p>
      </emu-note>

      <emu-clause id="sec-function.prototype.apply">
        <h1>Function.prototype.apply ( _thisArg_, _argArray_ )</h1>
        <p>When the `apply` method is called with arguments _thisArg_ and _argArray_, the following steps are taken:</p>
        <emu-alg>
          1. Let _func_ be the *this* value.
          1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.
          1. If _argArray_ is *undefined* or *null*, then
            1. Perform PrepareForTailCall().
            1. Return ? Call(_func_, _thisArg_).
          1. Let _argList_ be ? CreateListFromArrayLike(_argArray_).
          1. Perform PrepareForTailCall().
          1. Return ? Call(_func_, _thisArg_, _argList_).
        </emu-alg>
        <emu-note>
          <p>The _thisArg_ value is passed without modification as the *this* value. This is a change from Edition 3, where an *undefined* or *null* _thisArg_ is replaced with the global object and ToObject is applied to all other values and that result is passed as the *this* value. Even though the _thisArg_ is passed without modification, non-strict functions still perform these transformations upon entry to the function.</p>
        </emu-note>
        <emu-note>
          <p>If _func_ is an arrow function or a bound function then the _thisArg_ will be ignored by the function [[Call]] in step 5.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-function.prototype.bind">
        <h1>Function.prototype.bind ( _thisArg_, ..._args_ )</h1>
        <p>When the `bind` method is called with argument _thisArg_ and zero or more _args_, it performs the following steps:</p>
        <emu-alg>
          1. Let _Target_ be the *this* value.
          1. If IsCallable(_Target_) is *false*, throw a *TypeError* exception.
          1. Let _args_ be a new (possibly empty) List consisting of all of the argument values provided after _thisArg_ in order.
          1. Let _F_ be ? BoundFunctionCreate(_Target_, _thisArg_, _args_).
          1. Let _targetHasLength_ be ? HasOwnProperty(_Target_, `"length"`).
          1. If _targetHasLength_ is *true*, then
            1. Let _targetLen_ be ? Get(_Target_, `"length"`).
            1. If Type(_targetLen_) is not Number, let _L_ be 0.
            1. Else,
              1. Set _targetLen_ to ! ToInteger(_targetLen_).
              1. Let _L_ be the larger of 0 and the result of _targetLen_ minus the number of elements of _args_.
          1. Else, let _L_ be 0.
          1. Perform ! SetFunctionLength(_F_, _L_).
          1. Let _targetName_ be ? Get(_Target_, `"name"`).
          1. If Type(_targetName_) is not String, set _targetName_ to the empty string.
          1. Perform SetFunctionName(_F_, _targetName_, `"bound"`).
          1. Return _F_.
        </emu-alg>
        <emu-note>
          <p>Function objects created using `Function.prototype.bind` are exotic objects. They also do not have a `prototype` property.</p>
        </emu-note>
        <emu-note>
          <p>If _Target_ is an arrow function or a bound function then the _thisArg_ passed to this method will not be used by subsequent calls to _F_.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-function.prototype.call">
        <h1>Function.prototype.call ( _thisArg_, ..._args_ )</h1>
        <p>When the `call` method is called with argument _thisArg_ and zero or more _args_, the following steps are taken:</p>
        <emu-alg>
          1. Let _func_ be the *this* value.
          1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.
          1. Let _argList_ be a new empty List.
          1. If this method was called with more than one argument, then in left to right order, starting with the second argument, append each argument as the last element of _argList_.
          1. Perform PrepareForTailCall().
          1. Return ? Call(_func_, _thisArg_, _argList_).
        </emu-alg>
        <emu-note>
          <p>The _thisArg_ value is passed without modification as the *this* value. This is a change from Edition 3, where an *undefined* or *null* _thisArg_ is replaced with the global object and ToObject is applied to all other values and that result is passed as the *this* value. Even though the _thisArg_ is passed without modification, non-strict functions still perform these transformations upon entry to the function.</p>
        </emu-note>
        <emu-note>
          <p>If _func_ is an arrow function or a bound function then the _thisArg_ will be ignored by the function [[Call]] in step 5.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-function.prototype.constructor">
        <h1>Function.prototype.constructor</h1>
        <p>The initial value of `Function.prototype.constructor` is the intrinsic object %Function%.</p>
      </emu-clause>

      <emu-clause id="sec-function.prototype.tostring">
        <h1>Function.prototype.toString ( )</h1>
        <p>When the `toString` method is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _func_ be the *this* value.
          1. If _func_ is a <emu-xref href="#sec-bound-function-exotic-objects">Bound Function exotic object</emu-xref> or a <emu-xref href="#sec-built-in-function-objects">built-in function object</emu-xref>, then return an implementation-dependent String source code representation of _func_. The representation must have the syntax of a |NativeFunction|. Additionally, if _func_ is a <emu-xref href="#sec-well-known-intrinsic-objects">Well-known Intrinsic Object</emu-xref> and is not identified as an anonymous function, the portion of the returned String that would be matched by |PropertyName| must be the initial value of the `name` property of _func_.
          1. If Type(_func_) is Object and _func_ has a [[SourceText]] internal slot and Type(_func_.[[SourceText]]) is String and ! HostHasSourceTextAvailable(_func_) is *true*, then return _func_.[[SourceText]].
          1. If Type(_func_) is Object and IsCallable(_func_) is *true*, then return an implementation-dependent String source code representation of _func_. The representation must have the syntax of a |NativeFunction|.
          1. Throw a *TypeError* exception.
        </emu-alg>

        <emu-grammar type="definition">
          NativeFunction :
            `function` PropertyName[~Yield, ~Await]? `(` FormalParameters[~Yield, ~Await] `)` `{` `[` `native` `code` `]` `}`
        </emu-grammar>
      </emu-clause>

      <emu-clause id="sec-function.prototype-@@hasinstance">
        <h1>Function.prototype [ @@hasInstance ] ( _V_ )</h1>
        <p>When the `@@hasInstance` method of an object _F_ is called with value _V_, the following steps are taken:</p>
        <emu-alg>
          1. Let _F_ be the *this* value.
          1. Return ? OrdinaryHasInstance(_F_, _V_).
        </emu-alg>
        <p>The value of the `name` property of this function is `"[Symbol.hasInstance]"`.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        <emu-note>
          <p>This is the default implementation of `@@hasInstance` that most functions inherit. `@@hasInstance` is called by the `instanceof` operator to determine whether a value is an instance of a specific constructor. An expression such as</p>
          <pre><code class="javascript">
            v instanceof F
          </code></pre>
          <p>evaluates as</p>
          <pre><code class="javascript">
            F[@@hasInstance](v)
          </code></pre>
          <p>A constructor function can control which objects are recognized as its instances by `instanceof` by exposing a different `@@hasInstance` method on the function.</p>
        </emu-note>
        <p>This property is non-writable and non-configurable to prevent tampering that could be used to globally expose the target function of a bound function.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-instances">
      <h1>Function Instances</h1>
      <p>Every Function instance is an ECMAScript function object and has the internal slots listed in <emu-xref href="#table-27"></emu-xref>. Function objects created using the `Function.prototype.bind` method (<emu-xref href="#sec-function.prototype.bind"></emu-xref>) have the internal slots listed in <emu-xref href="#table-28"></emu-xref>.</p>
      <p>Function instances have the following properties:</p>

      <emu-clause id="sec-function-instances-length">
        <h1>length</h1>
        <p>The value of the `"length"` property is an integer that indicates the typical number of arguments expected by the function. However, the language permits the function to be invoked with some other number of arguments. The behaviour of a function when invoked on a number of arguments other than the number specified by its `"length"` property depends on the function. This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-function-instances-name">
        <h1>name</h1>
        <p>The value of the `name` property is a String that is descriptive of the function. The name has no semantic significance but is typically a variable or property name that is used to refer to the function at its point of definition in ECMAScript code. This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        <p>Anonymous functions objects that do not have a contextual name associated with them by this specification do not have a `name` own property but inherit the `name` property of %FunctionPrototype%.</p>
      </emu-clause>

      <emu-clause id="sec-function-instances-prototype">
        <h1>prototype</h1>
        <p>Function instances that can be used as a constructor have a `prototype` property. Whenever such a Function instance is created another ordinary object is also created and is the initial value of the function's `prototype` property. Unless otherwise specified, the value of the `prototype` property is used to initialize the [[Prototype]] internal slot of the object created when that function is invoked as a constructor.</p>
        <p>This property has the attributes { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        <emu-note>
          <p>Function objects created using `Function.prototype.bind`, or by evaluating a |MethodDefinition| (that is not a |GeneratorMethod| or |AsyncGeneratorMethod|) or an |ArrowFunction| do not have a `prototype` property.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-hosthassourcetextavailable">
      <h1>HostHasSourceTextAvailable ( _func_ )</h1>
      <p>HostHasSourceTextAvailable is an implementation-defined abstract operation that allows host environments to prevent the source text from being provided for a given function.</p>
      <p>An implementation of HostHasSourceTextAvailable must complete normally in all cases. This operation must be deterministic with respect to its parameters. Each time it is called with a specific _func_ as its argument, it must return the same completion record. The default implementation of HostHasSourceTextAvailable is to unconditionally return a normal completion with a value of *true*.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-boolean-objects">
    <h1>Boolean Objects</h1>

    <emu-clause id="sec-boolean-constructor">
      <h1>The Boolean Constructor</h1>
      <p>The Boolean constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%Boolean%</dfn>.</li>
        <li>is the initial value of the `Boolean` property of the global object.</li>
        <li>creates and initializes a new Boolean object when called as a constructor.</li>
        <li>performs a type conversion when called as a function rather than as a constructor.</li>
        <li>is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `Boolean` behaviour must include a `super` call to the `Boolean` constructor to create and initialize the subclass instance with a [[BooleanData]] internal slot.</li>
      </ul>

      <emu-clause id="sec-boolean-constructor-boolean-value">
        <h1>Boolean ( _value_ )</h1>
        <p>When `Boolean` is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _b_ be ToBoolean(_value_).
          1. If NewTarget is *undefined*, return _b_.
          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, `"%BooleanPrototype%"`, &laquo; [[BooleanData]] &raquo;).
          1. Set _O_.[[BooleanData]] to _b_.
          1. Return _O_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-boolean-constructor">
      <h1>Properties of the Boolean Constructor</h1>
      <p>The Boolean constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-boolean.prototype">
        <h1>Boolean.prototype</h1>
        <p>The initial value of `Boolean.prototype` is the intrinsic object %BooleanPrototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-boolean-prototype-object">
      <h1>Properties of the Boolean Prototype Object</h1>
      <p>The Boolean prototype object:</p>
      <ul>
        <li>is the intrinsic object <dfn>%BooleanPrototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>is itself a Boolean object; it has a [[BooleanData]] internal slot with the value *false*.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
      </ul>

      <p>The abstract operation <dfn id="sec-thisbooleanvalue" aoid="thisBooleanValue">thisBooleanValue</dfn>(_value_) performs the following steps:</p>
      <emu-alg>
        1. If Type(_value_) is Boolean, return _value_.
        1. If Type(_value_) is Object and _value_ has a [[BooleanData]] internal slot, then
          1. Let _b_ be _value_.[[BooleanData]].
          1. Assert: Type(_b_) is Boolean.
          1. Return _b_.
        1. Throw a *TypeError* exception.
      </emu-alg>

      <emu-clause id="sec-boolean.prototype.constructor">
        <h1>Boolean.prototype.constructor</h1>
        <p>The initial value of `Boolean.prototype.constructor` is the intrinsic object %Boolean%.</p>
      </emu-clause>

      <emu-clause id="sec-boolean.prototype.tostring">
        <h1>Boolean.prototype.toString ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _b_ be ? thisBooleanValue(*this* value).
          1. If _b_ is *true*, return `"true"`; else return `"false"`.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-boolean.prototype.valueof">
        <h1>Boolean.prototype.valueOf ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Return ? thisBooleanValue(*this* value).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-boolean-instances">
      <h1>Properties of Boolean Instances</h1>
      <p>Boolean instances are ordinary objects that inherit properties from the Boolean prototype object. Boolean instances have a [[BooleanData]] internal slot. The [[BooleanData]] internal slot is the Boolean value represented by this Boolean object.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-symbol-objects">
    <h1>Symbol Objects</h1>

    <emu-clause id="sec-symbol-constructor">
      <h1>The Symbol Constructor</h1>
      <p>The Symbol constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%Symbol%</dfn>.</li>
        <li>is the initial value of the `Symbol` property of the global object.</li>
        <li>returns a new Symbol value when called as a function.</li>
        <li>is not intended to be used with the `new` operator.</li>
        <li>is not intended to be subclassed.</li>
        <li>may be used as the value of an `extends` clause of a class definition but a `super` call to it will cause an exception.</li>
      </ul>

      <emu-clause id="sec-symbol-description">
        <h1>Symbol ( [ _description_ ] )</h1>
        <p>When `Symbol` is called with optional argument _description_, the following steps are taken:</p>
        <emu-alg>
          1. If NewTarget is not *undefined*, throw a *TypeError* exception.
          1. If _description_ is *undefined*, let _descString_ be *undefined*.
          1. Else, let _descString_ be ? ToString(_description_).
          1. Return a new unique Symbol value whose [[Description]] value is _descString_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-symbol-constructor">
      <h1>Properties of the Symbol Constructor</h1>
      <p>The Symbol constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-symbol.asynciterator">
        <h1>Symbol.asyncIterator</h1>
        <p>The initial value of `Symbol.asyncIterator` is the well known symbol @@asyncIterator (<emu-xref href="#table-1"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.for">
        <h1>Symbol.for ( _key_ )</h1>
        <p>When `Symbol.for` is called with argument _key_ it performs the following steps:</p>
        <emu-alg>
          1. Let _stringKey_ be ? ToString(_key_).
          1. For each element _e_ of the GlobalSymbolRegistry List, do
            1. If SameValue(_e_.[[Key]], _stringKey_) is *true*, return _e_.[[Symbol]].
          1. Assert: GlobalSymbolRegistry does not currently contain an entry for _stringKey_.
          1. Let _newSymbol_ be a new unique Symbol value whose [[Description]] value is _stringKey_.
          1. Append the Record { [[Key]]: _stringKey_, [[Symbol]]: _newSymbol_ } to the GlobalSymbolRegistry List.
          1. Return _newSymbol_.
        </emu-alg>
        <p>The GlobalSymbolRegistry is a List that is globally available. It is shared by all realms. Prior to the evaluation of any ECMAScript code it is initialized as a new empty List. Elements of the GlobalSymbolRegistry are Records with the structure defined in <emu-xref href="#table-44"></emu-xref>.</p>
        <emu-table id="table-44" caption="GlobalSymbolRegistry Record Fields">
          <table>
            <tbody>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value
              </th>
              <th>
                Usage
              </th>
            </tr>
            <tr>
              <td>
                [[Key]]
              </td>
              <td>
                A String
              </td>
              <td>
                A string key used to globally identify a Symbol.
              </td>
            </tr>
            <tr>
              <td>
                [[Symbol]]
              </td>
              <td>
                A Symbol
              </td>
              <td>
                A symbol that can be retrieved from any realm.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-symbol.hasinstance">
        <h1>Symbol.hasInstance</h1>
        <p>The initial value of `Symbol.hasInstance` is the well-known symbol @@hasInstance (<emu-xref href="#table-1"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.isconcatspreadable">
        <h1>Symbol.isConcatSpreadable</h1>
        <p>The initial value of `Symbol.isConcatSpreadable` is the well-known symbol @@isConcatSpreadable (<emu-xref href="#table-1"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.iterator">
        <h1>Symbol.iterator</h1>
        <p>The initial value of `Symbol.iterator` is the well-known symbol @@iterator (<emu-xref href="#table-1"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.keyfor">
        <h1>Symbol.keyFor ( _sym_ )</h1>
        <p>When `Symbol.keyFor` is called with argument _sym_ it performs the following steps:</p>
        <emu-alg>
          1. If Type(_sym_) is not Symbol, throw a *TypeError* exception.
          1. For each element _e_ of the GlobalSymbolRegistry List (see <emu-xref href="#sec-symbol.for"></emu-xref>), do
            1. If SameValue(_e_.[[Symbol]], _sym_) is *true*, return _e_.[[Key]].
          1. Assert: GlobalSymbolRegistry does not currently contain an entry for _sym_.
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-symbol.match">
        <h1>Symbol.match</h1>
        <p>The initial value of `Symbol.match` is the well-known symbol @@match (<emu-xref href="#table-1"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.matchall">
        <h1>Symbol.matchAll</h1>
        <p>The initial value of *Symbol.matchAll* is the well-known symbol @@matchAll (<emu-xref href="#table-2"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype">
        <h1>Symbol.prototype</h1>
        <p>The initial value of `Symbol.prototype` is the intrinsic object %SymbolPrototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.replace">
        <h1>Symbol.replace</h1>
        <p>The initial value of `Symbol.replace` is the well-known symbol @@replace (<emu-xref href="#table-1"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.search">
        <h1>Symbol.search</h1>
        <p>The initial value of `Symbol.search` is the well-known symbol @@search (<emu-xref href="#table-1"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.species">
        <h1>Symbol.species</h1>
        <p>The initial value of `Symbol.species` is the well-known symbol @@species (<emu-xref href="#table-1"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.split">
        <h1>Symbol.split</h1>
        <p>The initial value of `Symbol.split` is the well-known symbol @@split (<emu-xref href="#table-1"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.toprimitive">
        <h1>Symbol.toPrimitive</h1>
        <p>The initial value of `Symbol.toPrimitive` is the well-known symbol @@toPrimitive (<emu-xref href="#table-1"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.tostringtag">
        <h1>Symbol.toStringTag</h1>
        <p>The initial value of `Symbol.toStringTag` is the well-known symbol @@toStringTag (<emu-xref href="#table-1"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.unscopables">
        <h1>Symbol.unscopables</h1>
        <p>The initial value of `Symbol.unscopables` is the well-known symbol @@unscopables (<emu-xref href="#table-1"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-symbol-prototype-object">
      <h1>Properties of the Symbol Prototype Object</h1>
      <p>The Symbol prototype object:</p>
      <ul>
        <li>is the intrinsic object <dfn>%SymbolPrototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>is not a Symbol instance and does not have a [[SymbolData]] internal slot.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
      </ul>

      <p>The abstract operation <dfn id="sec-thissymbolvalue" aoid="thisSymbolValue">thisSymbolValue</dfn>(_value_) performs the following steps:</p>
      <emu-alg>
        1. If Type(_value_) is Symbol, return _value_.
        1. If Type(_value_) is Object and _value_ has a [[SymbolData]] internal slot, then
          1. Let _s_ be _value_.[[SymbolData]].
          1. Assert: Type(_s_) is Symbol.
          1. Return _s_.
        1. Throw a *TypeError* exception.
      </emu-alg>

      <emu-clause id="sec-symbol.prototype.constructor">
        <h1>Symbol.prototype.constructor</h1>
        <p>The initial value of `Symbol.prototype.constructor` is the intrinsic object %Symbol%.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype.description">
        <h1>get Symbol.prototype.description</h1>
        <p>`Symbol.prototype.description` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _s_ be the *this* value.
          1. Let _sym_ be ? thisSymbolValue(_s_).
          1. Return _sym_.[[Description]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype.tostring">
        <h1>Symbol.prototype.toString ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _sym_ be ? thisSymbolValue(*this* value).
          1. Return SymbolDescriptiveString(_sym_).
        </emu-alg>

        <emu-clause id="sec-symboldescriptivestring" aoid="SymbolDescriptiveString">
          <h1>Runtime Semantics: SymbolDescriptiveString ( _sym_ )</h1>
          <p>When the abstract operation SymbolDescriptiveString is called with argument _sym_, the following steps are taken:</p>
          <emu-alg>
            1. Assert: Type(_sym_) is Symbol.
            1. Let _desc_ be _sym_'s [[Description]] value.
            1. If _desc_ is *undefined*, set _desc_ to the empty string.
            1. Assert: Type(_desc_) is String.
            1. Return the string-concatenation of `"Symbol("`, _desc_, and `")"`.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype.valueof">
        <h1>Symbol.prototype.valueOf ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Return ? thisSymbolValue(*this* value).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype-@@toprimitive">
        <h1>Symbol.prototype [ @@toPrimitive ] ( _hint_ )</h1>
        <p>This function is called by ECMAScript language operators to convert a Symbol object to a primitive value. The allowed values for _hint_ are `"default"`, `"number"`, and `"string"`.</p>
        <p>When the `@@toPrimitive` method is called with argument _hint_, the following steps are taken:</p>
        <emu-alg>
          1. Return ? thisSymbolValue(*this* value).
        </emu-alg>
        <p>The value of the `name` property of this function is `"[Symbol.toPrimitive]"`.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype-@@tostringtag">
        <h1>Symbol.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value `"Symbol"`.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-symbol-instances">
      <h1>Properties of Symbol Instances</h1>
      <p>Symbol instances are ordinary objects that inherit properties from the Symbol prototype object. Symbol instances have a [[SymbolData]] internal slot. The [[SymbolData]] internal slot is the Symbol value represented by this Symbol object.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-error-objects">
    <h1>Error Objects</h1>
    <p>Instances of Error objects are thrown as exceptions when runtime errors occur. The Error objects may also serve as base objects for user-defined exception classes.</p>

    <emu-clause id="sec-error-constructor">
      <h1>The Error Constructor</h1>
      <p>The Error constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%Error%</dfn>.</li>
        <li>is the initial value of the `Error` property of the global object.</li>
        <li>creates and initializes a new Error object when called as a function rather than as a constructor. Thus the function call `Error(&hellip;)` is equivalent to the object creation expression `new Error(&hellip;)` with the same arguments.</li>
        <li>is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `Error` behaviour must include a `super` call to the `Error` constructor to create and initialize subclass instances with an [[ErrorData]] internal slot.</li>
      </ul>

      <emu-clause id="sec-error-message">
        <h1>Error ( _message_ )</h1>
        <p>When the `Error` function is called with argument _message_, the following steps are taken:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, let _newTarget_ be the active function object, else let _newTarget_ be NewTarget.
          1. Let _O_ be ? OrdinaryCreateFromConstructor(_newTarget_, `"%ErrorPrototype%"`, &laquo; [[ErrorData]] &raquo;).
          1. If _message_ is not *undefined*, then
            1. Let _msg_ be ? ToString(_message_).
            1. Let _msgDesc_ be the PropertyDescriptor { [[Value]]: _msg_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
            1. Perform ! DefinePropertyOrThrow(_O_, `"message"`, _msgDesc_).
          1. Return _O_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-error-constructor">
      <h1>Properties of the Error Constructor</h1>
      <p>The Error constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-error.prototype">
        <h1>Error.prototype</h1>
        <p>The initial value of `Error.prototype` is the intrinsic object %ErrorPrototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-error-prototype-object">
      <h1>Properties of the Error Prototype Object</h1>
      <p>The Error prototype object:</p>
      <ul>
        <li>is the intrinsic object <dfn>%ErrorPrototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>is not an Error instance and does not have an [[ErrorData]] internal slot.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
      </ul>

      <emu-clause id="sec-error.prototype.constructor">
        <h1>Error.prototype.constructor</h1>
        <p>The initial value of `Error.prototype.constructor` is the intrinsic object %Error%.</p>
      </emu-clause>

      <emu-clause id="sec-error.prototype.message">
        <h1>Error.prototype.message</h1>
        <p>The initial value of `Error.prototype.message` is the empty String.</p>
      </emu-clause>

      <emu-clause id="sec-error.prototype.name">
        <h1>Error.prototype.name</h1>
        <p>The initial value of `Error.prototype.name` is `"Error"`.</p>
      </emu-clause>

      <emu-clause id="sec-error.prototype.tostring">
        <h1>Error.prototype.toString ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If Type(_O_) is not Object, throw a *TypeError* exception.
          1. Let _name_ be ? Get(_O_, `"name"`).
          1. If _name_ is *undefined*, set _name_ to `"Error"`; otherwise set _name_ to ? ToString(_name_).
          1. Let _msg_ be ? Get(_O_, `"message"`).
          1. If _msg_ is *undefined*, set _msg_ to the empty String; otherwise set _msg_ to ? ToString(_msg_).
          1. If _name_ is the empty String, return _msg_.
          1. If _msg_ is the empty String, return _name_.
          1. Return the string-concatenation of _name_, the code unit 0x003A (COLON), the code unit 0x0020 (SPACE), and _msg_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-error-instances">
      <h1>Properties of Error Instances</h1>
      <p>Error instances are ordinary objects that inherit properties from the Error prototype object and have an [[ErrorData]] internal slot whose value is *undefined*. The only specified uses of [[ErrorData]] is to identify Error and _NativeError_ instances as Error objects within `Object.prototype.toString`.</p>
    </emu-clause>

    <emu-clause id="sec-native-error-types-used-in-this-standard">
      <h1>Native Error Types Used in This Standard</h1>
      <p>A new instance of one of the _NativeError_ objects below is thrown when a runtime error is detected. All of these objects share the same structure, as described in <emu-xref href="#sec-nativeerror-object-structure"></emu-xref>.</p>

      <emu-clause id="sec-native-error-types-used-in-this-standard-evalerror">
        <h1>EvalError</h1>
        <p>This exception is not currently used within this specification. This object remains for compatibility with previous editions of this specification.</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-rangeerror">
        <h1>RangeError</h1>
        <p>Indicates a value that is not in the set or range of allowable values.</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-referenceerror">
        <h1>ReferenceError</h1>
        <p>Indicate that an invalid reference value has been detected.</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-syntaxerror">
        <h1>SyntaxError</h1>
        <p>Indicates that a parsing error has occurred.</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-typeerror">
        <h1>TypeError</h1>
        <p>TypeError is used to indicate an unsuccessful operation when none of the other _NativeError_ objects are an appropriate indication of the failure cause.</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-urierror">
        <h1>URIError</h1>
        <p>Indicates that one of the global URI handling functions was used in a way that is incompatible with its definition.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-nativeerror-object-structure">
      <h1>_NativeError_ Object Structure</h1>
      <p>When an ECMAScript implementation detects a runtime error, it throws a new instance of one of the _NativeError_ objects defined in <emu-xref href="#sec-native-error-types-used-in-this-standard"></emu-xref>. Each of these objects has the structure described below, differing only in the name used as the constructor name instead of _NativeError_, in the `name` property of the prototype object, and in the implementation-defined `message` property of the prototype object.</p>
      <p>For each error object, references to _NativeError_ in the definition should be replaced with the appropriate error object name from <emu-xref href="#sec-native-error-types-used-in-this-standard"></emu-xref>.</p>

      <emu-clause id="sec-nativeerror-constructors">
        <h1>The _NativeError_ Constructors</h1>
        <p>Each _NativeError_ constructor:</p>
        <ul>
          <li>creates and initializes a new _NativeError_ object when called as a function rather than as a constructor. A call of the object as a function is equivalent to calling it as a constructor with the same arguments. Thus the function call <code><var>NativeError</var>(&hellip;)</code> is equivalent to the object creation expression <code>new <var>NativeError</var>(&hellip;)</code> with the same arguments.</li>
          <li>is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified _NativeError_ behaviour must include a `super` call to the _NativeError_ constructor to create and initialize subclass instances with an [[ErrorData]] internal slot.</li>
        </ul>

        <emu-clause id="sec-nativeerror">
          <h1>NativeError ( _message_ )</h1>
          <p>When a _NativeError_ function is called with argument _message_, the following steps are taken:</p>
          <emu-alg>
            1. If NewTarget is *undefined*, let _newTarget_ be the active function object, else let _newTarget_ be NewTarget.
            1. Let _O_ be ? OrdinaryCreateFromConstructor(_newTarget_, <code>"%<var>NativeError</var>Prototype%"</code>, &laquo; [[ErrorData]] &raquo;).
            1. If _message_ is not *undefined*, then
              1. Let _msg_ be ? ToString(_message_).
              1. Let _msgDesc_ be the PropertyDescriptor { [[Value]]: _msg_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
              1. Perform ! DefinePropertyOrThrow(_O_, `"message"`, _msgDesc_).
            1. Return _O_.
          </emu-alg>
          <p>The actual value of the string passed in step 2 is either `"%EvalErrorPrototype%"`, `"%RangeErrorPrototype%"`, `"%ReferenceErrorPrototype%"`, `"%SyntaxErrorPrototype%"`, `"%TypeErrorPrototype%"`, or `"%URIErrorPrototype%"` corresponding to which _NativeError_ constructor is being defined.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-nativeerror-constructors">
        <h1>Properties of the _NativeError_ Constructors</h1>
        <p>Each _NativeError_ constructor:</p>
        <ul>
          <li>has a [[Prototype]] internal slot whose value is the intrinsic object %Error%.</li>
          <li>has a `name` property whose value is the String value `"<var>NativeError</var>"`.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-nativeerror.prototype">
          <h1>NativeError.prototype</h1>
          <p>The initial value of <code><var>NativeError</var>.prototype</code> is a _NativeError_ prototype object (<emu-xref href="#sec-properties-of-the-nativeerror-prototype-objects"></emu-xref>). Each _NativeError_ constructor has a distinct prototype object.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-nativeerror-prototype-objects">
        <h1>Properties of the _NativeError_ Prototype Objects</h1>
        <p>Each _NativeError_ prototype object:</p>
        <ul>
          <li>is an ordinary object.</li>
          <li>is not an Error instance and does not have an [[ErrorData]] internal slot.</li>
          <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ErrorPrototype%.</li>
        </ul>

        <emu-clause id="sec-nativeerror.prototype.constructor">
          <h1>_NativeError_.prototype.constructor</h1>
          <p>The initial value of the `constructor` property of the prototype for a given _NativeError_ constructor is the corresponding intrinsic object %_NativeError_% (<emu-xref href="#sec-nativeerror-constructors"></emu-xref>).</p>
        </emu-clause>

        <emu-clause id="sec-nativeerror.prototype.message">
          <h1>_NativeError_.prototype.message</h1>
          <p>The initial value of the `message` property of the prototype for a given _NativeError_ constructor is the empty String.</p>
        </emu-clause>

        <emu-clause id="sec-nativeerror.prototype.name">
          <h1>_NativeError_.prototype.name</h1>
          <p>The initial value of the `name` property of the prototype for a given _NativeError_ constructor is the String value consisting of the name of the constructor (the name used instead of _NativeError_).</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-nativeerror-instances">
        <h1>Properties of _NativeError_ Instances</h1>
        <p>_NativeError_ instances are ordinary objects that inherit properties from their _NativeError_ prototype object and have an [[ErrorData]] internal slot whose value is *undefined*. The only specified use of [[ErrorData]] is by `Object.prototype.toString` (<emu-xref href="#sec-object.prototype.tostring"></emu-xref>) to identify Error or _NativeError_ instances.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-numbers-and-dates">
  <h1>Numbers and Dates</h1>

  <emu-clause id="sec-number-objects">
    <h1>Number Objects</h1>

    <emu-clause id="sec-number-constructor">
      <h1>The Number Constructor</h1>
      <p>The Number constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%Number%</dfn>.</li>
        <li>is the initial value of the `Number` property of the global object.</li>
        <li>creates and initializes a new Number object when called as a constructor.</li>
        <li>performs a type conversion when called as a function rather than as a constructor.</li>
        <li>is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `Number` behaviour must include a `super` call to the `Number` constructor to create and initialize the subclass instance with a [[NumberData]] internal slot.</li>
      </ul>

      <emu-clause id="sec-number-constructor-number-value">
        <h1>Number ( _value_ )</h1>
        <p>When `Number` is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If no arguments were passed to this function invocation, let _n_ be *+0*.
          1. Else, let _n_ be ? ToNumber(_value_).
          1. If NewTarget is *undefined*, return _n_.
          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, `"%NumberPrototype%"`, &laquo; [[NumberData]] &raquo;).
          1. Set _O_.[[NumberData]] to _n_.
          1. Return _O_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-number-constructor">
      <h1>Properties of the Number Constructor</h1>
      <p>The Number constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-number.epsilon">
        <h1>Number.EPSILON</h1>
        <p>The value of Number.EPSILON is the difference between 1 and the smallest value greater than 1 that is representable as a Number value, which is approximately 2.2204460492503130808472633361816 x 10<sup> - 16</sup>.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-number.isfinite">
        <h1>Number.isFinite ( _number_ )</h1>
        <p>When `Number.isFinite` is called with one argument _number_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_number_) is not Number, return *false*.
          1. If _number_ is *NaN*, *+&infin;*, or *-&infin;*, return *false*.
          1. Otherwise, return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.isinteger">
        <h1>Number.isInteger ( _number_ )</h1>
        <p>When `Number.isInteger` is called with one argument _number_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_number_) is not Number, return *false*.
          1. If _number_ is *NaN*, *+&infin;*, or *-&infin;*, return *false*.
          1. Let _integer_ be ! ToInteger(_number_).
          1. If _integer_ is not equal to _number_, return *false*.
          1. Otherwise, return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.isnan">
        <h1>Number.isNaN ( _number_ )</h1>
        <p>When `Number.isNaN` is called with one argument _number_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_number_) is not Number, return *false*.
          1. If _number_ is *NaN*, return *true*.
          1. Otherwise, return *false*.
        </emu-alg>
        <emu-note>
          <p>This function differs from the global isNaN function (<emu-xref href="#sec-isnan-number"></emu-xref>) in that it does not convert its argument to a Number before determining whether it is *NaN*.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-number.issafeinteger">
        <h1>Number.isSafeInteger ( _number_ )</h1>
        <p>When `Number.isSafeInteger` is called with one argument _number_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_number_) is not Number, return *false*.
          1. If _number_ is *NaN*, *+&infin;*, or *-&infin;*, return *false*.
          1. Let _integer_ be ! ToInteger(_number_).
          1. If _integer_ is not equal to _number_, return *false*.
          1. If abs(_integer_) &le; 2<sup>53</sup> - 1, return *true*.
          1. Otherwise, return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.max_safe_integer">
        <h1>Number.MAX_SAFE_INTEGER</h1>
        <emu-note>
          <p>The value of `Number.MAX_SAFE_INTEGER` is the largest integer n such that n and n + 1 are both exactly representable as a Number value.</p>
        </emu-note>
        <p>The value of Number.MAX_SAFE_INTEGER is 9007199254740991 (2<sup>53</sup> - 1).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-number.max_value">
        <h1>Number.MAX_VALUE</h1>
        <p>The value of `Number.MAX_VALUE` is the largest positive finite value of the Number type, which is approximately <emu-eqn>1.7976931348623157 &times; 10<sup>308</sup></emu-eqn>.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-number.min_safe_integer">
        <h1>Number.MIN_SAFE_INTEGER</h1>
        <emu-note>
          <p>The value of `Number.MIN_SAFE_INTEGER` is the smallest integer n such that n and n - 1 are both exactly representable as a Number value.</p>
        </emu-note>
        <p>The value of Number.MIN_SAFE_INTEGER is -9007199254740991 (-(2<sup>53</sup> - 1)).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-number.min_value">
        <h1>Number.MIN_VALUE</h1>
        <p>The value of `Number.MIN_VALUE` is the smallest positive value of the Number type, which is approximately <emu-eqn>5 &times; 10<sup>-324</sup></emu-eqn>.</p>
        <p>In the IEEE 754-2008 double precision binary representation, the smallest possible value is a denormalized number. If an implementation does not support denormalized values, the value of `Number.MIN_VALUE` must be the smallest non-zero positive value that can actually be represented by the implementation.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-number.nan">
        <h1>Number.NaN</h1>
        <p>The value of `Number.NaN` is *NaN*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-number.negative_infinity">
        <h1>Number.NEGATIVE_INFINITY</h1>
        <p>The value of Number.NEGATIVE_INFINITY is *-&infin;*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-number.parsefloat">
        <h1>Number.parseFloat ( _string_ )</h1>
        <p>The value of the `Number.parseFloat` data property is the same built-in function object that is the value of the `parseFloat` property of the global object defined in <emu-xref href="#sec-parsefloat-string"></emu-xref>.</p>
      </emu-clause>

      <emu-clause id="sec-number.parseint">
        <h1>Number.parseInt ( _string_, _radix_ )</h1>
        <p>The value of the `Number.parseInt` data property is the same built-in function object that is the value of the `parseInt` property of the global object defined in <emu-xref href="#sec-parseint-string-radix"></emu-xref>.</p>
      </emu-clause>

      <emu-clause id="sec-number.positive_infinity">
        <h1>Number.POSITIVE_INFINITY</h1>
        <p>The value of Number.POSITIVE_INFINITY is *+&infin;*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype">
        <h1>Number.prototype</h1>
        <p>The initial value of `Number.prototype` is the intrinsic object %NumberPrototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-number-prototype-object">
      <h1>Properties of the Number Prototype Object</h1>
      <p>The Number prototype object:</p>
      <ul>
        <li>is the intrinsic object <dfn>%NumberPrototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>is itself a Number object; it has a [[NumberData]] internal slot with the value *+0*.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
      </ul>
      <p>Unless explicitly stated otherwise, the methods of the Number prototype object defined below are not generic and the *this* value passed to them must be either a Number value or an object that has a [[NumberData]] internal slot that has been initialized to a Number value.</p>
      <p>The abstract operation <dfn id="sec-thisnumbervalue" aoid="thisNumberValue">thisNumberValue</dfn>(_value_) performs the following steps:</p>
      <emu-alg>
        1. If Type(_value_) is Number, return _value_.
        1. If Type(_value_) is Object and _value_ has a [[NumberData]] internal slot, then
          1. Let _n_ be _value_.[[NumberData]].
          1. Assert: Type(_n_) is Number.
          1. Return _n_.
        1. Throw a *TypeError* exception.
      </emu-alg>
      <p>The phrase &ldquo;this Number value&rdquo; within the specification of a method refers to the result returned by calling the abstract operation thisNumberValue with the *this* value of the method invocation passed as the argument.</p>

      <emu-clause id="sec-number.prototype.constructor">
        <h1>Number.prototype.constructor</h1>
        <p>The initial value of `Number.prototype.constructor` is the intrinsic object %Number%.</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype.toexponential">
        <h1>Number.prototype.toExponential ( _fractionDigits_ )</h1>
        <p>Return a String containing this Number value represented in decimal exponential notation with one digit before the significand's decimal point and _fractionDigits_ digits after the significand's decimal point. If _fractionDigits_ is *undefined*, include as many significand digits as necessary to uniquely specify the Number (just like in ToString except that in this case the Number is always output in exponential notation). Specifically, perform the following steps:</p>
        <emu-alg>
          1. Let _x_ be ? thisNumberValue(*this* value).
          1. Let _f_ be ? ToInteger(_fractionDigits_).
          1. Assert: If _fractionDigits_ is *undefined*, then _f_ is 0.
          1. If _x_ is *NaN*, return the String `"NaN"`.
          1. Let _s_ be the empty String.
          1. If _x_ &lt; 0, then
            1. Set _s_ to `"-"`.
            1. Set _x_ to -_x_.
          1. If _x_ = *+&infin;*, then
            1. Return the string-concatenation of _s_ and `"Infinity"`.
          1. If _f_ &lt; 0 or _f_ &gt; 100, throw a *RangeError* exception.
          1. If _x_ = 0, then
            1. Let _m_ be the String value consisting of _f_ + 1 occurrences of the code unit 0x0030 (DIGIT ZERO).
            1. Let _e_ be 0.
          1. Else _x_ &ne; 0,
            1. If _fractionDigits_ is not *undefined*, then
              1. Let _e_ and _n_ be integers such that 10<sup>_f_</sup> &le; _n_ &lt; 10<sup>_f_ + 1</sup> and for which the exact mathematical value of _n_ &times; 10<sup>_e_ - _f_</sup> - _x_ is as close to zero as possible. If there are two such sets of _e_ and _n_, pick the _e_ and _n_ for which _n_ &times; 10<sup>_e_ - _f_</sup> is larger.
            1. Else _fractionDigits_ is *undefined*,
              1. Let _e_, _n_, and _f_ be integers such that _f_ &ge; 0, 10<sup>_f_</sup> &le; _n_ &lt; 10<sup>_f_ + 1</sup>, the Number value for _n_ &times; 10<sup>_e_ - _f_</sup> is _x_, and _f_ is as small as possible. Note that the decimal representation of _n_ has _f_ + 1 digits, _n_ is not divisible by 10, and the least significant digit of _n_ is not necessarily uniquely determined by these criteria.
            1. Let _m_ be the String value consisting of the digits of the decimal representation of _n_ (in order, with no leading zeroes).
          1. If _f_ &ne; 0, then
            1. Let _a_ be the first code unit of _m_, and let _b_ be the remaining _f_ code units of _m_.
            1. Set _m_ to the string-concatenation of _a_, `"."`, and _b_.
          1. If _e_ = 0, then
            1. Let _c_ be `"+"`.
            1. Let _d_ be `"0"`.
          1. Else,
            1. If _e_ &gt; 0, let _c_ be `"+"`.
            1. Else _e_ &le; 0,
              1. Let _c_ be `"-"`.
              1. Set _e_ to -_e_.
            1. Let _d_ be the String value consisting of the digits of the decimal representation of _e_ (in order, with no leading zeroes).
          1. Set _m_ to the string-concatenation of _m_, `"e"`, _c_, and _d_.
          1. Return the string-concatenation of _s_ and _m_.
        </emu-alg>
        <emu-note>
          <p>For implementations that provide more accurate conversions than required by the rules above, it is recommended that the following alternative version of step 10.b.i be used as a guideline:</p>
          <emu-alg type="i">
            1. Let _e_, _n_, and _f_ be integers such that _f_ &ge; 0, 10<sup>_f_</sup> &le; _n_ &lt; 10<sup>_f_ + 1</sup>, the Number value for _n_ &times; 10<sup>_e_ - _f_</sup> is _x_, and _f_ is as small as possible. If there are multiple possibilities for _n_, choose the value of _n_ for which _n_ &times; 10<sup>_e_ - _f_</sup> is closest in value to _x_. If there are two such possible values of _n_, choose the one that is even.
          </emu-alg>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-number.prototype.tofixed">
        <h1>Number.prototype.toFixed ( _fractionDigits_ )</h1>
        <emu-note>
          <p>`toFixed` returns a String containing this Number value represented in decimal fixed-point notation with _fractionDigits_ digits after the decimal point. If _fractionDigits_ is *undefined*, 0 is assumed.</p>
        </emu-note>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _x_ be ? thisNumberValue(*this* value).
          1. Let _f_ be ? ToInteger(_fractionDigits_).
          1. Assert: If _fractionDigits_ is *undefined*, then _f_ is 0.
          1. If _f_ &lt; 0 or _f_ &gt; 100, throw a *RangeError* exception.
          1. If _x_ is *NaN*, return the String `"NaN"`.
          1. Let _s_ be the empty String.
          1. If _x_ &lt; 0, then
            1. Set _s_ to `"-"`.
            1. Set _x_ to -_x_.
          1. If _x_ &ge; 10<sup>21</sup>, then
            1. Let _m_ be ! ToString(_x_).
          1. Else _x_ &lt; 10<sup>21</sup>,
            1. Let _n_ be an integer for which the exact mathematical value of _n_ &divide; 10<sup>_f_</sup> - _x_ is as close to zero as possible. If there are two such _n_, pick the larger _n_.
            1. If _n_ = 0, let _m_ be the String `"0"`. Otherwise, let _m_ be the String value consisting of the digits of the decimal representation of _n_ (in order, with no leading zeroes).
            1. If _f_ &ne; 0, then
              1. Let _k_ be the length of _m_.
              1. If _k_ &le; _f_, then
                1. Let _z_ be the String value consisting of _f_ + 1 - _k_ occurrences of the code unit 0x0030 (DIGIT ZERO).
                1. Set _m_ to the string-concatenation of _z_ and _m_.
                1. Set _k_ to _f_ + 1.
              1. Let _a_ be the first _k_ - _f_ code units of _m_, and let _b_ be the remaining _f_ code units of _m_.
              1. Set _m_ to the string-concatenation of _a_, `"."`, and _b_.
          1. Return the string-concatenation of _s_ and _m_.
        </emu-alg>
        <emu-note>
          <p>The output of `toFixed` may be more precise than `toString` for some values because toString only prints enough significant digits to distinguish the number from adjacent number values. For example,</p>
          <p>`(1000000000000000128).toString()` returns `"1000000000000000100"`, while
            <br>
            `(1000000000000000128).toFixed(0)` returns `"1000000000000000128"`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-number.prototype.tolocalestring">
        <h1>Number.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Number.prototype.toLocaleString` method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `toLocaleString` method is used.</p>
        <p>Produces a String value that represents this Number value formatted according to the conventions of the host environment's current locale. This function is implementation-dependent, and it is permissible, but not encouraged, for it to return the same thing as `toString`.</p>
        <p>The meanings of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype.toprecision">
        <h1>Number.prototype.toPrecision ( _precision_ )</h1>
        <p>Return a String containing this Number value represented either in decimal exponential notation with one digit before the significand's decimal point and <emu-eqn>_precision_ - 1</emu-eqn> digits after the significand's decimal point or in decimal fixed notation with _precision_ significant digits. If _precision_ is *undefined*, call ToString instead. Specifically, perform the following steps:</p>
        <emu-alg>
          1. Let _x_ be ? thisNumberValue(*this* value).
          1. If _precision_ is *undefined*, return ! ToString(_x_).
          1. Let _p_ be ? ToInteger(_precision_).
          1. If _x_ is *NaN*, return the String `"NaN"`.
          1. Let _s_ be the empty String.
          1. If _x_ &lt; 0, then
            1. Set _s_ to the code unit 0x002D (HYPHEN-MINUS).
            1. Set _x_ to -_x_.
          1. If _x_ = *+&infin;*, then
            1. Return the string-concatenation of _s_ and `"Infinity"`.
          1. If _p_ &lt; 1 or _p_ &gt; 100, throw a *RangeError* exception.
          1. If _x_ = 0, then
            1. Let _m_ be the String value consisting of _p_ occurrences of the code unit 0x0030 (DIGIT ZERO).
            1. Let _e_ be 0.
          1. Else _x_ &ne; 0,
            1. Let _e_ and _n_ be integers such that 10<sup>_p_ - 1</sup> &le; _n_ &lt; 10<sup>_p_</sup> and for which the exact mathematical value of _n_ &times; 10<sup>_e_ - _p_ + 1</sup> - _x_ is as close to zero as possible. If there are two such sets of _e_ and _n_, pick the _e_ and _n_ for which _n_ &times; 10<sup>_e_ - _p_ + 1</sup> is larger.
            1. Let _m_ be the String value consisting of the digits of the decimal representation of _n_ (in order, with no leading zeroes).
            1. If _e_ &lt; -6 or _e_ &ge; _p_, then
              1. Assert: _e_ &ne; 0.
              1. If _p_ &ne; 1, then
                1. Let _a_ be the first code unit of _m_, and let _b_ be the remaining _p_ - 1 code units of _m_.
                1. Set _m_ to the string-concatenation of _a_, `"."`, and _b_.
              1. If _e_ &gt; 0, then
                1. Let _c_ be the code unit 0x002B (PLUS SIGN).
              1. Else _e_ &lt; 0,
                1. Let _c_ be the code unit 0x002D (HYPHEN-MINUS).
                1. Set _e_ to -_e_.
              1. Let _d_ be the String value consisting of the digits of the decimal representation of _e_ (in order, with no leading zeroes).
              1. Return the string-concatenation of _s_, _m_, the code unit 0x0065 (LATIN SMALL LETTER E), _c_, and _d_.
          1. If _e_ = _p_ - 1, return the string-concatenation of _s_ and _m_.
          1. If _e_ &ge; 0, then
            1. Set _m_ to the string-concatenation of the first _e_ + 1 code units of _m_, the code unit 0x002E (FULL STOP), and the remaining _p_ - (_e_ + 1) code units of _m_.
          1. Else _e_ &lt; 0,
            1. Set _m_ to the string-concatenation of the code unit 0x0030 (DIGIT ZERO), the code unit 0x002E (FULL STOP), -(_e_ + 1) occurrences of the code unit 0x0030 (DIGIT ZERO), and the String _m_.
          1. Return the string-concatenation of _s_ and _m_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.prototype.tostring">
        <h1>Number.prototype.toString ( [ _radix_ ] )</h1>
        <emu-note>
          <p>The optional _radix_ should be an integer value in the inclusive range 2 to 36. If _radix_ is not present or is *undefined* the Number 10 is used as the value of _radix_.</p>
        </emu-note>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _x_ be ? thisNumberValue(*this* value).
          1. If _radix_ is not present, let _radixNumber_ be 10.
          1. Else if _radix_ is *undefined*, let _radixNumber_ be 10.
          1. Else, let _radixNumber_ be ? ToInteger(_radix_).
          1. If _radixNumber_ &lt; 2 or _radixNumber_ &gt; 36, throw a *RangeError* exception.
          1. If _radixNumber_ = 10, return ! ToString(_x_).
          1. Return the String representation of this Number value using the radix specified by _radixNumber_. Letters `a`-`z` are used for digits with values 10 through 35. The precise algorithm is implementation-dependent, however the algorithm should be a generalization of that specified in <emu-xref href="#sec-tostring-applied-to-the-number-type"></emu-xref>.
        </emu-alg>
        <p>The `toString` function is not generic; it throws a *TypeError* exception if its *this* value is not a Number or a Number object. Therefore, it cannot be transferred to other kinds of objects for use as a method.</p>
        <p>The `"length"` property of the `toString` method is 1.</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype.valueof">
        <h1>Number.prototype.valueOf ( )</h1>
        <emu-alg>
          1. Return ? thisNumberValue(*this* value).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-number-instances">
      <h1>Properties of Number Instances</h1>
      <p>Number instances are ordinary objects that inherit properties from the Number prototype object. Number instances also have a [[NumberData]] internal slot. The [[NumberData]] internal slot is the Number value represented by this Number object.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-math-object">
    <h1>The Math Object</h1>
    <p>The Math object:</p>
    <ul>
      <li>is the intrinsic object <dfn>%Math%</dfn>.</li>
      <li>is the initial value of the `Math` property of the global object.</li>
      <li>is an ordinary object.</li>
      <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
      <li>is not a function object.</li>
      <li>does not have a [[Construct]] internal method; it cannot be used as a constructor with the `new` operator.</li>
      <li>does not have a [[Call]] internal method; it cannot be invoked as a function.</li>
    </ul>
    <emu-note>
      <p>In this specification, the phrase &ldquo;the Number value for _x_&rdquo; has a technical meaning defined in <emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref>.</p>
    </emu-note>

    <emu-clause id="sec-value-properties-of-the-math-object">
      <h1>Value Properties of the Math Object</h1>

      <emu-clause id="sec-math.e">
        <h1>Math.E</h1>
        <p>The Number value for _e_, the base of the natural logarithms, which is approximately 2.7182818284590452354.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-math.ln10">
        <h1>Math.LN10</h1>
        <p>The Number value for the natural logarithm of 10, which is approximately 2.302585092994046.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-math.ln2">
        <h1>Math.LN2</h1>
        <p>The Number value for the natural logarithm of 2, which is approximately 0.6931471805599453.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-math.log10e">
        <h1>Math.LOG10E</h1>
        <p>The Number value for the base-10 logarithm of _e_, the base of the natural logarithms; this value is approximately 0.4342944819032518.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        <emu-note>
          <p>The value of `Math.LOG10E` is approximately the reciprocal of the value of `Math.LN10`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.log2e">
        <h1>Math.LOG2E</h1>
        <p>The Number value for the base-2 logarithm of _e_, the base of the natural logarithms; this value is approximately 1.4426950408889634.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        <emu-note>
          <p>The value of `Math.LOG2E` is approximately the reciprocal of the value of `Math.LN2`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.pi">
        <h1>Math.PI</h1>
        <p>The Number value for &pi;, the ratio of the circumference of a circle to its diameter, which is approximately 3.1415926535897932.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-math.sqrt1_2">
        <h1>Math.SQRT1_2</h1>
        <p>The Number value for the square root of &frac12;, which is approximately 0.7071067811865476.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        <emu-note>
          <p>The value of `Math.SQRT1_2` is approximately the reciprocal of the value of `Math.SQRT2`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.sqrt2">
        <h1>Math.SQRT2</h1>
        <p>The Number value for the square root of 2, which is approximately 1.4142135623730951.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-math-@@tostringtag">
        <h1>Math [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value `"Math"`.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-properties-of-the-math-object">
      <h1>Function Properties of the Math Object</h1>
      <p>Each of the following `Math` object functions applies the ToNumber abstract operation to each of its arguments (in left-to-right order if there is more than one). If ToNumber returns an abrupt completion, that Completion Record is immediately returned. Otherwise, the function performs a computation on the resulting Number value(s). The value returned by each function is a Number.</p>
      <p>In the function descriptions below, the symbols *NaN*, *-0*, *+0*, *-&infin;* and *+&infin;* refer to the Number values described in <emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref>.</p>
      <emu-note>
        <p>The behaviour of the functions `acos`, `acosh`, `asin`, `asinh`, `atan`, `atanh`, `atan2`, `cbrt`, `cos`, `cosh`, `exp`, `expm1`, `hypot`, `log`,`log1p`, `log2`, `log10`, `pow`, `random`, `sin`, `sinh`, `sqrt`, `tan`, and `tanh` is not precisely specified here except to require specific results for certain argument values that represent boundary cases of interest. For other argument values, these functions are intended to compute approximations to the results of familiar mathematical functions, but some latitude is allowed in the choice of approximation algorithms. The general intent is that an implementer should be able to use the same mathematical library for ECMAScript on a given hardware platform that is available to C programmers on that platform.</p>
        <p>Although the choice of algorithms is left to the implementation, it is recommended (but not specified by this standard) that implementations use the approximation algorithms for IEEE 754-2008 arithmetic contained in `fdlibm`, the freely distributable mathematical library from Sun Microsystems (<a href="http://www.netlib.org/fdlibm">http://www.netlib.org/fdlibm</a>).</p>
      </emu-note>

      <emu-clause id="sec-math.abs">
        <h1>Math.abs ( _x_ )</h1>
        <p>Returns the absolute value of _x_; the result has the same magnitude as _x_ but has positive sign.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is *-0*, the result is *+0*.
          </li>
          <li>
            If _x_ is *-&infin;*, the result is *+&infin;*.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-math.acos">
        <h1>Math.acos ( _x_ )</h1>
        <p>Returns an implementation-dependent approximation to the arc cosine of _x_. The result is expressed in radians and ranges from *+0* to +&pi;.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is greater than 1, the result is *NaN*.
          </li>
          <li>
            If _x_ is less than -1, the result is *NaN*.
          </li>
          <li>
            If _x_ is exactly 1, the result is *+0*.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-math.acosh">
        <h1>Math.acosh ( _x_ )</h1>
        <p>Returns an implementation-dependent approximation to the inverse hyperbolic cosine of _x_.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If x is less than 1, the result is *NaN*.
          </li>
          <li>
            If x is 1, the result is *+0*.
          </li>
          <li>
            If _x_ is *+&infin;*, the result is *+&infin;*.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-math.asin">
        <h1>Math.asin ( _x_ )</h1>
        <p>Returns an implementation-dependent approximation to the arc sine of _x_. The result is expressed in radians and ranges from -&pi; / 2 to +&pi; / 2.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is greater than 1, the result is *NaN*.
          </li>
          <li>
            If _x_ is less than -1, the result is *NaN*.
          </li>
          <li>
            If _x_ is *+0*, the result is *+0*.
          </li>
          <li>
            If _x_ is *-0*, the result is *-0*.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-math.asinh">
        <h1>Math.asinh ( _x_ )</h1>
        <p>Returns an implementation-dependent approximation to the inverse hyperbolic sine of _x_.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is *+0*, the result is *+0*.
          </li>
          <li>
            If _x_ is *-0*, the result is *-0*.
          </li>
          <li>
            If _x_ is *+&infin;*, the result is *+&infin;*.
          </li>
          <li>
            If x is *-&infin;*, the result is *-&infin;*.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-math.atan">
        <h1>Math.atan ( _x_ )</h1>
        <p>Returns an implementation-dependent approximation to the arc tangent of _x_. The result is expressed in radians and ranges from -&pi; / 2 to +&pi; / 2.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is *+0*, the result is *+0*.
          </li>
          <li>
            If _x_ is *-0*, the result is *-0*.
          </li>
          <li>
            If _x_ is *+&infin;*, the result is an implementation-dependent approximation to +&pi; / 2.
          </li>
          <li>
            If _x_ is *-&infin;*, the result is an implementation-dependent approximation to -&pi; / 2.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-math.atanh">
        <h1>Math.atanh ( _x_ )</h1>
        <p>Returns an implementation-dependent approximation to the inverse hyperbolic tangent of _x_.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is less than -1, the result is *NaN*.
          </li>
          <li>
            If _x_ is greater than 1, the result is *NaN*.
          </li>
          <li>
            If _x_ is -1, the result is *-&infin;*.
          </li>
          <li>
            If _x_ is +1, the result is *+&infin;*.
          </li>
          <li>
            If _x_ is *+0*, the result is *+0*.
          </li>
          <li>
            If _x_ is *-0*, the result is *-0*.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-math.atan2">
        <h1>Math.atan2 ( _y_, _x_ )</h1>
        <p>Returns an implementation-dependent approximation to the arc tangent of the quotient <emu-eqn>_y_ / _x_</emu-eqn> of the arguments _y_ and _x_, where the signs of _y_ and _x_ are used to determine the quadrant of the result. Note that it is intentional and traditional for the two-argument arc tangent function that the argument named _y_ be first and the argument named _x_ be second. The result is expressed in radians and ranges from -&pi; to +&pi;.</p>
        <ul>
          <li>
            If either _x_ or _y_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _y_ &gt; 0 and _x_ is *+0*, the result is an implementation-dependent approximation to +&pi; / 2.
          </li>
          <li>
            If _y_ &gt; 0 and _x_ is *-0*, the result is an implementation-dependent approximation to +&pi; / 2.
          </li>
          <li>
            If _y_ is *+0* and _x_ &gt; 0, the result is *+0*.
          </li>
          <li>
            If _y_ is *+0* and _x_ is *+0*, the result is *+0*.
          </li>
          <li>
            If _y_ is *+0* and _x_ is *-0*, the result is an implementation-dependent approximation to +&pi;.
          </li>
          <li>
            If _y_ is *+0* and _x_ &lt; 0, the result is an implementation-dependent approximation to +&pi;.
          </li>
          <li>
            If _y_ is *-0* and _x_ &gt; 0, the result is *-0*.
          </li>
          <li>
            If _y_ is *-0* and _x_ is *+0*, the result is *-0*.
          </li>
          <li>
            If _y_ is *-0* and _x_ is *-0*, the result is an implementation-dependent approximation to -&pi;.
          </li>
          <li>
            If _y_ is *-0* and _x_ &lt; 0, the result is an implementation-dependent approximation to -&pi;.
          </li>
          <li>
            If _y_ &lt; 0 and _x_ is *+0*, the result is an implementation-dependent approximation to -&pi; / 2.
          </li>
          <li>
            If _y_ &lt; 0 and _x_ is *-0*, the result is an implementation-dependent approximation to -&pi; / 2.
          </li>
          <li>
            If _y_ &gt; 0 and _y_ is finite and _x_ is *+&infin;*, the result is *+0*.
          </li>
          <li>
            If _y_ &gt; 0 and _y_ is finite and _x_ is *-&infin;*, the result is an implementation-dependent approximation to +&pi;.
          </li>
          <li>
            If _y_ &lt; 0 and _y_ is finite and _x_ is *+&infin;*, the result is *-0*.
          </li>
          <li>
            If _y_ &lt; 0 and _y_ is finite and _x_ is *-&infin;*, the result is an implementation-dependent approximation to -&pi;.
          </li>
          <li>
            If _y_ is *+&infin;* and _x_ is finite, the result is an implementation-dependent approximation to +&pi; / 2.
          </li>
          <li>
            If _y_ is *-&infin;* and _x_ is finite, the result is an implementation-dependent approximation to -&pi; / 2.
          </li>
          <li>
            If _y_ is *+&infin;* and _x_ is *+&infin;*, the result is an implementation-dependent approximation to +&pi; / 4.
          </li>
          <li>
            If _y_ is *+&infin;* and _x_ is *-&infin;*, the result is an implementation-dependent approximation to +3&pi; / 4.
          </li>
          <li>
            If _y_ is *-&infin;* and _x_ is *+&infin;*, the result is an implementation-dependent approximation to -&pi; / 4.
          </li>
          <li>
            If _y_ is *-&infin;* and _x_ is *-&infin;*, the result is an implementation-dependent approximation to -3&pi; / 4.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-math.cbrt">
        <h1>Math.cbrt ( _x_ )</h1>
        <p>Returns an implementation-dependent approximation to the cube root of _x_.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is *+0*, the result is *+0*.
          </li>
          <li>
            If _x_ is *-0*, the result is *-0*.
          </li>
          <li>
            If _x_ is *+&infin;*, the result is *+&infin;*.
          </li>
          <li>
            If _x_ is *-&infin;*, the result is *-&infin;*.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-math.ceil">
        <h1>Math.ceil ( _x_ )</h1>
        <p>Returns the smallest (closest to *-&infin;*) Number value that is not less than _x_ and is equal to a mathematical integer. If _x_ is already an integer, the result is _x_.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is *+0*, the result is *+0*.
          </li>
          <li>
            If _x_ is *-0*, the result is *-0*.
          </li>
          <li>
            If _x_ is *+&infin;*, the result is *+&infin;*.
          </li>
          <li>
            If _x_ is *-&infin;*, the result is *-&infin;*.
          </li>
          <li>
            If _x_ is less than 0 but greater than -1, the result is *-0*.
          </li>
        </ul>
        <p>The value of `Math.ceil(x)` is the same as the value of `-Math.floor(-x)`.</p>
      </emu-clause>

      <emu-clause id="sec-math.clz32">
        <h1>Math.clz32 ( _x_ )</h1>
        <p>When `Math.clz32` is called with one argument _x_, the following steps are taken:</p>
        <emu-alg>
          1. Let _n_ be ? ToUint32(_x_).
          1. Let _p_ be the number of leading zero bits in the 32-bit binary representation of _n_.
          1. Return _p_.
        </emu-alg>
        <emu-note>
          <p>If _n_ is 0, _p_ will be 32. If the most significant bit of the 32-bit binary encoding of _n_ is 1, _p_ will be 0.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.cos">
        <h1>Math.cos ( _x_ )</h1>
        <p>Returns an implementation-dependent approximation to the cosine of _x_. The argument is expressed in radians.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is *+0*, the result is 1.
          </li>
          <li>
            If _x_ is *-0*, the result is 1.
          </li>
          <li>
            If _x_ is *+&infin;*, the result is *NaN*.
          </li>
          <li>
            If _x_ is *-&infin;*, the result is *NaN*.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-math.cosh">
        <h1>Math.cosh ( _x_ )</h1>
        <p>Returns an implementation-dependent approximation to the hyperbolic cosine of _x_.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is *+0*, the result is 1.
          </li>
          <li>
            If _x_ is *-0*, the result is 1.
          </li>
          <li>
            If _x_ is *+&infin;*, the result is *+&infin;*.
          </li>
          <li>
            If _x_ is *-&infin;*, the result is *+&infin;*.
          </li>
        </ul>
        <emu-note>
          <p>The value of cosh(x) is the same as <i>(exp(x) + exp(-x)) / 2</i>.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.exp">
        <h1>Math.exp ( _x_ )</h1>
        <p>Returns an implementation-dependent approximation to the exponential function of _x_ (_e_ raised to the power of _x_, where _e_ is the base of the natural logarithms).</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is *+0*, the result is 1.
          </li>
          <li>
            If _x_ is *-0*, the result is 1.
          </li>
          <li>
            If _x_ is *+&infin;*, the result is *+&infin;*.
          </li>
          <li>
            If _x_ is *-&infin;*, the result is *+0*.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-math.expm1">
        <h1>Math.expm1 ( _x_ )</h1>
        <p>Returns an implementation-dependent approximation to subtracting 1 from the exponential function of _x_ (_e_ raised to the power of _x_, where _e_ is the base of the natural logarithms). The result is computed in a way that is accurate even when the value of x is close 0.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is *+0*, the result is *+0*.
          </li>
          <li>
            If _x_ is *-0*, the result is *-0*.
          </li>
          <li>
            If _x_ is *+&infin;*, the result is *+&infin;*.
          </li>
          <li>
            If _x_ is *-&infin;*, the result is -1.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-math.floor">
        <h1>Math.floor ( _x_ )</h1>
        <p>Returns the greatest (closest to *+&infin;*) Number value that is not greater than _x_ and is equal to a mathematical integer. If _x_ is already an integer, the result is _x_.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is *+0*, the result is *+0*.
          </li>
          <li>
            If _x_ is *-0*, the result is *-0*.
          </li>
          <li>
            If _x_ is *+&infin;*, the result is *+&infin;*.
          </li>
          <li>
            If _x_ is *-&infin;*, the result is *-&infin;*.
          </li>
          <li>
            If _x_ is greater than 0 but less than 1, the result is *+0*.
          </li>
        </ul>
        <emu-note>
          <p>The value of `Math.floor(x)` is the same as the value of `-Math.ceil(-x)`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.fround">
        <h1>Math.fround ( _x_ )</h1>
        <p>When `Math.fround` is called with argument _x_, the following steps are taken:</p>
        <emu-alg>
          1. If _x_ is *NaN*, return *NaN*.
          1. If _x_ is one of *+0*, *-0*, *+&infin;*, *-&infin;*, return _x_.
          1. Let _x32_ be the result of converting _x_ to a value in IEEE 754-2008 binary32 format using roundTiesToEven mode.
          1. Let _x64_ be the result of converting _x32_ to a value in IEEE 754-2008 binary64 format.
          1. Return the ECMAScript Number value corresponding to _x64_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.hypot">
        <h1>Math.hypot ( _value1_, _value2_, ..._values_ )</h1>
        <p>`Math.hypot` returns an implementation-dependent approximation of the square root of the sum of squares of its arguments.</p>
        <ul>
          <li>
            If no arguments are passed, the result is *+0*.
          </li>
          <li>
            If any argument is *+&infin;*, the result is *+&infin;*.
          </li>
          <li>
            If any argument is *-&infin;*, the result is *+&infin;*.
          </li>
          <li>
            If no argument is *+&infin;* or *-&infin;*, and any argument is *NaN*, the result is *NaN*.
          </li>
          <li>
            If all arguments are either *+0* or *-0*, the result is *+0*.
          </li>
        </ul>
        <emu-note>
          <p>Implementations should take care to avoid the loss of precision from overflows and underflows that are prone to occur in naive implementations when this function is called with two or more arguments.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.imul">
        <h1>Math.imul ( _x_, _y_ )</h1>
        <p>When `Math.imul` is called with arguments _x_ and _y_, the following steps are taken:</p>
        <emu-alg>
          1. Let _a_ be ? ToUint32(_x_).
          1. Let _b_ be ? ToUint32(_y_).
          1. Let _product_ be (_a_ &times; _b_) modulo 2<sup>32</sup>.
          1. If _product_ &ge; 2<sup>31</sup>, return _product_ - 2<sup>32</sup>; otherwise return _product_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.log">
        <h1>Math.log ( _x_ )</h1>
        <p>Returns an implementation-dependent approximation to the natural logarithm of _x_.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is less than 0, the result is *NaN*.
          </li>
          <li>
            If _x_ is *+0* or *-0*, the result is *-&infin;*.
          </li>
          <li>
            If _x_ is 1, the result is *+0*.
          </li>
          <li>
            If _x_ is *+&infin;*, the result is *+&infin;*.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-math.log1p">
        <h1>Math.log1p ( _x_ )</h1>
        <p>Returns an implementation-dependent approximation to the natural logarithm of 1 + _x_. The result is computed in a way that is accurate even when the value of x is close to zero.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is less than -1, the result is *NaN*.
          </li>
          <li>
            If x is -1, the result is *-&infin;*.
          </li>
          <li>
            If _x_ is *+0*, the result is *+0*.
          </li>
          <li>
            If _x_ is *-0*, the result is *-0*.
          </li>
          <li>
            If _x_ is *+&infin;*, the result is *+&infin;*.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-math.log10">
        <h1>Math.log10 ( _x_ )</h1>
        <p>Returns an implementation-dependent approximation to the base 10 logarithm of _x_.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is less than 0, the result is *NaN*.
          </li>
          <li>
            If _x_ is *+0*, the result is *-&infin;*.
          </li>
          <li>
            If _x_ is *-0*, the result is *-&infin;*.
          </li>
          <li>
            If _x_ is 1, the result is *+0*.
          </li>
          <li>
            If _x_ is *+&infin;*, the result is *+&infin;*.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-math.log2">
        <h1>Math.log2 ( _x_ )</h1>
        <p>Returns an implementation-dependent approximation to the base 2 logarithm of _x_.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is less than 0, the result is *NaN*.
          </li>
          <li>
            If _x_ is *+0*, the result is *-&infin;*.
          </li>
          <li>
            If _x_ is *-0*, the result is *-&infin;*.
          </li>
          <li>
            If _x_ is 1, the result is *+0*.
          </li>
          <li>
            If _x_ is *+&infin;*, the result is *+&infin;*.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-math.max">
        <h1>Math.max ( _value1_, _value2_, ..._values_ )</h1>
        <p>Given zero or more arguments, calls ToNumber on each of the arguments and returns the largest of the resulting values.</p>
        <ul>
          <li>
            If no arguments are given, the result is *-&infin;*.
          </li>
          <li>
            If any value is *NaN*, the result is *NaN*.
          </li>
          <li>
            The comparison of values to determine the largest value is done using the Abstract Relational Comparison algorithm except that *+0* is considered to be larger than *-0*.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-math.min">
        <h1>Math.min ( _value1_, _value2_, ..._values_ )</h1>
        <p>Given zero or more arguments, calls ToNumber on each of the arguments and returns the smallest of the resulting values.</p>
        <ul>
          <li>
            If no arguments are given, the result is *+&infin;*.
          </li>
          <li>
            If any value is *NaN*, the result is *NaN*.
          </li>
          <li>
            The comparison of values to determine the smallest value is done using the Abstract Relational Comparison algorithm except that *+0* is considered to be larger than *-0*.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-math.pow">
        <h1>Math.pow ( _base_, _exponent_ )</h1>
        <emu-alg>
          1. Return the result of <emu-xref href="#sec-applying-the-exp-operator" title>Applying the ** operator</emu-xref> with _base_ and _exponent_ as specified in <emu-xref href="#sec-applying-the-exp-operator"></emu-xref>.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.random">
        <h1>Math.random ( )</h1>
        <p>Returns a Number value with positive sign, greater than or equal to 0 but less than 1, chosen randomly or pseudo randomly with approximately uniform distribution over that range, using an implementation-dependent algorithm or strategy. This function takes no arguments.</p>
        <p>Each `Math.random` function created for distinct realms must produce a distinct sequence of values from successive calls.</p>
      </emu-clause>

      <emu-clause id="sec-math.round">
        <h1>Math.round ( _x_ )</h1>
        <p>Returns the Number value that is closest to _x_ and is equal to a mathematical integer. If two integer Number values are equally close to _x_, then the result is the Number value that is closer to *+&infin;*. If _x_ is already an integer, the result is _x_.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is *+0*, the result is *+0*.
          </li>
          <li>
            If _x_ is *-0*, the result is *-0*.
          </li>
          <li>
            If _x_ is *+&infin;*, the result is *+&infin;*.
          </li>
          <li>
            If _x_ is *-&infin;*, the result is *-&infin;*.
          </li>
          <li>
            If _x_ is greater than 0 but less than 0.5, the result is *+0*.
          </li>
          <li>
            If _x_ is less than 0 but greater than or equal to -0.5, the result is *-0*.
          </li>
        </ul>
        <emu-note>
          <p>`Math.round(3.5)` returns 4, but `Math.round(-3.5)` returns -3.</p>
        </emu-note>
        <emu-note>
          <p>The value of `Math.round(x)` is not always the same as the value of `Math.floor(x + 0.5)`. When `x` is *-0* or is less than 0 but greater than or equal to -0.5, `Math.round(x)` returns *-0*, but `Math.floor(x + 0.5)` returns *+0*. `Math.round(x)` may also differ from the value of `Math.floor(x + 0.5)`because of internal rounding when computing `x + 0.5`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.sign">
        <h1>Math.sign ( _x_ )</h1>
        <p>Returns the sign of _x_, indicating whether _x_ is positive, negative, or zero.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is *-0*, the result is *-0*.
          </li>
          <li>
            If _x_ is *+0*, the result is *+0*.
          </li>
          <li>
            If _x_ is negative and not *-0*, the result is -1.
          </li>
          <li>
            If _x_ is positive and not *+0*, the result is +1.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-math.sin">
        <h1>Math.sin ( _x_ )</h1>
        <p>Returns an implementation-dependent approximation to the sine of _x_. The argument is expressed in radians.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is *+0*, the result is *+0*.
          </li>
          <li>
            If _x_ is *-0*, the result is *-0*.
          </li>
          <li>
            If _x_ is *+&infin;* or *-&infin;*, the result is *NaN*.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-math.sinh">
        <h1>Math.sinh ( _x_ )</h1>
        <p>Returns an implementation-dependent approximation to the hyperbolic sine of _x_.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is *+0*, the result is *+0*.
          </li>
          <li>
            If _x_ is *-0*, the result is *-0*.
          </li>
          <li>
            If _x_ is *+&infin;*, the result is *+&infin;*.
          </li>
          <li>
            If _x_ is *-&infin;*, the result is *-&infin;*.
          </li>
        </ul>
        <emu-note>
          <p>The value of sinh(x) is the same as <i>(exp(x) - exp(-x)) / 2</i>.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.sqrt">
        <h1>Math.sqrt ( _x_ )</h1>
        <p>Returns an implementation-dependent approximation to the square root of _x_.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is less than 0, the result is *NaN*.
          </li>
          <li>
            If _x_ is *+0*, the result is *+0*.
          </li>
          <li>
            If _x_ is *-0*, the result is *-0*.
          </li>
          <li>
            If _x_ is *+&infin;*, the result is *+&infin;*.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-math.tan">
        <h1>Math.tan ( _x_ )</h1>
        <p>Returns an implementation-dependent approximation to the tangent of _x_. The argument is expressed in radians.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is *+0*, the result is *+0*.
          </li>
          <li>
            If _x_ is *-0*, the result is *-0*.
          </li>
          <li>
            If _x_ is *+&infin;* or *-&infin;*, the result is *NaN*.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-math.tanh">
        <h1>Math.tanh ( _x_ )</h1>
        <p>Returns an implementation-dependent approximation to the hyperbolic tangent of _x_.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is *+0*, the result is *+0*.
          </li>
          <li>
            If _x_ is *-0*, the result is *-0*.
          </li>
          <li>
            If _x_ is *+&infin;*, the result is +1.
          </li>
          <li>
            If _x_ is *-&infin;*, the result is -1.
          </li>
        </ul>
        <emu-note>
          <p>The value of tanh(x) is the same as <i>(exp(x) - exp(-x))/(exp(x) + exp(-x))</i>.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.trunc">
        <h1>Math.trunc ( _x_ )</h1>
        <p>Returns the integral part of the number _x_, removing any fractional digits. If _x_ is already an integer, the result is _x_.</p>
        <ul>
          <li>
            If _x_ is *NaN*, the result is *NaN*.
          </li>
          <li>
            If _x_ is *-0*, the result is *-0*.
          </li>
          <li>
            If _x_ is *+0*, the result is *+0*.
          </li>
          <li>
            If _x_ is *+&infin;*, the result is *+&infin;*.
          </li>
          <li>
            If _x_ is *-&infin;*, the result is *-&infin;*.
          </li>
          <li>
            If _x_ is greater than 0 but less than 1, the result is *+0*.
          </li>
          <li>
            If _x_ is less than 0 but greater than -1, the result is *-0*.
          </li>
        </ul>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-date-objects">
    <h1>Date Objects</h1>

    <emu-clause id="sec-overview-of-date-objects-and-definitions-of-abstract-operations">
      <h1>Overview of Date Objects and Definitions of Abstract Operations</h1>
      <p>The following functions are abstract operations that operate on time values (defined in <emu-xref href="#sec-time-values-and-time-range"></emu-xref>). Note that, in every case, if any argument to one of these functions is *NaN*, the result will be *NaN*.</p>

      <emu-clause id="sec-time-values-and-time-range">
        <h1>Time Values and Time Range</h1>
        <p>A Date object contains a Number representing an instant in time with millisecond precision. Such a Number is called a <dfn>time value</dfn>. A time value may also be *NaN*, indicating that the Date object does not represent a specific instant in time.</p>
        <p>Time is measured in ECMAScript as milliseconds since midnight at the beginning of 01 January, 1970 UTC. Time in ECMAScript does not observe leap seconds; they are ignored. Time calculations assume each and every day contains exactly <emu-eqn>60 &times; 60 &times; 24 &times; 1000 = 86,400,000</emu-eqn> milliseconds, to align with the POSIX specification of each and every day containing exactly 86,400 seconds.</p>
        <p>A Number can exactly represent all integers from -9,007,199,254,740,992 to 9,007,199,254,740,992 (<emu-xref href="#sec-number.min_safe_integer"></emu-xref> and <emu-xref href="#sec-number.max_safe_integer"></emu-xref>). A time value supports a slightly smaller range of exactly -100,000,000 days to 100,000,000 days measured relative to midnight at the beginning of 01 January, 1970 UTC. This yields an exact supported time value range of -8,640,000,000,000,000 to 8,640,000,000,000,000 milliseconds relative to midnight at the beginning of 01 January, 1970 UTC.</p>
        <p>The exact moment of midnight at the beginning of 01 January, 1970 UTC is represented by the time value *+0*.</p>
        <emu-note>
          <p>The 400 year cycle of the Gregorian calendar contains 97 leap years. This yields an average of 365.2425 days per year, or an average of 31,556,952,000 milliseconds per year under the Gregorian calendar. ECMAScript applies a proleptic Gregorian calendar for all time computations.</p>
          <p>As specified by this section, the maximum year range a Number can represent exactly with millisecond precision is approximately -285,426 to 285,426 years relative to midnight at the beginning of 01 January, 1970 UTC.</p>
          <p>As specified by this section, the maximum year range a time value can represent is approximately -273,790 to 273,790 years relative to midnight at the beginning of 01 January, 1970 UTC.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-day-number-and-time-within-day">
        <h1>Day Number and Time within Day</h1>
        <p>A given time value _t_ belongs to day number</p>
        <emu-eqn id="eqn-Day" aoid="Day">Day(_t_) = floor(_t_ / msPerDay)</emu-eqn>
        <p>where the number of milliseconds per day is</p>
        <emu-eqn id="eqn-msPerDay" aoid="msPerDay">msPerDay = 86400000</emu-eqn>
        <p>The remainder is called the time within the day:</p>
        <emu-eqn id="eqn-TimeWithinDay" aoid="TimeWithinDay">TimeWithinDay(_t_) = _t_ modulo msPerDay</emu-eqn>
      </emu-clause>

      <emu-clause id="sec-year-number">
        <h1>Year Number</h1>
        <p>ECMAScript uses a proleptic Gregorian calendar to map a day number to a year number and to determine the month and date within that year. In this calendar, leap years are precisely those which are (divisible by 4) and ((not divisible by 100) or (divisible by 400)). The number of days in year number _y_ is therefore defined by</p>
        <emu-eqn id="eqn-DaysInYear" aoid="DaysInYear">DaysInYear(_y_)
          = 365 if (_y_ modulo 4) &ne; 0
          = 366 if (_y_ modulo 4) = 0 and (_y_ modulo 100) &ne; 0
          = 365 if (_y_ modulo 100) = 0 and (_y_ modulo 400) &ne; 0
          = 366 if (_y_ modulo 400) = 0
        </emu-eqn>
        <p>All non-leap years have 365 days with the usual number of days per month and leap years have an extra day in February. The day number of the first day of year _y_ is given by:</p>
        <emu-eqn id="eqn-DaysFromYear" aoid="DayFromYear">DayFromYear(_y_) = 365 &times; (_y_ - 1970) + floor((_y_ - 1969) / 4) - floor((_y_ - 1901) / 100) + floor((_y_ - 1601) / 400)</emu-eqn>
        <p>The time value of the start of a year is:</p>
        <emu-eqn id="eqn-TimeFromYear" aoid="TimeFromYear">TimeFromYear(_y_) = msPerDay &times; DayFromYear(_y_)</emu-eqn>
        <p>A time value determines a year by:</p>
        <emu-eqn id="eqn-YearFromTime" aoid="YearFromTime">YearFromTime(_t_) = the largest integer _y_ (closest to positive infinity) such that TimeFromYear(_y_) &le; _t_</emu-eqn>
        <p>The leap-year function is 1 for a time within a leap year and otherwise is zero:</p>
        <emu-eqn id="eqn-InLeapYear" aoid="InLeapYear">InLeapYear(_t_)
          = 0 if DaysInYear(YearFromTime(_t_)) = 365
          = 1 if DaysInYear(YearFromTime(_t_)) = 366
        </emu-eqn>
      </emu-clause>

      <emu-clause id="sec-month-number">
        <h1>Month Number</h1>
        <p>Months are identified by an integer in the range 0 to 11, inclusive. The mapping MonthFromTime(_t_) from a time value _t_ to a month number is defined by:</p>
        <emu-eqn id="eqn-MonthFromTime" aoid="MonthFromTime">MonthFromTime(_t_)
          = 0 if 0 &le; DayWithinYear(_t_) &lt; 31
          = 1 if 31 &le; DayWithinYear(_t_) &lt; 59 + InLeapYear(_t_)
          = 2 if 59 + InLeapYear(_t_) &le; DayWithinYear(_t_) &lt; 90 + InLeapYear(_t_)
          = 3 if 90 + InLeapYear(_t_) &le; DayWithinYear(_t_) &lt; 120 + InLeapYear(_t_)
          = 4 if 120 + InLeapYear(_t_) &le; DayWithinYear(_t_) &lt; 151 + InLeapYear(_t_)
          = 5 if 151 + InLeapYear(_t_) &le; DayWithinYear(_t_) &lt; 181 + InLeapYear(_t_)
          = 6 if 181 + InLeapYear(_t_) &le; DayWithinYear(_t_) &lt; 212 + InLeapYear(_t_)
          = 7 if 212 + InLeapYear(_t_) &le; DayWithinYear(_t_) &lt; 243 + InLeapYear(_t_)
          = 8 if 243 + InLeapYear(_t_) &le; DayWithinYear(_t_) &lt; 273 + InLeapYear(_t_)
          = 9 if 273 + InLeapYear(_t_) &le; DayWithinYear(_t_) &lt; 304 + InLeapYear(_t_)
          = 10 if 304 + InLeapYear(_t_) &le; DayWithinYear(_t_) &lt; 334 + InLeapYear(_t_)
          = 11 if 334 + InLeapYear(_t_) &le; DayWithinYear(_t_) &lt; 365 + InLeapYear(_t_)
        </emu-eqn>
        <p>where</p>
        <emu-eqn id="eqn-DayWithinYear" aoid="DayWithinYear">DayWithinYear(_t_) = Day(_t_) - DayFromYear(YearFromTime(_t_))</emu-eqn>
        <p>A month value of 0 specifies January; 1 specifies February; 2 specifies March; 3 specifies April; 4 specifies May; 5 specifies June; 6 specifies July; 7 specifies August; 8 specifies September; 9 specifies October; 10 specifies November; and 11 specifies December. Note that <emu-eqn>MonthFromTime(0) = 0</emu-eqn>, corresponding to Thursday, 01 January, 1970.</p>
      </emu-clause>

      <emu-clause id="sec-date-number">
        <h1>Date Number</h1>
        <p>A date number is identified by an integer in the range 1 through 31, inclusive. The mapping DateFromTime(_t_) from a time value _t_ to a date number is defined by:</p>
        <emu-eqn aoid="DateFromTime">DateFromTime(_t_)
          = DayWithinYear(_t_) + 1  if MonthFromTime(_t_) = 0
          = DayWithinYear(_t_) - 30  if MonthFromTime(_t_) = 1
          = DayWithinYear(_t_) - 58 - InLeapYear(_t_) if MonthFromTime(_t_) = 2
          = DayWithinYear(_t_) - 89 - InLeapYear(_t_) if MonthFromTime(_t_) = 3
          = DayWithinYear(_t_) - 119 - InLeapYear(_t_) if MonthFromTime(_t_) = 4
          = DayWithinYear(_t_) - 150 - InLeapYear(_t_) if MonthFromTime(_t_) = 5
          = DayWithinYear(_t_) - 180 - InLeapYear(_t_) if MonthFromTime(_t_) = 6
          = DayWithinYear(_t_) - 211 - InLeapYear(_t_) if MonthFromTime(_t_) = 7
          = DayWithinYear(_t_) - 242 - InLeapYear(_t_) if MonthFromTime(_t_) = 8
          = DayWithinYear(_t_) - 272 - InLeapYear(_t_) if MonthFromTime(_t_) = 9
          = DayWithinYear(_t_) - 303 - InLeapYear(_t_) if MonthFromTime(_t_) = 10
          = DayWithinYear(_t_) - 333 - InLeapYear(_t_) if MonthFromTime(_t_) = 11
        </emu-eqn>
      </emu-clause>

      <emu-clause id="sec-week-day">
        <h1>Week Day</h1>
        <p>The weekday for a particular time value _t_ is defined as</p>
        <emu-eqn aoid="WeekDay">WeekDay(_t_) = (Day(_t_) + 4) modulo 7</emu-eqn>
        <p>A weekday value of 0 specifies Sunday; 1 specifies Monday; 2 specifies Tuesday; 3 specifies Wednesday; 4 specifies Thursday; 5 specifies Friday; and 6 specifies Saturday. Note that <emu-eqn>WeekDay(0) = 4</emu-eqn>, corresponding to Thursday, 01 January, 1970.</p>
      </emu-clause>

      <emu-clause id="sec-local-time-zone-adjustment">
        <h1>LocalTZA ( _t_, _isUTC_ )</h1>
        <p>LocalTZA( _t_, _isUTC_ ) is an implementation-defined algorithm that must return a number representing milliseconds suitable for adding to a Time Value. The local political rules for standard time and daylight saving time in effect at _t_ should be used to determine the result in the way specified in the following three paragraphs.</p>
        <p>When _isUTC_ is true, <dfn>LocalTZA( _t_, true )</dfn> should return the offset of the local time zone from UTC measured in milliseconds at time represented by time value _t_ (UTC). When the result is added to _t_ (UTC), it should yield the local time.</p>
        <p>When _isUTC_ is false, <dfn>LocalTZA( _t_, false )</dfn> should return the offset of the local time zone from UTC measured in milliseconds at local time represented by time value <dfn><emu-eqn>_t_<sub>local</sub> = _t_</emu-eqn></dfn>. When the result is subtracted from the local time <emu-eqn>_t_<sub>local</sub></emu-eqn>, it should yield the corresponding UTC.</p>
        <p>When <emu-eqn>_t_<sub>local</sub></emu-eqn> represents local time repeating multiple times at a negative time zone transition (e.g. when the daylight saving time ends or the time zone adjustment is decreased due to a time zone rule change) or skipped local time at a positive time zone transitions (e.g. when the daylight saving time starts or the time zone adjustment is increased due to a time zone rule change), <emu-eqn>_t_<sub>local</sub></emu-eqn> must be interpreted with the time zone adjustment before the transition.</p>
        <p>If an implementation does not support a conversion described above or if political rules for time _t_ are not available within the implementation, the result must be 0.</p>
        <emu-note>
          <p>It is recommended that implementations use the time zone information of the IANA Time Zone Database <a href="https://www.iana.org/time-zones/">https://www.iana.org/time-zones/</a>.</p>
          <p>1:30 AM on November 5, 2017 in America/New_York is repeated twice (fall backward), but it must be interpreted as 1:30 AM UTC-04 instead of 1:30 AM UTC-05. LocalTZA(TimeClip(MakeDate(MakeDay(2017, 10, 5), MakeTime(1, 30, 0, 0))), false) is <emu-eqn>-4 &times; msPerHour</emu-eqn>.</p>
          <p>2:30 AM on March 12, 2017 in America/New_York does not exist, but it must be interpreted as 2:30 AM UTC-05 (equivalent to 3:30 AM UTC-04). LocalTZA(TimeClip(MakeDate(MakeDay(2017, 2, 12), MakeTime(2, 30, 0, 0))), false) is <emu-eqn>-5 &times; msPerHour</emu-eqn>.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-localtime" aoid="LocalTime">
        <h1>LocalTime ( _t_ )</h1>
        <p>The abstract operation LocalTime with argument _t_ converts _t_ from UTC to local time by performing the following steps:</p>
        <emu-alg>
          1. Return _t_ + LocalTZA(_t_, *true*).
        </emu-alg>
        <emu-note>
          <p>Two different time values (_t_ (UTC)) are converted to the same local time <emu-eqn>t<sub>local</sub></emu-eqn> at a negative time zone transition when there are repeated times (e.g. the daylight saving time ends or the time zone adjustment is decreased.).</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-utc-t" aoid="UTC">
        <h1>UTC ( _t_ )</h1>
        <p>The abstract operation UTC with argument _t_ converts _t_ from local time to UTC. It performs the following steps:</p>
        <emu-alg>
          1. Return _t_ - LocalTZA(_t_, *false*).
        </emu-alg>
        <emu-note>
          <p><emu-eqn>UTC(LocalTime(_t_))</emu-eqn> is not necessarily always equal to _t_. <emu-eqn>LocalTime(UTC(_t_<sub>local</sub>))</emu-eqn> is not necessarily always equal to <emu-eqn>_t_<sub>local</sub></emu-eqn>, either.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-hours-minutes-second-and-milliseconds">
        <h1>Hours, Minutes, Second, and Milliseconds</h1>
        <p>The following abstract operations are useful in decomposing time values:</p>
        <emu-eqn id="eqn-HourFromTime" aoid="HourFromTime">HourFromTime(_t_) = floor(_t_ / msPerHour) modulo HoursPerDay</emu-eqn>
        <emu-eqn id="eqn-MinFromTime" aoid="MinFromTime">MinFromTime(_t_) = floor(_t_ / msPerMinute) modulo MinutesPerHour</emu-eqn>
        <emu-eqn id="eqn-SecFromTime" aoid="SecFromTime">SecFromTime(_t_) = floor(_t_ / msPerSecond) modulo SecondsPerMinute</emu-eqn>
        <emu-eqn id="eqn-msFromTime" aoid="msFromTime">msFromTime(_t_) = _t_ modulo msPerSecond</emu-eqn>
        <p>where</p>
        <emu-eqn id="eqn-HoursPerDay" aoid="HoursPerDay">HoursPerDay = 24</emu-eqn>
        <emu-eqn id="eqn-MinutesPerHour" aoid="MinutesPerHour">MinutesPerHour = 60</emu-eqn>
        <emu-eqn id="eqn-SecondsPerMinute" aoid="SecondsPerMinute">SecondsPerMinute = 60</emu-eqn>
        <emu-eqn id="eqn-msPerSecond" aoid="msPerSecond">msPerSecond = 1000</emu-eqn>
        <emu-eqn id="eqn-msPerMinute" aoid="msPerMinute">msPerMinute = 60000 = msPerSecond &times; SecondsPerMinute</emu-eqn>
        <emu-eqn id="eqn-msPerHour" aoid="msPerHour">msPerHour = 3600000 = msPerMinute &times; MinutesPerHour</emu-eqn>
      </emu-clause>

      <emu-clause id="sec-maketime" aoid="MakeTime">
        <h1>MakeTime ( _hour_, _min_, _sec_, _ms_ )</h1>
        <p>The abstract operation MakeTime calculates a number of milliseconds from its four arguments, which must be ECMAScript Number values. This operator functions as follows:</p>
        <emu-alg>
          1. If _hour_ is not finite or _min_ is not finite or _sec_ is not finite or _ms_ is not finite, return *NaN*.
          1. Let _h_ be ! ToInteger(_hour_).
          1. Let _m_ be ! ToInteger(_min_).
          1. Let _s_ be ! ToInteger(_sec_).
          1. Let _milli_ be ! ToInteger(_ms_).
          1. Let _t_ be _h_ `*` msPerHour `+` _m_ `*` msPerMinute `+` _s_ `*` msPerSecond `+` _milli_, performing the arithmetic according to IEEE 754-2008 rules (that is, as if using the ECMAScript operators `*` and `+`).
          1. Return _t_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makeday" aoid="MakeDay">
        <h1>MakeDay ( _year_, _month_, _date_ )</h1>
        <p>The abstract operation MakeDay calculates a number of days from its three arguments, which must be ECMAScript Number values. This operator functions as follows:</p>
        <emu-alg>
          1. If _year_ is not finite or _month_ is not finite or _date_ is not finite, return *NaN*.
          1. Let _y_ be ! ToInteger(_year_).
          1. Let _m_ be ! ToInteger(_month_).
          1. Let _dt_ be ! ToInteger(_date_).
          1. Let _ym_ be _y_ + floor(_m_ / 12).
          1. Let _mn_ be _m_ modulo 12.
          1. Find a value _t_ such that YearFromTime(_t_) is _ym_ and MonthFromTime(_t_) is _mn_ and DateFromTime(_t_) is 1; but if this is not possible (because some argument is out of range), return *NaN*.
          1. Return Day(_t_) + _dt_ - 1.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makedate" aoid="MakeDate">
        <h1>MakeDate ( _day_, _time_ )</h1>
        <p>The abstract operation MakeDate calculates a number of milliseconds from its two arguments, which must be ECMAScript Number values. This operator functions as follows:</p>
        <emu-alg>
          1. If _day_ is not finite or _time_ is not finite, return *NaN*.
          1. Return _day_ &times; msPerDay + _time_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-timeclip" aoid="TimeClip">
        <h1>TimeClip ( _time_ )</h1>
        <p>The abstract operation TimeClip calculates a number of milliseconds from its argument, which must be an ECMAScript Number value. This operator functions as follows:</p>
        <emu-alg>
          1. If _time_ is not finite, return *NaN*.
          1. If abs(_time_) &gt; 8.64 &times; 10<sup>15</sup>, return *NaN*.
          1. Let _clippedTime_ be ! ToInteger(_time_).
          1. If _clippedTime_ is *-0*, set _clippedTime_ to *+0*.
          1. Return _clippedTime_.
        </emu-alg>
        <emu-note>
          <p>The point of step 4 is that an implementation is permitted a choice of internal representations of time values, for example as a 64-bit signed integer or as a 64-bit floating-point value. Depending on the implementation, this internal representation may or may not distinguish *-0* and *+0*.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date-time-string-format">
        <h1>Date Time String Format</h1>
        <p>ECMAScript defines a string interchange format for date-times based upon a simplification of the ISO 8601 calendar date extended format. The format is as follows: `YYYY-MM-DDTHH:mm:ss.sssZ`</p>
        <p>Where the elements are as follows:</p>
        <figure>
          <table class="lightweight-table">
            <tbody>
            <tr>
              <td>
                `YYYY`
              </td>
              <td>
                is the year in the proleptic Gregorian calendar as four decimal digits from 0000 to 9999, or as an <emu-xref href="#sec-expanded-years">expanded year</emu-xref> of `"+"` or `"-"` followed by six decimal digits.
              </td>
            </tr>
            <tr>
              <td>
                `-`
              </td>
              <td>
                `"-"` (hyphen) appears literally twice in the string.
              </td>
            </tr>
            <tr>
              <td>
                `MM`
              </td>
              <td>
                is the month of the year as two decimal digits from 01 (January) to 12 (December).
              </td>
            </tr>
            <tr>
              <td>
                `DD`
              </td>
              <td>
                is the day of the month as two decimal digits from 01 to 31.
              </td>
            </tr>
            <tr>
              <td>
                `T`
              </td>
              <td>
                `"T"` appears literally in the string, to indicate the beginning of the time element.
              </td>
            </tr>
            <tr>
              <td>
                `HH`
              </td>
              <td>
                is the number of complete hours that have passed since midnight as two decimal digits from 00 to 24.
              </td>
            </tr>
            <tr>
              <td>
                `:`
              </td>
              <td>
                `":"` (colon) appears literally twice in the string.
              </td>
            </tr>
            <tr>
              <td>
                `mm`
              </td>
              <td>
                is the number of complete minutes since the start of the hour as two decimal digits from 00 to 59.
              </td>
            </tr>
            <tr>
              <td>
                `ss`
              </td>
              <td>
                is the number of complete seconds since the start of the minute as two decimal digits from 00 to 59.
              </td>
            </tr>
            <tr>
              <td>
                `.`
              </td>
              <td>
                `"."` (dot) appears literally in the string.
              </td>
            </tr>
            <tr>
              <td>
                `sss`
              </td>
              <td>
                is the number of complete milliseconds since the start of the second as three decimal digits.
              </td>
            </tr>
            <tr>
              <td>
                `Z`
              </td>
              <td>
                is the UTC offset representation specified as `"Z"` (for UTC with no offset) or an offset of either `"+"` or `"-"` followed by a time expression `HH:mm` (indicating local time ahead of or behind UTC, respectively)
              </td>
            </tr>
            </tbody>
          </table>
        </figure>
        <p>This format includes date-only forms:</p>
        <pre>
YYYY
YYYY-MM
YYYY-MM-DD
        </pre>
        <p>It also includes &ldquo;date-time&rdquo; forms that consist of one of the above date-only forms immediately followed by one of the following time forms with an optional UTC offset representation appended:</p>
        <pre>
THH:mm
THH:mm:ss
THH:mm:ss.sss
        </pre>
        <p>A string containing out-of-bounds or nonconforming elements is not a valid instance of this format.</p>
        <emu-note>
          <p>As every day both starts and ends with midnight, the two notations `00:00` and `24:00` are available to distinguish the two midnights that can be associated with one date. This means that the following two notations refer to exactly the same point in time: `1995-02-04T24:00` and `1995-02-05T00:00`. This interpretation of the latter form as "end of a calendar day" is consistent with ISO 8601, even though that specification reserves it for describing time intervals and does not permit it within representations of single points in time.</p>
        </emu-note>
        <emu-note>
          <p>There exists no international standard that specifies abbreviations for civil time zones like CET, EST, etc. and sometimes the same abbreviation is even used for two very different time zones. For this reason, both ISO 8601 and this format specify numeric representations of time zone offsets.</p>
        </emu-note>

        <emu-clause id="sec-expanded-years" oldids="sec-extended-years">
          <h1>Expanded Years</h1>
          <p>Covering the full time value range of approximately 273,790 years forward or backward from 01 January, 1970 (<emu-xref href="#sec-time-values-and-time-range"></emu-xref>) requires representing years before 0 or after 9999. ISO 8601 permits expansion of the year representation, but only by mutual agreement of the partners in information interchange. In the simplified ECMAScript format, such an expanded year representation shall have 6 digits and is always prefixed with a + or - sign. The year 0 is considered positive and hence prefixed with a + sign. Strings matching the <emu-xref href="#sec-date-time-string-format">Date Time String Format</emu-xref> with expanded years representing instants in time outside the range of a time value are treated as unrecognizable by <emu-xref href="#sec-date.parse">`Date.parse`</emu-xref> and cause that function to return *NaN* without falling back to implementation-specific behavior or heuristics.</p>
          <emu-note>
            <p>Examples of date-time values with expanded years:</p>
            <figure>
              <table class="lightweight-table">
                <tbody>
                  <tr>
                    <td>-271821-04-20T00:00:00Z</td>
                    <td>271822 B.C.</td>
                  </tr>
                  <tr>
                    <td>-000001-01-01T00:00:00Z</td>
                    <td>2 B.C.</td>
                  </tr>
                  <tr>
                    <td>+000000-01-01T00:00:00Z</td>
                    <td>1 B.C.</td>
                  </tr>
                  <tr>
                    <td>+000001-01-01T00:00:00Z</td>
                    <td>1 A.D.</td>
                  </tr>
                  <tr>
                    <td>+001970-01-01T00:00:00Z</td>
                    <td>1970 A.D.</td>
                  </tr>
                  <tr>
                    <td>+002009-12-15T00:00:00Z</td>
                    <td>2009 A.D.</td>
                  </tr>
                  <tr>
                    <td>+275760-09-13T00:00:00Z</td>
                    <td>275760 A.D.</td>
                  </tr>
                </tbody>
              </table>
            </figure>
          </emu-note>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-date-constructor">
      <h1>The Date Constructor</h1>
      <p>The Date constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%Date%</dfn>.</li>
        <li>is the initial value of the `Date` property of the global object.</li>
        <li>creates and initializes a new Date object when called as a constructor.</li>
        <li>returns a String representing the current time (UTC) when called as a function rather than as a constructor.</li>
        <li>is a single function whose behaviour is overloaded based upon the number and types of its arguments.</li>
        <li>is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `Date` behaviour must include a `super` call to the `Date` constructor to create and initialize the subclass instance with a [[DateValue]] internal slot.</li>
        <li>has a `"length"` property whose value is 7.</li>
      </ul>

      <emu-clause id="sec-date-year-month-date-hours-minutes-seconds-ms">
        <h1>Date ( _year_, _month_ [ , _date_ [ , _hours_ [ , _minutes_ [ , _seconds_ [ , _ms_ ] ] ] ] ] )</h1>
        <p>This description applies only if the Date constructor is called with at least two arguments.</p>
        <p>When the `Date` function is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _numberOfArgs_ be the number of arguments passed to this function call.
          1. Assert: _numberOfArgs_ &ge; 2.
          1. If NewTarget is *undefined*, then
            1. Let _now_ be the Number that is the time value (UTC) identifying the current time.
            1. Return ToDateString(_now_).
          1. Else,
            1. Let _y_ be ? ToNumber(_year_).
            1. Let _m_ be ? ToNumber(_month_).
            1. If _date_ is present, let _dt_ be ? ToNumber(_date_); else let _dt_ be 1.
            1. If _hours_ is present, let _h_ be ? ToNumber(_hours_); else let _h_ be 0.
            1. If _minutes_ is present, let _min_ be ? ToNumber(_minutes_); else let _min_ be 0.
            1. If _seconds_ is present, let _s_ be ? ToNumber(_seconds_); else let _s_ be 0.
            1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_); else let _milli_ be 0.
            1. If _y_ is *NaN*, let _yr_ be *NaN*.
            1. Else,
              1. Let _yi_ be ! ToInteger(_y_).
              1. If 0 &le; _yi_ &le; 99, let _yr_ be 1900 + _yi_; otherwise, let _yr_ be _y_.
            1. Let _finalDate_ be MakeDate(MakeDay(_yr_, _m_, _dt_), MakeTime(_h_, _min_, _s_, _milli_)).
            1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, `"%DatePrototype%"`, &laquo; [[DateValue]] &raquo;).
            1. Set _O_.[[DateValue]] to TimeClip(UTC(_finalDate_)).
            1. Return _O_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date-value">
        <h1>Date ( _value_ )</h1>
        <p>This description applies only if the Date constructor is called with exactly one argument.</p>
        <p>When the `Date` function is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _numberOfArgs_ be the number of arguments passed to this function call.
          1. Assert: _numberOfArgs_ = 1.
          1. If NewTarget is *undefined*, then
            1. Let _now_ be the Number that is the time value (UTC) identifying the current time.
            1. Return ToDateString(_now_).
          1. Else,
            1. If Type(_value_) is Object and _value_ has a [[DateValue]] internal slot, then
              1. Let _tv_ be thisTimeValue(_value_).
            1. Else,
              1. Let _v_ be ? ToPrimitive(_value_).
              1. If Type(_v_) is String, then
                1. Assert: The next step never returns an abrupt completion because Type(_v_) is String.
                1. Let _tv_ be the result of parsing _v_ as a date, in exactly the same manner as for the `parse` method (<emu-xref href="#sec-date.parse"></emu-xref>).
              1. Else,
                1. Let _tv_ be ? ToNumber(_v_).
            1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, `"%DatePrototype%"`, &laquo; [[DateValue]] &raquo;).
            1. Set _O_.[[DateValue]] to TimeClip(_tv_).
            1. Return _O_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date-constructor-date">
        <h1>Date ( )</h1>
        <p>This description applies only if the Date constructor is called with no arguments.</p>
        <p>When the `Date` function is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _numberOfArgs_ be the number of arguments passed to this function call.
          1. Assert: _numberOfArgs_ = 0.
          1. If NewTarget is *undefined*, then
            1. Let _now_ be the Number that is the time value (UTC) identifying the current time.
            1. Return ToDateString(_now_).
          1. Else,
            1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, `"%DatePrototype%"`, &laquo; [[DateValue]] &raquo;).
            1. Set _O_.[[DateValue]] to the time value (UTC) identifying the current time.
            1. Return _O_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-date-constructor">
      <h1>Properties of the Date Constructor</h1>
      <p>The Date constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-date.now">
        <h1>Date.now ( )</h1>
        <p>The `now` function returns a Number value that is the time value designating the UTC date and time of the occurrence of the call to `now`.</p>
      </emu-clause>

      <emu-clause id="sec-date.parse">
        <h1>Date.parse ( _string_ )</h1>
        <p>The `parse` function applies the ToString operator to its argument. If ToString results in an abrupt completion the Completion Record is immediately returned. Otherwise, `parse` interprets the resulting String as a date and time; it returns a Number, the UTC time value corresponding to the date and time. The String may be interpreted as a local time, a UTC time, or a time in some other time zone, depending on the contents of the String. The function first attempts to parse the String according to the format described in Date Time String Format (<emu-xref href="#sec-date-time-string-format"></emu-xref>), including expanded years. If the String does not conform to that format the function may fall back to any implementation-specific heuristics or implementation-specific date formats. Strings that are unrecognizable or contain out-of-bounds format element values shall cause `Date.parse` to return *NaN*.</p>
        <p>If the String conforms to the <emu-xref href="#sec-date-time-string-format">Date Time String Format</emu-xref>, substitute values take the place of absent format elements. When the `MM` or `DD` elements are absent, `"01"` is used. When the `HH`, `mm`, or `ss` elements are absent, `"00"` is used. When the `sss` element is absent, `"000"` is used. When the UTC offset representation is absent, date-only forms are interpreted as a UTC time and date-time forms are interpreted as a local time.</p>
        <p>If `x` is any Date object whose milliseconds amount is zero within a particular implementation of ECMAScript, then all of the following expressions should produce the same numeric value in that implementation, if all the properties referenced have their initial values:</p>
        <pre><code class="javascript">
          x.valueOf()
          Date.parse(x.toString())
          Date.parse(x.toUTCString())
          Date.parse(x.toISOString())
        </code></pre>
        <p>However, the expression</p>
        <pre><code class="javascript">
          Date.parse(x.toLocaleString())
        </code></pre>
        <p>is not required to produce the same Number value as the preceding three expressions and, in general, the value produced by `Date.parse` is implementation-dependent when given any String value that does not conform to the Date Time String Format (<emu-xref href="#sec-date-time-string-format"></emu-xref>) and that could not be produced in that implementation by the `toString` or `toUTCString` method.</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype">
        <h1>Date.prototype</h1>
        <p>The initial value of `Date.prototype` is the intrinsic object %DatePrototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-date.utc">
        <h1>Date.UTC ( _year_ [ , _month_ [ , _date_ [ , _hours_ [ , _minutes_ [ , _seconds_ [ , _ms_ ] ] ] ] ] ] )</h1>
        <p>When the `UTC` function is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _y_ be ? ToNumber(_year_).
          1. If _month_ is present, let _m_ be ? ToNumber(_month_); else let _m_ be 0.
          1. If _date_ is present, let _dt_ be ? ToNumber(_date_); else let _dt_ be 1.
          1. If _hours_ is present, let _h_ be ? ToNumber(_hours_); else let _h_ be 0.
          1. If _minutes_ is present, let _min_ be ? ToNumber(_minutes_); else let _min_ be 0.
          1. If _seconds_ is present, let _s_ be ? ToNumber(_seconds_); else let _s_ be 0.
          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_); else let _milli_ be 0.
          1. If _y_ is *NaN*, let _yr_ be *NaN*.
          1. Else,
            1. Let _yi_ be ! ToInteger(_y_).
            1. If 0 &le; _yi_ &le; 99, let _yr_ be 1900 + _yi_; otherwise, let _yr_ be _y_.
          1. Return TimeClip(MakeDate(MakeDay(_yr_, _m_, _dt_), MakeTime(_h_, _min_, _s_, _milli_))).
        </emu-alg>
        <p>The `"length"` property of the `UTC` function is 7.</p>
        <emu-note>
          <p>The `UTC` function differs from the `Date` constructor in two ways: it returns a time value as a Number, rather than creating a Date object, and it interprets the arguments in UTC rather than as local time.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-date-prototype-object">
      <h1>Properties of the Date Prototype Object</h1>
      <p>The Date prototype object:</p>
      <ul>
        <li>is the intrinsic object <dfn>%DatePrototype%</dfn>.</li>
        <li>is itself an ordinary object.</li>
        <li>is not a Date instance and does not have a [[DateValue]] internal slot.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
      </ul>
      <p>Unless explicitly defined otherwise, the methods of the Date prototype object defined below are not generic and the *this* value passed to them must be an object that has a [[DateValue]] internal slot that has been initialized to a time value.</p>
      <p>The abstract operation <dfn id="sec-thistimevalue" aoid="thisTimeValue">thisTimeValue</dfn>(_value_) performs the following steps:</p>
      <emu-alg>
        1. If Type(_value_) is Object and _value_ has a [[DateValue]] internal slot, then
          1. Return _value_.[[DateValue]].
        1. Throw a *TypeError* exception.
      </emu-alg>
      <p>In following descriptions of functions that are properties of the Date prototype object, the phrase &ldquo;<dfn id="this-Date-object">this Date object</dfn>&rdquo; refers to the object that is the *this* value for the invocation of the function. If the Type of the *this* value is not Object, a *TypeError* exception is thrown. The phrase &ldquo;<dfn id="this-time-value">this time value</dfn>&rdquo; within the specification of a method refers to the result returned by calling the abstract operation thisTimeValue with the *this* value of the method invocation passed as the argument.</p>

      <emu-clause id="sec-date.prototype.constructor">
        <h1>Date.prototype.constructor</h1>
        <p>The initial value of `Date.prototype.constructor` is the intrinsic object %Date%.</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getdate">
        <h1>Date.prototype.getDate ( )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. If _t_ is *NaN*, return *NaN*.
          1. Return DateFromTime(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getday">
        <h1>Date.prototype.getDay ( )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. If _t_ is *NaN*, return *NaN*.
          1. Return WeekDay(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getfullyear">
        <h1>Date.prototype.getFullYear ( )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. If _t_ is *NaN*, return *NaN*.
          1. Return YearFromTime(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.gethours">
        <h1>Date.prototype.getHours ( )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. If _t_ is *NaN*, return *NaN*.
          1. Return HourFromTime(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getmilliseconds">
        <h1>Date.prototype.getMilliseconds ( )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. If _t_ is *NaN*, return *NaN*.
          1. Return msFromTime(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getminutes">
        <h1>Date.prototype.getMinutes ( )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. If _t_ is *NaN*, return *NaN*.
          1. Return MinFromTime(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getmonth">
        <h1>Date.prototype.getMonth ( )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. If _t_ is *NaN*, return *NaN*.
          1. Return MonthFromTime(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getseconds">
        <h1>Date.prototype.getSeconds ( )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. If _t_ is *NaN*, return *NaN*.
          1. Return SecFromTime(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.gettime">
        <h1>Date.prototype.getTime ( )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Return ? thisTimeValue(*this* value).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.gettimezoneoffset">
        <h1>Date.prototype.getTimezoneOffset ( )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. If _t_ is *NaN*, return *NaN*.
          1. Return (_t_ - LocalTime(_t_)) / msPerMinute.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcdate">
        <h1>Date.prototype.getUTCDate ( )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. If _t_ is *NaN*, return *NaN*.
          1. Return DateFromTime(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcday">
        <h1>Date.prototype.getUTCDay ( )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. If _t_ is *NaN*, return *NaN*.
          1. Return WeekDay(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcfullyear">
        <h1>Date.prototype.getUTCFullYear ( )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. If _t_ is *NaN*, return *NaN*.
          1. Return YearFromTime(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutchours">
        <h1>Date.prototype.getUTCHours ( )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. If _t_ is *NaN*, return *NaN*.
          1. Return HourFromTime(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcmilliseconds">
        <h1>Date.prototype.getUTCMilliseconds ( )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. If _t_ is *NaN*, return *NaN*.
          1. Return msFromTime(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcminutes">
        <h1>Date.prototype.getUTCMinutes ( )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. If _t_ is *NaN*, return *NaN*.
          1. Return MinFromTime(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcmonth">
        <h1>Date.prototype.getUTCMonth ( )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. If _t_ is *NaN*, return *NaN*.
          1. Return MonthFromTime(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcseconds">
        <h1>Date.prototype.getUTCSeconds ( )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. If _t_ is *NaN*, return *NaN*.
          1. Return SecFromTime(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setdate">
        <h1>Date.prototype.setDate ( _date_ )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be LocalTime(? thisTimeValue(*this* value)).
          1. Let _dt_ be ? ToNumber(_date_).
          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), MonthFromTime(_t_), _dt_), TimeWithinDay(_t_)).
          1. Let _u_ be TimeClip(UTC(_newDate_)).
          1. Set the [[DateValue]] internal slot of this Date object to _u_.
          1. Return _u_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setfullyear">
        <h1>Date.prototype.setFullYear ( _year_ [ , _month_ [ , _date_ ] ] )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. If _t_ is *NaN*, set _t_ to *+0*; otherwise, set _t_ to LocalTime(_t_).
          1. Let _y_ be ? ToNumber(_year_).
          1. If _month_ is not present, let _m_ be MonthFromTime(_t_); otherwise, let _m_ be ? ToNumber(_month_).
          1. If _date_ is not present, let _dt_ be DateFromTime(_t_); otherwise, let _dt_ be ? ToNumber(_date_).
          1. Let _newDate_ be MakeDate(MakeDay(_y_, _m_, _dt_), TimeWithinDay(_t_)).
          1. Let _u_ be TimeClip(UTC(_newDate_)).
          1. Set the [[DateValue]] internal slot of this Date object to _u_.
          1. Return _u_.
        </emu-alg>
        <p>The `"length"` property of the `setFullYear` method is 3.</p>
        <emu-note>
          <p>If _month_ is not present, this method behaves as if _month_ was present with the value `getMonth()`. If _date_ is not present, it behaves as if _date_ was present with the value `getDate()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.sethours">
        <h1>Date.prototype.setHours ( _hour_ [ , _min_ [ , _sec_ [ , _ms_ ] ] ] )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be LocalTime(? thisTimeValue(*this* value)).
          1. Let _h_ be ? ToNumber(_hour_).
          1. If _min_ is not present, let _m_ be MinFromTime(_t_); otherwise, let _m_ be ? ToNumber(_min_).
          1. If _sec_ is not present, let _s_ be SecFromTime(_t_); otherwise, let _s_ be ? ToNumber(_sec_).
          1. If _ms_ is not present, let _milli_ be msFromTime(_t_); otherwise, let _milli_ be ? ToNumber(_ms_).
          1. Let _date_ be MakeDate(Day(_t_), MakeTime(_h_, _m_, _s_, _milli_)).
          1. Let _u_ be TimeClip(UTC(_date_)).
          1. Set the [[DateValue]] internal slot of this Date object to _u_.
          1. Return _u_.
        </emu-alg>
        <p>The `"length"` property of the `setHours` method is 4.</p>
        <emu-note>
          <p>If _min_ is not present, this method behaves as if _min_ was present with the value `getMinutes()`. If _sec_ is not present, it behaves as if _sec_ was present with the value `getSeconds()`. If _ms_ is not present, it behaves as if _ms_ was present with the value `getMilliseconds()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setmilliseconds">
        <h1>Date.prototype.setMilliseconds ( _ms_ )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be LocalTime(? thisTimeValue(*this* value)).
          1. Set _ms_ to ? ToNumber(_ms_).
          1. Let _time_ be MakeTime(HourFromTime(_t_), MinFromTime(_t_), SecFromTime(_t_), _ms_).
          1. Let _u_ be TimeClip(UTC(MakeDate(Day(_t_), _time_))).
          1. Set the [[DateValue]] internal slot of this Date object to _u_.
          1. Return _u_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setminutes">
        <h1>Date.prototype.setMinutes ( _min_ [ , _sec_ [ , _ms_ ] ] )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be LocalTime(? thisTimeValue(*this* value)).
          1. Let _m_ be ? ToNumber(_min_).
          1. If _sec_ is not present, let _s_ be SecFromTime(_t_); otherwise, let _s_ be ? ToNumber(_sec_).
          1. If _ms_ is not present, let _milli_ be msFromTime(_t_); otherwise, let _milli_ be ? ToNumber(_ms_).
          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), _m_, _s_, _milli_)).
          1. Let _u_ be TimeClip(UTC(_date_)).
          1. Set the [[DateValue]] internal slot of this Date object to _u_.
          1. Return _u_.
        </emu-alg>
        <p>The `"length"` property of the `setMinutes` method is 3.</p>
        <emu-note>
          <p>If _sec_ is not present, this method behaves as if _sec_ was present with the value `getSeconds()`. If _ms_ is not present, this behaves as if _ms_ was present with the value `getMilliseconds()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setmonth">
        <h1>Date.prototype.setMonth ( _month_ [ , _date_ ] )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be LocalTime(? thisTimeValue(*this* value)).
          1. Let _m_ be ? ToNumber(_month_).
          1. If _date_ is not present, let _dt_ be DateFromTime(_t_); otherwise, let _dt_ be ? ToNumber(_date_).
          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), _m_, _dt_), TimeWithinDay(_t_)).
          1. Let _u_ be TimeClip(UTC(_newDate_)).
          1. Set the [[DateValue]] internal slot of this Date object to _u_.
          1. Return _u_.
        </emu-alg>
        <p>The `"length"` property of the `setMonth` method is 2.</p>
        <emu-note>
          <p>If _date_ is not present, this method behaves as if _date_ was present with the value `getDate()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setseconds">
        <h1>Date.prototype.setSeconds ( _sec_ [ , _ms_ ] )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be LocalTime(? thisTimeValue(*this* value)).
          1. Let _s_ be ? ToNumber(_sec_).
          1. If _ms_ is not present, let _milli_ be msFromTime(_t_); otherwise, let _milli_ be ? ToNumber(_ms_).
          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), MinFromTime(_t_), _s_, _milli_)).
          1. Let _u_ be TimeClip(UTC(_date_)).
          1. Set the [[DateValue]] internal slot of this Date object to _u_.
          1. Return _u_.
        </emu-alg>
        <p>The `"length"` property of the `setSeconds` method is 2.</p>
        <emu-note>
          <p>If _ms_ is not present, this method behaves as if _ms_ was present with the value `getMilliseconds()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.settime">
        <h1>Date.prototype.setTime ( _time_ )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Perform ? thisTimeValue(*this* value).
          1. Let _t_ be ? ToNumber(_time_).
          1. Let _v_ be TimeClip(_t_).
          1. Set the [[DateValue]] internal slot of this Date object to _v_.
          1. Return _v_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcdate">
        <h1>Date.prototype.setUTCDate ( _date_ )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. Let _dt_ be ? ToNumber(_date_).
          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), MonthFromTime(_t_), _dt_), TimeWithinDay(_t_)).
          1. Let _v_ be TimeClip(_newDate_).
          1. Set the [[DateValue]] internal slot of this Date object to _v_.
          1. Return _v_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcfullyear">
        <h1>Date.prototype.setUTCFullYear ( _year_ [ , _month_ [ , _date_ ] ] )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. If _t_ is *NaN*, set _t_ to *+0*.
          1. Let _y_ be ? ToNumber(_year_).
          1. If _month_ is not present, let _m_ be MonthFromTime(_t_); otherwise, let _m_ be ? ToNumber(_month_).
          1. If _date_ is not present, let _dt_ be DateFromTime(_t_); otherwise, let _dt_ be ? ToNumber(_date_).
          1. Let _newDate_ be MakeDate(MakeDay(_y_, _m_, _dt_), TimeWithinDay(_t_)).
          1. Let _v_ be TimeClip(_newDate_).
          1. Set the [[DateValue]] internal slot of this Date object to _v_.
          1. Return _v_.
        </emu-alg>
        <p>The `"length"` property of the `setUTCFullYear` method is 3.</p>
        <emu-note>
          <p>If _month_ is not present, this method behaves as if _month_ was present with the value `getUTCMonth()`. If _date_ is not present, it behaves as if _date_ was present with the value `getUTCDate()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutchours">
        <h1>Date.prototype.setUTCHours ( _hour_ [ , _min_ [ , _sec_ [ , _ms_ ] ] ] )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. Let _h_ be ? ToNumber(_hour_).
          1. If _min_ is not present, let _m_ be MinFromTime(_t_); otherwise, let _m_ be ? ToNumber(_min_).
          1. If _sec_ is not present, let _s_ be SecFromTime(_t_); otherwise, let _s_ be ? ToNumber(_sec_).
          1. If _ms_ is not present, let _milli_ be msFromTime(_t_); otherwise, let _milli_ be ? ToNumber(_ms_).
          1. Let _newDate_ be MakeDate(Day(_t_), MakeTime(_h_, _m_, _s_, _milli_)).
          1. Let _v_ be TimeClip(_newDate_).
          1. Set the [[DateValue]] internal slot of this Date object to _v_.
          1. Return _v_.
        </emu-alg>
        <p>The `"length"` property of the `setUTCHours` method is 4.</p>
        <emu-note>
          <p>If _min_ is not present, this method behaves as if _min_ was present with the value `getUTCMinutes()`. If _sec_ is not present, it behaves as if _sec_ was present with the value `getUTCSeconds()`. If _ms_ is not present, it behaves as if _ms_ was present with the value `getUTCMilliseconds()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcmilliseconds">
        <h1>Date.prototype.setUTCMilliseconds ( _ms_ )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. Let _milli_ be ? ToNumber(_ms_).
          1. Let _time_ be MakeTime(HourFromTime(_t_), MinFromTime(_t_), SecFromTime(_t_), _milli_).
          1. Let _v_ be TimeClip(MakeDate(Day(_t_), _time_)).
          1. Set the [[DateValue]] internal slot of this Date object to _v_.
          1. Return _v_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcminutes">
        <h1>Date.prototype.setUTCMinutes ( _min_ [ , _sec_ [ , _ms_ ] ] )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. Let _m_ be ? ToNumber(_min_).
          1. If _sec_ is not present, let _s_ be SecFromTime(_t_).
          1. Else,
            1. Let _s_ be ? ToNumber(_sec_).
          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).
          1. Else,
            1. Let _milli_ be ? ToNumber(_ms_).
          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), _m_, _s_, _milli_)).
          1. Let _v_ be TimeClip(_date_).
          1. Set the [[DateValue]] internal slot of this Date object to _v_.
          1. Return _v_.
        </emu-alg>
        <p>The `"length"` property of the `setUTCMinutes` method is 3.</p>
        <emu-note>
          <p>If _sec_ is not present, this method behaves as if _sec_ was present with the value `getUTCSeconds()`. If _ms_ is not present, it function behaves as if _ms_ was present with the value return by `getUTCMilliseconds()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcmonth">
        <h1>Date.prototype.setUTCMonth ( _month_ [ , _date_ ] )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. Let _m_ be ? ToNumber(_month_).
          1. If _date_ is not present, let _dt_ be DateFromTime(_t_).
          1. Else,
            1. Let _dt_ be ? ToNumber(_date_).
          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), _m_, _dt_), TimeWithinDay(_t_)).
          1. Let _v_ be TimeClip(_newDate_).
          1. Set the [[DateValue]] internal slot of this Date object to _v_.
          1. Return _v_.
        </emu-alg>
        <p>The `"length"` property of the `setUTCMonth` method is 2.</p>
        <emu-note>
          <p>If _date_ is not present, this method behaves as if _date_ was present with the value `getUTCDate()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcseconds">
        <h1>Date.prototype.setUTCSeconds ( _sec_ [ , _ms_ ] )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. Let _s_ be ? ToNumber(_sec_).
          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).
          1. Else,
            1. Let _milli_ be ? ToNumber(_ms_).
          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), MinFromTime(_t_), _s_, _milli_)).
          1. Let _v_ be TimeClip(_date_).
          1. Set the [[DateValue]] internal slot of this Date object to _v_.
          1. Return _v_.
        </emu-alg>
        <p>The `"length"` property of the `setUTCSeconds` method is 2.</p>
        <emu-note>
          <p>If _ms_ is not present, this method behaves as if _ms_ was present with the value `getUTCMilliseconds()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.todatestring">
        <h1>Date.prototype.toDateString ( )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _O_ be this Date object.
          1. Let _tv_ be ? thisTimeValue(_O_).
          1. If _tv_ is *NaN*, return `"Invalid Date"`.
          1. Let _t_ be LocalTime(_tv_).
          1. Return DateString(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.toisostring">
        <h1>Date.prototype.toISOString ( )</h1>
        <p>If this time value is not a finite Number or if it corresponds with a year that cannot be represented in the <emu-xref href="#sec-date-time-string-format">Date Time String Format</emu-xref>, this function throws a *RangeError* exception. Otherwise, it returns a String representation of this time value in that format on the UTC time scale, including all format elements and the UTC offset representation `"Z"`. </p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tojson">
        <h1>Date.prototype.toJSON ( _key_ )</h1>
        <p>This function provides a String representation of a Date object for use by `JSON.stringify` (<emu-xref href="#sec-json.stringify"></emu-xref>).</p>
        <p>When the `toJSON` method is called with argument _key_, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _tv_ be ? ToPrimitive(_O_, hint Number).
          1. If Type(_tv_) is Number and _tv_ is not finite, return *null*.
          1. Return ? Invoke(_O_, `"toISOString"`).
        </emu-alg>
        <emu-note>
          <p>The argument is ignored.</p>
        </emu-note>
        <emu-note>
          <p>The `toJSON` function is intentionally generic; it does not require that its *this* value be a Date object. Therefore, it can be transferred to other kinds of objects for use as a method. However, it does require that any such object have a `toISOString` method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tolocaledatestring">
        <h1>Date.prototype.toLocaleDateString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Date.prototype.toLocaleDateString` method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `toLocaleDateString` method is used.</p>
        <p>This function returns a String value. The contents of the String are implementation-dependent, but are intended to represent the &ldquo;date&rdquo; portion of the Date in the current time zone in a convenient, human-readable form that corresponds to the conventions of the host environment's current locale.</p>
        <p>The meaning of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tolocalestring">
        <h1>Date.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Date.prototype.toLocaleString` method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `toLocaleString` method is used.</p>
        <p>This function returns a String value. The contents of the String are implementation-dependent, but are intended to represent the Date in the current time zone in a convenient, human-readable form that corresponds to the conventions of the host environment's current locale.</p>
        <p>The meaning of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tolocaletimestring">
        <h1>Date.prototype.toLocaleTimeString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Date.prototype.toLocaleTimeString` method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `toLocaleTimeString` method is used.</p>
        <p>This function returns a String value. The contents of the String are implementation-dependent, but are intended to represent the &ldquo;time&rdquo; portion of the Date in the current time zone in a convenient, human-readable form that corresponds to the conventions of the host environment's current locale.</p>
        <p>The meaning of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tostring">
        <h1>Date.prototype.toString ( )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _tv_ be ? thisTimeValue(*this* value).
          1. Return ToDateString(_tv_).
        </emu-alg>
        <emu-note>
          <p>For any Date object `d` whose milliseconds amount is zero, the result of `Date.parse(d.toString())` is equal to `d.valueOf()`. See <emu-xref href="#sec-date.parse"></emu-xref>.</p>
        </emu-note>
        <emu-note>
          <p>The `toString` function is not generic; it throws a *TypeError* exception if its *this* value is not a Date object. Therefore, it cannot be transferred to other kinds of objects for use as a method.</p>
        </emu-note>

        <emu-clause id="sec-timestring" aoid="TimeString">
          <h1>Runtime Semantics: TimeString ( _tv_ )</h1>
          <p>The following steps are performed:</p>
          <emu-alg>
            1. Assert: Type(_tv_) is Number.
            1. Assert: _tv_ is not *NaN*.
            1. Let _hour_ be the String representation of HourFromTime(_tv_), formatted as a two-digit decimal number, padded to the left with a zero if necessary.
            1. Let _minute_ be the String representation of MinFromTime(_tv_), formatted as a two-digit decimal number, padded to the left with a zero if necessary.
            1. Let _second_ be the String representation of SecFromTime(_tv_), formatted as a two-digit decimal number, padded to the left with a zero if necessary.
            1. Return the string-concatenation of _hour_, `":"`, _minute_, `":"`, _second_, the code unit 0x0020 (SPACE), and `"GMT"`.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-datestring" aoid="DateString">
          <h1>Runtime Semantics: DateString ( _tv_ )</h1>
          <p>The following steps are performed:</p>
          <emu-alg>
            1. Assert: Type(_tv_) is Number.
            1. Assert: _tv_ is not *NaN*.
            1. Let _weekday_ be the Name of the entry in <emu-xref href="#sec-todatestring-day-names"></emu-xref> with the Number WeekDay(_tv_).
            1. Let _month_ be the Name of the entry in <emu-xref href="#sec-todatestring-month-names"></emu-xref> with the Number MonthFromTime(_tv_).
            1. Let _day_ be the String representation of DateFromTime(_tv_), formatted as a two-digit decimal number, padded to the left with a zero if necessary.
            1. Let _yv_ be YearFromTime(_tv_).
            1. If _yv_ &ge; 0, let _yearSign_ be the empty string; otherwise, let _yearSign_ be `"-"`.
            1. Let _year_ be the String representation of abs(_yv_), formatted as a decimal number.
            1. Let _paddedYear_ be ! StringPad(_year_, 4, *"0"*, *"start"*).
            1. Return the string-concatenation of _weekday_, the code unit 0x0020 (SPACE), _month_, the code unit 0x0020 (SPACE), _day_, the code unit 0x0020 (SPACE), _yearSign_, and _paddedYear_.
          </emu-alg>
          <emu-table id="sec-todatestring-day-names" caption="Names of days of the week">
            <table>
              <tbody>
              <tr>
                <th>
                  Number
                </th>
                <th>
                  Name
                </th>
              </tr>
              <tr>
                <td>
                  0
                </td>
                <td>
                  `"Sun"`
                </td>
              </tr>
              <tr>
                <td>
                  1
                </td>
                <td>
                  `"Mon"`
                </td>
              </tr>
              <tr>
                <td>
                  2
                </td>
                <td>
                  `"Tue"`
                </td>
              </tr>
              <tr>
                <td>
                  3
                </td>
                <td>
                  `"Wed"`
                </td>
              </tr>
              <tr>
                <td>
                  4
                </td>
                <td>
                  `"Thu"`
                </td>
              </tr>
              <tr>
                <td>
                  5
                </td>
                <td>
                  `"Fri"`
                </td>
              </tr>
              <tr>
                <td>
                  6
                </td>
                <td>
                  `"Sat"`
                </td>
              </tr>
              </tbody>
            </table>
          </emu-table>
          <emu-table id="sec-todatestring-month-names" caption="Names of months of the year">
            <table>
              <tbody>
              <tr>
                <th>
                  Number
                </th>
                <th>
                  Name
                </th>
              </tr>
              <tr>
                <td>
                  0
                </td>
                <td>
                  `"Jan"`
                </td>
              </tr>
              <tr>
                <td>
                  1
                </td>
                <td>
                  `"Feb"`
                </td>
              </tr>
              <tr>
                <td>
                  2
                </td>
                <td>
                  `"Mar"`
                </td>
              </tr>
              <tr>
                <td>
                  3
                </td>
                <td>
                  `"Apr"`
                </td>
              </tr>
              <tr>
                <td>
                  4
                </td>
                <td>
                  `"May"`
                </td>
              </tr>
              <tr>
                <td>
                  5
                </td>
                <td>
                  `"Jun"`
                </td>
              </tr>
              <tr>
                <td>
                  6
                </td>
                <td>
                  `"Jul"`
                </td>
              </tr>
              <tr>
                <td>
                  7
                </td>
                <td>
                  `"Aug"`
                </td>
              </tr>
              <tr>
                <td>
                  8
                </td>
                <td>
                  `"Sep"`
                </td>
              </tr>
              <tr>
                <td>
                  9
                </td>
                <td>
                  `"Oct"`
                </td>
              </tr>
              <tr>
                <td>
                  10
                </td>
                <td>
                  `"Nov"`
                </td>
              </tr>
              <tr>
                <td>
                  11
                </td>
                <td>
                  `"Dec"`
                </td>
              </tr>
              </tbody>
            </table>
          </emu-table>
        </emu-clause>

        <emu-clause id="sec-timezoneestring" aoid="TimeZoneString">
          <h1>Runtime Semantics: TimeZoneString ( _tv_ )</h1>
          <p>The following steps are performed:</p>
          <emu-alg>
            1. Assert: Type(_tv_) is Number.
            1. Assert: _tv_ is not *NaN*.
            1. Let _offset_ be LocalTZA(_tv_, *true*).
            1. If _offset_ &ge; 0, let _offsetSign_ be `"+"`; otherwise, let _offsetSign_ be `"-"`.
            1. Let _offsetMin_ be the String representation of MinFromTime(abs(_offset_)), formatted as a two-digit decimal number, padded to the left with a zero if necessary.
            1. Let _offsetHour_ be the String representation of HourFromTime(abs(_offset_)), formatted as a two-digit decimal number, padded to the left with a zero if necessary.
            1. Let _tzName_ be an implementation-defined string that is either the empty string or the string-concatenation of the code unit 0x0020 (SPACE), the code unit 0x0028 (LEFT PARENTHESIS), an implementation-dependent timezone name, and the code unit 0x0029 (RIGHT PARENTHESIS).
            1. Return the string-concatenation of _offsetSign_, _offsetHour_, _offsetMin_, and _tzName_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-todatestring" aoid="ToDateString">
          <h1>Runtime Semantics: ToDateString ( _tv_ )</h1>
          <p>The following steps are performed:</p>
          <emu-alg>
            1. Assert: Type(_tv_) is Number.
            1. If _tv_ is *NaN*, return `"Invalid Date"`.
            1. Let _t_ be LocalTime(_tv_).
            1. Return the string-concatenation of DateString(_t_), the code unit 0x0020 (SPACE), TimeString(_t_), and TimeZoneString(_tv_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-date.prototype.totimestring">
        <h1>Date.prototype.toTimeString ( )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _O_ be this Date object.
          1. Let _tv_ be ? thisTimeValue(_O_).
          1. If _tv_ is *NaN*, return `"Invalid Date"`.
          1. Let _t_ be LocalTime(_tv_).
          1. Return the string-concatenation of TimeString(_t_) and TimeZoneString(_tv_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.toutcstring">
        <h1>Date.prototype.toUTCString ( )</h1>
        <p>The `toUTCString` method returns a String value representing the instance in time corresponding to this time value. The format of the String is based upon "HTTP-date" from RFC 7231, generalized to support the full range of times supported by ECMAScript Date objects. It performs the following steps:</p>
        <emu-alg>
          1. Let _O_ be this Date object.
          1. Let _tv_ be ? thisTimeValue(_O_).
          1. If _tv_ is *NaN*, return `"Invalid Date"`.
          1. Let _weekday_ be the Name of the entry in <emu-xref href="#sec-todatestring-day-names"></emu-xref> with the Number WeekDay(_tv_).
          1. Let _month_ be the Name of the entry in <emu-xref href="#sec-todatestring-month-names"></emu-xref> with the Number MonthFromTime(_tv_).
          1. Let _day_ be the String representation of DateFromTime(_tv_), formatted as a two-digit decimal number, padded to the left with a zero if necessary.
          1. Let _yv_ be YearFromTime(_tv_).
          1. If _yv_ &ge; 0, let _yearSign_ be the empty string; otherwise, let _yearSign_ be `"-"`.
          1. Let _year_ be the String representation of abs(_yv_), formatted as a decimal number.
          1. Let _paddedYear_ be ! StringPad(_year_, 4, *"0"*, *"start"*).
          1. Return the string-concatenation of _weekday_, `","`, the code unit 0x0020 (SPACE), _day_, the code unit 0x0020 (SPACE), _month_, the code unit 0x0020 (SPACE), _yearSign_, _paddedYear_, the code unit 0x0020 (SPACE), and TimeString(_tv_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.valueof">
        <h1>Date.prototype.valueOf ( )</h1>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Return ? thisTimeValue(*this* value).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype-@@toprimitive">
        <h1>Date.prototype [ @@toPrimitive ] ( _hint_ )</h1>
        <p>This function is called by ECMAScript language operators to convert a Date object to a primitive value. The allowed values for _hint_ are `"default"`, `"number"`, and `"string"`. Date objects, are unique among built-in ECMAScript object in that they treat `"default"` as being equivalent to `"string"`, All other built-in ECMAScript objects treat `"default"` as being equivalent to `"number"`.</p>
        <p>When the `@@toPrimitive` method is called with argument _hint_, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If Type(_O_) is not Object, throw a *TypeError* exception.
          1. If _hint_ is the String value `"string"` or the String value `"default"`, then
            1. Let _tryFirst_ be `"string"`.
          1. Else if _hint_ is the String value `"number"`, then
            1. Let _tryFirst_ be `"number"`.
          1. Else, throw a *TypeError* exception.
          1. Return ? OrdinaryToPrimitive(_O_, _tryFirst_).
        </emu-alg>
        <p>The value of the `name` property of this function is `"[Symbol.toPrimitive]"`.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-date-instances">
      <h1>Properties of Date Instances</h1>
      <p>Date instances are ordinary objects that inherit properties from the Date prototype object. Date instances also have a [[DateValue]] internal slot. The [[DateValue]] internal slot is the time value represented by this Date object.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-text-processing">
  <h1>Text Processing</h1>

  <emu-clause id="sec-string-objects">
    <h1>String Objects</h1>

    <emu-clause id="sec-string-constructor">
      <h1>The String Constructor</h1>
      <p>The String constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%String%</dfn>.</li>
        <li>is the initial value of the `String` property of the global object.</li>
        <li>creates and initializes a new String object when called as a constructor.</li>
        <li>performs a type conversion when called as a function rather than as a constructor.</li>
        <li>is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `String` behaviour must include a `super` call to the `String` constructor to create and initialize the subclass instance with a [[StringData]] internal slot.</li>
      </ul>

      <emu-clause id="sec-string-constructor-string-value">
        <h1>String ( _value_ )</h1>
        <p>When `String` is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If no arguments were passed to this function invocation, let _s_ be `""`.
          1. Else,
            1. If NewTarget is *undefined* and Type(_value_) is Symbol, return SymbolDescriptiveString(_value_).
            1. Let _s_ be ? ToString(_value_).
          1. If NewTarget is *undefined*, return _s_.
          1. Return ! StringCreate(_s_, ? GetPrototypeFromConstructor(NewTarget, `"%StringPrototype%"`)).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-string-constructor">
      <h1>Properties of the String Constructor</h1>
      <p>The String constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-string.fromcharcode">
        <h1>String.fromCharCode ( ..._codeUnits_ )</h1>
        <p>The `String.fromCharCode` function may be called with any number of arguments which form the rest parameter _codeUnits_. The following steps are taken:</p>
        <emu-alg>
          1. Let _codeUnits_ be a List containing the arguments passed to this function.
          1. Let _length_ be the number of elements in _codeUnits_.
          1. Let _elements_ be a new empty List.
          1. Let _nextIndex_ be 0.
          1. Repeat, while _nextIndex_ &lt; _length_
            1. Let _next_ be _codeUnits_[_nextIndex_].
            1. Let _nextCU_ be ? ToUint16(_next_).
            1. Append _nextCU_ to the end of _elements_.
            1. Increase _nextIndex_ by 1.
          1. Return the String value whose code units are, in order, the elements in the List _elements_. If _length_ is 0, the empty string is returned.
        </emu-alg>
        <p>The `"length"` property of the `fromCharCode` function is 1.</p>
      </emu-clause>

      <emu-clause id="sec-string.fromcodepoint">
        <h1>String.fromCodePoint ( ..._codePoints_ )</h1>
        <p>The `String.fromCodePoint` function may be called with any number of arguments which form the rest parameter _codePoints_. The following steps are taken:</p>
        <emu-alg>
          1. Let _codePoints_ be a List containing the arguments passed to this function.
          1. Let _length_ be the number of elements in _codePoints_.
          1. Let _elements_ be a new empty List.
          1. Let _nextIndex_ be 0.
          1. Repeat, while _nextIndex_ &lt; _length_
            1. Let _next_ be _codePoints_[_nextIndex_].
            1. Let _nextCP_ be ? ToNumber(_next_).
            1. If SameValue(_nextCP_, ! ToInteger(_nextCP_)) is *false*, throw a *RangeError* exception.
            1. If _nextCP_ &lt; 0 or _nextCP_ &gt; 0x10FFFF, throw a *RangeError* exception.
            1. Append the elements of the UTF16Encoding of _nextCP_ to the end of _elements_.
            1. Increase _nextIndex_ by 1.
          1. Return the String value whose code units are, in order, the elements in the List _elements_. If _length_ is 0, the empty string is returned.
        </emu-alg>
        <p>The `"length"` property of the `fromCodePoint` function is 1.</p>
      </emu-clause>

      <emu-clause id="sec-string.prototype">
        <h1>String.prototype</h1>
        <p>The initial value of `String.prototype` is the intrinsic object %StringPrototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-string.raw">
        <h1>String.raw ( _template_, ..._substitutions_ )</h1>
        <p>The `String.raw` function may be called with a variable number of arguments. The first argument is _template_ and the remainder of the arguments form the List _substitutions_. The following steps are taken:</p>
        <emu-alg>
          1. Let _substitutions_ be a List consisting of all of the arguments passed to this function, starting with the second argument. If fewer than two arguments were passed, the List is empty.
          1. Let _numberOfSubstitutions_ be the number of elements in _substitutions_.
          1. Let _cooked_ be ? ToObject(_template_).
          1. Let _raw_ be ? ToObject(? Get(_cooked_, `"raw"`)).
          1. Let _literalSegments_ be ? ToLength(? Get(_raw_, `"length"`)).
          1. If _literalSegments_ &le; 0, return the empty string.
          1. Let _stringElements_ be a new empty List.
          1. Let _nextIndex_ be 0.
          1. Repeat,
            1. Let _nextKey_ be ! ToString(_nextIndex_).
            1. Let _nextSeg_ be ? ToString(? Get(_raw_, _nextKey_)).
            1. Append in order the code unit elements of _nextSeg_ to the end of _stringElements_.
            1. If _nextIndex_ + 1 = _literalSegments_, then
              1. Return the String value whose code units are, in order, the elements in the List _stringElements_. If _stringElements_ has no elements, the empty string is returned.
            1. If _nextIndex_ &lt; _numberOfSubstitutions_, let _next_ be _substitutions_[_nextIndex_].
            1. Else, let _next_ be the empty String.
            1. Let _nextSub_ be ? ToString(_next_).
            1. Append in order the code unit elements of _nextSub_ to the end of _stringElements_.
            1. Increase _nextIndex_ by 1.
        </emu-alg>
        <emu-note>
          <p>String.raw is intended for use as a tag function of a Tagged Template (<emu-xref href="#sec-tagged-templates"></emu-xref>). When called as such, the first argument will be a well formed template object and the rest parameter will contain the substitution values.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-string-prototype-object">
      <h1>Properties of the String Prototype Object</h1>
      <p>The String prototype object:</p>
      <ul>
        <li>is the intrinsic object <dfn>%StringPrototype%</dfn>.</li>
        <li>is a String exotic object and has the internal methods specified for such objects.</li>
        <li>has a [[StringData]] internal slot whose value is the empty String.</li>
        <li>has a `"length"` property whose initial value is 0 and whose attributes are { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
      </ul>
      <p>Unless explicitly stated otherwise, the methods of the String prototype object defined below are not generic and the *this* value passed to them must be either a String value or an object that has a [[StringData]] internal slot that has been initialized to a String value.</p>
      <p>The abstract operation <dfn id="sec-thisstringvalue" aoid="thisStringValue">thisStringValue</dfn>(_value_) performs the following steps:</p>
      <emu-alg>
        1. If Type(_value_) is String, return _value_.
        1. If Type(_value_) is Object and _value_ has a [[StringData]] internal slot, then
          1. Let _s_ be _value_.[[StringData]].
          1. Assert: Type(_s_) is String.
          1. Return _s_.
        1. Throw a *TypeError* exception.
      </emu-alg>

      <emu-clause id="sec-string.prototype.charat">
        <h1>String.prototype.charAt ( _pos_ )</h1>
        <emu-note>
          <p>Returns a single element String containing the code unit at index _pos_ within the String value resulting from converting this object to a String. If there is no element at that index, the result is the empty String. The result is a String value, not a String object.</p>
          <p>If `pos` is a value of Number type that is an integer, then the result of `x.charAt(pos)` is equal to the result of `x.substring(pos, pos + 1)`.</p>
        </emu-note>
        <p>When the `charAt` method is called with one argument _pos_, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. Let _S_ be ? ToString(_O_).
          1. Let _position_ be ? ToInteger(_pos_).
          1. Let _size_ be the length of _S_.
          1. If _position_ &lt; 0 or _position_ &ge; _size_, return the empty String.
          1. Return the String value of length 1, containing one code unit from _S_, namely the code unit at index _position_.
        </emu-alg>
        <emu-note>
          <p>The `charAt` function is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.charcodeat">
        <h1>String.prototype.charCodeAt ( _pos_ )</h1>
        <emu-note>
          <p>Returns a Number (a nonnegative integer less than 2<sup>16</sup>) that is the numeric value of the code unit at index _pos_ within the String resulting from converting this object to a String. If there is no element at that index, the result is *NaN*.</p>
        </emu-note>
        <p>When the `charCodeAt` method is called with one argument _pos_, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. Let _S_ be ? ToString(_O_).
          1. Let _position_ be ? ToInteger(_pos_).
          1. Let _size_ be the length of _S_.
          1. If _position_ &lt; 0 or _position_ &ge; _size_, return *NaN*.
          1. Return a value of Number type, whose value is the numeric value of the code unit at index _position_ within the String _S_.
        </emu-alg>
        <emu-note>
          <p>The `charCodeAt` function is intentionally generic; it does not require that its *this* value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.codepointat">
        <h1>String.prototype.codePointAt ( _pos_ )</h1>
        <emu-note>
          <p>Returns a nonnegative integer Number less than 0x110000 that is the code point value of the UTF-16 encoded code point (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>) starting at the string element at index _pos_ within the String resulting from converting this object to a String. If there is no element at that index, the result is *undefined*. If a valid UTF-16 <emu-xref href="#surrogate-pair"></emu-xref> does not begin at _pos_, the result is the code unit at _pos_.</p>
        </emu-note>
        <p>When the `codePointAt` method is called with one argument _pos_, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. Let _S_ be ? ToString(_O_).
          1. Let _position_ be ? ToInteger(_pos_).
          1. Let _size_ be the length of _S_.
          1. If _position_ &lt; 0 or _position_ &ge; _size_, return *undefined*.
          1. Let _first_ be the numeric value of the code unit at index _position_ within the String _S_.
          1. If _first_ &lt; 0xD800 or _first_ &gt; 0xDBFF or _position_ + 1 = _size_, return _first_.
          1. Let _second_ be the numeric value of the code unit at index _position_ + 1 within the String _S_.
          1. If _second_ &lt; 0xDC00 or _second_ &gt; 0xDFFF, return _first_.
          1. Return UTF16Decode(_first_, _second_).
        </emu-alg>
        <emu-note>
          <p>The `codePointAt` function is intentionally generic; it does not require that its *this* value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.concat">
        <h1>String.prototype.concat ( ..._args_ )</h1>
        <emu-note>
          <p>When the `concat` method is called it returns the String value consisting of the code units of the `this` object (converted to a String) followed by the code units of each of the arguments converted to a String. The result is a String value, not a String object.</p>
        </emu-note>
        <p>When the `concat` method is called with zero or more arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. Let _S_ be ? ToString(_O_).
          1. Let _args_ be a List whose elements are the arguments passed to this function.
          1. Let _R_ be _S_.
          1. Repeat, while _args_ is not empty
            1. Remove the first element from _args_ and let _next_ be the value of that element.
            1. Let _nextString_ be ? ToString(_next_).
            1. Set _R_ to the string-concatenation of the previous value of _R_ and _nextString_.
          1. Return _R_.
        </emu-alg>
        <p>The `"length"` property of the `concat` method is 1.</p>
        <emu-note>
          <p>The `concat` function is intentionally generic; it does not require that its *this* value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.constructor">
        <h1>String.prototype.constructor</h1>
        <p>The initial value of `String.prototype.constructor` is the intrinsic object %String%.</p>
      </emu-clause>

      <emu-clause id="sec-string.prototype.endswith">
        <h1>String.prototype.endsWith ( _searchString_ [ , _endPosition_ ] )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. Let _S_ be ? ToString(_O_).
          1. Let _isRegExp_ be ? IsRegExp(_searchString_).
          1. If _isRegExp_ is *true*, throw a *TypeError* exception.
          1. Let _searchStr_ be ? ToString(_searchString_).
          1. Let _len_ be the length of _S_.
          1. If _endPosition_ is *undefined*, let _pos_ be _len_, else let _pos_ be ? ToInteger(_endPosition_).
          1. Let _end_ be min(max(_pos_, 0), _len_).
          1. Let _searchLength_ be the length of _searchStr_.
          1. Let _start_ be _end_ - _searchLength_.
          1. If _start_ is less than 0, return *false*.
          1. If the sequence of code units of _S_ starting at _start_ of length _searchLength_ is the same as the full code unit sequence of _searchStr_, return *true*.
          1. Otherwise, return *false*.
        </emu-alg>
        <emu-note>
          <p>Returns *true* if the sequence of code units of _searchString_ converted to a String is the same as the corresponding code units of this object (converted to a String) starting at _endPosition_ - length(this). Otherwise returns *false*.</p>
        </emu-note>
        <emu-note>
          <p>Throwing an exception if the first argument is a RegExp is specified in order to allow future editions to define extensions that allow such argument values.</p>
        </emu-note>
        <emu-note>
          <p>The `endsWith` function is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.includes">
        <h1>String.prototype.includes ( _searchString_ [ , _position_ ] )</h1>
        <p>The `includes` method takes two arguments, _searchString_ and _position_, and performs the following steps:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. Let _S_ be ? ToString(_O_).
          1. Let _isRegExp_ be ? IsRegExp(_searchString_).
          1. If _isRegExp_ is *true*, throw a *TypeError* exception.
          1. Let _searchStr_ be ? ToString(_searchString_).
          1. Let _pos_ be ? ToInteger(_position_).
          1. Assert: If _position_ is *undefined*, then _pos_ is 0.
          1. Let _len_ be the length of _S_.
          1. Let _start_ be min(max(_pos_, 0), _len_).
          1. Let _searchLen_ be the length of _searchStr_.
          1. If there exists any integer _k_ not smaller than _start_ such that _k_ + _searchLen_ is not greater than _len_, and for all nonnegative integers _j_ less than _searchLen_, the code unit at index _k_ + _j_ within _S_ is the same as the code unit at index _j_ within _searchStr_, return *true*; but if there is no such integer _k_, return *false*.
        </emu-alg>
        <emu-note>
          <p>If _searchString_ appears as a substring of the result of converting this object to a String, at one or more indices that are greater than or equal to _position_, return *true*; otherwise, returns *false*. If _position_ is *undefined*, 0 is assumed, so as to search all of the String.</p>
        </emu-note>
        <emu-note>
          <p>Throwing an exception if the first argument is a RegExp is specified in order to allow future editions to define extensions that allow such argument values.</p>
        </emu-note>
        <emu-note>
          <p>The `includes` function is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.indexof">
        <h1>String.prototype.indexOf ( _searchString_ [ , _position_ ] )</h1>
        <emu-note>
          <p>If _searchString_ appears as a substring of the result of converting this object to a String, at one or more indices that are greater than or equal to _position_, then the smallest such index is returned; otherwise, -1 is returned. If _position_ is *undefined*, 0 is assumed, so as to search all of the String.</p>
        </emu-note>
        <p>The `indexOf` method takes two arguments, _searchString_ and _position_, and performs the following steps:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. Let _S_ be ? ToString(_O_).
          1. Let _searchStr_ be ? ToString(_searchString_).
          1. Let _pos_ be ? ToInteger(_position_).
          1. Assert: If _position_ is *undefined*, then _pos_ is 0.
          1. Let _len_ be the length of _S_.
          1. Let _start_ be min(max(_pos_, 0), _len_).
          1. Let _searchLen_ be the length of _searchStr_.
          1. Return the smallest possible integer _k_ not smaller than _start_ such that _k_ + _searchLen_ is not greater than _len_, and for all nonnegative integers _j_ less than _searchLen_, the code unit at index _k_ + _j_ within _S_ is the same as the code unit at index _j_ within _searchStr_; but if there is no such integer _k_, return the value -1.
        </emu-alg>
        <emu-note>
          <p>The `indexOf` function is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.lastindexof">
        <h1>String.prototype.lastIndexOf ( _searchString_ [ , _position_ ] )</h1>
        <emu-note>
          <p>If _searchString_ appears as a substring of the result of converting this object to a String at one or more indices that are smaller than or equal to _position_, then the greatest such index is returned; otherwise, -1 is returned. If _position_ is *undefined*, the length of the String value is assumed, so as to search all of the String.</p>
        </emu-note>
        <p>The `lastIndexOf` method takes two arguments, _searchString_ and _position_, and performs the following steps:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. Let _S_ be ? ToString(_O_).
          1. Let _searchStr_ be ? ToString(_searchString_).
          1. Let _numPos_ be ? ToNumber(_position_).
          1. Assert: If _position_ is *undefined*, then _numPos_ is *NaN*.
          1. If _numPos_ is *NaN*, let _pos_ be *+&infin;*; otherwise, let _pos_ be ! ToInteger(_numPos_).
          1. Let _len_ be the length of _S_.
          1. Let _start_ be min(max(_pos_, 0), _len_).
          1. Let _searchLen_ be the length of _searchStr_.
          1. Return the largest possible nonnegative integer _k_ not larger than _start_ such that _k_ + _searchLen_ is not greater than _len_, and for all nonnegative integers _j_ less than _searchLen_, the code unit at index _k_ + _j_ within _S_ is the same as the code unit at index _j_ within _searchStr_; but if there is no such integer _k_, return the value -1.
        </emu-alg>
        <emu-note>
          <p>The `lastIndexOf` function is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.localecompare">
        <h1>String.prototype.localeCompare ( _that_ [ , _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `localeCompare` method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `localeCompare` method is used.</p>
        <p>When the `localeCompare` method is called with argument _that_, it returns a Number other than *NaN* that represents the result of a locale-sensitive String comparison of the *this* value (converted to a String) with _that_ (converted to a String). The two Strings are _S_ and _That_. The two Strings are compared in an implementation-defined fashion. The result is intended to order String values in the sort order specified by a host default locale, and will be negative, zero, or positive, depending on whether _S_ comes before _That_ in the sort order, the Strings are equal, or _S_ comes after _That_ in the sort order, respectively.</p>
        <p>Before performing the comparisons, the following steps are performed to prepare the Strings:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. Let _S_ be ? ToString(_O_).
          1. Let _That_ be ? ToString(_that_).
        </emu-alg>
        <p>The meaning of the optional second and third parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not assign any other interpretation to those parameter positions.</p>
        <p>The `localeCompare` method, if considered as a function of two arguments *this* and _that_, is a consistent comparison function (as defined in <emu-xref href="#sec-array.prototype.sort"></emu-xref>) on the set of all Strings.</p>
        <p>The actual return values are implementation-defined to permit implementers to encode additional information in the value, but the function is required to define a total ordering on all Strings. This function must treat Strings that are canonically equivalent according to the Unicode standard as identical and must return `0` when comparing Strings that are considered canonically equivalent.</p>
        <emu-note>
          <p>The `localeCompare` method itself is not directly suitable as an argument to `Array.prototype.sort` because the latter requires a function of two arguments.</p>
        </emu-note>
        <emu-note>
          <p>This function is intended to rely on whatever language-sensitive comparison functionality is available to the ECMAScript environment from the host environment, and to compare according to the rules of the host environment's current locale. However, regardless of the host provided comparison capabilities, this function must treat Strings that are canonically equivalent according to the Unicode standard as identical. It is recommended that this function should not honour Unicode compatibility equivalences or decompositions. For a definition and discussion of canonical equivalence see the Unicode Standard, chapters 2 and 3, as well as Unicode Standard Annex #15, Unicode Normalization Forms (<a href="https://unicode.org/reports/tr15/">https://unicode.org/reports/tr15/</a>) and Unicode Technical Note #5, Canonical Equivalence in Applications (<a href="https://unicode.org/notes/tn5/">https://www.unicode.org/notes/tn5/</a>). Also see Unicode Technical Standard #10, Unicode Collation Algorithm (<a href="https://unicode.org/reports/tr10/">https://unicode.org/reports/tr10/</a>).</p>
        </emu-note>
        <emu-note>
          <p>The `localeCompare` function is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.match">
        <h1>String.prototype.match ( _regexp_ )</h1>
        <p>When the `match` method is called with argument _regexp_, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. If _regexp_ is neither *undefined* nor *null*, then
            1. Let _matcher_ be ? GetMethod(_regexp_, @@match).
            1. If _matcher_ is not *undefined*, then
              1. Return ? Call(_matcher_, _regexp_, &laquo; _O_ &raquo;).
          1. Let _S_ be ? ToString(_O_).
          1. Let _rx_ be ? RegExpCreate(_regexp_, *undefined*).
          1. Return ? Invoke(_rx_, @@match, &laquo; _S_ &raquo;).
        </emu-alg>
        <emu-note>
          <p>The `match` function is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string-prototype-matchall">
        <h1>String.prototype.matchAll ( _regexp_ )</h1>

        <p>Performs a regular expression match of the String representing the *this* value against _regexp_ and returns an iterator. Each iteration results value is an Array object containing the results of the match, or *null* if the String did not match.</p>

        <p>When the `matchAll` method is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. If _regexp_ is neither *undefined* nor *null*, then
            1. Let _matcher_ be ? GetMethod(_regexp_, @@matchAll).
            1. If _matcher_ is not *undefined*, then
              1. Return ? Call(_matcher_, _regexp_, &laquo; _O_ &raquo;).
          1. Let _S_ be ? ToString(_O_).
          1. Let _rx_ be ? RegExpCreate(_regexp_, `"g"`).
          1. Return ? Invoke(_rx_, @@matchAll, &laquo; _S_ &raquo;).
        </emu-alg>
        <emu-note>The `matchAll` function is intentionally generic, it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</emu-note>
        <emu-note>Similarly to `String.prototype.split`, `String.prototype.matchAll` is designed to typically act without mutating its inputs.</emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.normalize">
        <h1>String.prototype.normalize ( [ _form_ ] )</h1>
        <p>When the `normalize` method is called with one argument _form_, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. Let _S_ be ? ToString(_O_).
          1. If _form_ is not present or _form_ is *undefined*, set _form_ to `"NFC"`.
          1. Let _f_ be ? ToString(_form_).
          1. If _f_ is not one of `"NFC"`, `"NFD"`, `"NFKC"`, or `"NFKD"`, throw a *RangeError* exception.
          1. Let _ns_ be the String value that is the result of normalizing _S_ into the normalization form named by _f_ as specified in <a href="https://unicode.org/reports/tr15/">https://unicode.org/reports/tr15/</a>.
          1. Return _ns_.
        </emu-alg>
        <emu-note>
          <p>The `normalize` function is intentionally generic; it does not require that its *this* value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.padend">
        <h1>String.prototype.padEnd ( _maxLength_ [ , _fillString_ ] )</h1>
        <p>When the `padEnd` method is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. Return ? StringPad(_O_, _maxLength_, _fillString_, *"end"*).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.padstart">
        <h1>String.prototype.padStart ( _maxLength_ [ , _fillString_ ] )</h1>
        <p>When the `padStart` method is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. Return ? StringPad(_O_, _maxLength_, _fillString_, *"start"*).
        </emu-alg>

        <emu-clause id="sec-stringpad" aoid="StringPad">
          <h1>Runtime Semantics: StringPad ( _O_, _maxLength_, _fillString_, _placement_ )</h1>
          <p>When the abstract operation StringPad is called with arguments _O_, _maxLength_, _fillString_, and _placement_, the following steps are taken:</p>
          <emu-alg>
            1. Assert: _placement_ is *"start"* or *"end"*.
            1. Let _S_ be ? ToString(_O_).
            1. Let _intMaxLength_ be ? ToLength(_maxLength_).
            1. Let _stringLength_ be the length of _S_.
            1. If _intMaxLength_ is not greater than _stringLength_, return _S_.
            1. If _fillString_ is *undefined*, let _filler_ be the String value consisting solely of the code unit 0x0020 (SPACE).
            1. Else, let _filler_ be ? ToString(_fillString_).
            1. If _filler_ is the empty String, return _S_.
            1. Let _fillLen_ be _intMaxLength_ - _stringLength_.
            1. Let _truncatedStringFiller_ be the String value consisting of repeated concatenations of _filler_ truncated to length _fillLen_.
            1. If _placement_ is *"start"*, return the string-concatenation of _truncatedStringFiller_ and _S_.
            1. Else, return the string-concatenation of _S_ and _truncatedStringFiller_.
          </emu-alg>
          <emu-note>
            <p>The argument _maxLength_ will be clamped such that it can be no smaller than the length of _S_.</p>
          </emu-note>
          <emu-note>
            <p>The argument _fillString_ defaults to *" "* (the String value consisting of the code unit 0x0020 SPACE).</p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype.repeat">
        <h1>String.prototype.repeat ( _count_ )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. Let _S_ be ? ToString(_O_).
          1. Let _n_ be ? ToInteger(_count_).
          1. If _n_ &lt; 0, throw a *RangeError* exception.
          1. If _n_ is *+&infin;*, throw a *RangeError* exception.
          1. If _n_ is 0, return the empty String.
          1. Return the String value that is made from _n_ copies of _S_ appended together.
        </emu-alg>
        <emu-note>
          <p>This method creates the String value consisting of the code units of the `this` object (converted to String) repeated _count_ times.</p>
        </emu-note>
        <emu-note>
          <p>The `repeat` function is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.replace">
        <h1>String.prototype.replace ( _searchValue_, _replaceValue_ )</h1>
        <p>When the `replace` method is called with arguments _searchValue_ and _replaceValue_, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. If _searchValue_ is neither *undefined* nor *null*, then
            1. Let _replacer_ be ? GetMethod(_searchValue_, @@replace).
            1. If _replacer_ is not *undefined*, then
              1. Return ? Call(_replacer_, _searchValue_, &laquo; _O_, _replaceValue_ &raquo;).
          1. Let _string_ be ? ToString(_O_).
          1. Let _searchString_ be ? ToString(_searchValue_).
          1. Let _functionalReplace_ be IsCallable(_replaceValue_).
          1. If _functionalReplace_ is *false*, then
            1. Set _replaceValue_ to ? ToString(_replaceValue_).
          1. Search _string_ for the first occurrence of _searchString_ and let _pos_ be the index within _string_ of the first code unit of the matched substring and let _matched_ be _searchString_. If no occurrences of _searchString_ were found, return _string_.
          1. If _functionalReplace_ is *true*, then
            1. Let _replValue_ be ? Call(_replaceValue_, *undefined*, &laquo; _matched_, _pos_, _string_ &raquo;).
            1. Let _replStr_ be ? ToString(_replValue_).
          1. Else,
            1. Let _captures_ be a new empty List.
            1. Let _replStr_ be GetSubstitution(_matched_, _string_, _pos_, _captures_, *undefined*, _replaceValue_).
          1. Let _tailPos_ be _pos_ + the number of code units in _matched_.
          1. Let _newString_ be the string-concatenation of the first _pos_ code units of _string_, _replStr_, and the trailing substring of _string_ starting at index _tailPos_. If _pos_ is 0, the first element of the concatenation will be the empty String.
          1. Return _newString_.
        </emu-alg>
        <emu-note>
          <p>The `replace` function is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>

        <emu-clause id="sec-getsubstitution" aoid="GetSubstitution">
          <h1>Runtime Semantics: GetSubstitution ( _matched_, _str_, _position_, _captures_, _namedCaptures_, _replacement_ )</h1>
          <p>The abstract operation GetSubstitution performs the following steps:</p>
          <emu-alg>
            1. Assert: Type(_matched_) is String.
            1. Let _matchLength_ be the number of code units in _matched_.
            1. Assert: Type(_str_) is String.
            1. Let _stringLength_ be the number of code units in _str_.
            1. Assert: _position_ is a nonnegative integer.
            1. Assert: _position_ &le; _stringLength_.
            1. Assert: _captures_ is a possibly empty List of Strings.
            1. Assert: Type(_replacement_) is String.
            1. Let _tailPos_ be _position_ + _matchLength_.
            1. Let _m_ be the number of elements in _captures_.
            1. If _namedCaptures_ is not *undefined*, then
              1. Set _namedCaptures_ to ? ToObject(_namedCaptures_).
            1. Let _result_ be the String value derived from _replacement_ by copying code unit elements from _replacement_ to _result_ while performing replacements as specified in <emu-xref href="#table-45"></emu-xref>. These `$` replacements are done left-to-right, and, once such a replacement is performed, the new replacement text is not subject to further replacements.
            1. Return _result_.
          </emu-alg>
          <emu-table id="table-45" caption="Replacement Text Symbol Substitutions">
            <table>
              <tbody>
              <tr>
                <th>
                  Code units
                </th>
                <th>
                  Unicode Characters
                </th>
                <th>
                  Replacement text
                </th>
              </tr>
              <tr>
                <td>
                  0x0024, 0x0024
                </td>
                <td>
                  `$$`
                </td>
                <td>
                  `$`
                </td>
              </tr>
              <tr>
                <td>
                  0x0024, 0x0026
                </td>
                <td>
                  `$&amp;`
                </td>
                <td>
                  _matched_
                </td>
              </tr>
              <tr>
                <td>
                  0x0024, 0x0060
                </td>
                <td>
                  <code>$`</code>
                </td>
                <td>
                  If _position_ is 0, the replacement is the empty String. Otherwise the replacement is the substring of _str_ that starts at index 0 and whose last code unit is at index _position_ - 1.
                </td>
              </tr>
              <tr>
                <td>
                  0x0024, 0x0027
                </td>
                <td>
                  `$'`
                </td>
                <td>
                  If _tailPos_ &ge; _stringLength_, the replacement is the empty String. Otherwise the replacement is the substring of _str_ that starts at index _tailPos_ and continues to the end of _str_.
                </td>
              </tr>
              <tr>
                <td>
                  0x0024, N
                  <br>
                  Where
                  <br>
                  0x0031 &le; N &le; 0x0039
                </td>
                <td>
                  `$n` where
                  <br>
                  `n` is one of `1 2 3 4 5 6 7 8 9` and `$n` is not followed by a decimal digit
                </td>
                <td>
                  The _n_<sup>th</sup> element of _captures_, where _n_ is a single digit in the range 1 to 9. If _n_ &le; _m_ and the _n_<sup>th</sup> element of _captures_ is *undefined*, use the empty String instead. If _n_ &gt; _m_, no replacement is done.
                </td>
              </tr>
              <tr>
                <td>
                  0x0024, N, N
                  <br>
                  Where
                  <br>
                  0x0030 &le; N &le; 0x0039
                </td>
                <td>
                  `$nn` where
                  <br>
                  `n` is one of `0 1 2 3 4 5 6 7 8 9`
                </td>
                <td>
                  The _nn_<sup>th</sup> element of _captures_, where _nn_ is a two-digit decimal number in the range 01 to 99. If _nn_ &le; _m_ and the _nn_<sup>th</sup> element of _captures_ is *undefined*, use the empty String instead. If _nn_ is 00 or _nn_ &gt; _m_, no replacement is done.
                </td>
              </tr>
              <tr>
                <td>
                  0x0024, 0x003C
                </td>
                <td>
                  `$&lt;`
                </td>
                <td>
                  <emu-alg>
                    1. If _namedCaptures_ is *undefined*, the replacement text is the String `"$&lt;"`.
                    1. Else,
                      1. Scan until the next `>` U+003E (GREATER-THAN SIGN).
                      1. If none is found, the replacement text is the String `"$&lt;"`.
                      1. Else,
                        1. Let _groupName_ be the enclosed substring.
                        1. Let _capture_ be ? Get(_namedCaptures_, _groupName_).
                        1. If _capture_ is *undefined*, replace the text through `>` with the empty string.
                        1. Otherwise, replace the text through `>` with ? ToString(_capture_).
                  </emu-alg>
                </td>
              </tr>
              <tr>
                <td>
                  0x0024
                </td>
                <td>
                  `$` in any context that does not match any of the above.
                </td>
                <td>
                  `$`
                </td>
              </tr>
              </tbody>
            </table>
          </emu-table>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype.search">
        <h1>String.prototype.search ( _regexp_ )</h1>
        <p>When the `search` method is called with argument _regexp_, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. If _regexp_ is neither *undefined* nor *null*, then
            1. Let _searcher_ be ? GetMethod(_regexp_, @@search).
            1. If _searcher_ is not *undefined*, then
              1. Return ? Call(_searcher_, _regexp_, &laquo; _O_ &raquo;).
          1. Let _string_ be ? ToString(_O_).
          1. Let _rx_ be ? RegExpCreate(_regexp_, *undefined*).
          1. Return ? Invoke(_rx_, @@search, &laquo; _string_ &raquo;).
        </emu-alg>
        <emu-note>
          <p>The `search` function is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.slice">
        <h1>String.prototype.slice ( _start_, _end_ )</h1>
        <p>The `slice` method takes two arguments, _start_ and _end_, and returns a substring of the result of converting this object to a String, starting from index _start_ and running to, but not including, index _end_ (or through the end of the String if _end_ is *undefined*). If _start_ is negative, it is treated as <emu-eqn>_sourceLength_ + _start_</emu-eqn> where _sourceLength_ is the length of the String. If _end_ is negative, it is treated as <emu-eqn>_sourceLength_ + _end_</emu-eqn> where _sourceLength_ is the length of the String. The result is a String value, not a String object. The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. Let _S_ be ? ToString(_O_).
          1. Let _len_ be the length of _S_.
          1. Let _intStart_ be ? ToInteger(_start_).
          1. If _end_ is *undefined*, let _intEnd_ be _len_; else let _intEnd_ be ? ToInteger(_end_).
          1. If _intStart_ &lt; 0, let _from_ be max(_len_ + _intStart_, 0); otherwise let _from_ be min(_intStart_, _len_).
          1. If _intEnd_ &lt; 0, let _to_ be max(_len_ + _intEnd_, 0); otherwise let _to_ be min(_intEnd_, _len_).
          1. Let _span_ be max(_to_ - _from_, 0).
          1. Return the String value containing _span_ consecutive code units from _S_ beginning with the code unit at index _from_.
        </emu-alg>
        <emu-note>
          <p>The `slice` function is intentionally generic; it does not require that its *this* value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.split">
        <h1>String.prototype.split ( _separator_, _limit_ )</h1>
        <p>Returns an Array object into which substrings of the result of converting this object to a String have been stored. The substrings are determined by searching from left to right for occurrences of _separator_; these occurrences are not part of any substring in the returned array, but serve to divide up the String value. The value of _separator_ may be a String of any length or it may be an object, such as a RegExp, that has a @@split method.</p>
        <p>When the `split` method is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. If _separator_ is neither *undefined* nor *null*, then
            1. Let _splitter_ be ? GetMethod(_separator_, @@split).
            1. If _splitter_ is not *undefined*, then
              1. Return ? Call(_splitter_, _separator_, &laquo; _O_, _limit_ &raquo;).
          1. Let _S_ be ? ToString(_O_).
          1. Let _A_ be ! ArrayCreate(0).
          1. Let _lengthA_ be 0.
          1. If _limit_ is *undefined*, let _lim_ be 2<sup>32</sup> - 1; else let _lim_ be ? ToUint32(_limit_).
          1. Let _s_ be the length of _S_.
          1. Let _p_ be 0.
          1. Let _R_ be ? ToString(_separator_).
          1. If _lim_ = 0, return _A_.
          1. If _separator_ is *undefined*, then
            1. Perform ! CreateDataProperty(_A_, `"0"`, _S_).
            1. Return _A_.
          1. If _s_ = 0, then
            1. Let _z_ be SplitMatch(_S_, 0, _R_).
            1. If _z_ is not *false*, return _A_.
            1. Perform ! CreateDataProperty(_A_, `"0"`, _S_).
            1. Return _A_.
          1. Let _q_ be _p_.
          1. Repeat, while _q_ &ne; _s_
            1. Let _e_ be SplitMatch(_S_, _q_, _R_).
            1. If _e_ is *false*, increase _q_ by 1.
            1. Else _e_ is an integer index &le; _s_,
              1. If _e_ = _p_, increase _q_ by 1.
              1. Else _e_ &ne; _p_,
                1. Let _T_ be the String value equal to the substring of _S_ consisting of the code units at indices _p_ (inclusive) through _q_ (exclusive).
                1. Perform ! CreateDataProperty(_A_, ! ToString(_lengthA_), _T_).
                1. Increment _lengthA_ by 1.
                1. If _lengthA_ = _lim_, return _A_.
                1. Set _p_ to _e_.
                1. Set _q_ to _p_.
          1. Let _T_ be the String value equal to the substring of _S_ consisting of the code units at indices _p_ (inclusive) through _s_ (exclusive).
          1. Perform ! CreateDataProperty(_A_, ! ToString(_lengthA_), _T_).
          1. Return _A_.
        </emu-alg>
        <emu-note>
          <p>The value of _separator_ may be an empty String. In this case, _separator_ does not match the empty substring at the beginning or end of the input String, nor does it match the empty substring at the end of the previous separator match. If _separator_ is the empty String, the String is split up into individual code unit elements; the length of the result array equals the length of the String, and each substring contains one code unit.</p>
          <p>If the *this* object is (or converts to) the empty String, the result depends on whether _separator_ can match the empty String. If it can, the result array contains no elements. Otherwise, the result array contains one element, which is the empty String.</p>
          <p>If _separator_ is *undefined*, then the result array contains just one String, which is the *this* value (converted to a String). If _limit_ is not *undefined*, then the output array is truncated so that it contains no more than _limit_ elements.</p>
        </emu-note>
        <emu-note>
          <p>The `split` function is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>

        <emu-clause id="sec-splitmatch" aoid="SplitMatch">
          <h1>Runtime Semantics: SplitMatch ( _S_, _q_, _R_ )</h1>
          <p>The abstract operation SplitMatch takes three parameters, a String _S_, an integer _q_, and a String _R_, and performs the following steps in order to return either *false* or the end index of a match:</p>
          <emu-alg>
            1. Assert: Type(_R_) is String.
            1. Let _r_ be the number of code units in _R_.
            1. Let _s_ be the number of code units in _S_.
            1. If _q_ + _r_ &gt; _s_, return *false*.
            1. If there exists an integer _i_ between 0 (inclusive) and _r_ (exclusive) such that the code unit at index _q_ + _i_ within _S_ is different from the code unit at index _i_ within _R_, return *false*.
            1. Return _q_ + _r_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype.startswith">
        <h1>String.prototype.startsWith ( _searchString_ [ , _position_ ] )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. Let _S_ be ? ToString(_O_).
          1. Let _isRegExp_ be ? IsRegExp(_searchString_).
          1. If _isRegExp_ is *true*, throw a *TypeError* exception.
          1. Let _searchStr_ be ? ToString(_searchString_).
          1. Let _pos_ be ? ToInteger(_position_).
          1. Assert: If _position_ is *undefined*, then _pos_ is 0.
          1. Let _len_ be the length of _S_.
          1. Let _start_ be min(max(_pos_, 0), _len_).
          1. Let _searchLength_ be the length of _searchStr_.
          1. If _searchLength_ + _start_ is greater than _len_, return *false*.
          1. If the sequence of code units of _S_ starting at _start_ of length _searchLength_ is the same as the full code unit sequence of _searchStr_, return *true*.
          1. Otherwise, return *false*.
        </emu-alg>
        <emu-note>
          <p>This method returns *true* if the sequence of code units of _searchString_ converted to a String is the same as the corresponding code units of this object (converted to a String) starting at index _position_. Otherwise returns *false*.</p>
        </emu-note>
        <emu-note>
          <p>Throwing an exception if the first argument is a RegExp is specified in order to allow future editions to define extensions that allow such argument values.</p>
        </emu-note>
        <emu-note>
          <p>The `startsWith` function is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.substring">
        <h1>String.prototype.substring ( _start_, _end_ )</h1>
        <p>The `substring` method takes two arguments, _start_ and _end_, and returns a substring of the result of converting this object to a String, starting from index _start_ and running to, but not including, index _end_ of the String (or through the end of the String if _end_ is *undefined*). The result is a String value, not a String object.</p>
        <p>If either argument is *NaN* or negative, it is replaced with zero; if either argument is larger than the length of the String, it is replaced with the length of the String.</p>
        <p>If _start_ is larger than _end_, they are swapped.</p>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. Let _S_ be ? ToString(_O_).
          1. Let _len_ be the length of _S_.
          1. Let _intStart_ be ? ToInteger(_start_).
          1. If _end_ is *undefined*, let _intEnd_ be _len_; else let _intEnd_ be ? ToInteger(_end_).
          1. Let _finalStart_ be min(max(_intStart_, 0), _len_).
          1. Let _finalEnd_ be min(max(_intEnd_, 0), _len_).
          1. Let _from_ be min(_finalStart_, _finalEnd_).
          1. Let _to_ be max(_finalStart_, _finalEnd_).
          1. Return the String value whose length is _to_ - _from_, containing code units from _S_, namely the code units with indices _from_ through _to_ - 1, in ascending order.
        </emu-alg>
        <emu-note>
          <p>The `substring` function is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tolocalelowercase">
        <h1>String.prototype.toLocaleLowerCase ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `toLocaleLowerCase` method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `toLocaleLowerCase` method is used.</p>
        <p>This function interprets a String value as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        <p>This function works exactly the same as `toLowerCase` except that its result is intended to yield the correct result for the host environment's current locale, rather than a locale-independent result. There will only be a difference in the few cases (such as Turkish) where the rules for that language conflict with the regular Unicode case mappings.</p>
        <p>The meaning of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
        <emu-note>
          <p>The `toLocaleLowerCase` function is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tolocaleuppercase">
        <h1>String.prototype.toLocaleUpperCase ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `toLocaleUpperCase` method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `toLocaleUpperCase` method is used.</p>
        <p>This function interprets a String value as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        <p>This function works exactly the same as `toUpperCase` except that its result is intended to yield the correct result for the host environment's current locale, rather than a locale-independent result. There will only be a difference in the few cases (such as Turkish) where the rules for that language conflict with the regular Unicode case mappings.</p>
        <p>The meaning of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
        <emu-note>
          <p>The `toLocaleUpperCase` function is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tolowercase">
        <h1>String.prototype.toLowerCase ( )</h1>
        <p>This function interprets a String value as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>. The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. Let _S_ be ? ToString(_O_).
          1. Let _cpList_ be a List containing in order the code points as defined in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> of _S_, starting at the first element of _S_.
          1. Let _cuList_ be a List where the elements are the result of toLowercase(_cpList_), according to the Unicode Default Case Conversion algorithm.
          1. Let _L_ be the String value whose code units are the UTF16Encoding of the code points of _cuList_.
          1. Return _L_.
        </emu-alg>
        <p>The result must be derived according to the locale-insensitive case mappings in the Unicode Character Database (this explicitly includes not only the UnicodeData.txt file, but also all locale-insensitive mappings in the SpecialCasings.txt file that accompanies it).</p>
        <emu-note>
          <p>The case mapping of some code points may produce multiple code points. In this case the result String may not be the same length as the source String. Because both `toUpperCase` and `toLowerCase` have context-sensitive behaviour, the functions are not symmetrical. In other words, `s.toUpperCase().toLowerCase()` is not necessarily equal to `s.toLowerCase()`.</p>
        </emu-note>
        <emu-note>
          <p>The `toLowerCase` function is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tostring">
        <h1>String.prototype.toString ( )</h1>
        <p>When the `toString` method is called, the following steps are taken:</p>
        <emu-alg>
          1. Return ? thisStringValue(*this* value).
        </emu-alg>
        <emu-note>
          <p>For a String object, the `toString` method happens to return the same thing as the `valueOf` method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.touppercase">
        <h1>String.prototype.toUpperCase ( )</h1>
        <p>This function interprets a String value as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        <p>This function behaves in exactly the same way as `String.prototype.toLowerCase`, except that the String is mapped using the toUppercase algorithm of the Unicode Default Case Conversion.</p>
        <emu-note>
          <p>The `toUpperCase` function is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.trim">
        <h1>String.prototype.trim ( )</h1>
        <p>This function interprets a String value as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be *this* value.
          1. Return ? TrimString(_S_, `"start+end"`).
        </emu-alg>
        <emu-note>
          <p>The `trim` function is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>

        <emu-clause id="sec-trimstring" aoid="TrimString">
          <h1>Runtime Semantics: TrimString ( _string_, _where_ )</h1>
          <p>The abstract operation TrimString is called with arguments _string_ and _where_, and interprets the String value _string_ as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>. It performs the following steps:</p>
          <emu-alg>
            1. Let _str_ be ? RequireObjectCoercible(_string_).
            1. Let _S_ be ? ToString(_str_).
            1. If _where_ is `"start"`, let _T_ be the String value that is a copy of _S_ with leading white space removed.
            1. Else if _where_ is `"end"`, let _T_ be the String value that is a copy of _S_ with trailing white space removed.
            1. Else,
              1. Assert: _where_ is `"start+end"`.
              1. Let _T_ be the String value that is a copy of _S_ with both leading and trailing white space removed.
            1. Return _T_.
          </emu-alg>
          <p>The definition of white space is the union of |WhiteSpace| and |LineTerminator|. When determining whether a Unicode code point is in Unicode general category &ldquo;Space_Separator&rdquo; (&ldquo;Zs&rdquo;), code unit sequences are interpreted as UTF-16 encoded code point sequences as specified in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype.trimend">
        <h1>String.prototype.trimEnd ( )</h1>
        <p>This function interprets a String value as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be *this* value.
          1. Return ? TrimString(_S_, `"end"`).
        </emu-alg>
        <emu-note>
          <p>The `trimEnd` function is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.trimstart">
        <h1>String.prototype.trimStart ( )</h1>
        <p>This function interprets a String value as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be *this* value.
          1. Return ? TrimString(_S_, `"start"`).
        </emu-alg>
        <emu-note>
          <p>The `trimStart` function is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.valueof">
        <h1>String.prototype.valueOf ( )</h1>
        <p>When the `valueOf` method is called, the following steps are taken:</p>
        <emu-alg>
          1. Return ? thisStringValue(*this* value).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype-@@iterator">
        <h1>String.prototype [ @@iterator ] ( )</h1>
        <p>When the `@@iterator` method is called it returns an Iterator object (<emu-xref href="#sec-iterator-interface"></emu-xref>) that iterates over the code points of a String value, returning each code point as a String value. The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. Let _S_ be ? ToString(_O_).
          1. Return CreateStringIterator(_S_).
        </emu-alg>
        <p>The value of the `name` property of this function is `"[Symbol.iterator]"`.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-string-instances">
      <h1>Properties of String Instances</h1>
      <p>String instances are String exotic objects and have the internal methods specified for such objects. String instances inherit properties from the String prototype object. String instances also have a [[StringData]] internal slot.</p>
      <p>String instances have a `"length"` property, and a set of enumerable properties with integer-indexed names.</p>

      <emu-clause id="sec-properties-of-string-instances-length">
        <h1>length</h1>
        <p>The number of elements in the String value represented by this String object.</p>
        <p>Once a String object is initialized, this property is unchanging. It has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-string-iterator-objects">
      <h1>String Iterator Objects</h1>
      <p>A String Iterator is an object, that represents a specific iteration over some specific String instance object. There is not a named constructor for String Iterator objects. Instead, String iterator objects are created by calling certain methods of String instance objects.</p>

      <emu-clause id="sec-createstringiterator" aoid="CreateStringIterator">
        <h1>CreateStringIterator ( _string_ )</h1>
        <p>Several methods of String objects return Iterator objects. The abstract operation CreateStringIterator with argument _string_ is used to create such iterator objects. It performs the following steps:</p>
        <emu-alg>
          1. Assert: Type(_string_) is String.
          1. Let _iterator_ be ObjectCreate(%StringIteratorPrototype%, &laquo; [[IteratedString]], [[StringIteratorNextIndex]] &raquo;).
          1. Set _iterator_.[[IteratedString]] to _string_.
          1. Set _iterator_.[[StringIteratorNextIndex]] to 0.
          1. Return _iterator_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%stringiteratorprototype%-object">
        <h1>The %StringIteratorPrototype% Object</h1>
        <p>The <dfn>%StringIteratorPrototype%</dfn> object:</p>
        <ul>
          <li>has properties that are inherited by all String Iterator Objects.</li>
          <li>is an ordinary object.</li>
          <li>has a [[Prototype]] internal slot whose value is the intrinsic object %IteratorPrototype%.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-%stringiteratorprototype%.next">
          <h1>%StringIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. Let _O_ be the *this* value.
            1. If Type(_O_) is not Object, throw a *TypeError* exception.
            1. If _O_ does not have all of the internal slots of a String Iterator Instance (<emu-xref href="#sec-properties-of-string-iterator-instances"></emu-xref>), throw a *TypeError* exception.
            1. Let _s_ be _O_.[[IteratedString]].
            1. If _s_ is *undefined*, return CreateIterResultObject(*undefined*, *true*).
            1. Let _position_ be _O_.[[StringIteratorNextIndex]].
            1. Let _len_ be the length of _s_.
            1. If _position_ &ge; _len_, then
              1. Set _O_.[[IteratedString]] to *undefined*.
              1. Return CreateIterResultObject(*undefined*, *true*).
            1. Let _first_ be the numeric value of the code unit at index _position_ within _s_.
            1. If _first_ &lt; 0xD800 or _first_ &gt; 0xDBFF or _position_ + 1 = _len_, let _resultString_ be the String value consisting of the single code unit _first_.
            1. Else,
              1. Let _second_ be the numeric value of the code unit at index _position_ + 1 within the String _s_.
              1. If _second_ &lt; 0xDC00 or _second_ &gt; 0xDFFF, let _resultString_ be the String value consisting of the single code unit _first_.
              1. Else, let _resultString_ be the string-concatenation of the code unit _first_ and the code unit _second_.
            1. Let _resultSize_ be the number of code units in _resultString_.
            1. Set _O_.[[StringIteratorNextIndex]] to _position_ + _resultSize_.
            1. Return CreateIterResultObject(_resultString_, *false*).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%stringiteratorprototype%-@@tostringtag">
          <h1>%StringIteratorPrototype% [ @@toStringTag ]</h1>
          <p>The initial value of the @@toStringTag property is the String value `"String Iterator"`.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-string-iterator-instances">
        <h1>Properties of String Iterator Instances</h1>
        <p>String Iterator instances are ordinary objects that inherit properties from the %StringIteratorPrototype% intrinsic object. String Iterator instances are initially created with the internal slots listed in <emu-xref href="#table-46"></emu-xref>.</p>
        <emu-table id="table-46" caption="Internal Slots of String Iterator Instances">
          <table>
            <tbody>
            <tr>
              <th>
                Internal Slot
              </th>
              <th>
                Description
              </th>
            </tr>
            <tr>
              <td>
                [[IteratedString]]
              </td>
              <td>
                The String value whose code units are being iterated.
              </td>
            </tr>
            <tr>
              <td>
                [[StringIteratorNextIndex]]
              </td>
              <td>
                The integer index of the next string index to be examined by this iteration.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-regexp-regular-expression-objects">
    <h1>RegExp (Regular Expression) Objects</h1>
    <p>A RegExp object contains a regular expression and the associated flags.</p>
    <emu-note>
      <p>The form and functionality of regular expressions is modelled after the regular expression facility in the Perl 5 programming language.</p>
    </emu-note>

    <emu-clause id="sec-patterns">
      <h1>Patterns</h1>
      <p>The `RegExp` constructor applies the following grammar to the input pattern String. An error occurs if the grammar cannot interpret the String as an expansion of |Pattern|.</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        Pattern[U, N] ::
          Disjunction[?U, ?N]

        Disjunction[U, N] ::
          Alternative[?U, ?N]
          Alternative[?U, ?N] `|` Disjunction[?U, ?N]

        Alternative[U, N] ::
          [empty]
          Alternative[?U, ?N] Term[?U, ?N]

        Term[U, N] ::
          Assertion[?U, ?N]
          Atom[?U, ?N]
          Atom[?U, ?N] Quantifier

        Assertion[U, N] ::
          `^`
          `$`
          `\` `b`
          `\` `B`
          `(` `?` `=` Disjunction[?U, ?N] `)`
          `(` `?` `!` Disjunction[?U, ?N] `)`
          `(` `?` `&lt;=` Disjunction[?U, ?N] `)`
          `(` `?` `&lt;!` Disjunction[?U, ?N] `)`

        Quantifier ::
          QuantifierPrefix
          QuantifierPrefix `?`

        QuantifierPrefix ::
          `*`
          `+`
          `?`
          `{` DecimalDigits `}`
          `{` DecimalDigits `,` `}`
          `{` DecimalDigits `,` DecimalDigits `}`

        Atom[U, N] ::
          PatternCharacter
          `.`
          `\` AtomEscape[?U, ?N]
          CharacterClass[?U]
          `(` GroupSpecifier[?U] Disjunction[?U, ?N] `)`
          `(` `?` `:` Disjunction[?U, ?N] `)`

        SyntaxCharacter :: one of
          `^` `$` `\` `.` `*` `+` `?` `(` `)` `[` `]` `{` `}` `|`

        PatternCharacter ::
          SourceCharacter but not SyntaxCharacter

        AtomEscape[U, N] ::
          DecimalEscape
          CharacterClassEscape[?U]
          CharacterEscape[?U]
          [+N] `k` GroupName[?U]

        CharacterEscape[U] ::
          ControlEscape
          `c` ControlLetter
          `0` [lookahead &lt;! DecimalDigit]
          HexEscapeSequence
          RegExpUnicodeEscapeSequence[?U]
          IdentityEscape[?U]

        ControlEscape :: one of
          `f` `n` `r` `t` `v`

        ControlLetter :: one of
          `a` `b` `c` `d` `e` `f` `g` `h` `i` `j` `k` `l` `m` `n` `o` `p` `q` `r` `s` `t` `u` `v` `w` `x` `y` `z`
          `A` `B` `C` `D` `E` `F` `G` `H` `I` `J` `K` `L` `M` `N` `O` `P` `Q` `R` `S` `T` `U` `V` `W` `X` `Y` `Z`

        GroupSpecifier[U] ::
          [empty]
          `?` GroupName[?U]

        GroupName[U] ::
          `&lt;` RegExpIdentifierName[?U] `&gt;`

        RegExpIdentifierName[U] ::
          RegExpIdentifierStart[?U]
          RegExpIdentifierName[?U] RegExpIdentifierPart[?U]

        RegExpIdentifierStart[U] ::
          UnicodeIDStart
          `$`
          `_`
          `\` RegExpUnicodeEscapeSequence[?U]

        RegExpIdentifierPart[U] ::
          UnicodeIDContinue
          `$`
          `\` RegExpUnicodeEscapeSequence[?U]
          &lt;ZWNJ&gt;
          &lt;ZWJ&gt;

        RegExpUnicodeEscapeSequence[U] ::
          [+U] `u` LeadSurrogate `\u` TrailSurrogate
          [+U] `u` LeadSurrogate
          [+U] `u` TrailSurrogate
          [+U] `u` NonSurrogate
          [~U] `u` Hex4Digits
          [+U] `u{` CodePoint `}`
      </emu-grammar>
      <p>Each `\\u` |TrailSurrogate| for which the choice of associated `u` |LeadSurrogate| is ambiguous shall be associated with the nearest possible `u` |LeadSurrogate| that would otherwise have no corresponding `\\u` |TrailSurrogate|.</p>
      <emu-grammar type="definition">
        LeadSurrogate ::
          Hex4Digits [> but only if the SV of |Hex4Digits| is in the inclusive range 0xD800 to 0xDBFF]

        TrailSurrogate ::
          Hex4Digits [> but only if the SV of |Hex4Digits| is in the inclusive range 0xDC00 to 0xDFFF]

        NonSurrogate ::
          Hex4Digits [> but only if the SV of |Hex4Digits| is not in the inclusive range 0xD800 to 0xDFFF]

        IdentityEscape[U] ::
          [+U] SyntaxCharacter
          [+U] `/`
          [~U] SourceCharacter but not UnicodeIDContinue

        DecimalEscape ::
          NonZeroDigit DecimalDigits? [lookahead &lt;! DecimalDigit]

        CharacterClassEscape[U] ::
          `d`
          `D`
          `s`
          `S`
          `w`
          `W`
          [+U] `p{` UnicodePropertyValueExpression `}`
          [+U] `P{` UnicodePropertyValueExpression `}`

        UnicodePropertyValueExpression ::
          UnicodePropertyName `=` UnicodePropertyValue
          LoneUnicodePropertyNameOrValue

        UnicodePropertyName ::
          UnicodePropertyNameCharacters

        UnicodePropertyNameCharacters ::
          UnicodePropertyNameCharacter UnicodePropertyNameCharacters?

        UnicodePropertyValue ::
          UnicodePropertyValueCharacters

        LoneUnicodePropertyNameOrValue ::
          UnicodePropertyValueCharacters

        UnicodePropertyValueCharacters ::
          UnicodePropertyValueCharacter UnicodePropertyValueCharacters?

        UnicodePropertyValueCharacter ::
          UnicodePropertyNameCharacter
          `0`
          `1`
          `2`
          `3`
          `4`
          `5`
          `6`
          `7`
          `8`
          `9`

        UnicodePropertyNameCharacter ::
          ControlLetter
          `_`

        CharacterClass[U] ::
          `[` [lookahead != `^`] ClassRanges[?U] `]`
          `[` `^` ClassRanges[?U] `]`

        ClassRanges[U] ::
          [empty]
          NonemptyClassRanges[?U]

        NonemptyClassRanges[U] ::
          ClassAtom[?U]
          ClassAtom[?U] NonemptyClassRangesNoDash[?U]
          ClassAtom[?U] `-` ClassAtom[?U] ClassRanges[?U]

        NonemptyClassRangesNoDash[U] ::
          ClassAtom[?U]
          ClassAtomNoDash[?U] NonemptyClassRangesNoDash[?U]
          ClassAtomNoDash[?U] `-` ClassAtom[?U] ClassRanges[?U]

        ClassAtom[U] ::
          `-`
          ClassAtomNoDash[?U]

        ClassAtomNoDash[U] ::
          SourceCharacter but not one of `\` or `]` or `-`
          `\` ClassEscape[?U]

        ClassEscape[U] ::
          `b`
          [+U] `-`
          CharacterClassEscape[?U]
          CharacterEscape[?U]
      </emu-grammar>

      <emu-clause id="sec-patterns-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>Pattern :: Disjunction</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if _NcapturingParens_ &ge; 2<sup>32</sup> - 1.
          </li>
          <li>
            It is a Syntax Error if |Pattern| contains multiple |GroupSpecifier|s whose enclosed |RegExpIdentifierName|s have the same StringValue.
          </li>
        </ul>
        <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `,` DecimalDigits `}`</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the MV of the first |DecimalDigits| is larger than the MV of the second |DecimalDigits|.
          </li>
        </ul>
        <emu-grammar>AtomEscape :: `k` GroupName</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the enclosing |Pattern| does not contain a |GroupSpecifier| with an enclosed |RegExpIdentifierName| whose StringValue equals the StringValue of the |RegExpIdentifierName| of this production's |GroupName|.
          </li>
        </ul>
        <emu-grammar>AtomEscape :: DecimalEscape</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the CapturingGroupNumber of |DecimalEscape| is larger than _NcapturingParens_ (<emu-xref href="#sec-notation"></emu-xref>).
          </li>
        </ul>
        <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassRanges</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if IsCharacterClass of the first |ClassAtom| is *true* or IsCharacterClass of the second |ClassAtom| is *true*.
          </li>
          <li>
            It is a Syntax Error if IsCharacterClass of the first |ClassAtom| is *false* and IsCharacterClass of the second |ClassAtom| is *false* and the CharacterValue of the first |ClassAtom| is larger than the CharacterValue of the second |ClassAtom|.
          </li>
        </ul>
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassRanges</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if IsCharacterClass of |ClassAtomNoDash| is *true* or IsCharacterClass of |ClassAtom| is *true*.
          </li>
          <li>
            It is a Syntax Error if IsCharacterClass of |ClassAtomNoDash| is *false* and IsCharacterClass of |ClassAtom| is *false* and the CharacterValue of |ClassAtomNoDash| is larger than the CharacterValue of |ClassAtom|.
          </li>
        </ul>
        <emu-grammar>RegExpIdentifierStart[U] :: `\` RegExpUnicodeEscapeSequence[?U]</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if SV(|RegExpUnicodeEscapeSequence|) is none of `"$"`, or `"_"`, or the UTF16Encoding of a code point matched by the |UnicodeIDStart| lexical grammar production.
          </li>
        </ul>
        <emu-grammar>RegExpIdentifierPart[U] :: `\` RegExpUnicodeEscapeSequence[?U]</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if SV(|RegExpUnicodeEscapeSequence|) is none of `"$"`, or `"_"`, or the UTF16Encoding of either &lt;ZWNJ&gt; or &lt;ZWJ&gt;, or the UTF16Encoding of a Unicode code point that would be matched by the |UnicodeIDContinue| lexical grammar production.
          </li>
        </ul>
        <emu-grammar>UnicodePropertyValueExpression :: UnicodePropertyName `=` UnicodePropertyValue</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the List of Unicode code points that is SourceText of |UnicodePropertyName| is not identical to a List of Unicode code points that is a Unicode property name or property alias listed in the &ldquo;Property name and aliases&rdquo; column of <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref>.
          </li>
          <li>
            It is a Syntax Error if the List of Unicode code points that is SourceText of |UnicodePropertyValue| is not identical to a List of Unicode code points that is a value or value alias for the Unicode property or property alias given by SourceText of |UnicodePropertyName| listed in the &ldquo;Property value and aliases&rdquo; column of the corresponding tables <emu-xref href="#table-unicode-general-category-values"></emu-xref> or <emu-xref href="#table-unicode-script-values"></emu-xref>.
          </li>
        </ul>
        <emu-grammar>UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the List of Unicode code points that is SourceText of |LoneUnicodePropertyNameOrValue| is not identical to a List of Unicode code points that is a Unicode general category or general category alias listed in the &ldquo;Property value and aliases&rdquo; column of <emu-xref href="#table-unicode-general-category-values"></emu-xref>, nor a binary property or binary property alias listed in the &ldquo;Property name and aliases&rdquo; column of <emu-xref href="#table-binary-unicode-properties"></emu-xref>.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-patterns-static-semantics-capturing-group-number">
        <h1>Static Semantics: CapturingGroupNumber</h1>
        <emu-grammar>DecimalEscape :: NonZeroDigit</emu-grammar>
        <emu-alg>
          1. Return the MV of |NonZeroDigit|.
        </emu-alg>
        <emu-grammar>DecimalEscape :: NonZeroDigit DecimalDigits</emu-grammar>
        <emu-alg>
          1. Let _n_ be the number of code points in |DecimalDigits|.
          1. Return (the MV of |NonZeroDigit| &times; 10<sup>_n_</sup>) plus the MV of |DecimalDigits|.
        </emu-alg>
        <p>The definitions of &ldquo;the MV of |NonZeroDigit|&rdquo; and &ldquo;the MV of |DecimalDigits|&rdquo; are in <emu-xref href="#sec-literals-numeric-literals"></emu-xref>.</p>
      </emu-clause>

      <emu-clause id="sec-patterns-static-semantics-is-character-class">
        <h1>Static Semantics: IsCharacterClass</h1>
        <emu-grammar>
          ClassAtom :: `-`

          ClassAtomNoDash :: SourceCharacter but not one of `\` or `]` or `-`

          ClassEscape :: `b`

          ClassEscape :: `-`

          ClassEscape :: CharacterEscape
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>ClassEscape :: CharacterClassEscape</emu-grammar>
        <emu-alg>
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-patterns-static-semantics-character-value">
        <h1>Static Semantics: CharacterValue</h1>
        <emu-grammar>
          ClassAtom :: `-`
        </emu-grammar>
        <emu-alg>
          1. Return the code point value of U+002D (HYPHEN-MINUS).
        </emu-alg>
        <emu-grammar>
          ClassAtomNoDash :: SourceCharacter but not one of `\` or `]` or `-`
        </emu-grammar>
        <emu-alg>
          1. Let _ch_ be the code point matched by |SourceCharacter|.
          1. Return the code point value of _ch_.
        </emu-alg>
        <emu-grammar>
          ClassEscape :: `b`
        </emu-grammar>
        <emu-alg>
          1. Return the code point value of U+0008 (BACKSPACE).
        </emu-alg>
        <emu-grammar>
          ClassEscape :: `-`
        </emu-grammar>
        <emu-alg>
          1. Return the code point value of U+002D (HYPHEN-MINUS).
        </emu-alg>
        <emu-grammar>CharacterEscape :: ControlEscape</emu-grammar>
        <emu-alg>
          1. Return the code point value according to <emu-xref href="#table-47"></emu-xref>.
        </emu-alg>
        <emu-table id="table-47" caption="ControlEscape Code Point Values">
          <table>
            <tbody>
            <tr>
              <th>
                ControlEscape
              </th>
              <th>
                Code Point Value
              </th>
              <th>
                Code Point
              </th>
              <th>
                Unicode Name
              </th>
              <th>
                Symbol
              </th>
            </tr>
            <tr>
              <td>
                `t`
              </td>
              <td>
                9
              </td>
              <td>
                `U+0009`
              </td>
              <td>
                CHARACTER TABULATION
              </td>
              <td>
                &lt;HT&gt;
              </td>
            </tr>
            <tr>
              <td>
                `n`
              </td>
              <td>
                10
              </td>
              <td>
                `U+000A`
              </td>
              <td>
                LINE FEED (LF)
              </td>
              <td>
                &lt;LF&gt;
              </td>
            </tr>
            <tr>
              <td>
                `v`
              </td>
              <td>
                11
              </td>
              <td>
                `U+000B`
              </td>
              <td>
                LINE TABULATION
              </td>
              <td>
                &lt;VT&gt;
              </td>
            </tr>
            <tr>
              <td>
                `f`
              </td>
              <td>
                12
              </td>
              <td>
                `U+000C`
              </td>
              <td>
                FORM FEED (FF)
              </td>
              <td>
                &lt;FF&gt;
              </td>
            </tr>
            <tr>
              <td>
                `r`
              </td>
              <td>
                13
              </td>
              <td>
                `U+000D`
              </td>
              <td>
                CARRIAGE RETURN (CR)
              </td>
              <td>
                &lt;CR&gt;
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
        <emu-grammar>CharacterEscape :: `c` ControlLetter</emu-grammar>
        <emu-alg>
          1. Let _ch_ be the code point matched by |ControlLetter|.
          1. Let _i_ be _ch_'s code point value.
          1. Return the remainder of dividing _i_ by 32.
        </emu-alg>
        <emu-grammar>CharacterEscape :: `0` [lookahead &lt;! DecimalDigit]</emu-grammar>
        <emu-alg>
          1. Return the code point value of U+0000 (NULL).
        </emu-alg>
        <emu-note>
          <p>`\\0` represents the &lt;NUL&gt; character and cannot be followed by a decimal digit.</p>
        </emu-note>
        <emu-grammar>CharacterEscape :: HexEscapeSequence</emu-grammar>
        <emu-alg>
          1. Return the numeric value of the code unit that is the SV of |HexEscapeSequence|.
        </emu-alg>
        <emu-grammar>RegExpUnicodeEscapeSequence :: `u` LeadSurrogate `\u` TrailSurrogate</emu-grammar>
        <emu-alg>
          1. Let _lead_ be the CharacterValue of |LeadSurrogate|.
          1. Let _trail_ be the CharacterValue of |TrailSurrogate|.
          1. Let _cp_ be UTF16Decode(_lead_, _trail_).
          1. Return the code point value of _cp_.
        </emu-alg>
        <emu-grammar>RegExpUnicodeEscapeSequence :: `u` LeadSurrogate</emu-grammar>
        <emu-alg>
          1. Return the CharacterValue of |LeadSurrogate|.
        </emu-alg>
        <emu-grammar>RegExpUnicodeEscapeSequence :: `u` TrailSurrogate</emu-grammar>
        <emu-alg>
          1. Return the CharacterValue of |TrailSurrogate|.
        </emu-alg>
        <emu-grammar>RegExpUnicodeEscapeSequence :: `u` NonSurrogate</emu-grammar>
        <emu-alg>
          1. Return the CharacterValue of |NonSurrogate|.
        </emu-alg>
        <emu-grammar>RegExpUnicodeEscapeSequence :: `u` Hex4Digits</emu-grammar>
        <emu-alg>
          1. Return the MV of |Hex4Digits|.
        </emu-alg>
        <emu-grammar>RegExpUnicodeEscapeSequence :: `u{` CodePoint `}`</emu-grammar>
        <emu-alg>
          1. Return the MV of |CodePoint|.
        </emu-alg>
        <emu-grammar>
          LeadSurrogate :: Hex4Digits

          TrailSurrogate :: Hex4Digits

          NonSurrogate :: Hex4Digits
        </emu-grammar>
        <emu-alg>
          1. Return the MV of |HexDigits|.
        </emu-alg>
        <emu-grammar>CharacterEscape :: IdentityEscape</emu-grammar>
        <emu-alg>
          1. Let _ch_ be the code point matched by |IdentityEscape|.
          1. Return the code point value of _ch_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-sourcetext">
        <h1>Static Semantics: SourceText</h1>
        <emu-grammar>
          UnicodePropertyNameCharacters :: UnicodePropertyNameCharacter UnicodePropertyNameCharacters?

          UnicodePropertyValueCharacters :: UnicodePropertyValueCharacter UnicodePropertyValueCharacters?
        </emu-grammar>
        <emu-alg>
          1. Return the List, in source text order, of Unicode code points in the source text matched by this production.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexp-identifier-names-static-semantics-stringvalue">
        <h1>Static Semantics: StringValue</h1>
        <emu-see-also-para op="StringValue"></emu-see-also-para>
        <emu-grammar>
          RegExpIdentifierName[U] ::
            RegExpIdentifierStart[?U]
            RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
        </emu-grammar>
        <emu-alg>
          1. Return the String value consisting of the sequence of code units corresponding to |RegExpIdentifierName|. In determining the sequence any occurrences of `\\` |RegExpUnicodeEscapeSequence| are first replaced with the code point represented by the |RegExpUnicodeEscapeSequence| and then the code points of the entire |RegExpIdentifierName| are converted to code units by UTF16Encoding each code point.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-pattern-semantics">
      <h1>Pattern Semantics</h1>
      <p>A regular expression pattern is converted into an internal procedure using the process described below. An implementation is encouraged to use more efficient algorithms than the ones listed below, as long as the results are the same. The internal procedure is used as the value of a RegExp object's [[RegExpMatcher]] internal slot.</p>
      <p>A |Pattern| is either a BMP pattern or a Unicode pattern depending upon whether or not its associated flags contain a `"u"`. A BMP pattern matches against a String interpreted as consisting of a sequence of 16-bit values that are Unicode code points in the range of the Basic Multilingual Plane. A Unicode pattern matches against a String interpreted as consisting of Unicode code points encoded using UTF-16. In the context of describing the behaviour of a BMP pattern &ldquo;character&rdquo; means a single 16-bit Unicode BMP code point. In the context of describing the behaviour of a Unicode pattern &ldquo;character&rdquo; means a UTF-16 encoded code point (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>). In either context, &ldquo;character value&rdquo; means the numeric value of the corresponding non-encoded code point.</p>
      <p>The syntax and semantics of |Pattern| is defined as if the source code for the |Pattern| was a List of |SourceCharacter| values where each |SourceCharacter| corresponds to a Unicode code point. If a BMP pattern contains a non-BMP |SourceCharacter| the entire pattern is encoded using UTF-16 and the individual code units of that encoding are used as the elements of the List.</p>
      <emu-note>
        <p>For example, consider a pattern expressed in source text as the single non-BMP character U+1D11E (MUSICAL SYMBOL G CLEF). Interpreted as a Unicode pattern, it would be a single element (character) List consisting of the single code point 0x1D11E. However, interpreted as a BMP pattern, it is first UTF-16 encoded to produce a two element List consisting of the code units 0xD834 and 0xDD1E.</p>
        <p>Patterns are passed to the RegExp constructor as ECMAScript String values in which non-BMP characters are UTF-16 encoded. For example, the single character MUSICAL SYMBOL G CLEF pattern, expressed as a String value, is a String of length 2 whose elements were the code units 0xD834 and 0xDD1E. So no further translation of the string would be necessary to process it as a BMP pattern consisting of two pattern characters. However, to process it as a Unicode pattern UTF16Decode must be used in producing a List consisting of a single pattern character, the code point U+1D11E.</p>
        <p>An implementation may not actually perform such translations to or from UTF-16, but the semantics of this specification requires that the result of pattern matching be as if such translations were performed.</p>
      </emu-note>

      <emu-clause id="sec-notation">
        <h1>Notation</h1>
        <p>The descriptions below use the following variables:</p>
        <ul>
          <li>
            _Input_ is a List consisting of all of the characters, in order, of the String being matched by the regular expression pattern. Each character is either a code unit or a code point, depending upon the kind of pattern involved. The notation _Input_[_n_] means the _n_<sup>th</sup> character of _Input_, where _n_ can range between 0 (inclusive) and _InputLength_ (exclusive).
          </li>
          <li>
            _InputLength_ is the number of characters in _Input_.
          </li>
          <li>
            _NcapturingParens_ is the total number of left-capturing parentheses (i.e. the total number of <emu-grammar>Atom :: `(` GroupSpecifier Disjunction `)`</emu-grammar> Parse Nodes) in the pattern. A left-capturing parenthesis is any `(` pattern character that is matched by the `(` terminal of the <emu-grammar>Atom :: `(` GroupSpecifier Disjunction `)`</emu-grammar> production.
          </li>
          <li>
            _DotAll_ is *true* if the RegExp object's [[OriginalFlags]] internal slot contains `"s"` and otherwise is *false*.
          </li>
          <li>
            _IgnoreCase_ is *true* if the RegExp object's [[OriginalFlags]] internal slot contains `"i"` and otherwise is *false*.
          </li>
          <li>
            _Multiline_ is *true* if the RegExp object's [[OriginalFlags]] internal slot contains `"m"` and otherwise is *false*.
          </li>
          <li>
            _Unicode_ is *true* if the RegExp object's [[OriginalFlags]] internal slot contains `"u"` and otherwise is *false*.
          </li>
        </ul>
        <p>Furthermore, the descriptions below use the following internal data structures:</p>
        <ul>
          <li>
            A <em>CharSet</em> is a mathematical set of characters, either code units or code points depending up the state of the _Unicode_ flag. &ldquo;All characters&rdquo; means either all code unit values or all code point values also depending upon the state of _Unicode_.
          </li>
          <li>
            A <em>State</em> is an ordered pair (_endIndex_, _captures_) where _endIndex_ is an integer and _captures_ is a List of _NcapturingParens_ values. States are used to represent partial match states in the regular expression matching algorithms. The _endIndex_ is one plus the index of the last input character matched so far by the pattern, while _captures_ holds the results of capturing parentheses. The _n_<sup>th</sup> element of _captures_ is either a List that represents the value obtained by the _n_<sup>th</sup> set of capturing parentheses or *undefined* if the _n_<sup>th</sup> set of capturing parentheses hasn't been reached yet. Due to backtracking, many States may be in use at any time during the matching process.
          </li>
          <li>
            A <em>MatchResult</em> is either a State or the special token ~failure~ that indicates that the match failed.
          </li>
          <li>
            A <em>Continuation</em> procedure is an internal closure (i.e. an internal procedure with some arguments already bound to values) that takes one State argument and returns a MatchResult result. If an internal closure references variables which are bound in the function that creates the closure, the closure uses the values that these variables had at the time the closure was created. The Continuation attempts to match the remaining portion (specified by the closure's already-bound arguments) of the pattern against _Input_, starting at the intermediate state given by its State argument. If the match succeeds, the Continuation returns the final State that it reached; if the match fails, the Continuation returns ~failure~.
          </li>
          <li>
            A <em>Matcher</em> procedure is an internal closure that takes two arguments &mdash; a State and a Continuation &mdash; and returns a MatchResult result. A Matcher attempts to match a middle subpattern (specified by the closure's already-bound arguments) of the pattern against _Input_, starting at the intermediate state given by its State argument. The Continuation argument should be a closure that matches the rest of the pattern. After matching the subpattern of a pattern to obtain a new State, the Matcher then calls Continuation on that new State to test if the rest of the pattern can match as well. If it can, the Matcher returns the State returned by Continuation; if not, the Matcher may try different choices at its choice points, repeatedly calling Continuation until it either succeeds or all possibilities have been exhausted.
          </li>
          <li>
            An <em>AssertionTester</em> procedure is an internal closure that takes a State argument and returns a Boolean result. The assertion tester tests a specific condition (specified by the closure's already-bound arguments) against the current place in _Input_ and returns *true* if the condition matched or *false* if not.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-pattern">
        <h1>Pattern</h1>
        <p>The production <emu-grammar>Pattern :: Disjunction</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate |Disjunction| with +1 as its _direction_ argument to obtain a Matcher _m_.
          1. Return an internal closure that takes two arguments, a String _str_ and an integer _index_, and performs the following steps:
            1. Assert: _index_ &le; the length of _str_.
            1. If _Unicode_ is *true*, let _Input_ be a List consisting of the sequence of code points of _str_ interpreted as a UTF-16 encoded (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>) Unicode string. Otherwise, let _Input_ be a List consisting of the sequence of code units that are the elements of _str_. _Input_ will be used throughout the algorithms in <emu-xref href="#sec-pattern-semantics"></emu-xref>. Each element of _Input_ is considered to be a character.
            1. Let _InputLength_ be the number of characters contained in _Input_. This variable will be used throughout the algorithms in <emu-xref href="#sec-pattern-semantics"></emu-xref>.
            1. Let _listIndex_ be the index into _Input_ of the character that was obtained from element _index_ of _str_.
            1. Let _c_ be a Continuation that always returns its State argument as a successful MatchResult.
            1. Let _cap_ be a List of _NcapturingParens_ *undefined* values, indexed 1 through _NcapturingParens_.
            1. Let _x_ be the State (_listIndex_, _cap_).
            1. Call _m_(_x_, _c_) and return its result.
        </emu-alg>
        <emu-note>
          <p>A Pattern evaluates (&ldquo;compiles&rdquo;) to an internal procedure value. RegExpBuiltinExec can then apply this procedure to a String and an offset within the String to determine whether the pattern would match starting at exactly that offset within the String, and, if it does match, what the values of the capturing parentheses would be. The algorithms in <emu-xref href="#sec-pattern-semantics"></emu-xref> are designed so that compiling a pattern may throw a *SyntaxError* exception; on the other hand, once the pattern is successfully compiled, applying the resulting internal procedure to find a match in a String cannot throw an exception (except for any host-defined exceptions that can occur anywhere such as out-of-memory).</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-disjunction">
        <h1>Disjunction</h1>
        <p>With parameter _direction_.</p>
        <p>The production <emu-grammar>Disjunction :: Alternative</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate |Alternative| with argument _direction_ to obtain a Matcher _m_.
          1. Return _m_.
        </emu-alg>
        <p>The production <emu-grammar>Disjunction :: Alternative `|` Disjunction</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate |Alternative| with argument _direction_ to obtain a Matcher _m1_.
          1. Evaluate |Disjunction| with argument _direction_ to obtain a Matcher _m2_.
          1. Return an internal Matcher closure that takes two arguments, a State _x_ and a Continuation _c_, and performs the following steps when evaluated:
            1. Call _m1_(_x_, _c_) and let _r_ be its result.
            1. If _r_ is not ~failure~, return _r_.
            1. Call _m2_(_x_, _c_) and return its result.
        </emu-alg>
        <emu-note>
          <p>The `|` regular expression operator separates two alternatives. The pattern first tries to match the left |Alternative| (followed by the sequel of the regular expression); if it fails, it tries to match the right |Disjunction| (followed by the sequel of the regular expression). If the left |Alternative|, the right |Disjunction|, and the sequel all have choice points, all choices in the sequel are tried before moving on to the next choice in the left |Alternative|. If choices in the left |Alternative| are exhausted, the right |Disjunction| is tried instead of the left |Alternative|. Any capturing parentheses inside a portion of the pattern skipped by `|` produce *undefined* values instead of Strings. Thus, for example,</p>
          <pre><code class="javascript">/a|ab/.exec("abc")</code></pre>
          <p>returns the result `"a"` and not `"ab"`. Moreover,</p>
          <pre><code class="javascript">/((a)|(ab))((c)|(bc))/.exec("abc")</code></pre>
          <p>returns the array</p>
          <pre><code class="javascript">["abc", "a", "a", undefined, "bc", undefined, "bc"]</code></pre>
          <p>and not</p>
          <pre><code class="javascript">["abc", "ab", undefined, "ab", "c", "c", undefined]</code></pre>
          <p>The order in which the two alternatives are tried is independent of the value of _direction_.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-alternative">
        <h1>Alternative</h1>
        <p>With parameter _direction_.</p>
        <p>The production <emu-grammar>Alternative :: [empty]</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return a Matcher that takes two arguments, a State _x_ and a Continuation _c_, and returns the result of calling _c_(_x_).
        </emu-alg>
        <p>The production <emu-grammar>Alternative :: Alternative Term</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate |Alternative| with argument _direction_ to obtain a Matcher _m1_.
          1. Evaluate |Term| with argument _direction_ to obtain a Matcher _m2_.
          1. If _direction_ is equal to +1, then
            1. Return an internal Matcher closure that takes two arguments, a State _x_ and a Continuation _c_, and performs the following steps when evaluated:
              1. Let _d_ be a Continuation that takes a State argument _y_ and returns the result of calling _m2_(_y_, _c_).
              1. Call _m1_(_x_, _d_) and return its result.
          1. Else,
            1. Assert: _direction_ is equal to -1.
            1. Return an internal Matcher closure that takes two arguments, a State _x_ and a Continuation _c_, and performs the following steps when evaluated:
              1. Let _d_ be a Continuation that takes a State argument _y_ and returns the result of calling _m1_(_y_, _c_).
              1. Call _m2_(_x_, _d_) and return its result.
        </emu-alg>
        <emu-note>
          <p>Consecutive |Term|s try to simultaneously match consecutive portions of _Input_. When _direction_ is equal to +1, if the left |Alternative|, the right |Term|, and the sequel of the regular expression all have choice points, all choices in the sequel are tried before moving on to the next choice in the right |Term|, and all choices in the right |Term| are tried before moving on to the next choice in the left |Alternative|. When _direction_ is equal to -1, the evaluation order of |Alternative| and |Term| are reversed.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-term">
        <h1>Term</h1>
        <p>With parameter _direction_.</p>
        <p>The production <emu-grammar>Term :: Assertion</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return an internal Matcher closure that takes two arguments, a State _x_ and a Continuation _c_, and performs the following steps when evaluated:
            1. Evaluate |Assertion| to obtain an AssertionTester _t_.
            1. Call _t_(_x_) and let _r_ be the resulting Boolean value.
            1. If _r_ is *false*, return ~failure~.
            1. Call _c_(_x_) and return its result.
        </emu-alg>
        <emu-note>
          <p>The AssertionTester is independent of _direction_.</p>
        </emu-note>
        <p>The production <emu-grammar>Term :: Atom</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return the Matcher that is the result of evaluating |Atom| with argument _direction_.
        </emu-alg>
        <p>The production <emu-grammar>Term :: Atom Quantifier</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate |Atom| with argument _direction_ to obtain a Matcher _m_.
          1. Evaluate |Quantifier| to obtain the three results: an integer _min_, an integer (or &infin;) _max_, and Boolean _greedy_.
          1. Assert: If _max_ is finite, then _max_ is not less than _min_.
          1. Let _parenIndex_ be the number of left-capturing parentheses in the entire regular expression that occur to the left of this |Term|. This is the total number of <emu-grammar>Atom :: `(` GroupSpecifier Disjunction `)`</emu-grammar> Parse Nodes prior to or enclosing this |Term|.
          1. Let _parenCount_ be the number of left-capturing parentheses in |Atom|. This is the total number of <emu-grammar>Atom :: `(` GroupSpecifier Disjunction `)`</emu-grammar> Parse Nodes enclosed by |Atom|.
          1. Return an internal Matcher closure that takes two arguments, a State _x_ and a Continuation _c_, and performs the following steps when evaluated:
            1. Call RepeatMatcher(_m_, _min_, _max_, _greedy_, _x_, _c_, _parenIndex_, _parenCount_) and return its result.
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-repeatmatcher-abstract-operation" aoid="RepeatMatcher">
          <h1>Runtime Semantics: RepeatMatcher ( _m_, _min_, _max_, _greedy_, _x_, _c_, _parenIndex_, _parenCount_ )</h1>
          <p>The abstract operation RepeatMatcher takes eight parameters, a Matcher _m_, an integer _min_, an integer (or &infin;) _max_, a Boolean _greedy_, a State _x_, a Continuation _c_, an integer _parenIndex_, and an integer _parenCount_, and performs the following steps:</p>
          <emu-alg>
            1. If _max_ is zero, return _c_(_x_).
            1. Let _d_ be an internal Continuation closure that takes one State argument _y_ and performs the following steps when evaluated:
              1. If _min_ is zero and _y_'s _endIndex_ is equal to _x_'s _endIndex_, return ~failure~.
              1. If _min_ is zero, let _min2_ be zero; otherwise let _min2_ be _min_ - 1.
              1. If _max_ is &infin;, let _max2_ be &infin;; otherwise let _max2_ be _max_ - 1.
              1. Call RepeatMatcher(_m_, _min2_, _max2_, _greedy_, _y_, _c_, _parenIndex_, _parenCount_) and return its result.
            1. Let _cap_ be a copy of _x_'s _captures_ List.
            1. For each integer _k_ that satisfies _parenIndex_ &lt; _k_ and _k_ &le; _parenIndex_ + _parenCount_, set _cap_[_k_] to *undefined*.
            1. Let _e_ be _x_'s _endIndex_.
            1. Let _xr_ be the State (_e_, _cap_).
            1. If _min_ is not zero, return _m_(_xr_, _d_).
            1. If _greedy_ is *false*, then
              1. Call _c_(_x_) and let _z_ be its result.
              1. If _z_ is not ~failure~, return _z_.
              1. Call _m_(_xr_, _d_) and return its result.
            1. Call _m_(_xr_, _d_) and let _z_ be its result.
            1. If _z_ is not ~failure~, return _z_.
            1. Call _c_(_x_) and return its result.
          </emu-alg>
          <emu-note>
            <p>An |Atom| followed by a |Quantifier| is repeated the number of times specified by the |Quantifier|. A |Quantifier| can be non-greedy, in which case the |Atom| pattern is repeated as few times as possible while still matching the sequel, or it can be greedy, in which case the |Atom| pattern is repeated as many times as possible while still matching the sequel. The |Atom| pattern is repeated rather than the input character sequence that it matches, so different repetitions of the |Atom| can match different input substrings.</p>
          </emu-note>
          <emu-note>
            <p>If the |Atom| and the sequel of the regular expression all have choice points, the |Atom| is first matched as many (or as few, if non-greedy) times as possible. All choices in the sequel are tried before moving on to the next choice in the last repetition of |Atom|. All choices in the last (n<sup>th</sup>) repetition of |Atom| are tried before moving on to the next choice in the next-to-last (n - 1)<sup>st</sup> repetition of |Atom|; at which point it may turn out that more or fewer repetitions of |Atom| are now possible; these are exhausted (again, starting with either as few or as many as possible) before moving on to the next choice in the (n - 1)<sup>st</sup> repetition of |Atom| and so on.</p>
            <p>Compare</p>
            <pre><code class="javascript">/a[a-z]{2,4}/.exec("abcdefghi")</code></pre>
            <p>which returns `"abcde"` with</p>
            <pre><code class="javascript">/a[a-z]{2,4}?/.exec("abcdefghi")</code></pre>
            <p>which returns `"abc"`.</p>
            <p>Consider also</p>
            <pre><code class="javascript">/(aa|aabaac|ba|b|c)*/.exec("aabaac")</code></pre>
            <p>which, by the choice point ordering above, returns the array</p>
            <pre><code class="javascript">["aaba", "ba"]</code></pre>
            <p>and not any of:</p>
            <pre><code class="javascript">
              ["aabaac", "aabaac"]
              ["aabaac", "c"]
            </code></pre>
            <p>The above ordering of choice points can be used to write a regular expression that calculates the greatest common divisor of two numbers (represented in unary notation). The following example calculates the gcd of 10 and 15:</p>
            <pre><code class="javascript">"aaaaaaaaaa,aaaaaaaaaaaaaaa".replace(/^(a+)\1*,\1+$/, "$1")</code></pre>
            <p>which returns the gcd in unary notation `"aaaaa"`.</p>
          </emu-note>
          <emu-note>
            <p>Step 4 of the RepeatMatcher clears |Atom|'s captures each time |Atom| is repeated. We can see its behaviour in the regular expression</p>
            <pre><code class="javascript">/(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac")</code></pre>
            <p>which returns the array</p>
            <pre><code class="javascript">["zaacbbbcac", "z", "ac", "a", undefined, "c"]</code></pre>
            <p>and not</p>
            <pre><code class="javascript">["zaacbbbcac", "z", "ac", "a", "bbb", "c"]</code></pre>
            <p>because each iteration of the outermost `*` clears all captured Strings contained in the quantified |Atom|, which in this case includes capture Strings numbered 2, 3, 4, and 5.</p>
          </emu-note>
          <emu-note>
            <p>Step 1 of the RepeatMatcher's _d_ closure states that, once the minimum number of repetitions has been satisfied, any more expansions of |Atom| that match the empty character sequence are not considered for further repetitions. This prevents the regular expression engine from falling into an infinite loop on patterns such as:</p>
            <pre><code class="javascript">/(a*)*/.exec("b")</code></pre>
            <p>or the slightly more complicated:</p>
            <pre><code class="javascript">/(a*)b\1+/.exec("baaaac")</code></pre>
            <p>which returns the array</p>
            <pre><code class="javascript">["b", ""]</code></pre>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-assertion">
        <h1>Assertion</h1>
        <p>The production <emu-grammar>Assertion :: `^`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return an internal AssertionTester closure that takes a State argument _x_ and performs the following steps when evaluated:
            1. Let _e_ be _x_'s _endIndex_.
            1. If _e_ is zero, return *true*.
            1. If _Multiline_ is *false*, return *false*.
            1. If the character _Input_[_e_ - 1] is one of |LineTerminator|, return *true*.
            1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>Even when the `y` flag is used with a pattern, `^` always matches only at the beginning of _Input_, or (if _Multiline_ is *true*) at the beginning of a line.</p>
        </emu-note>
        <p>The production <emu-grammar>Assertion :: `$`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return an internal AssertionTester closure that takes a State argument _x_ and performs the following steps when evaluated:
            1. Let _e_ be _x_'s _endIndex_.
            1. If _e_ is equal to _InputLength_, return *true*.
            1. If _Multiline_ is *false*, return *false*.
            1. If the character _Input_[_e_] is one of |LineTerminator|, return *true*.
            1. Return *false*.
        </emu-alg>
        <p>The production <emu-grammar>Assertion :: `\` `b`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return an internal AssertionTester closure that takes a State argument _x_ and performs the following steps when evaluated:
            1. Let _e_ be _x_'s _endIndex_.
            1. Call IsWordChar(_e_ - 1) and let _a_ be the Boolean result.
            1. Call IsWordChar(_e_) and let _b_ be the Boolean result.
            1. If _a_ is *true* and _b_ is *false*, return *true*.
            1. If _a_ is *false* and _b_ is *true*, return *true*.
            1. Return *false*.
        </emu-alg>
        <p>The production <emu-grammar>Assertion :: `\` `B`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return an internal AssertionTester closure that takes a State argument _x_ and performs the following steps when evaluated:
            1. Let _e_ be _x_'s _endIndex_.
            1. Call IsWordChar(_e_ - 1) and let _a_ be the Boolean result.
            1. Call IsWordChar(_e_) and let _b_ be the Boolean result.
            1. If _a_ is *true* and _b_ is *false*, return *false*.
            1. If _a_ is *false* and _b_ is *true*, return *false*.
            1. Return *true*.
        </emu-alg>
        <p>The production <emu-grammar>Assertion :: `(` `?` `=` Disjunction `)`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate |Disjunction| with +1 as its _direction_ argument to obtain a Matcher _m_.
          1. Return an internal Matcher closure that takes two arguments, a State _x_ and a Continuation _c_, and performs the following steps:
            1. Let _d_ be a Continuation that always returns its State argument as a successful MatchResult.
            1. Call _m_(_x_, _d_) and let _r_ be its result.
            1. If _r_ is ~failure~, return ~failure~.
            1. Let _y_ be _r_'s State.
            1. Let _cap_ be _y_'s _captures_ List.
            1. Let _xe_ be _x_'s _endIndex_.
            1. Let _z_ be the State (_xe_, _cap_).
            1. Call _c_(_z_) and return its result.
        </emu-alg>
        <p>The production <emu-grammar>Assertion :: `(` `?` `!` Disjunction `)`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate |Disjunction| with +1 as its _direction_ argument to obtain a Matcher _m_.
          1. Return an internal Matcher closure that takes two arguments, a State _x_ and a Continuation _c_, and performs the following steps:
            1. Let _d_ be a Continuation that always returns its State argument as a successful MatchResult.
            1. Call _m_(_x_, _d_) and let _r_ be its result.
            1. If _r_ is not ~failure~, return ~failure~.
            1. Call _c_(_x_) and return its result.
        </emu-alg>
        <p>The production <emu-grammar>Assertion :: `(` `?` `&lt;=` Disjunction `)`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate |Disjunction| with -1 as its _direction_ argument to obtain a Matcher _m_.
          1. Return an internal Matcher closure that takes two arguments, a State _x_ and a Continuation _c_, and performs the following steps:
            1. Let _d_ be a Continuation that always returns its State argument as a successful MatchResult.
            1. Call _m_(_x_, _d_) and let _r_ be its result.
            1. If _r_ is ~failure~, return ~failure~.
            1. Let _y_ be _r_'s State.
            1. Let _cap_ be _y_'s _captures_ List.
            1. Let _xe_ be _x_'s _endIndex_.
            1. Let _z_ be the State (_xe_, _cap_).
            1. Call _c_(_z_) and return its result.
        </emu-alg>
        <p>The production <emu-grammar>Assertion :: `(` `?` `&lt;!` Disjunction `)`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate |Disjunction| with -1 as its _direction_ argument to obtain a Matcher _m_.
          1. Return an internal Matcher closure that takes two arguments, a State _x_ and a Continuation _c_, and performs the following steps:
            1. Let _d_ be a Continuation that always returns its State argument as a successful MatchResult.
            1. Call _m_(_x_, _d_) and let _r_ be its result.
            1. If _r_ is not ~failure~, return ~failure~.
            1. Call _c_(_x_) and return its result.
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-wordcharacters-abstract-operation" aoid="WordCharacters">
          <h1>Runtime Semantics: WordCharacters ( )</h1>
          <p>The abstract operation WordCharacters performs the following steps:</p>
          <emu-alg>
            1. Let _A_ be a set of characters containing the sixty-three characters:
            <figure>
              <table class="lightweight-table">
                <tbody>
                  <tr>
                    <td>
                      `a`
                    </td>
                    <td>
                      `b`
                    </td>
                    <td>
                      `c`
                    </td>
                    <td>
                      `d`
                    </td>
                    <td>
                      `e`
                    </td>
                    <td>
                      `f`
                    </td>
                    <td>
                      `g`
                    </td>
                    <td>
                      `h`
                    </td>
                    <td>
                      `i`
                    </td>
                    <td>
                      `j`
                    </td>
                    <td>
                      `k`
                    </td>
                    <td>
                      `l`
                    </td>
                    <td>
                      `m`
                    </td>
                    <td>
                      `n`
                    </td>
                    <td>
                      `o`
                    </td>
                    <td>
                      `p`
                    </td>
                    <td>
                      `q`
                    </td>
                    <td>
                      `r`
                    </td>
                    <td>
                      `s`
                    </td>
                    <td>
                      `t`
                    </td>
                    <td>
                      `u`
                    </td>
                    <td>
                      `v`
                    </td>
                    <td>
                      `w`
                    </td>
                    <td>
                      `x`
                    </td>
                    <td>
                      `y`
                    </td>
                    <td>
                      `z`
                    </td>
                  </tr>
                  <tr>
                    <td>
                      `A`
                    </td>
                    <td>
                      `B`
                    </td>
                    <td>
                      `C`
                    </td>
                    <td>
                      `D`
                    </td>
                    <td>
                      `E`
                    </td>
                    <td>
                      `F`
                    </td>
                    <td>
                      `G`
                    </td>
                    <td>
                      `H`
                    </td>
                    <td>
                      `I`
                    </td>
                    <td>
                      `J`
                    </td>
                    <td>
                      `K`
                    </td>
                    <td>
                      `L`
                    </td>
                    <td>
                      `M`
                    </td>
                    <td>
                      `N`
                    </td>
                    <td>
                      `O`
                    </td>
                    <td>
                      `P`
                    </td>
                    <td>
                      `Q`
                    </td>
                    <td>
                      `R`
                    </td>
                    <td>
                      `S`
                    </td>
                    <td>
                      `T`
                    </td>
                    <td>
                      `U`
                    </td>
                    <td>
                      `V`
                    </td>
                    <td>
                      `W`
                    </td>
                    <td>
                      `X`
                    </td>
                    <td>
                      `Y`
                    </td>
                    <td>
                      `Z`
                    </td>
                  </tr>
                  <tr>
                    <td>
                      `0`
                    </td>
                    <td>
                      `1`
                    </td>
                    <td>
                      `2`
                    </td>
                    <td>
                      `3`
                    </td>
                    <td>
                      `4`
                    </td>
                    <td>
                      `5`
                    </td>
                    <td>
                      `6`
                    </td>
                    <td>
                      `7`
                    </td>
                    <td>
                      `8`
                    </td>
                    <td>
                      `9`
                    </td>
                    <td>
                      `_`
                    </td>
                    <td>
                    </td>
                    <td>
                    </td>
                    <td>
                    </td>
                    <td>
                    </td>
                    <td>
                    </td>
                    <td>
                    </td>
                    <td>
                    </td>
                    <td>
                    </td>
                    <td>
                    </td>
                    <td>
                    </td>
                    <td>
                    </td>
                    <td>
                    </td>
                    <td>
                    </td>
                    <td>
                    </td>
                    <td>
                    </td>
                  </tr>
                </tbody>
              </table>
            </figure>
            1. Let _U_ be an empty set.
            1. For each character _c_ not in set _A_ where Canonicalize(_c_) is in _A_, add _c_ to _U_.
            1. Assert: Unless _Unicode_ and _IgnoreCase_ are both *true*, _U_ is empty.
            1. Add the characters in set _U_ to set _A_.
            1. Return _A_.
          </emu-alg>
        </emu-clause>
        <emu-clause id="sec-runtime-semantics-iswordchar-abstract-operation" aoid="IsWordChar">
          <h1>Runtime Semantics: IsWordChar ( _e_ )</h1>
          <p>The abstract operation IsWordChar takes an integer parameter _e_ and performs the following steps:</p>
          <emu-alg>
            1. If _e_ is -1 or _e_ is _InputLength_, return *false*.
            1. Let _c_ be the character _Input_[_e_].
            1. Let _wordChars_ be the result of ! WordCharacters().
            1. If _c_ is in _wordChars_, return *true*.
            1. Return *false*.
          </emu-alg>
        </emu-clause>
      </emu-clause>
      <emu-clause id="sec-quantifier">
        <h1>Quantifier</h1>
        <p>The production <emu-grammar>Quantifier :: QuantifierPrefix</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate |QuantifierPrefix| to obtain the two results: an integer _min_ and an integer (or &infin;) _max_.
          1. Return the three results _min_, _max_, and *true*.
        </emu-alg>
        <p>The production <emu-grammar>Quantifier :: QuantifierPrefix `?`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate |QuantifierPrefix| to obtain the two results: an integer _min_ and an integer (or &infin;) _max_.
          1. Return the three results _min_, _max_, and *false*.
        </emu-alg>
        <p>The production <emu-grammar>QuantifierPrefix :: `*`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return the two results 0 and &infin;.
        </emu-alg>
        <p>The production <emu-grammar>QuantifierPrefix :: `+`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return the two results 1 and &infin;.
        </emu-alg>
        <p>The production <emu-grammar>QuantifierPrefix :: `?`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return the two results 0 and 1.
        </emu-alg>
        <p>The production <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `}`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Let _i_ be the MV of |DecimalDigits| (see <emu-xref href="#sec-literals-numeric-literals"></emu-xref>).
          1. Return the two results _i_ and _i_.
        </emu-alg>
        <p>The production <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `,` `}`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Let _i_ be the MV of |DecimalDigits|.
          1. Return the two results _i_ and &infin;.
        </emu-alg>
        <p>The production <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `,` DecimalDigits `}`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Let _i_ be the MV of the first |DecimalDigits|.
          1. Let _j_ be the MV of the second |DecimalDigits|.
          1. Return the two results _i_ and _j_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-atom">
        <h1>Atom</h1>
        <p>With parameter _direction_.</p>
        <p>The production <emu-grammar>Atom :: PatternCharacter</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Let _ch_ be the character matched by |PatternCharacter|.
          1. Let _A_ be a one-element CharSet containing the character _ch_.
          1. Call CharacterSetMatcher(_A_, *false*, _direction_) and return its Matcher result.
        </emu-alg>
        <p>The production <emu-grammar>Atom :: `.`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. If _DotAll_ is *true*, then
            1. Let _A_ be the set of all characters.
          1. Otherwise, let _A_ be the set of all characters except |LineTerminator|.
          1. Call CharacterSetMatcher(_A_, *false*, _direction_) and return its Matcher result.
        </emu-alg>
        <p>The production <emu-grammar>Atom :: `\` AtomEscape</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return the Matcher that is the result of evaluating |AtomEscape| with argument _direction_.
        </emu-alg>
        <p>The production <emu-grammar>Atom :: CharacterClass</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate |CharacterClass| to obtain a CharSet _A_ and a Boolean _invert_.
          1. Call CharacterSetMatcher(_A_, _invert_, _direction_) and return its Matcher result.
        </emu-alg>
        <p>The production <emu-grammar>Atom :: `(` GroupSpecifier Disjunction `)`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate |Disjunction| with argument _direction_ to obtain a Matcher _m_.
          1. Let _parenIndex_ be the number of left-capturing parentheses in the entire regular expression that occur to the left of this |Atom|. This is the total number of <emu-grammar>Atom :: `(` GroupSpecifier Disjunction `)`</emu-grammar> Parse Nodes prior to or enclosing this |Atom|.
          1. Return an internal Matcher closure that takes two arguments, a State _x_ and a Continuation _c_, and performs the following steps:
            1. Let _d_ be an internal Continuation closure that takes one State argument _y_ and performs the following steps:
              1. Let _cap_ be a copy of _y_'s _captures_ List.
              1. Let _xe_ be _x_'s _endIndex_.
              1. Let _ye_ be _y_'s _endIndex_.
              1. If _direction_ is equal to +1, then
                1. Assert: _xe_ &le; _ye_.
                1. Let _s_ be a new List whose elements are the characters of _Input_ at indices _xe_ (inclusive) through _ye_ (exclusive).
              1. Else,
                1. Assert: _direction_ is equal to -1.
                1. Assert: _ye_ &le; _xe_.
                1. Let _s_ be a new List whose elements are the characters of _Input_ at indices _ye_ (inclusive) through _xe_ (exclusive).
              1. Set _cap_[_parenIndex_ + 1] to _s_.
              1. Let _z_ be the State (_ye_, _cap_).
              1. Call _c_(_z_) and return its result.
            1. Call _m_(_x_, _d_) and return its result.
        </emu-alg>
        <p>The production <emu-grammar>Atom :: `(` `?` `:` Disjunction `)`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return the Matcher that is the result of evaluating |Disjunction| with argument _direction_.
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-charactersetmatcher-abstract-operation" aoid="CharacterSetMatcher">
          <h1>Runtime Semantics: CharacterSetMatcher ( _A_, _invert_, _direction_ )</h1>
          <p>The abstract operation CharacterSetMatcher takes three arguments, a CharSet _A_, a Boolean flag _invert_, and an integer _direction_, and performs the following steps:</p>
          <emu-alg>
            1. Return an internal Matcher closure that takes two arguments, a State _x_ and a Continuation _c_, and performs the following steps when evaluated:
              1. Let _e_ be _x_'s _endIndex_.
              1. Let _f_ be _e_ + _direction_.
              1. If _f_ &lt; 0 or _f_ &gt; _InputLength_, return ~failure~.
              1. Let _index_ be min(_e_, _f_).
              1. Let _ch_ be the character _Input_[_index_].
              1. Let _cc_ be Canonicalize(_ch_).
              1. If _invert_ is *false*, then
                1. If there does not exist a member _a_ of set _A_ such that Canonicalize(_a_) is _cc_, return ~failure~.
              1. Else,
                1. Assert: _invert_ is *true*.
                1. If there exists a member _a_ of set _A_ such that Canonicalize(_a_) is _cc_, return ~failure~.
              1. Let _cap_ be _x_'s _captures_ List.
              1. Let _y_ be the State (_f_, _cap_).
              1. Call _c_(_y_) and return its result.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-canonicalize-ch" aoid="Canonicalize">
          <h1>Runtime Semantics: Canonicalize ( _ch_ )</h1>
          <p>The abstract operation Canonicalize takes a character parameter _ch_ and performs the following steps:</p>
          <emu-alg>
            1. If _IgnoreCase_ is *false*, return _ch_.
            1. If _Unicode_ is *true*, then
              1. If the file CaseFolding.txt of the Unicode Character Database provides a simple or common case folding mapping for _ch_, return the result of applying that mapping to _ch_.
              1. Return _ch_.
            1. Else,
              1. Assert: _ch_ is a UTF-16 code unit.
              1. Let _s_ be the String value consisting of the single code unit _ch_.
              1. Let _u_ be the same result produced as if by performing the algorithm for `String.prototype.toUpperCase` using _s_ as the *this* value.
              1. Assert: Type(_u_) is String.
              1. If _u_ does not consist of a single code unit, return _ch_.
              1. Let _cu_ be _u_'s single code unit element.
              1. If the numeric value of _ch_ &ge; 128 and the numeric value of _cu_ &lt; 128, return _ch_.
              1. Return _cu_.
          </emu-alg>
          <emu-note>
            <p>Parentheses of the form `(` |Disjunction| `)` serve both to group the components of the |Disjunction| pattern together and to save the result of the match. The result can be used either in a backreference (`\\` followed by a nonzero decimal number), referenced in a replace String, or returned as part of an array from the regular expression matching internal procedure. To inhibit the capturing behaviour of parentheses, use the form `(?:` |Disjunction| `)` instead.</p>
          </emu-note>
          <emu-note>
            <p>The form `(?=` |Disjunction| `)` specifies a zero-width positive lookahead. In order for it to succeed, the pattern inside |Disjunction| must match at the current position, but the current position is not advanced before matching the sequel. If |Disjunction| can match at the current position in several ways, only the first one is tried. Unlike other regular expression operators, there is no backtracking into a `(?=` form (this unusual behaviour is inherited from Perl). This only matters when the |Disjunction| contains capturing parentheses and the sequel of the pattern contains backreferences to those captures.</p>
            <p>For example,</p>
            <pre><code class="javascript">/(?=(a+))/.exec("baaabac")</code></pre>
            <p>matches the empty String immediately after the first `b` and therefore returns the array:</p>
            <pre><code class="javascript">["", "aaa"]</code></pre>
            <p>To illustrate the lack of backtracking into the lookahead, consider:</p>
            <pre><code class="javascript">/(?=(a+))a*b\1/.exec("baaabac")</code></pre>
            <p>This expression returns</p>
            <pre><code class="javascript">["aba", "a"]</code></pre>
            <p>and not:</p>
            <pre><code class="javascript">["aaaba", "a"]</code></pre>
          </emu-note>
          <emu-note>
            <p>The form `(?!` |Disjunction| `)` specifies a zero-width negative lookahead. In order for it to succeed, the pattern inside |Disjunction| must fail to match at the current position. The current position is not advanced before matching the sequel. |Disjunction| can contain capturing parentheses, but backreferences to them only make sense from within |Disjunction| itself. Backreferences to these capturing parentheses from elsewhere in the pattern always return *undefined* because the negative lookahead must fail for the pattern to succeed. For example,</p>
            <pre><code class="javascript">/(.*?)a(?!(a+)b\2c)\2(.*)/.exec("baaabaac")</code></pre>
            <p>looks for an `a` not immediately followed by some positive number n of `a`'s, a `b`, another n `a`'s (specified by the first `\\2`) and a `c`. The second `\\2` is outside the negative lookahead, so it matches against *undefined* and therefore always succeeds. The whole expression returns the array:</p>
            <pre><code class="javascript">["baaabaac", "ba", undefined, "abaac"]</code></pre>
          </emu-note>
          <emu-note>
            <p>In case-insignificant matches when _Unicode_ is *true*, all characters are implicitly case-folded using the simple mapping provided by the Unicode standard immediately before they are compared. The simple mapping always maps to a single code point, so it does not map, for example, `"&szlig;"` (U+00DF) to `"SS"`. It may however map a code point outside the Basic Latin range to a character within, for example, `"&#x17f;"` (U+017F) to `"s"`. Such characters are not mapped if _Unicode_ is *false*. This prevents Unicode code points such as U+017F and U+212A from matching regular expressions such as `/[a-z]/i`, but they will match `/[a-z]/ui`.</p>
          </emu-note>
        </emu-clause>
        <emu-clause id="sec-runtime-semantics-unicodematchproperty-p" aoid="UnicodeMatchProperty">
          <h1>Runtime Semantics: UnicodeMatchProperty ( _p_ )</h1>
          <p>The abstract operation UnicodeMatchProperty takes a parameter _p_ that is a List of Unicode code points and performs the following steps:</p>
          <emu-alg>
            1. Assert: _p_ is a List of Unicode code points that is identical to a List of Unicode code points that is a Unicode property name or property alias listed in the &ldquo;Property name and aliases&rdquo; column of <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref> or <emu-xref href="#table-binary-unicode-properties"></emu-xref>.
            1. Let _c_ be the canonical property name of _p_ as given in the &ldquo;Canonical property name&rdquo; column of the corresponding row.
            1. Return the List of Unicode code points of _c_.
          </emu-alg>
          <p>Implementations must support the Unicode property names and aliases listed in <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref> and <emu-xref href="#table-binary-unicode-properties"></emu-xref>. To ensure interoperability, implementations must not support any other property names or aliases.</p>
          <emu-note>
            <p>For example, `Script_Extensions` (property name) and `scx` (property alias) are valid, but `script_extensions` or `Scx` aren't.</p>
          </emu-note>
          <emu-note>
            <p>The listed properties form a superset of what <a href="https://unicode.org/reports/tr18/#RL1.2">UTS18 RL1.2</a> requires.</p>
          </emu-note>
          <emu-import href="table-nonbinary-unicode-properties.html"></emu-import>
          <emu-import href="table-binary-unicode-properties.html"></emu-import>
        </emu-clause>
        <emu-clause id="sec-runtime-semantics-unicodematchpropertyvalue-p-v" aoid="UnicodeMatchPropertyValue">
          <h1>Runtime Semantics: UnicodeMatchPropertyValue ( _p_, _v_ )</h1>
          <p>The abstract operation UnicodeMatchPropertyValue takes two parameters _p_ and _v_, each of which is a List of Unicode code points, and performs the following steps:</p>
          <emu-alg>
            1. Assert: _p_ is a List of Unicode code points that is identical to a List of Unicode code points that is a canonical, unaliased Unicode property name listed in the &ldquo;Canonical property name&rdquo; column of <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref>.
            1. Assert: _v_ is a List of Unicode code points that is identical to a List of Unicode code points that is a property value or property value alias for Unicode property _p_ listed in the &ldquo;Property value and aliases&rdquo; column of <emu-xref href="#table-unicode-general-category-values"></emu-xref> or <emu-xref href="#table-unicode-script-values"></emu-xref>.
            1. Let _value_ be the canonical property value of _v_ as given in the &ldquo;Canonical property value&rdquo; column of the corresponding row.
            1. Return the List of Unicode code points of _value_.
          </emu-alg>
          <p>Implementations must support the Unicode property value names and aliases listed in <emu-xref href="#table-unicode-general-category-values"></emu-xref> and <emu-xref href="#table-unicode-script-values"></emu-xref>. To ensure interoperability, implementations must not support any other property value names or aliases.</p>
          <emu-note>
            <p>For example, `Xpeo` and `Old_Persian` are valid `Script_Extensions` values, but `xpeo` and `Old Persian` aren't.</p>
          </emu-note>
          <emu-note>
            <p>This algorithm differs from <a href="https://unicode.org/reports/tr44/#Matching_Symbolic">the matching rules for symbolic values listed in UAX44</a>: case, <emu-xref href="#sec-white-space">white space</emu-xref>, U+002D (HYPHEN-MINUS), and U+005F (LOW LINE) are not ignored, and the `Is` prefix is not supported.</p>
          </emu-note>
          <emu-import href="table-unicode-general-category-values.html"></emu-import>
          <emu-import href="table-unicode-script-values.html"></emu-import>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-atomescape">
        <h1>AtomEscape</h1>
        <p>With parameter _direction_.</p>
        <p>The production <emu-grammar>AtomEscape :: DecimalEscape</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate |DecimalEscape| to obtain an integer _n_.
          1. Assert: _n_ &le; _NcapturingParens_.
          1. Call BackreferenceMatcher(_n_, _direction_) and return its Matcher result.
        </emu-alg>
        <p>The production <emu-grammar>AtomEscape :: CharacterEscape</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate |CharacterEscape| to obtain a character _ch_.
          1. Let _A_ be a one-element CharSet containing the character _ch_.
          1. Call CharacterSetMatcher(_A_, *false*, _direction_) and return its Matcher result.
        </emu-alg>
        <p>The production <emu-grammar>AtomEscape :: CharacterClassEscape</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate |CharacterClassEscape| to obtain a CharSet _A_.
          1. Call CharacterSetMatcher(_A_, *false*, _direction_) and return its Matcher result.
        </emu-alg>
        <emu-note>
          <p>An escape sequence of the form `\\` followed by a nonzero decimal number _n_ matches the result of the _n_th set of capturing parentheses (<emu-xref href="#sec-notation"></emu-xref>). It is an error if the regular expression has fewer than _n_ capturing parentheses. If the regular expression has _n_ or more capturing parentheses but the _n_th one is *undefined* because it has not captured anything, then the backreference always succeeds.</p>
        </emu-note>
        <p>The production <emu-grammar>AtomEscape :: `k` GroupName</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Search the enclosing |Pattern| for an instance of a |GroupSpecifier| for a |RegExpIdentifierName| which has a StringValue equal to the StringValue of the |RegExpIdentifierName| contained in |GroupName|.
          1. Assert: A unique such |GroupSpecifier| is found.
          1. Let _parenIndex_ be the number of left-capturing parentheses in the entire regular expression that occur to the left of the located |GroupSpecifier|. This is the total number of <emu-grammar>Atom :: `(` GroupSpecifier Disjunction `)`</emu-grammar> Parse Nodes prior to or enclosing the located |GroupSpecifier|.
          1. Call BackreferenceMatcher(_parenIndex_, _direction_) and return its Matcher result.
        </emu-alg>

        <emu-clause id="sec-backreference-matcher" aoid="BackreferenceMatcher">
          <h1>Runtime Semantics: BackreferenceMatcher ( _n_, _direction_ )</h1>
          <p>The abstract operation BackreferenceMatcher takes two arguments, an integer _n_ and an integer _direction_, and performs the following steps:</p>
          <emu-alg>
            1. Return an internal Matcher closure that takes two arguments, a State _x_ and a Continuation _c_, and performs the following steps:
              1. Let _cap_ be _x_'s _captures_ List.
              1. Let _s_ be _cap_[_n_].
              1. If _s_ is *undefined*, return _c_(_x_).
              1. Let _e_ be _x_'s _endIndex_.
              1. Let _len_ be the number of elements in _s_.
              1. Let _f_ be _e_ + _direction_ &times; _len_.
              1. If _f_ &lt; 0 or _f_ &gt; _InputLength_, return ~failure~.
              1. Let _g_ be min(_e_, _f_).
              1. If there exists an integer _i_ between 0 (inclusive) and _len_ (exclusive) such that Canonicalize(_s_[_i_]) is not the same character value as Canonicalize(_Input_[_g_ + _i_]), return ~failure~.
              1. Let _y_ be the State (_f_, _cap_).
              1. Call _c_(_y_) and return its result.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-characterescape">
        <h1>CharacterEscape</h1>
        <p>The |CharacterEscape| productions evaluate as follows:</p>
        <emu-grammar>
          CharacterEscape ::
            ControlEscape
            `c` ControlLetter
            `0` [lookahead &lt;! DecimalDigit]
            HexEscapeSequence
            RegExpUnicodeEscapeSequence
            IdentityEscape
        </emu-grammar>
        <emu-alg>
          1. Let _cv_ be the CharacterValue of this |CharacterEscape|.
          1. Return the character whose character value is _cv_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-decimalescape">
        <h1>DecimalEscape</h1>
        <p>The |DecimalEscape| productions evaluate as follows:</p>
        <emu-grammar>DecimalEscape :: NonZeroDigit DecimalDigits?</emu-grammar>
        <emu-alg>
          1. Return the CapturingGroupNumber of this |DecimalEscape|.
        </emu-alg>
        <emu-note>
          <p>If `\\` is followed by a decimal number _n_ whose first digit is not `0`, then the escape sequence is considered to be a backreference. It is an error if _n_ is greater than the total number of left-capturing parentheses in the entire regular expression.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-characterclassescape">
        <h1>CharacterClassEscape</h1>
        <p>The production <emu-grammar>CharacterClassEscape :: `d`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return the ten-element set of characters containing the characters `0` through `9` inclusive.
        </emu-alg>
        <p>The production <emu-grammar>CharacterClassEscape :: `D`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return the set of all characters not included in the set returned by <emu-grammar>CharacterClassEscape :: `d`</emu-grammar>.
        </emu-alg>
        <p>The production <emu-grammar>CharacterClassEscape :: `s`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return the set of characters containing the characters that are on the right-hand side of the |WhiteSpace| or |LineTerminator| productions.
        </emu-alg>
        <p>The production <emu-grammar>CharacterClassEscape :: `S`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return the set of all characters not included in the set returned by <emu-grammar>CharacterClassEscape :: `s`</emu-grammar> .
        </emu-alg>
        <p>The production <emu-grammar>CharacterClassEscape :: `w`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return the set of all characters returned by WordCharacters().
        </emu-alg>
        <p>The production <emu-grammar>CharacterClassEscape :: `W`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return the set of all characters not included in the set returned by <emu-grammar>CharacterClassEscape :: `w`</emu-grammar> .
        </emu-alg>
        <p>The production <emu-grammar>CharacterClassEscape :: `p{` UnicodePropertyValueExpression `}`</emu-grammar> evaluates by returning the CharSet containing all Unicode code points included in the CharSet returned by |UnicodePropertyValueExpression|.</p>
        <p>The production <emu-grammar>CharacterClassEscape :: `P{` UnicodePropertyValueExpression `}`</emu-grammar> evaluates by returning the CharSet containing all Unicode code points not included in the CharSet returned by |UnicodePropertyValueExpression|.</p>
        <p>The production <emu-grammar>UnicodePropertyValueExpression :: UnicodePropertyName `=` UnicodePropertyValue</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Let _ps_ be SourceText of |UnicodePropertyName|.
          1. Let _p_ be ! UnicodeMatchProperty(_ps_).
          1. Assert: _p_ is a Unicode property name or property alias listed in the &ldquo;Property name and aliases&rdquo; column of <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref>.
          1. Let _vs_ be SourceText of |UnicodePropertyValue|.
          1. Let _v_ be ! UnicodeMatchPropertyValue(_p_, _vs_).
          1. Return the CharSet containing all Unicode code points whose character database definition includes the property _p_ with value _v_.
        </emu-alg>
        <p>The production <emu-grammar>UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Let _s_ be SourceText of |LoneUnicodePropertyNameOrValue|.
          1. If ! UnicodeMatchPropertyValue(`"General_Category"`, _s_) is identical to a List of Unicode code points that is the name of a Unicode general category or general category alias listed in the &ldquo;Property value and aliases&rdquo; column of <emu-xref href="#table-unicode-general-category-values"></emu-xref>, then
            1. Return the CharSet containing all Unicode code points whose character database definition includes the property &ldquo;General_Category&rdquo; with value _s_.
          1. Let _p_ be ! UnicodeMatchProperty(_s_).
          1. Assert: _p_ is a binary Unicode property or binary property alias listed in the &ldquo;Property name and aliases&rdquo; column of <emu-xref href="#table-binary-unicode-properties"></emu-xref>.
          1. Return the CharSet containing all Unicode code points whose character database definition includes the property _p_ with value &ldquo;True&rdquo;.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-characterclass">
        <h1>CharacterClass</h1>
        <p>The production <emu-grammar>CharacterClass :: `[` ClassRanges `]`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate |ClassRanges| to obtain a CharSet _A_.
          1. Return the two results _A_ and *false*.
        </emu-alg>
        <p>The production <emu-grammar>CharacterClass :: `[` `^` ClassRanges `]`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate |ClassRanges| to obtain a CharSet _A_.
          1. Return the two results _A_ and *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-classranges">
        <h1>ClassRanges</h1>
        <p>The production <emu-grammar>ClassRanges :: [empty]</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return the empty CharSet.
        </emu-alg>
        <p>The production <emu-grammar>ClassRanges :: NonemptyClassRanges</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return the CharSet that is the result of evaluating |NonemptyClassRanges|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-nonemptyclassranges">
        <h1>NonemptyClassRanges</h1>
        <p>The production <emu-grammar>NonemptyClassRanges :: ClassAtom</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return the CharSet that is the result of evaluating |ClassAtom|.
        </emu-alg>
        <p>The production <emu-grammar>NonemptyClassRanges :: ClassAtom NonemptyClassRangesNoDash</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate |ClassAtom| to obtain a CharSet _A_.
          1. Evaluate |NonemptyClassRangesNoDash| to obtain a CharSet _B_.
          1. Return the union of CharSets _A_ and _B_.
        </emu-alg>
        <p>The production <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassRanges</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate the first |ClassAtom| to obtain a CharSet _A_.
          1. Evaluate the second |ClassAtom| to obtain a CharSet _B_.
          1. Evaluate |ClassRanges| to obtain a CharSet _C_.
          1. Call CharacterRange(_A_, _B_) and let _D_ be the resulting CharSet.
          1. Return the union of CharSets _D_ and _C_.
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-characterrange-abstract-operation" aoid="CharacterRange">
          <h1>Runtime Semantics: CharacterRange ( _A_, _B_ )</h1>
          <p>The abstract operation CharacterRange takes two CharSet parameters _A_ and _B_ and performs the following steps:</p>
          <emu-alg>
            1. Assert: _A_ and _B_ each contain exactly one character.
            1. Let _a_ be the one character in CharSet _A_.
            1. Let _b_ be the one character in CharSet _B_.
            1. Let _i_ be the character value of character _a_.
            1. Let _j_ be the character value of character _b_.
            1. Assert: _i_ &le; _j_.
            1. Return the set containing all characters numbered _i_ through _j_, inclusive.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-nonemptyclassrangesnodash">
        <h1>NonemptyClassRangesNoDash</h1>
        <p>The production <emu-grammar>NonemptyClassRangesNoDash :: ClassAtom</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return the CharSet that is the result of evaluating |ClassAtom|.
        </emu-alg>
        <p>The production <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash NonemptyClassRangesNoDash</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate |ClassAtomNoDash| to obtain a CharSet _A_.
          1. Evaluate |NonemptyClassRangesNoDash| to obtain a CharSet _B_.
          1. Return the union of CharSets _A_ and _B_.
        </emu-alg>
        <p>The production <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassRanges</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate |ClassAtomNoDash| to obtain a CharSet _A_.
          1. Evaluate |ClassAtom| to obtain a CharSet _B_.
          1. Evaluate |ClassRanges| to obtain a CharSet _C_.
          1. Call CharacterRange(_A_, _B_) and let _D_ be the resulting CharSet.
          1. Return the union of CharSets _D_ and _C_.
        </emu-alg>
        <emu-note>
          <p>|ClassRanges| can expand into a single |ClassAtom| and/or ranges of two |ClassAtom| separated by dashes. In the latter case the |ClassRanges| includes all characters between the first |ClassAtom| and the second |ClassAtom|, inclusive; an error occurs if either |ClassAtom| does not represent a single character (for example, if one is \w) or if the first |ClassAtom|'s character value is greater than the second |ClassAtom|'s character value.</p>
        </emu-note>
        <emu-note>
          <p>Even if the pattern ignores case, the case of the two ends of a range is significant in determining which characters belong to the range. Thus, for example, the pattern `/[E-F]/i` matches only the letters `E`, `F`, `e`, and `f`, while the pattern `/[E-f]/i` matches all upper and lower-case letters in the Unicode Basic Latin block as well as the symbols `[`, `\\`, `]`, `^`, `_`, and <code>`</code>.</p>
        </emu-note>
        <emu-note>
          <p>A `-` character can be treated literally or it can denote a range. It is treated literally if it is the first or last character of |ClassRanges|, the beginning or end limit of a range specification, or immediately follows a range specification.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-classatom">
        <h1>ClassAtom</h1>
        <p>The production <emu-grammar>ClassAtom :: `-`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return the CharSet containing the single character `-` U+002D (HYPHEN-MINUS).
        </emu-alg>
        <p>The production <emu-grammar>ClassAtom :: ClassAtomNoDash</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return the CharSet that is the result of evaluating |ClassAtomNoDash|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-classatomnodash">
        <h1>ClassAtomNoDash</h1>
        <p>The production <emu-grammar>ClassAtomNoDash :: SourceCharacter but not one of `\` or `]` or `-`</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return the CharSet containing the character matched by |SourceCharacter|.
        </emu-alg>
        <p>The production <emu-grammar>ClassAtomNoDash :: `\` ClassEscape</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return the CharSet that is the result of evaluating |ClassEscape|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-classescape">
        <h1>ClassEscape</h1>
        <p>The |ClassEscape| productions evaluate as follows:</p>
        <emu-grammar>
          ClassEscape :: `b`

          ClassEscape :: `-`

          ClassEscape :: CharacterEscape
        </emu-grammar>
        <emu-alg>
          1. Let _cv_ be the CharacterValue of this |ClassEscape|.
          1. Let _c_ be the character whose character value is _cv_.
          1. Return the CharSet containing the single character _c_.
        </emu-alg>
        <emu-grammar>
          ClassEscape :: CharacterClassEscape
        </emu-grammar>
        <emu-alg>
          1. Return the CharSet that is the result of evaluating |CharacterClassEscape|.
        </emu-alg>
        <emu-note>
          <p>A |ClassAtom| can use any of the escape sequences that are allowed in the rest of the regular expression except for `\\b`, `\\B`, and backreferences. Inside a |CharacterClass|, `\\b` means the backspace character, while `\\B` and backreferences raise errors. Using a backreference inside a |ClassAtom| causes an error.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-regexp-constructor">
      <h1>The RegExp Constructor</h1>
      <p>The RegExp constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%RegExp%</dfn>.</li>
        <li>is the initial value of the `RegExp` property of the global object.</li>
        <li>creates and initializes a new RegExp object when called as a function rather than as a constructor. Thus the function call `RegExp(&hellip;)` is equivalent to the object creation expression `new RegExp(&hellip;)` with the same arguments.</li>
        <li>is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `RegExp` behaviour must include a `super` call to the `RegExp` constructor to create and initialize subclass instances with the necessary internal slots.</li>
      </ul>

      <emu-clause id="sec-regexp-pattern-flags">
        <h1>RegExp ( _pattern_, _flags_ )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _patternIsRegExp_ be ? IsRegExp(_pattern_).
          1. If NewTarget is *undefined*, then
            1. Let _newTarget_ be the active function object.
            1. If _patternIsRegExp_ is *true* and _flags_ is *undefined*, then
              1. Let _patternConstructor_ be ? Get(_pattern_, `"constructor"`).
              1. If SameValue(_newTarget_, _patternConstructor_) is *true*, return _pattern_.
          1. Else, let _newTarget_ be NewTarget.
          1. If Type(_pattern_) is Object and _pattern_ has a [[RegExpMatcher]] internal slot, then
            1. Let _P_ be _pattern_.[[OriginalSource]].
            1. If _flags_ is *undefined*, let _F_ be _pattern_.[[OriginalFlags]].
            1. Else, let _F_ be _flags_.
          1. Else if _patternIsRegExp_ is *true*, then
            1. Let _P_ be ? Get(_pattern_, `"source"`).
            1. If _flags_ is *undefined*, then
              1. Let _F_ be ? Get(_pattern_, `"flags"`).
            1. Else, let _F_ be _flags_.
          1. Else,
            1. Let _P_ be _pattern_.
            1. Let _F_ be _flags_.
          1. Let _O_ be ? RegExpAlloc(_newTarget_).
          1. Return ? RegExpInitialize(_O_, _P_, _F_).
        </emu-alg>
        <emu-note>
          <p>If pattern is supplied using a |StringLiteral|, the usual escape sequence substitutions are performed before the String is processed by RegExp. If pattern must contain an escape sequence to be recognized by RegExp, any U+005C (REVERSE SOLIDUS) code points must be escaped within the |StringLiteral| to prevent them being removed when the contents of the |StringLiteral| are formed.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-abstract-operations-for-the-regexp-constructor">
        <h1>Abstract Operations for the RegExp Constructor</h1>

        <emu-clause id="sec-regexpalloc" aoid="RegExpAlloc">
          <h1>Runtime Semantics: RegExpAlloc ( _newTarget_ )</h1>
          <p>When the abstract operation RegExpAlloc with argument _newTarget_ is called, the following steps are taken:</p>
          <emu-alg>
            1. Let _obj_ be ? OrdinaryCreateFromConstructor(_newTarget_, `"%RegExpPrototype%"`, &laquo; [[RegExpMatcher]], [[OriginalSource]], [[OriginalFlags]] &raquo;).
            1. Perform ! DefinePropertyOrThrow(_obj_, `"lastIndex"`, PropertyDescriptor { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
            1. Return _obj_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-regexpinitialize" aoid="RegExpInitialize">
          <h1>Runtime Semantics: RegExpInitialize ( _obj_, _pattern_, _flags_ )</h1>
          <p>When the abstract operation RegExpInitialize with arguments _obj_, _pattern_, and _flags_ is called, the following steps are taken:</p>
          <emu-alg>
            1. If _pattern_ is *undefined*, let _P_ be the empty String.
            1. Else, let _P_ be ? ToString(_pattern_).
            1. If _flags_ is *undefined*, let _F_ be the empty String.
            1. Else, let _F_ be ? ToString(_flags_).
            1. If _F_ contains any code unit other than `"g"`, `"i"`, `"m"`, `"s"`, `"u"`, or `"y"` or if it contains the same code unit more than once, throw a *SyntaxError* exception.
            1. If _F_ contains `"u"`, let _BMP_ be *false*; else let _BMP_ be *true*.
            1. If _BMP_ is *true*, then
              1. Parse _P_ using the grammars in <emu-xref href="#sec-patterns"></emu-xref> and interpreting each of its 16-bit elements as a Unicode BMP code point. UTF-16 decoding is not applied to the elements. The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of parsing contains a |GroupName|, reparse with the goal symbol |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError* exception if _P_ did not conform to the grammar, if any elements of _P_ were not matched by the parse, or if any Early Error conditions exist.
              1. Let _patternCharacters_ be a List whose elements are the code unit elements of _P_.
            1. Else,
              1. Parse _P_ using the grammars in <emu-xref href="#sec-patterns"></emu-xref> and interpreting _P_ as UTF-16 encoded Unicode code points (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>). The goal symbol for the parse is |Pattern[+U, +N]|. Throw a *SyntaxError* exception if _P_ did not conform to the grammar, if any elements of _P_ were not matched by the parse, or if any Early Error conditions exist.
              1. Let _patternCharacters_ be a List whose elements are the code points resulting from applying UTF-16 decoding to _P_'s sequence of elements.
            1. Set _obj_.[[OriginalSource]] to _P_.
            1. Set _obj_.[[OriginalFlags]] to _F_.
            1. Set _obj_.[[RegExpMatcher]] to the internal procedure that evaluates the above parse of _P_ by applying the semantics provided in <emu-xref href="#sec-pattern-semantics"></emu-xref> using _patternCharacters_ as the pattern's List of |SourceCharacter| values and _F_ as the flag parameters.
            1. Perform ? Set(_obj_, `"lastIndex"`, 0, *true*).
            1. Return _obj_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-regexpcreate" aoid="RegExpCreate">
          <h1>Runtime Semantics: RegExpCreate ( _P_, _F_ )</h1>
          <p>When the abstract operation RegExpCreate with arguments _P_ and _F_ is called, the following steps are taken:</p>
          <emu-alg>
            1. Let _obj_ be ? RegExpAlloc(%RegExp%).
            1. Return ? RegExpInitialize(_obj_, _P_, _F_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-escaperegexppattern" aoid="EscapeRegExpPattern">
          <h1>Runtime Semantics: EscapeRegExpPattern ( _P_, _F_ )</h1>
          <p>When the abstract operation EscapeRegExpPattern with arguments _P_ and _F_ is called, the following occurs:</p>
          <emu-alg>
            1. Let _S_ be a String in the form of a |Pattern[~U]| (|Pattern[+U]| if _F_ contains `"u"`) equivalent to _P_ interpreted as UTF-16 encoded Unicode code points (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>), in which certain code points are escaped as described below. _S_ may or may not be identical to _P_; however, the internal procedure that would result from evaluating _S_ as a |Pattern[~U]| (|Pattern[+U]| if _F_ contains `"u"`) must behave identically to the internal procedure given by the constructed object's [[RegExpMatcher]] internal slot. Multiple calls to this abstract operation using the same values for _P_ and _F_ must produce identical results.
            1. The code points `/` or any |LineTerminator| occurring in the pattern shall be escaped in _S_ as necessary to ensure that the string-concatenation of `"/"`, _S_, `"/"`, and _F_ can be parsed (in an appropriate lexical context) as a |RegularExpressionLiteral| that behaves identically to the constructed regular expression. For example, if _P_ is `"/"`, then _S_ could be `"\\/"` or `"\\u002F"`, among other possibilities, but not `"/"`, because `///` followed by _F_ would be parsed as a |SingleLineComment| rather than a |RegularExpressionLiteral|. If _P_ is the empty String, this specification can be met by letting _S_ be `"(?:)"`.
            1. Return _S_.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-regexp-constructor">
      <h1>Properties of the RegExp Constructor</h1>
      <p>The RegExp constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-regexp.prototype">
        <h1>RegExp.prototype</h1>
        <p>The initial value of `RegExp.prototype` is the intrinsic object %RegExpPrototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-get-regexp-@@species">
        <h1>get RegExp [ @@species ]</h1>
        <p>`RegExp[@@species]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the `name` property of this function is `"get [Symbol.species]"`.</p>
        <emu-note>
          <p>RegExp prototype methods normally use their `this` object's constructor to create a derived object. However, a subclass constructor may over-ride that default behaviour by redefining its @@species property.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-regexp-prototype-object">
      <h1>Properties of the RegExp Prototype Object</h1>
      <p>The RegExp prototype object:</p>
      <ul>
        <li>is the intrinsic object <dfn>%RegExpPrototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>is not a RegExp instance and does not have a [[RegExpMatcher]] internal slot or any of the other internal slots of RegExp instance objects.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
      </ul>
      <emu-note>
        <p>The RegExp prototype object does not have a `valueOf` property of its own; however, it inherits the `valueOf` property from the Object prototype object.</p>
      </emu-note>

      <emu-clause id="sec-regexp.prototype.constructor">
        <h1>RegExp.prototype.constructor</h1>
        <p>The initial value of `RegExp.prototype.constructor` is the intrinsic object %RegExp%.</p>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype.exec">
        <h1>RegExp.prototype.exec ( _string_ )</h1>
        <p>Performs a regular expression match of _string_ against the regular expression and returns an Array object containing the results of the match, or *null* if _string_ did not match.</p>
        <p>The String ToString(_string_) is searched for an occurrence of the regular expression pattern as follows:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. Perform ? RequireInternalSlot(_R_, [[RegExpMatcher]]).
          1. Let _S_ be ? ToString(_string_).
          1. Return ? RegExpBuiltinExec(_R_, _S_).
        </emu-alg>

        <emu-clause id="sec-regexpexec" aoid="RegExpExec">
          <h1>Runtime Semantics: RegExpExec ( _R_, _S_ )</h1>
          <p>The abstract operation RegExpExec with arguments _R_ and _S_ performs the following steps:</p>
          <emu-alg>
            1. Assert: Type(_R_) is Object.
            1. Assert: Type(_S_) is String.
            1. Let _exec_ be ? Get(_R_, `"exec"`).
            1. If IsCallable(_exec_) is *true*, then
              1. Let _result_ be ? Call(_exec_, _R_, &laquo; _S_ &raquo;).
              1. If Type(_result_) is neither Object or Null, throw a *TypeError* exception.
              1. Return _result_.
              1. Perform ? RequireInternalSlot(_R_, [[RegExpMatcher]]).
            1. Return ? RegExpBuiltinExec(_R_, _S_).
          </emu-alg>
          <emu-note>
            <p>If a callable `exec` property is not found this algorithm falls back to attempting to use the built-in RegExp matching algorithm. This provides compatible behaviour for code written for prior editions where most built-in algorithms that use regular expressions did not perform a dynamic property lookup of `exec`.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-regexpbuiltinexec" aoid="RegExpBuiltinExec">
          <h1>Runtime Semantics: RegExpBuiltinExec ( _R_, _S_ )</h1>
          <p>The abstract operation RegExpBuiltinExec with arguments _R_ and _S_ performs the following steps:</p>
          <emu-alg>
            1. Assert: _R_ is an initialized RegExp instance.
            1. Assert: Type(_S_) is String.
            1. Let _length_ be the number of code units in _S_.
            1. Let _lastIndex_ be ? ToLength(? Get(_R_, `"lastIndex"`)).
            1. Let _flags_ be _R_.[[OriginalFlags]].
            1. If _flags_ contains `"g"`, let _global_ be *true*, else let _global_ be *false*.
            1. If _flags_ contains `"y"`, let _sticky_ be *true*, else let _sticky_ be *false*.
            1. If _global_ is *false* and _sticky_ is *false*, set _lastIndex_ to 0.
            1. Let _matcher_ be _R_.[[RegExpMatcher]].
            1. If _flags_ contains `"u"`, let _fullUnicode_ be *true*, else let _fullUnicode_ be *false*.
            1. Let _matchSucceeded_ be *false*.
            1. Repeat, while _matchSucceeded_ is *false*
              1. If _lastIndex_ &gt; _length_, then
                1. If _global_ is *true* or _sticky_ is *true*, then
                  1. Perform ? Set(_R_, `"lastIndex"`, 0, *true*).
                1. Return *null*.
              1. Let _r_ be _matcher_(_S_, _lastIndex_).
              1. If _r_ is ~failure~, then
                1. If _sticky_ is *true*, then
                  1. Perform ? Set(_R_, `"lastIndex"`, 0, *true*).
                  1. Return *null*.
                1. Set _lastIndex_ to AdvanceStringIndex(_S_, _lastIndex_, _fullUnicode_).
              1. Else,
                1. Assert: _r_ is a State.
                1. Set _matchSucceeded_ to *true*.
            1. Let _e_ be _r_'s _endIndex_ value.
            1. If _fullUnicode_ is *true*, then
              1. _e_ is an index into the _Input_ character list, derived from _S_, matched by _matcher_. Let _eUTF_ be the smallest index into _S_ that corresponds to the character at element _e_ of _Input_. If _e_ is greater than or equal to the number of elements in _Input_, then _eUTF_ is the number of code units in _S_.
              1. Set _e_ to _eUTF_.
            1. If _global_ is *true* or _sticky_ is *true*, then
              1. Perform ? Set(_R_, `"lastIndex"`, _e_, *true*).
            1. Let _n_ be the number of elements in _r_'s _captures_ List. (This is the same value as <emu-xref href="#sec-notation"></emu-xref>'s _NcapturingParens_.)
            1. Assert: _n_ &lt; 2<sup>32</sup> - 1.
            1. Let _A_ be ! ArrayCreate(_n_ + 1).
            1. Assert: The value of _A_'s `"length"` property is _n_ + 1.
            1. Perform ! CreateDataProperty(_A_, `"index"`, _lastIndex_).
            1. Perform ! CreateDataProperty(_A_, `"input"`, _S_).
            1. Let _matchedSubstr_ be the matched substring (i.e. the portion of _S_ between offset _lastIndex_ inclusive and offset _e_ exclusive).
            1. Perform ! CreateDataProperty(_A_, `"0"`, _matchedSubstr_).
            1. If _R_ contains any |GroupName|, then
              1. Let _groups_ be ObjectCreate(*null*).
            1. Else,
              1. Let _groups_ be *undefined*.
            1. Perform ! CreateDataProperty(_A_, `"groups"`, _groups_).
            1. For each integer _i_ such that _i_ &gt; 0 and _i_ &le; _n_, do
              1. Let _captureI_ be _i_<sup>th</sup> element of _r_'s _captures_ List.
              1. If _captureI_ is *undefined*, let _capturedValue_ be *undefined*.
              1. Else if _fullUnicode_ is *true*, then
                1. Assert: _captureI_ is a List of code points.
                1. Let _capturedValue_ be the String value whose code units are the UTF16Encoding of the code points of _captureI_.
              1. Else _fullUnicode_ is *false*,
                1. Assert: _captureI_ is a List of code units.
                1. Let _capturedValue_ be the String value consisting of the code units of _captureI_.
              1. Perform ! CreateDataProperty(_A_, ! ToString(_i_), _capturedValue_).
              1. If the _i_th capture of _R_ was defined with a |GroupName|, then
                1. Let _s_ be the StringValue of the corresponding |RegExpIdentifierName|.
                1. Perform ! CreateDataProperty(_groups_, _s_, _capturedValue_).
            1. Return _A_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-advancestringindex" aoid="AdvanceStringIndex">
          <h1>AdvanceStringIndex ( _S_, _index_, _unicode_ )</h1>
          <p>The abstract operation AdvanceStringIndex with arguments _S_, _index_, and _unicode_ performs the following steps:</p>
          <emu-alg>
            1. Assert: Type(_S_) is String.
            1. Assert: _index_ is an integer such that 0 &le; _index_ &le; 2<sup>53</sup> - 1.
            1. Assert: Type(_unicode_) is Boolean.
            1. If _unicode_ is *false*, return _index_ + 1.
            1. Let _length_ be the number of code units in _S_.
            1. If _index_ + 1 &ge; _length_, return _index_ + 1.
            1. Let _first_ be the numeric value of the code unit at index _index_ within _S_.
            1. If _first_ &lt; 0xD800 or _first_ &gt; 0xDBFF, return _index_ + 1.
            1. Let _second_ be the numeric value of the code unit at index _index_ + 1 within _S_.
            1. If _second_ &lt; 0xDC00 or _second_ &gt; 0xDFFF, return _index_ + 1.
            1. Return _index_ + 2.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.dotAll">
        <h1>get RegExp.prototype.dotAll</h1>
        <p>`RegExp.prototype.dotAll` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. If Type(_R_) is not Object, throw a *TypeError* exception.
          1. If _R_ does not have an [[OriginalFlags]] internal slot, then
            1. If SameValue(_R_, %RegExpPrototype%) is *true*, return *undefined*.
            1. Otherwise, throw a *TypeError* exception.
          1. Let _flags_ be _R_.[[OriginalFlags]].
          1. If _flags_ contains the code unit 0x0073 (LATIN SMALL LETTER S), return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.flags">
        <h1>get RegExp.prototype.flags</h1>
        <p>`RegExp.prototype.flags` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. If Type(_R_) is not Object, throw a *TypeError* exception.
          1. Let _result_ be the empty String.
          1. Let _global_ be ToBoolean(? Get(_R_, `"global"`)).
          1. If _global_ is *true*, append the code unit 0x0067 (LATIN SMALL LETTER G) as the last code unit of _result_.
          1. Let _ignoreCase_ be ToBoolean(? Get(_R_, `"ignoreCase"`)).
          1. If _ignoreCase_ is *true*, append the code unit 0x0069 (LATIN SMALL LETTER I) as the last code unit of _result_.
          1. Let _multiline_ be ToBoolean(? Get(_R_, `"multiline"`)).
          1. If _multiline_ is *true*, append the code unit 0x006D (LATIN SMALL LETTER M) as the last code unit of _result_.
          1. Let _dotAll_ be ToBoolean(? Get(_R_, `"dotAll"`)).
          1. If _dotAll_ is *true*, append the code unit 0x0073 (LATIN SMALL LETTER S) as the last code unit of _result_.
          1. Let _unicode_ be ToBoolean(? Get(_R_, `"unicode"`)).
          1. If _unicode_ is *true*, append the code unit 0x0075 (LATIN SMALL LETTER U) as the last code unit of _result_.
          1. Let _sticky_ be ToBoolean(? Get(_R_, `"sticky"`)).
          1. If _sticky_ is *true*, append the code unit 0x0079 (LATIN SMALL LETTER Y) as the last code unit of _result_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.global">
        <h1>get RegExp.prototype.global</h1>
        <p>`RegExp.prototype.global` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. If Type(_R_) is not Object, throw a *TypeError* exception.
          1. If _R_ does not have an [[OriginalFlags]] internal slot, then
            1. If SameValue(_R_, %RegExpPrototype%) is *true*, return *undefined*.
            1. Otherwise, throw a *TypeError* exception.
          1. Let _flags_ be _R_.[[OriginalFlags]].
          1. If _flags_ contains the code unit 0x0067 (LATIN SMALL LETTER G), return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.ignorecase">
        <h1>get RegExp.prototype.ignoreCase</h1>
        <p>`RegExp.prototype.ignoreCase` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. If Type(_R_) is not Object, throw a *TypeError* exception.
          1. If _R_ does not have an [[OriginalFlags]] internal slot, then
            1. If SameValue(_R_, %RegExpPrototype%) is *true*, return *undefined*.
            1. Otherwise, throw a *TypeError* exception.
          1. Let _flags_ be _R_.[[OriginalFlags]].
          1. If _flags_ contains the code unit 0x0069 (LATIN SMALL LETTER I), return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype-@@match">
        <h1>RegExp.prototype [ @@match ] ( _string_ )</h1>
        <p>When the `@@match` method is called with argument _string_, the following steps are taken:</p>
        <emu-alg>
          1. Let _rx_ be the *this* value.
          1. If Type(_rx_) is not Object, throw a *TypeError* exception.
          1. Let _S_ be ? ToString(_string_).
          1. Let _global_ be ToBoolean(? Get(_rx_, `"global"`)).
          1. If _global_ is *false*, then
            1. Return ? RegExpExec(_rx_, _S_).
          1. Else _global_ is *true*,
            1. Let _fullUnicode_ be ToBoolean(? Get(_rx_, `"unicode"`)).
            1. Perform ? Set(_rx_, `"lastIndex"`, 0, *true*).
            1. Let _A_ be ! ArrayCreate(0).
            1. Let _n_ be 0.
            1. Repeat,
              1. Let _result_ be ? RegExpExec(_rx_, _S_).
              1. If _result_ is *null*, then
                1. If _n_ = 0, return *null*.
                1. Return _A_.
              1. Else _result_ is not *null*,
                1. Let _matchStr_ be ? ToString(? Get(_result_, `"0"`)).
                1. Let _status_ be CreateDataProperty(_A_, ! ToString(_n_), _matchStr_).
                1. Assert: _status_ is *true*.
                1. If _matchStr_ is the empty String, then
                  1. Let _thisIndex_ be ? ToLength(? Get(_rx_, `"lastIndex"`)).
                  1. Let _nextIndex_ be AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).
                  1. Perform ? Set(_rx_, `"lastIndex"`, _nextIndex_, *true*).
                1. Increment _n_.
        </emu-alg>
        <p>The value of the `name` property of this function is `"[Symbol.match]"`.</p>
        <emu-note>
          <p>The @@match property is used by the IsRegExp abstract operation to identify objects that have the basic behaviour of regular expressions. The absence of a @@match property or the existence of such a property whose value does not Boolean coerce to *true* indicates that the object is not intended to be used as a regular expression object.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-regexp-prototype-matchall">
        <h1>RegExp.prototype [ @@matchAll ] ( _string_ )</h1>

        <p>When the `@@matchAll` method is called with argument _string_, the following steps are taken:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. If Type(_R_) is not Object, throw a *TypeError* exception.
          1. Let _S_ be ? ToString(_string_).
          1. Let _C_ be ? SpeciesConstructor(_R_, %RegExp%).
          1. Let _flags_ be ? ToString(? Get(_R_, `"flags"`)).
          1. Let _matcher_ be ? Construct(_C_, &laquo; _R_, _flags_ &raquo;).
          1. Let _lastIndex_ be ? ToLength(? Get(_R_, `"lastIndex"`)).
          1. Perform ? Set(_matcher_, `"lastIndex"`, _lastIndex_, *true*).
          1. If _flags_ contains `"g"`, let _global_ be *true*.
          1. Else, let _global_ be *false*.
          1. If _flags_ contains `"u"`, let _fullUnicode_ be *true*.
          1. Else, let _fullUnicode_ be *false*.
          1. Return ! CreateRegExpStringIterator(_matcher_, _S_, _global_, _fullUnicode_).
        </emu-alg>
        <p>The value of the *name* property of this function is *"[Symbol.matchAll]"*.</p>

        <emu-clause id="sec-createregexpstringiterator" aoid="CreateRegExpStringIterator">
          <h1>CreateRegExpStringIterator ( _R_, _S_, _global_, _fullUnicode_ )</h1>

          <p>The abstract operation _CreateRegExpStringIterator_ is used to create such iterator objects. It performs the following steps:</p>
          <emu-alg>
            1. Assert: Type(_S_) is String.
            1. Assert: Type(_global_) is Boolean.
            1. Assert: Type(_fullUnicode_) is Boolean.
            1. Let _iterator_ be ObjectCreate(<emu-xref href="#%RegExpStringIteratorPrototype%">%RegExpStringIteratorPrototype%</emu-xref>, &laquo; [[IteratingRegExp]], [[IteratedString]], [[Global]], [[Unicode]], [[Done]] &raquo;).
            1. Set _iterator_.[[IteratingRegExp]] to _R_.
            1. Set _iterator_.[[IteratedString]] to _S_.
            1. Set _iterator_.[[Global]] to _global_.
            1. Set _iterator_.[[Unicode]] to _fullUnicode_.
            1. Set _iterator_.[[Done]] to *false*.
            1. Return _iterator_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.multiline">
        <h1>get RegExp.prototype.multiline</h1>
        <p>`RegExp.prototype.multiline` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. If Type(_R_) is not Object, throw a *TypeError* exception.
          1. If _R_ does not have an [[OriginalFlags]] internal slot, then
            1. If SameValue(_R_, %RegExpPrototype%) is *true*, return *undefined*.
            1. Otherwise, throw a *TypeError* exception.
          1. Let _flags_ be _R_.[[OriginalFlags]].
          1. If _flags_ contains the code unit 0x006D (LATIN SMALL LETTER M), return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype-@@replace">
        <h1>RegExp.prototype [ @@replace ] ( _string_, _replaceValue_ )</h1>
        <p>When the `@@replace` method is called with arguments _string_ and _replaceValue_, the following steps are taken:</p>
        <emu-alg>
          1. Let _rx_ be the *this* value.
          1. If Type(_rx_) is not Object, throw a *TypeError* exception.
          1. Let _S_ be ? ToString(_string_).
          1. Let _lengthS_ be the number of code unit elements in _S_.
          1. Let _functionalReplace_ be IsCallable(_replaceValue_).
          1. If _functionalReplace_ is *false*, then
            1. Set _replaceValue_ to ? ToString(_replaceValue_).
          1. Let _global_ be ToBoolean(? Get(_rx_, `"global"`)).
          1. If _global_ is *true*, then
            1. Let _fullUnicode_ be ToBoolean(? Get(_rx_, `"unicode"`)).
            1. Perform ? Set(_rx_, `"lastIndex"`, 0, *true*).
          1. Let _results_ be a new empty List.
          1. Let _done_ be *false*.
          1. Repeat, while _done_ is *false*
            1. Let _result_ be ? RegExpExec(_rx_, _S_).
            1. If _result_ is *null*, set _done_ to *true*.
            1. Else _result_ is not *null*,
              1. Append _result_ to the end of _results_.
              1. If _global_ is *false*, set _done_ to *true*.
              1. Else,
                1. Let _matchStr_ be ? ToString(? Get(_result_, `"0"`)).
                1. If _matchStr_ is the empty String, then
                  1. Let _thisIndex_ be ? ToLength(? Get(_rx_, `"lastIndex"`)).
                  1. Let _nextIndex_ be AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).
                  1. Perform ? Set(_rx_, `"lastIndex"`, _nextIndex_, *true*).
          1. Let _accumulatedResult_ be the empty String value.
          1. Let _nextSourcePosition_ be 0.
          1. For each _result_ in _results_, do
            1. Let _nCaptures_ be ? ToLength(? Get(_result_, `"length"`)).
            1. Set _nCaptures_ to max(_nCaptures_ - 1, 0).
            1. Let _matched_ be ? ToString(? Get(_result_, `"0"`)).
            1. Let _matchLength_ be the number of code units in _matched_.
            1. Let _position_ be ? ToInteger(? Get(_result_, `"index"`)).
            1. Set _position_ to max(min(_position_, _lengthS_), 0).
            1. Let _n_ be 1.
            1. Let _captures_ be a new empty List.
            1. Repeat, while _n_ &le; _nCaptures_
              1. Let _capN_ be ? Get(_result_, ! ToString(_n_)).
              1. If _capN_ is not *undefined*, then
                1. Set _capN_ to ? ToString(_capN_).
              1. Append _capN_ as the last element of _captures_.
              1. Increase _n_ by 1.
            1. Let _namedCaptures_ be ? Get(_result_, `"groups"`).
            1. If _functionalReplace_ is *true*, then
              1. Let _replacerArgs_ be &laquo; _matched_ &raquo;.
              1. Append in list order the elements of _captures_ to the end of the List _replacerArgs_.
              1. Append _position_ and _S_ to _replacerArgs_.
              1. If _namedCaptures_ is not *undefined*, then
                1. Append _namedCaptures_ as the last element of _replacerArgs_.
              1. Let _replValue_ be ? Call(_replaceValue_, *undefined*, _replacerArgs_).
              1. Let _replacement_ be ? ToString(_replValue_).
            1. Else,
              1. Let _replacement_ be GetSubstitution(_matched_, _S_, _position_, _captures_, _namedCaptures_, _replaceValue_).
            1. If _position_ &ge; _nextSourcePosition_, then
              1. NOTE: _position_ should not normally move backwards. If it does, it is an indication of an ill-behaving RegExp subclass or use of an access triggered side-effect to change the global flag or other characteristics of _rx_. In such cases, the corresponding substitution is ignored.
              1. Set _accumulatedResult_ to the string-concatenation of the current value of _accumulatedResult_, the substring of _S_ consisting of the code units from _nextSourcePosition_ (inclusive) up to _position_ (exclusive), and _replacement_.
              1. Set _nextSourcePosition_ to _position_ + _matchLength_.
          1. If _nextSourcePosition_ &ge; _lengthS_, return _accumulatedResult_.
          1. Return the string-concatenation of _accumulatedResult_ and the substring of _S_ consisting of the code units from _nextSourcePosition_ (inclusive) up through the final code unit of _S_ (inclusive).
        </emu-alg>
        <p>The value of the `name` property of this function is `"[Symbol.replace]"`.</p>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype-@@search">
        <h1>RegExp.prototype [ @@search ] ( _string_ )</h1>
        <p>When the `@@search` method is called with argument _string_, the following steps are taken:</p>
        <emu-alg>
          1. Let _rx_ be the *this* value.
          1. If Type(_rx_) is not Object, throw a *TypeError* exception.
          1. Let _S_ be ? ToString(_string_).
          1. Let _previousLastIndex_ be ? Get(_rx_, `"lastIndex"`).
          1. If SameValue(_previousLastIndex_, 0) is *false*, then
            1. Perform ? Set(_rx_, `"lastIndex"`, 0, *true*).
          1. Let _result_ be ? RegExpExec(_rx_, _S_).
          1. Let _currentLastIndex_ be ? Get(_rx_, `"lastIndex"`).
          1. If SameValue(_currentLastIndex_, _previousLastIndex_) is *false*, then
            1. Perform ? Set(_rx_, `"lastIndex"`, _previousLastIndex_, *true*).
          1. If _result_ is *null*, return -1.
          1. Return ? Get(_result_, `"index"`).
        </emu-alg>
        <p>The value of the `name` property of this function is `"[Symbol.search]"`.</p>
        <emu-note>
          <p>The `lastIndex` and `global` properties of this RegExp object are ignored when performing the search. The `lastIndex` property is left unchanged.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.source">
        <h1>get RegExp.prototype.source</h1>
        <p>`RegExp.prototype.source` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. If Type(_R_) is not Object, throw a *TypeError* exception.
          1. If _R_ does not have an [[OriginalSource]] internal slot, then
            1. If SameValue(_R_, %RegExpPrototype%) is *true*, return `"(?:)"`.
            1. Otherwise, throw a *TypeError* exception.
          1. Assert: _R_ has an [[OriginalFlags]] internal slot.
          1. Let _src_ be _R_.[[OriginalSource]].
          1. Let _flags_ be _R_.[[OriginalFlags]].
          1. Return EscapeRegExpPattern(_src_, _flags_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype-@@split">
        <h1>RegExp.prototype [ @@split ] ( _string_, _limit_ )</h1>
        <emu-note>
          <p>Returns an Array object into which substrings of the result of converting _string_ to a String have been stored. The substrings are determined by searching from left to right for matches of the *this* value regular expression; these occurrences are not part of any substring in the returned array, but serve to divide up the String value.</p>
          <p>The *this* value may be an empty regular expression or a regular expression that can match an empty String. In this case, the regular expression does not match the empty substring at the beginning or end of the input String, nor does it match the empty substring at the end of the previous separator match. (For example, if the regular expression matches the empty String, the String is split up into individual code unit elements; the length of the result array equals the length of the String, and each substring contains one code unit.) Only the first match at a given index of the String is considered, even if backtracking could yield a non-empty-substring match at that index. (For example, `/a*?/[Symbol.split]("ab")` evaluates to the array `["a", "b"]`, while `/a*/[Symbol.split]("ab")` evaluates to the array `["","b"]`.)</p>
          <p>If the _string_ is (or converts to) the empty String, the result depends on whether the regular expression can match the empty String. If it can, the result array contains no elements. Otherwise, the result array contains one element, which is the empty String.</p>
          <p>If the regular expression contains capturing parentheses, then each time _separator_ is matched the results (including any *undefined* results) of the capturing parentheses are spliced into the output array. For example,</p>
          <pre><code class="javascript">/&lt;(\/)?([^&lt;&gt;]+)&gt;/[Symbol.split]("A&lt;B&gt;bold&lt;/B&gt;and&lt;CODE&gt;coded&lt;/CODE&gt;")</code></pre>
          <p>evaluates to the array</p>
          <pre><code class="javascript">["A", undefined, "B", "bold", "/", "B", "and", undefined, "CODE", "coded", "/", "CODE", ""]</code></pre>
          <p>If _limit_ is not *undefined*, then the output array is truncated so that it contains no more than _limit_ elements.</p>
        </emu-note>
        <p>When the `@@split` method is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _rx_ be the *this* value.
          1. If Type(_rx_) is not Object, throw a *TypeError* exception.
          1. Let _S_ be ? ToString(_string_).
          1. Let _C_ be ? SpeciesConstructor(_rx_, %RegExp%).
          1. Let _flags_ be ? ToString(? Get(_rx_, `"flags"`)).
          1. If _flags_ contains `"u"`, let _unicodeMatching_ be *true*.
          1. Else, let _unicodeMatching_ be *false*.
          1. If _flags_ contains `"y"`, let _newFlags_ be _flags_.
          1. Else, let _newFlags_ be the string-concatenation of _flags_ and `"y"`.
          1. Let _splitter_ be ? Construct(_C_, &laquo; _rx_, _newFlags_ &raquo;).
          1. Let _A_ be ! ArrayCreate(0).
          1. Let _lengthA_ be 0.
          1. If _limit_ is *undefined*, let _lim_ be 2<sup>32</sup> - 1; else let _lim_ be ? ToUint32(_limit_).
          1. Let _size_ be the length of _S_.
          1. Let _p_ be 0.
          1. If _lim_ = 0, return _A_.
          1. If _size_ = 0, then
            1. Let _z_ be ? RegExpExec(_splitter_, _S_).
            1. If _z_ is not *null*, return _A_.
            1. Perform ! CreateDataProperty(_A_, `"0"`, _S_).
            1. Return _A_.
          1. Let _q_ be _p_.
          1. Repeat, while _q_ &lt; _size_
            1. Perform ? Set(_splitter_, `"lastIndex"`, _q_, *true*).
            1. Let _z_ be ? RegExpExec(_splitter_, _S_).
            1. If _z_ is *null*, set _q_ to AdvanceStringIndex(_S_, _q_, _unicodeMatching_).
            1. Else _z_ is not *null*,
              1. Let _e_ be ? ToLength(? Get(_splitter_, `"lastIndex"`)).
              1. Set _e_ to min(_e_, _size_).
              1. If _e_ = _p_, set _q_ to AdvanceStringIndex(_S_, _q_, _unicodeMatching_).
              1. Else _e_ &ne; _p_,
                1. Let _T_ be the String value equal to the substring of _S_ consisting of the code units at indices _p_ (inclusive) through _q_ (exclusive).
                1. Perform ! CreateDataProperty(_A_, ! ToString(_lengthA_), _T_).
                1. Increase _lengthA_ by 1.
                1. If _lengthA_ = _lim_, return _A_.
                1. Set _p_ to _e_.
                1. Let _numberOfCaptures_ be ? ToLength(? Get(_z_, `"length"`)).
                1. Set _numberOfCaptures_ to max(_numberOfCaptures_ - 1, 0).
                1. Let _i_ be 1.
                1. Repeat, while _i_ &le; _numberOfCaptures_,
                  1. Let _nextCapture_ be ? Get(_z_, ! ToString(_i_)).
                  1. Perform ! CreateDataProperty(_A_, ! ToString(_lengthA_), _nextCapture_).
                  1. Increase _i_ by 1.
                  1. Increase _lengthA_ by 1.
                  1. If _lengthA_ = _lim_, return _A_.
                1. Set _q_ to _p_.
          1. Let _T_ be the String value equal to the substring of _S_ consisting of the code units at indices _p_ (inclusive) through _size_ (exclusive).
          1. Perform ! CreateDataProperty(_A_, ! ToString(_lengthA_), _T_).
          1. Return _A_.
        </emu-alg>
        <p>The value of the `name` property of this function is `"[Symbol.split]"`.</p>
        <emu-note>
          <p>The `@@split` method ignores the value of the `global` and `sticky` properties of this RegExp object.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.sticky">
        <h1>get RegExp.prototype.sticky</h1>
        <p>`RegExp.prototype.sticky` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. If Type(_R_) is not Object, throw a *TypeError* exception.
          1. If _R_ does not have an [[OriginalFlags]] internal slot, then
            1. If SameValue(_R_, %RegExpPrototype%) is *true*, return *undefined*.
            1. Otherwise, throw a *TypeError* exception.
          1. Let _flags_ be _R_.[[OriginalFlags]].
          1. If _flags_ contains the code unit 0x0079 (LATIN SMALL LETTER Y), return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype.test">
        <h1>RegExp.prototype.test ( _S_ )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. If Type(_R_) is not Object, throw a *TypeError* exception.
          1. Let _string_ be ? ToString(_S_).
          1. Let _match_ be ? RegExpExec(_R_, _string_).
          1. If _match_ is not *null*, return *true*; else return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype.tostring">
        <h1>RegExp.prototype.toString ( )</h1>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. If Type(_R_) is not Object, throw a *TypeError* exception.
          1. Let _pattern_ be ? ToString(? Get(_R_, `"source"`)).
          1. Let _flags_ be ? ToString(? Get(_R_, `"flags"`)).
          1. Let _result_ be the string-concatenation of `"/"`, _pattern_, `"/"`, and _flags_.
          1. Return _result_.
        </emu-alg>
        <emu-note>
          <p>The returned String has the form of a |RegularExpressionLiteral| that evaluates to another RegExp object with the same behaviour as this object.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.unicode">
        <h1>get RegExp.prototype.unicode</h1>
        <p>`RegExp.prototype.unicode` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. If Type(_R_) is not Object, throw a *TypeError* exception.
          1. If _R_ does not have an [[OriginalFlags]] internal slot, then
            1. If SameValue(_R_, %RegExpPrototype%) is *true*, return *undefined*.
            1. Otherwise, throw a *TypeError* exception.
          1. Let _flags_ be _R_.[[OriginalFlags]].
          1. If _flags_ contains the code unit 0x0075 (LATIN SMALL LETTER U), return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-regexp-instances">
      <h1>Properties of RegExp Instances</h1>
      <p>RegExp instances are ordinary objects that inherit properties from the RegExp prototype object. RegExp instances have internal slots [[RegExpMatcher]], [[OriginalSource]], and [[OriginalFlags]]. The value of the [[RegExpMatcher]] internal slot is an implementation-dependent representation of the |Pattern| of the RegExp object.</p>
      <emu-note>
        <p>Prior to ECMAScript 2015, `RegExp` instances were specified as having the own data properties `source`, `global`, `ignoreCase`, and `multiline`. Those properties are now specified as accessor properties of RegExp.prototype.</p>
      </emu-note>
      <p>RegExp instances also have the following property:</p>

      <emu-clause id="sec-lastindex">
        <h1>lastIndex</h1>
        <p>The value of the `lastIndex` property specifies the String index at which to start the next match. It is coerced to an integer when used (see <emu-xref href="#sec-regexpbuiltinexec"></emu-xref>). This property shall have the attributes { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-regexp-string-iterator-objects">
      <h1>RegExp String Iterator Objects</h1>
      <p>A RegExp String Iterator is an object, that represents a specific iteration over some specific String instance object, matching against some specific RegExp instance object. There is not a named constructor for RegExp String Iterator objects. Instead, RegExp String iterator objects are created by calling certain methods of RegExp instance objects.</p>

      <emu-clause id="%RegExpStringIteratorPrototype%">
        <h1>The %RegExpStringIteratorPrototype% Object</h1>

        <p>All RegExp String Iterator Objects inherit properties from the <emu-xref href="#%RegExpStringIteratorPrototype%">%RegExpStringIteratorPrototype%</emu-xref> intrinsic object. The %RegExpStringIteratorPrototype% object is an ordinary object and its [[Prototype]] <a href="https://tc39.github.io/ecma262/#sec-object-internal-methods-and-internal-slots">internal slot</a> is the <a href="https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object">%IteratorPrototype% intrinsic object</a>. In addition, %RegExpStringIteratorPrototype% has the following properties:</p>

        <emu-clause id="%RegExpStringIteratorPrototype%.next">
          <h1>%RegExpStringIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. Let _O_ be the *this* value.
            1. If Type(_O_) is not Object, throw a *TypeError* exception.
            1. If _O_ does not have all of the internal slots of a RegExp String Iterator Object Instance (see <emu-xref href="#PropertiesOfRegExpStringIteratorInstances"></emu-xref>), throw a *TypeError* exception.
            1. If _O_.[[Done]] is *true*, then
              1. Return ! CreateIterResultObject(*undefined*, *true*).
            1. Let _R_ be _O_.[[IteratingRegExp]].
            1. Let _S_ be _O_.[[IteratedString]].
            1. Let _global_ be _O_.[[Global]].
            1. Let _fullUnicode_ be _O_.[[Unicode]].
            1. Let _match_ be ? RegExpExec(_R_, _S_).
            1. If _match_ is *null*, then
              1. Set _O_.[[Done]] to *true*.
              1. Return ! CreateIterResultObject(*undefined*, *true*).
            1. Else,
              1. If _global_ is *true*,
                1. Let _matchStr_ be ? ToString(? Get(_match_, *"0"*)).
                1. If _matchStr_ is the empty string,
                  1. Let _thisIndex_ be ? ToLength(? Get(_R_, *"lastIndex"*)).
                  1. Let _nextIndex_ be ! AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).
                  1. Perform ? Set(_R_, *"lastIndex"*, _nextIndex_, *true*).
                1. Return ! CreateIterResultObject(_match_, *false*).
              1. Else,
                1. Set _O_.[[Done]] to *true*.
                1. Return ! CreateIterResultObject(_match_, *false*).
          </emu-alg>
        </emu-clause>

        <emu-clause id="%RegExpStringIteratorPrototype%[@@toStringTag]">
          <h1>%RegExpStringIteratorPrototype%[ @@toStringTag ]</h1>
          <p>The initial value of the _@@toStringTag_ property is the String value *"RegExp String Iterator"*.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        </emu-clause>

        <emu-clause id="PropertiesOfRegExpStringIteratorInstances">
          <h1>Properties of RegExp String Iterator Instances</h1>
          <p>RegExp String Iterator instances are ordinary objects that inherit properties from the <emu-xref href="#%RegExpStringIteratorPrototype%">%RegExpStringIteratorPrototype%</emu-xref> intrinsic object. RegExp String Iterator instances are initially created with the internal slots listed in <a href="#table-1">Table 1</a>.</p>
          <figure>
            <figcaption><span id="table-1">Table 1</span> &ndash; Internal Slots of RegExp String Iterator Instances</figcaption>
            <table class="real-table">
              <tbody>
                <tr>
                  <th>Internal Slot</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td>[[IteratingRegExp]]</td>
                  <td>The regular expression used for iteration. IsRegExp([[IteratingRegExp]]) is initially *true*.</td>
                </tr>
                <tr>
                  <td>[[IteratedString]]</td>
                  <td>The String value being iterated upon.</td>
                </tr>
                <tr>
                  <td>[[Global]]</td>
                  <td>A Boolean value to indicate whether the [[IteratingRegExp]] is global or not.</td>
                </tr>
                <tr>
                  <td>[[Unicode]]</td>
                  <td>A Boolean value to indicate whether the [[IteratingRegExp]] is in Unicode mode or not.</td>
                </tr>
                <tr>
                  <td>[[Done]]</td>
                  <td>A Boolean value to indicate whether the iteration is complete or not.</td>
                </tr>
                <tr>
              </tbody>
            </table>
          </figure>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-indexed-collections">
  <h1>Indexed Collections</h1>

  <emu-clause id="sec-array-objects">
    <h1>Array Objects</h1>
    <p>Array objects are exotic objects that give special treatment to a certain class of property names. See <emu-xref href="#sec-array-exotic-objects"></emu-xref> for a definition of this special treatment.</p>

    <emu-clause id="sec-array-constructor">
      <h1>The Array Constructor</h1>
      <p>The Array constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%Array%</dfn>.</li>
        <li>is the initial value of the `Array` property of the global object.</li>
        <li>creates and initializes a new Array exotic object when called as a constructor.</li>
        <li>also creates and initializes a new Array object when called as a function rather than as a constructor. Thus the function call `Array(&hellip;)` is equivalent to the object creation expression `new Array(&hellip;)` with the same arguments.</li>
        <li>is a single function whose behaviour is overloaded based upon the number and types of its arguments.</li>
        <li>is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the exotic `Array` behaviour must include a `super` call to the `Array` constructor to initialize subclass instances that are Array exotic objects. However, most of the `Array.prototype` methods are generic methods that are not dependent upon their `this` value being an Array exotic object.</li>
        <li>has a `"length"` property whose value is 1.</li>
      </ul>

      <emu-clause id="sec-array-constructor-array">
        <h1>Array ( )</h1>
        <p>This description applies if and only if the Array constructor is called with no arguments.</p>
        <emu-alg>
          1. Let _numberOfArgs_ be the number of arguments passed to this function call.
          1. Assert: _numberOfArgs_ = 0.
          1. If NewTarget is *undefined*, let _newTarget_ be the active function object, else let _newTarget_ be NewTarget.
          1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, `"%ArrayPrototype%"`).
          1. Return ! ArrayCreate(0, _proto_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array-len">
        <h1>Array ( _len_ )</h1>
        <p>This description applies if and only if the Array constructor is called with exactly one argument.</p>
        <emu-alg>
          1. Let _numberOfArgs_ be the number of arguments passed to this function call.
          1. Assert: _numberOfArgs_ = 1.
          1. If NewTarget is *undefined*, let _newTarget_ be the active function object, else let _newTarget_ be NewTarget.
          1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, `"%ArrayPrototype%"`).
          1. Let _array_ be ! ArrayCreate(0, _proto_).
          1. If Type(_len_) is not Number, then
            1. Let _defineStatus_ be CreateDataProperty(_array_, `"0"`, _len_).
            1. Assert: _defineStatus_ is *true*.
            1. Let _intLen_ be 1.
          1. Else,
            1. Let _intLen_ be ToUint32(_len_).
            1. If _intLen_ &ne; _len_, throw a *RangeError* exception.
          1. Perform ! Set(_array_, `"length"`, _intLen_, *true*).
          1. Return _array_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array-items">
        <h1>Array ( ..._items_ )</h1>
        <p>This description applies if and only if the Array constructor is called with at least two arguments.</p>
        <p>When the `Array` function is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _numberOfArgs_ be the number of arguments passed to this function call.
          1. Assert: _numberOfArgs_ &ge; 2.
          1. If NewTarget is *undefined*, let _newTarget_ be the active function object, else let _newTarget_ be NewTarget.
          1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, `"%ArrayPrototype%"`).
          1. Let _array_ be ? ArrayCreate(_numberOfArgs_, _proto_).
          1. Let _k_ be 0.
          1. Let _items_ be a zero-origined List containing the argument items in order.
          1. Repeat, while _k_ &lt; _numberOfArgs_
            1. Let _Pk_ be ! ToString(_k_).
            1. Let _itemK_ be _items_[_k_].
            1. Let _defineStatus_ be CreateDataProperty(_array_, _Pk_, _itemK_).
            1. Assert: _defineStatus_ is *true*.
            1. Increase _k_ by 1.
          1. Assert: The value of _array_'s `"length"` property is _numberOfArgs_.
          1. Return _array_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-array-constructor">
      <h1>Properties of the Array Constructor</h1>
      <p>The Array constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-array.from">
        <h1>Array.from ( _items_ [ , _mapfn_ [ , _thisArg_ ] ] )</h1>
        <p>When the `from` method is called with argument _items_ and optional arguments _mapfn_ and _thisArg_, the following steps are taken:</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. If _mapfn_ is *undefined*, let _mapping_ be *false*.
          1. Else,
            1. If IsCallable(_mapfn_) is *false*, throw a *TypeError* exception.
            1. If _thisArg_ is present, let _T_ be _thisArg_; else let _T_ be *undefined*.
            1. Let _mapping_ be *true*.
          1. Let _usingIterator_ be ? GetMethod(_items_, @@iterator).
          1. If _usingIterator_ is not *undefined*, then
            1. If IsConstructor(_C_) is *true*, then
              1. Let _A_ be ? Construct(_C_).
            1. Else,
              1. Let _A_ be ! ArrayCreate(0).
            1. Let _iteratorRecord_ be ? GetIterator(_items_, ~sync~, _usingIterator_).
            1. Let _k_ be 0.
            1. Repeat,
              1. If _k_ &ge; 2<sup>53</sup> - 1, then
                1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
                1. Return ? IteratorClose(_iteratorRecord_, _error_).
              1. Let _Pk_ be ! ToString(_k_).
              1. Let _next_ be ? IteratorStep(_iteratorRecord_).
              1. If _next_ is *false*, then
                1. Perform ? Set(_A_, `"length"`, _k_, *true*).
                1. Return _A_.
              1. Let _nextValue_ be ? IteratorValue(_next_).
              1. If _mapping_ is *true*, then
                1. Let _mappedValue_ be Call(_mapfn_, _T_, &laquo; _nextValue_, _k_ &raquo;).
                1. If _mappedValue_ is an abrupt completion, return ? IteratorClose(_iteratorRecord_, _mappedValue_).
                1. Set _mappedValue_ to _mappedValue_.[[Value]].
              1. Else, let _mappedValue_ be _nextValue_.
              1. Let _defineStatus_ be CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_).
              1. If _defineStatus_ is an abrupt completion, return ? IteratorClose(_iteratorRecord_, _defineStatus_).
              1. Increase _k_ by 1.
          1. NOTE: _items_ is not an Iterable so assume it is an array-like object.
          1. Let _arrayLike_ be ! ToObject(_items_).
          1. Let _len_ be ? ToLength(? Get(_arrayLike_, `"length"`)).
          1. If IsConstructor(_C_) is *true*, then
            1. Let _A_ be ? Construct(_C_, &laquo; _len_ &raquo;).
          1. Else,
            1. Let _A_ be ? ArrayCreate(_len_).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_
            1. Let _Pk_ be ! ToString(_k_).
            1. Let _kValue_ be ? Get(_arrayLike_, _Pk_).
            1. If _mapping_ is *true*, then
              1. Let _mappedValue_ be ? Call(_mapfn_, _T_, &laquo; _kValue_, _k_ &raquo;).
            1. Else, let _mappedValue_ be _kValue_.
            1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_).
            1. Increase _k_ by 1.
          1. Perform ? Set(_A_, `"length"`, _len_, *true*).
          1. Return _A_.
        </emu-alg>
        <emu-note>
          <p>The `from` function is an intentionally generic factory method; it does not require that its *this* value be the Array constructor. Therefore it can be transferred to or inherited by any other constructors that may be called with a single numeric argument.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.isarray">
        <h1>Array.isArray ( _arg_ )</h1>
        <p>The `isArray` function takes one argument _arg_, and performs the following steps:</p>
        <emu-alg>
          1. Return ? IsArray(_arg_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.of">
        <h1>Array.of ( ..._items_ )</h1>
        <p>When the `of` method is called with any number of arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _len_ be the actual number of arguments passed to this function.
          1. Let _items_ be the List of arguments passed to this function.
          1. Let _C_ be the *this* value.
          1. If IsConstructor(_C_) is *true*, then
            1. Let _A_ be ? Construct(_C_, &laquo; _len_ &raquo;).
          1. Else,
            1. Let _A_ be ? ArrayCreate(_len_).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_
            1. Let _kValue_ be _items_[_k_].
            1. Let _Pk_ be ! ToString(_k_).
            1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _kValue_).
            1. Increase _k_ by 1.
          1. Perform ? Set(_A_, `"length"`, _len_, *true*).
          1. Return _A_.
        </emu-alg>
        <emu-note>
          <p>The _items_ argument is assumed to be a well-formed rest argument value.</p>
        </emu-note>
        <emu-note>
          <p>The `of` function is an intentionally generic factory method; it does not require that its *this* value be the Array constructor. Therefore it can be transferred to or inherited by other constructors that may be called with a single numeric argument.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype">
        <h1>Array.prototype</h1>
        <p>The value of `Array.prototype` is %ArrayPrototype%, the intrinsic Array prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-get-array-@@species">
        <h1>get Array [ @@species ]</h1>
        <p>`Array[@@species]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the `name` property of this function is `"get [Symbol.species]"`.</p>
        <emu-note>
          <p>Array prototype methods normally use their `this` object's constructor to create a derived object. However, a subclass constructor may over-ride that default behaviour by redefining its @@species property.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-array-prototype-object">
      <h1>Properties of the Array Prototype Object</h1>
      <p>The Array prototype object:</p>
      <ul>
        <li>is the intrinsic object <dfn>%ArrayPrototype%</dfn>.</li>
        <li>is an Array exotic object and has the internal methods specified for such objects.</li>
        <li>has a `"length"` property whose initial value is 0 and whose attributes are { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
      </ul>
      <emu-note>
        <p>The Array prototype object is specified to be an Array exotic object to ensure compatibility with ECMAScript code that was created prior to the ECMAScript 2015 specification.</p>
      </emu-note>

      <emu-clause id="sec-array.prototype.concat">
        <h1>Array.prototype.concat ( ..._arguments_ )</h1>
        <p>When the `concat` method is called with zero or more arguments, it returns an array containing the array elements of the object followed by the array elements of each argument in order.</p>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).
          1. Let _n_ be 0.
          1. Let _items_ be a List whose first element is _O_ and whose subsequent elements are, in left to right order, the arguments that were passed to this function invocation.
          1. Repeat, while _items_ is not empty
            1. Remove the first element from _items_ and let _E_ be the value of the element.
            1. Let _spreadable_ be ? IsConcatSpreadable(_E_).
            1. If _spreadable_ is *true*, then
              1. Let _k_ be 0.
              1. Let _len_ be ? ToLength(? Get(_E_, `"length"`)).
              1. If _n_ + _len_ &gt; 2<sup>53</sup> - 1, throw a *TypeError* exception.
              1. Repeat, while _k_ &lt; _len_
                1. Let _P_ be ! ToString(_k_).
                1. Let _exists_ be ? HasProperty(_E_, _P_).
                1. If _exists_ is *true*, then
                  1. Let _subElement_ be ? Get(_E_, _P_).
                  1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(_n_), _subElement_).
                1. Increase _n_ by 1.
                1. Increase _k_ by 1.
            1. Else _E_ is added as a single item rather than spread,
              1. If _n_ &ge; 2<sup>53</sup> - 1, throw a *TypeError* exception.
              1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(_n_), _E_).
              1. Increase _n_ by 1.
          1. Perform ? Set(_A_, `"length"`, _n_, *true*).
          1. Return _A_.
        </emu-alg>
        <p>The `"length"` property of the `concat` method is 1.</p>
        <emu-note>
          <p>The explicit setting of the `"length"` property in step 6 is necessary to ensure that its value is correct in situations where the trailing elements of the result Array are not present.</p>
        </emu-note>
        <emu-note>
          <p>The `concat` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>

        <emu-clause id="sec-isconcatspreadable" aoid="IsConcatSpreadable">
          <h1>Runtime Semantics: IsConcatSpreadable ( _O_ )</h1>
          <p>The abstract operation IsConcatSpreadable with argument _O_ performs the following steps:</p>
          <emu-alg>
            1. If Type(_O_) is not Object, return *false*.
            1. Let _spreadable_ be ? Get(_O_, @@isConcatSpreadable).
            1. If _spreadable_ is not *undefined*, return ToBoolean(_spreadable_).
            1. Return ? IsArray(_O_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-array.prototype.constructor">
        <h1>Array.prototype.constructor</h1>
        <p>The initial value of `Array.prototype.constructor` is the intrinsic object %Array%.</p>
      </emu-clause>

      <emu-clause id="sec-array.prototype.copywithin">
        <h1>Array.prototype.copyWithin ( _target_, _start_ [ , _end_ ] )</h1>
        <p>The `copyWithin` method takes up to three arguments _target_, _start_ and _end_.</p>
        <emu-note>
          <p>The _end_ argument is optional with the length of the *this* object as its default value. If _target_ is negative, it is treated as <emu-eqn>_length_ + _target_</emu-eqn> where _length_ is the length of the array. If _start_ is negative, it is treated as <emu-eqn>_length_ + _start_</emu-eqn>. If _end_ is negative, it is treated as <emu-eqn>_length_ + _end_</emu-eqn>.</p>
        </emu-note>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_O_, `"length"`)).
          1. Let _relativeTarget_ be ? ToInteger(_target_).
          1. If _relativeTarget_ &lt; 0, let _to_ be max((_len_ + _relativeTarget_), 0); else let _to_ be min(_relativeTarget_, _len_).
          1. Let _relativeStart_ be ? ToInteger(_start_).
          1. If _relativeStart_ &lt; 0, let _from_ be max((_len_ + _relativeStart_), 0); else let _from_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToInteger(_end_).
          1. If _relativeEnd_ &lt; 0, let _final_ be max((_len_ + _relativeEnd_), 0); else let _final_ be min(_relativeEnd_, _len_).
          1. Let _count_ be min(_final_ - _from_, _len_ - _to_).
          1. If _from_ &lt; _to_ and _to_ &lt; _from_ + _count_, then
            1. Let _direction_ be -1.
            1. Set _from_ to _from_ + _count_ - 1.
            1. Set _to_ to _to_ + _count_ - 1.
          1. Else,
            1. Let _direction_ be 1.
          1. Repeat, while _count_ &gt; 0
            1. Let _fromKey_ be ! ToString(_from_).
            1. Let _toKey_ be ! ToString(_to_).
            1. Let _fromPresent_ be ? HasProperty(_O_, _fromKey_).
            1. If _fromPresent_ is *true*, then
              1. Let _fromVal_ be ? Get(_O_, _fromKey_).
              1. Perform ? Set(_O_, _toKey_, _fromVal_, *true*).
            1. Else _fromPresent_ is *false*,
              1. Perform ? DeletePropertyOrThrow(_O_, _toKey_).
            1. Set _from_ to _from_ + _direction_.
            1. Set _to_ to _to_ + _direction_.
            1. Decrease _count_ by 1.
          1. Return _O_.
        </emu-alg>
        <emu-note>
          <p>The `copyWithin` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.entries">
        <h1>Array.prototype.entries ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Return CreateArrayIterator(_O_, `"key+value"`).
        </emu-alg>
        <p>This function is the <dfn>%ArrayProto_entries%</dfn> intrinsic object.</p>
      </emu-clause>

      <emu-clause id="sec-array.prototype.every">
        <h1>Array.prototype.every ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callbackfn_ should be a function that accepts three arguments and returns a value that is coercible to the Boolean value *true* or *false*. `every` calls _callbackfn_ once for each element present in the array, in ascending order, until it finds one where _callbackfn_ returns *false*. If such an element is found, `every` immediately returns *false*. Otherwise, if _callbackfn_ returned *true* for all elements, `every` will return *true*. _callbackfn_ is called only for elements of the array which actually exist; it is not called for missing elements of the array.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _callbackfn_. If it is not provided, *undefined* is used instead.</p>
          <p>_callbackfn_ is called with three arguments: the value of the element, the index of the element, and the object being traversed.</p>
          <p>`every` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callbackfn_.</p>
          <p>The range of elements processed by `every` is set before the first call to _callbackfn_. Elements which are appended to the array after the call to `every` begins will not be visited by _callbackfn_. If existing elements of the array are changed, their value as passed to _callbackfn_ will be the value at the time `every` visits them; elements that are deleted after the call to `every` begins and before being visited are not visited. `every` acts like the "for all" quantifier in mathematics. In particular, for an empty array, it returns *true*.</p>
        </emu-note>
        <p>When the `every` method is called with one or two arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_O_, `"length"`)).
          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.
          1. If _thisArg_ is present, let _T_ be _thisArg_; else let _T_ be *undefined*.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_
            1. Let _Pk_ be ! ToString(_k_).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Let _testResult_ be ToBoolean(? Call(_callbackfn_, _T_, &laquo; _kValue_, _k_, _O_ &raquo;)).
              1. If _testResult_ is *false*, return *false*.
            1. Increase _k_ by 1.
          1. Return *true*.
        </emu-alg>
        <emu-note>
          <p>The `every` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.fill">
        <h1>Array.prototype.fill ( _value_ [ , _start_ [ , _end_ ] ] )</h1>
        <p>The `fill` method takes up to three arguments _value_, _start_ and _end_.</p>
        <emu-note>
          <p>The _start_ and _end_ arguments are optional with default values of 0 and the length of the *this* object. If _start_ is negative, it is treated as <emu-eqn>_length_ + _start_</emu-eqn> where _length_ is the length of the array. If _end_ is negative, it is treated as <emu-eqn>_length_ + _end_</emu-eqn>.</p>
        </emu-note>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_O_, `"length"`)).
          1. Let _relativeStart_ be ? ToInteger(_start_).
          1. If _relativeStart_ &lt; 0, let _k_ be max((_len_ + _relativeStart_), 0); else let _k_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToInteger(_end_).
          1. If _relativeEnd_ &lt; 0, let _final_ be max((_len_ + _relativeEnd_), 0); else let _final_ be min(_relativeEnd_, _len_).
          1. Repeat, while _k_ &lt; _final_
            1. Let _Pk_ be ! ToString(_k_).
            1. Perform ? Set(_O_, _Pk_, _value_, *true*).
            1. Increase _k_ by 1.
          1. Return _O_.
        </emu-alg>
        <emu-note>
          <p>The `fill` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.filter">
        <h1>Array.prototype.filter ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callbackfn_ should be a function that accepts three arguments and returns a value that is coercible to the Boolean value *true* or *false*. `filter` calls _callbackfn_ once for each element in the array, in ascending order, and constructs a new array of all the values for which _callbackfn_ returns *true*. _callbackfn_ is called only for elements of the array which actually exist; it is not called for missing elements of the array.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _callbackfn_. If it is not provided, *undefined* is used instead.</p>
          <p>_callbackfn_ is called with three arguments: the value of the element, the index of the element, and the object being traversed.</p>
          <p>`filter` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callbackfn_.</p>
          <p>The range of elements processed by `filter` is set before the first call to _callbackfn_. Elements which are appended to the array after the call to `filter` begins will not be visited by _callbackfn_. If existing elements of the array are changed their value as passed to _callbackfn_ will be the value at the time `filter` visits them; elements that are deleted after the call to `filter` begins and before being visited are not visited.</p>
        </emu-note>
        <p>When the `filter` method is called with one or two arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_O_, `"length"`)).
          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.
          1. If _thisArg_ is present, let _T_ be _thisArg_; else let _T_ be *undefined*.
          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).
          1. Let _k_ be 0.
          1. Let _to_ be 0.
          1. Repeat, while _k_ &lt; _len_
            1. Let _Pk_ be ! ToString(_k_).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Let _selected_ be ToBoolean(? Call(_callbackfn_, _T_, &laquo; _kValue_, _k_, _O_ &raquo;)).
              1. If _selected_ is *true*, then
                1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(_to_), _kValue_).
                1. Increase _to_ by 1.
            1. Increase _k_ by 1.
          1. Return _A_.
        </emu-alg>
        <emu-note>
          <p>The `filter` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.find">
        <h1>Array.prototype.find ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>The `find` method is called with one or two arguments, _predicate_ and _thisArg_.</p>
        <emu-note>
          <p>_predicate_ should be a function that accepts three arguments and returns a value that is coercible to a Boolean value. `find` calls _predicate_ once for each element of the array, in ascending order, until it finds one where _predicate_ returns *true*. If such an element is found, `find` immediately returns that element value. Otherwise, `find` returns *undefined*.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _predicate_. If it is not provided, *undefined* is used instead.</p>
          <p>_predicate_ is called with three arguments: the value of the element, the index of the element, and the object being traversed.</p>
          <p>`find` does not directly mutate the object on which it is called but the object may be mutated by the calls to _predicate_.</p>
          <p>The range of elements processed by `find` is set before the first call to _predicate_. Elements that are appended to the array after the call to `find` begins will not be visited by _predicate_. If existing elements of the array are changed, their value as passed to _predicate_ will be the value at the time that `find` visits them.</p>
        </emu-note>
        <p>When the `find` method is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_O_, `"length"`)).
          1. If IsCallable(_predicate_) is *false*, throw a *TypeError* exception.
          1. If _thisArg_ is present, let _T_ be _thisArg_; else let _T_ be *undefined*.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_
            1. Let _Pk_ be ! ToString(_k_).
            1. Let _kValue_ be ? Get(_O_, _Pk_).
            1. Let _testResult_ be ToBoolean(? Call(_predicate_, _T_, &laquo; _kValue_, _k_, _O_ &raquo;)).
            1. If _testResult_ is *true*, return _kValue_.
            1. Increase _k_ by 1.
          1. Return *undefined*.
        </emu-alg>
        <emu-note>
          <p>The `find` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.findindex">
        <h1>Array.prototype.findIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_predicate_ should be a function that accepts three arguments and returns a value that is coercible to the Boolean value *true* or *false*. `findIndex` calls _predicate_ once for each element of the array, in ascending order, until it finds one where _predicate_ returns *true*. If such an element is found, `findIndex` immediately returns the index of that element value. Otherwise, `findIndex` returns -1.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _predicate_. If it is not provided, *undefined* is used instead.</p>
          <p>_predicate_ is called with three arguments: the value of the element, the index of the element, and the object being traversed.</p>
          <p>`findIndex` does not directly mutate the object on which it is called but the object may be mutated by the calls to _predicate_.</p>
          <p>The range of elements processed by `findIndex` is set before the first call to _predicate_. Elements that are appended to the array after the call to `findIndex` begins will not be visited by _predicate_. If existing elements of the array are changed, their value as passed to _predicate_ will be the value at the time that `findIndex` visits them.</p>
        </emu-note>
        <p>When the `findIndex` method is called with one or two arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_O_, `"length"`)).
          1. If IsCallable(_predicate_) is *false*, throw a *TypeError* exception.
          1. If _thisArg_ is present, let _T_ be _thisArg_; else let _T_ be *undefined*.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_
            1. Let _Pk_ be ! ToString(_k_).
            1. Let _kValue_ be ? Get(_O_, _Pk_).
            1. Let _testResult_ be ToBoolean(? Call(_predicate_, _T_, &laquo; _kValue_, _k_, _O_ &raquo;)).
            1. If _testResult_ is *true*, return _k_.
            1. Increase _k_ by 1.
          1. Return -1.
        </emu-alg>
        <emu-note>
          <p>The `findIndex` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.flat">
        <h1>Array.prototype.flat ( [ _depth_ ] )</h1>
        <p>When the `flat` method is called with zero or one arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _sourceLen_ be ? ToLength(? Get(_O_, `"length"`)).
          1. Let _depthNum_ be 1.
          1. If _depth_ is not *undefined*, then
            1. Set _depthNum_ to ? ToInteger(_depth_).
          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).
          1. Perform ? FlattenIntoArray(_A_, _O_, _sourceLen_, 0, _depthNum_).
          1. Return _A_.
        </emu-alg>

        <emu-clause id="sec-flattenintoarray" aoid="FlattenIntoArray">
          <h1>FlattenIntoArray ( _target_, _source_, _sourceLen_, _start_, _depth_ [ , _mapperFunction_, _thisArg_ ] )</h1>
          <emu-alg>
            1. Let _targetIndex_ be _start_.
            1. Let _sourceIndex_ be 0.
            1. Repeat, while _sourceIndex_ &lt; _sourceLen_
              1. Let _P_ be ! ToString(_sourceIndex_).
              1. Let _exists_ be ? HasProperty(_source_, _P_).
              1. If _exists_ is *true*, then
                1. Let _element_ be ? Get(_source_, _P_).
                1. If _mapperFunction_ is present, then
                  1. Assert: _thisArg_ is present.
                  1. Set _element_ to ? Call(_mapperFunction_, _thisArg_, &laquo; _element_, _sourceIndex_, _source_ &raquo;).
                1. Let _shouldFlatten_ be *false*.
                1. If _depth_ &gt; 0, then
                  1. Set _shouldFlatten_ to ? IsArray(_element_).
                1. If _shouldFlatten_ is *true*, then
                  1. Let _elementLen_ be ? ToLength(? Get(_element_, `"length"`)).
                  1. Set _targetIndex_ to ? FlattenIntoArray(_target_, _element_, _elementLen_, _targetIndex_, _depth_ - 1).
                1. Else,
                  1. If _targetIndex_ &ge; 2<sup>53</sup> - 1, throw a *TypeError* exception.
                  1. Perform ? CreateDataPropertyOrThrow(_target_, ! ToString(_targetIndex_), _element_).
                  1. Increase _targetIndex_ by 1.
              1. Increase _sourceIndex_ by 1.
            1. Return _targetIndex_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-array.prototype.flatmap">
        <h1>Array.prototype.flatMap ( _mapperFunction_ [ , _thisArg_ ] )</h1>
        <p>When the `flatMap` method is called with one or two arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _sourceLen_ be ? ToLength(? Get(_O_, `"length"`)).
          1. If IsCallable(_mapperFunction_) is *false*, throw a *TypeError* exception.
          1. If _thisArg_ is present, let _T_ be _thisArg_; else let _T_ be *undefined*.
          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).
          1. Perform ? FlattenIntoArray(_A_, _O_, _sourceLen_, 0, 1, _mapperFunction_, _T_).
          1. Return _A_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.foreach">
        <h1>Array.prototype.forEach ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callbackfn_ should be a function that accepts three arguments. `forEach` calls _callbackfn_ once for each element present in the array, in ascending order. _callbackfn_ is called only for elements of the array which actually exist; it is not called for missing elements of the array.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _callbackfn_. If it is not provided, *undefined* is used instead.</p>
          <p>_callbackfn_ is called with three arguments: the value of the element, the index of the element, and the object being traversed.</p>
          <p>`forEach` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callbackfn_.</p>
        </emu-note>
        <p>When the `forEach` method is called with one or two arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_O_, `"length"`)).
          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.
          1. If _thisArg_ is present, let _T_ be _thisArg_; else let _T_ be *undefined*.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_
            1. Let _Pk_ be ! ToString(_k_).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Perform ? Call(_callbackfn_, _T_, &laquo; _kValue_, _k_, _O_ &raquo;).
            1. Increase _k_ by 1.
          1. Return *undefined*.
        </emu-alg>
        <p>This function is the <dfn>%ArrayProto_forEach%</dfn> intrinsic object.</p>
        <emu-note>
          <p>The `forEach` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.includes">
        <h1>Array.prototype.includes ( _searchElement_ [ , _fromIndex_ ] )</h1>

        <emu-note>
          <p>`includes` compares _searchElement_ to the elements of the array, in ascending order, using the SameValueZero algorithm, and if found at any position, returns *true*; otherwise, *false* is returned.</p>

          <p>The optional second argument _fromIndex_ defaults to 0 (i.e. the whole array is searched). If it is greater than or equal to the length of the array, *false* is returned, i.e. the array will not be searched. If it is negative, it is used as the offset from the end of the array to compute _fromIndex_. If the computed index is less than 0, the whole array will be searched.</p>
        </emu-note>

        <p>When the `includes` method is called, the following steps are taken:</p>

        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_O_, `"length"`)).
          1. If _len_ is 0, return *false*.
          1. Let _n_ be ? ToInteger(_fromIndex_).
          1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.
          1. If _n_ &ge; 0, then
            1. Let _k_ be _n_.
          1. Else _n_ &lt; 0,
            1. Let _k_ be _len_ + _n_.
            1. If _k_ &lt; 0, set _k_ to 0.
          1. Repeat, while _k_ &lt; _len_
            1. Let _elementK_ be the result of ? Get(_O_, ! ToString(_k_)).
            1. If SameValueZero(_searchElement_, _elementK_) is *true*, return *true*.
            1. Increase _k_ by 1.
          1. Return *false*.
        </emu-alg>

        <emu-note>
          <p>The `includes` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>

        <emu-note>
          <p>The `includes` method intentionally differs from the similar `indexOf` method in two ways. First, it uses the SameValueZero algorithm, instead of Strict Equality Comparison, allowing it to detect *NaN* array elements. Second, it does not skip missing array elements, instead treating them as *undefined*.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.indexof">
        <h1>Array.prototype.indexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <emu-note>
          <p>`indexOf` compares _searchElement_ to the elements of the array, in ascending order, using the Strict Equality Comparison algorithm, and if found at one or more indices, returns the smallest such index; otherwise, -1 is returned.</p>
          <p>The optional second argument _fromIndex_ defaults to 0 (i.e. the whole array is searched). If it is greater than or equal to the length of the array, -1 is returned, i.e. the array will not be searched. If it is negative, it is used as the offset from the end of the array to compute _fromIndex_. If the computed index is less than 0, the whole array will be searched.</p>
        </emu-note>
        <p>When the `indexOf` method is called with one or two arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_O_, `"length"`)).
          1. If _len_ is 0, return -1.
          1. Let _n_ be ? ToInteger(_fromIndex_).
          1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.
          1. If _n_ &ge; _len_, return -1.
          1. If _n_ &ge; 0, then
            1. If _n_ is *-0*, let _k_ be *+0*; else let _k_ be _n_.
          1. Else _n_ &lt; 0,
            1. Let _k_ be _len_ + _n_.
            1. If _k_ &lt; 0, set _k_ to 0.
          1. Repeat, while _k_ &lt; _len_
            1. Let _kPresent_ be ? HasProperty(_O_, ! ToString(_k_)).
            1. If _kPresent_ is *true*, then
              1. Let _elementK_ be ? Get(_O_, ! ToString(_k_)).
              1. Let _same_ be the result of performing Strict Equality Comparison _searchElement_ === _elementK_.
              1. If _same_ is *true*, return _k_.
            1. Increase _k_ by 1.
          1. Return -1.
        </emu-alg>
        <emu-note>
          <p>The `indexOf` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.join">
        <h1>Array.prototype.join ( _separator_ )</h1>
        <emu-note>
          <p>The elements of the array are converted to Strings, and these Strings are then concatenated, separated by occurrences of the _separator_. If no separator is provided, a single comma is used as the separator.</p>
        </emu-note>
        <emu-note>
          The `join` method has a [[SeenObjects]] internal slot whose value is a new empty List.
        </emu-note>
        <p>The `join` method takes one argument, _separator_, and performs the following steps:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_O_, `"length"`)).
          1. If _separator_ is *undefined*, let _sep_ be the single-element String `","`.
          1. Else, let _sep_ be ? ToString(_separator_).
          1. Let _R_ be the empty String.
          1. Let _k_ be 0.
          1. Let _seen_ be %Array.prototype.join%.[[SeenObjects]].
          1. Repeat, while _k_ &lt; _len_
            1. If _k_ &gt; 0, set _R_ to the string-concatenation of _R_ and _sep_.
            1. Let _element_ be ? Get(_O_, ! ToString(_k_)).
            1. If Type(_element_) is Object and _seen_ contains _element_, then
              1. Let _next_ be the empty String.
            1. Else,
              1. If Type(_element_) is Object, append _element_ to _seen_.
              1. If _element_ is *undefined* or *null*, let _next_ be the empty String; otherwise, let _next_ be ? ToString(_element_).
            1. Set _R_ to the string-concatenation of _R_ and _next_.
            1. Increase _k_ by 1.
          1. Set %Array.prototype.join%.[[SeenObjects]] to a new empty List.
          1. Return _R_.
        </emu-alg>
        <emu-note>
          <p>The `join` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.keys">
        <h1>Array.prototype.keys ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Return CreateArrayIterator(_O_, `"key"`).
        </emu-alg>
        <p>This function is the <dfn>%ArrayProto_keys%</dfn> intrinsic object.</p>
      </emu-clause>

      <emu-clause id="sec-array.prototype.lastindexof">
        <h1>Array.prototype.lastIndexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <emu-note>
          <p>`lastIndexOf` compares _searchElement_ to the elements of the array in descending order using the Strict Equality Comparison algorithm, and if found at one or more indices, returns the largest such index; otherwise, -1 is returned.</p>
          <p>The optional second argument _fromIndex_ defaults to the array's length minus one (i.e. the whole array is searched). If it is greater than or equal to the length of the array, the whole array will be searched. If it is negative, it is used as the offset from the end of the array to compute _fromIndex_. If the computed index is less than 0, -1 is returned.</p>
        </emu-note>
        <p>When the `lastIndexOf` method is called with one or two arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_O_, `"length"`)).
          1. If _len_ is 0, return -1.
          1. If _fromIndex_ is present, let _n_ be ? ToInteger(_fromIndex_); else let _n_ be _len_ - 1.
          1. If _n_ &ge; 0, then
            1. If _n_ is *-0*, let _k_ be *+0*; else let _k_ be min(_n_, _len_ - 1).
          1. Else _n_ &lt; 0,
            1. Let _k_ be _len_ + _n_.
          1. Repeat, while _k_ &ge; 0
            1. Let _kPresent_ be ? HasProperty(_O_, ! ToString(_k_)).
            1. If _kPresent_ is *true*, then
              1. Let _elementK_ be ? Get(_O_, ! ToString(_k_)).
              1. Let _same_ be the result of performing Strict Equality Comparison _searchElement_ === _elementK_.
              1. If _same_ is *true*, return _k_.
            1. Decrease _k_ by 1.
          1. Return -1.
        </emu-alg>
        <emu-note>
          <p>The `lastIndexOf` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.map">
        <h1>Array.prototype.map ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callbackfn_ should be a function that accepts three arguments. `map` calls _callbackfn_ once for each element in the array, in ascending order, and constructs a new Array from the results. _callbackfn_ is called only for elements of the array which actually exist; it is not called for missing elements of the array.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _callbackfn_. If it is not provided, *undefined* is used instead.</p>
          <p>_callbackfn_ is called with three arguments: the value of the element, the index of the element, and the object being traversed.</p>
          <p>`map` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callbackfn_.</p>
          <p>The range of elements processed by `map` is set before the first call to _callbackfn_. Elements which are appended to the array after the call to `map` begins will not be visited by _callbackfn_. If existing elements of the array are changed, their value as passed to _callbackfn_ will be the value at the time `map` visits them; elements that are deleted after the call to `map` begins and before being visited are not visited.</p>
        </emu-note>
        <p>When the `map` method is called with one or two arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_O_, `"length"`)).
          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.
          1. If _thisArg_ is present, let _T_ be _thisArg_; else let _T_ be *undefined*.
          1. Let _A_ be ? ArraySpeciesCreate(_O_, _len_).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_
            1. Let _Pk_ be ! ToString(_k_).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Let _mappedValue_ be ? Call(_callbackfn_, _T_, &laquo; _kValue_, _k_, _O_ &raquo;).
              1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_).
            1. Increase _k_ by 1.
          1. Return _A_.
        </emu-alg>
        <emu-note>
          <p>The `map` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.pop">
        <h1>Array.prototype.pop ( )</h1>
        <emu-note>
          <p>The last element of the array is removed from the array and returned.</p>
        </emu-note>
        <p>When the `pop` method is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_O_, `"length"`)).
          1. If _len_ is zero, then
            1. Perform ? Set(_O_, `"length"`, 0, *true*).
            1. Return *undefined*.
          1. Else _len_ &gt; 0,
            1. Let _newLen_ be _len_ - 1.
            1. Let _index_ be ! ToString(_newLen_).
            1. Let _element_ be ? Get(_O_, _index_).
            1. Perform ? DeletePropertyOrThrow(_O_, _index_).
            1. Perform ? Set(_O_, `"length"`, _newLen_, *true*).
            1. Return _element_.
        </emu-alg>
        <emu-note>
          <p>The `pop` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.push">
        <h1>Array.prototype.push ( ..._items_ )</h1>
        <emu-note>
          <p>The arguments are appended to the end of the array, in the order in which they appear. The new length of the array is returned as the result of the call.</p>
        </emu-note>
        <p>When the `push` method is called with zero or more arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_O_, `"length"`)).
          1. Let _items_ be a List whose elements are, in left to right order, the arguments that were passed to this function invocation.
          1. Let _argCount_ be the number of elements in _items_.
          1. If _len_ + _argCount_ &gt; 2<sup>53</sup> - 1, throw a *TypeError* exception.
          1. Repeat, while _items_ is not empty
            1. Remove the first element from _items_ and let _E_ be the value of the element.
            1. Perform ? Set(_O_, ! ToString(_len_), _E_, *true*).
            1. Increase _len_ by 1.
          1. Perform ? Set(_O_, `"length"`, _len_, *true*).
          1. Return _len_.
        </emu-alg>
        <p>The `"length"` property of the `push` method is 1.</p>
        <emu-note>
          <p>The `push` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.reduce">
        <h1>Array.prototype.reduce ( _callbackfn_ [ , _initialValue_ ] )</h1>
        <emu-note>
          <p>_callbackfn_ should be a function that takes four arguments. `reduce` calls the callback, as a function, once for each element after the first element present in the array, in ascending order.</p>
          <p>_callbackfn_ is called with four arguments: the _previousValue_ (value from the previous call to _callbackfn_), the _currentValue_ (value of the current element), the _currentIndex_, and the object being traversed. The first time that callback is called, the _previousValue_ and _currentValue_ can be one of two values. If an _initialValue_ was supplied in the call to `reduce`, then _previousValue_ will be equal to _initialValue_ and _currentValue_ will be equal to the first value in the array. If no _initialValue_ was supplied, then _previousValue_ will be equal to the first value in the array and _currentValue_ will be equal to the second. It is a *TypeError* if the array contains no elements and _initialValue_ is not provided.</p>
          <p>`reduce` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callbackfn_.</p>
          <p>The range of elements processed by `reduce` is set before the first call to _callbackfn_. Elements that are appended to the array after the call to `reduce` begins will not be visited by _callbackfn_. If existing elements of the array are changed, their value as passed to _callbackfn_ will be the value at the time `reduce` visits them; elements that are deleted after the call to `reduce` begins and before being visited are not visited.</p>
        </emu-note>
        <p>When the `reduce` method is called with one or two arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_O_, `"length"`)).
          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.
          1. If _len_ is 0 and _initialValue_ is not present, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Let _accumulator_ be *undefined*.
          1. If _initialValue_ is present, then
            1. Set _accumulator_ to _initialValue_.
          1. Else _initialValue_ is not present,
            1. Let _kPresent_ be *false*.
            1. Repeat, while _kPresent_ is *false* and _k_ &lt; _len_
              1. Let _Pk_ be ! ToString(_k_).
              1. Set _kPresent_ to ? HasProperty(_O_, _Pk_).
              1. If _kPresent_ is *true*, then
                1. Set _accumulator_ to ? Get(_O_, _Pk_).
              1. Increase _k_ by 1.
            1. If _kPresent_ is *false*, throw a *TypeError* exception.
          1. Repeat, while _k_ &lt; _len_
            1. Let _Pk_ be ! ToString(_k_).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Set _accumulator_ to ? Call(_callbackfn_, *undefined*, &laquo; _accumulator_, _kValue_, _k_, _O_ &raquo;).
            1. Increase _k_ by 1.
          1. Return _accumulator_.
        </emu-alg>
        <emu-note>
          <p>The `reduce` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.reduceright">
        <h1>Array.prototype.reduceRight ( _callbackfn_ [ , _initialValue_ ] )</h1>
        <emu-note>
          <p>_callbackfn_ should be a function that takes four arguments. `reduceRight` calls the callback, as a function, once for each element after the first element present in the array, in descending order.</p>
          <p>_callbackfn_ is called with four arguments: the _previousValue_ (value from the previous call to _callbackfn_), the _currentValue_ (value of the current element), the _currentIndex_, and the object being traversed. The first time the function is called, the _previousValue_ and _currentValue_ can be one of two values. If an _initialValue_ was supplied in the call to `reduceRight`, then _previousValue_ will be equal to _initialValue_ and _currentValue_ will be equal to the last value in the array. If no _initialValue_ was supplied, then _previousValue_ will be equal to the last value in the array and _currentValue_ will be equal to the second-to-last value. It is a *TypeError* if the array contains no elements and _initialValue_ is not provided.</p>
          <p>`reduceRight` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callbackfn_.</p>
          <p>The range of elements processed by `reduceRight` is set before the first call to _callbackfn_. Elements that are appended to the array after the call to `reduceRight` begins will not be visited by _callbackfn_. If existing elements of the array are changed by _callbackfn_, their value as passed to _callbackfn_ will be the value at the time `reduceRight` visits them; elements that are deleted after the call to `reduceRight` begins and before being visited are not visited.</p>
        </emu-note>
        <p>When the `reduceRight` method is called with one or two arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_O_, `"length"`)).
          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.
          1. If _len_ is 0 and _initialValue_ is not present, throw a *TypeError* exception.
          1. Let _k_ be _len_ - 1.
          1. Let _accumulator_ be *undefined*.
          1. If _initialValue_ is present, then
            1. Set _accumulator_ to _initialValue_.
          1. Else _initialValue_ is not present,
            1. Let _kPresent_ be *false*.
            1. Repeat, while _kPresent_ is *false* and _k_ &ge; 0
              1. Let _Pk_ be ! ToString(_k_).
              1. Set _kPresent_ to ? HasProperty(_O_, _Pk_).
              1. If _kPresent_ is *true*, then
                1. Set _accumulator_ to ? Get(_O_, _Pk_).
              1. Decrease _k_ by 1.
            1. If _kPresent_ is *false*, throw a *TypeError* exception.
          1. Repeat, while _k_ &ge; 0
            1. Let _Pk_ be ! ToString(_k_).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Set _accumulator_ to ? Call(_callbackfn_, *undefined*, &laquo; _accumulator_, _kValue_, _k_, _O_ &raquo;).
            1. Decrease _k_ by 1.
          1. Return _accumulator_.
        </emu-alg>
        <emu-note>
          <p>The `reduceRight` function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.reverse">
        <h1>Array.prototype.reverse ( )</h1>
        <emu-note>
          <p>The elements of the array are rearranged so as to reverse their order. The object is returned as the result of the call.</p>
        </emu-note>
        <p>When the `reverse` method is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_O_, `"length"`)).
          1. Let _middle_ be floor(_len_ / 2).
          1. Let _lower_ be 0.
          1. Repeat, while _lower_ &ne; _middle_
            1. Let _upper_ be _len_ - _lower_ - 1.
            1. Let _upperP_ be ! ToString(_upper_).
            1. Let _lowerP_ be ! ToString(_lower_).
            1. Let _lowerExists_ be ? HasProperty(_O_, _lowerP_).
            1. If _lowerExists_ is *true*, then
              1. Let _lowerValue_ be ? Get(_O_, _lowerP_).
            1. Let _upperExists_ be ? HasProperty(_O_, _upperP_).
            1. If _upperExists_ is *true*, then
              1. Let _upperValue_ be ? Get(_O_, _upperP_).
            1. If _lowerExists_ is *true* and _upperExists_ is *true*, then
              1. Perform ? Set(_O_, _lowerP_, _upperValue_, *true*).
              1. Perform ? Set(_O_, _upperP_, _lowerValue_, *true*).
            1. Else if _lowerExists_ is *false* and _upperExists_ is *true*, then
              1. Perform ? Set(_O_, _lowerP_, _upperValue_, *true*).
              1. Perform ? DeletePropertyOrThrow(_O_, _upperP_).
            1. Else if _lowerExists_ is *true* and _upperExists_ is *false*, then
              1. Perform ? DeletePropertyOrThrow(_O_, _lowerP_).
              1. Perform ? Set(_O_, _upperP_, _lowerValue_, *true*).
            1. Else both _lowerExists_ and _upperExists_ are *false*,
              1. No action is required.
            1. Increase _lower_ by 1.
          1. Return _O_.
        </emu-alg>
        <emu-note>
          <p>The `reverse` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.shift">
        <h1>Array.prototype.shift ( )</h1>
        <emu-note>
          <p>The first element of the array is removed from the array and returned.</p>
        </emu-note>
        <p>When the `shift` method is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_O_, `"length"`)).
          1. If _len_ is zero, then
            1. Perform ? Set(_O_, `"length"`, 0, *true*).
            1. Return *undefined*.
          1. Let _first_ be ? Get(_O_, `"0"`).
          1. Let _k_ be 1.
          1. Repeat, while _k_ &lt; _len_
            1. Let _from_ be ! ToString(_k_).
            1. Let _to_ be ! ToString(_k_ - 1).
            1. Let _fromPresent_ be ? HasProperty(_O_, _from_).
            1. If _fromPresent_ is *true*, then
              1. Let _fromVal_ be ? Get(_O_, _from_).
              1. Perform ? Set(_O_, _to_, _fromVal_, *true*).
            1. Else _fromPresent_ is *false*,
              1. Perform ? DeletePropertyOrThrow(_O_, _to_).
            1. Increase _k_ by 1.
          1. Perform ? DeletePropertyOrThrow(_O_, ! ToString(_len_ - 1)).
          1. Perform ? Set(_O_, `"length"`, _len_ - 1, *true*).
          1. Return _first_.
        </emu-alg>
        <emu-note>
          <p>The `shift` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.slice">
        <h1>Array.prototype.slice ( _start_, _end_ )</h1>
        <emu-note>
          <p>The `slice` method takes two arguments, _start_ and _end_, and returns an array containing the elements of the array from element _start_ up to, but not including, element _end_ (or through the end of the array if _end_ is *undefined*). If _start_ is negative, it is treated as <emu-eqn>_length_ + _start_</emu-eqn> where _length_ is the length of the array. If _end_ is negative, it is treated as <emu-eqn>_length_ + _end_</emu-eqn> where _length_ is the length of the array.</p>
        </emu-note>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_O_, `"length"`)).
          1. Let _relativeStart_ be ? ToInteger(_start_).
          1. If _relativeStart_ &lt; 0, let _k_ be max((_len_ + _relativeStart_), 0); else let _k_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToInteger(_end_).
          1. If _relativeEnd_ &lt; 0, let _final_ be max((_len_ + _relativeEnd_), 0); else let _final_ be min(_relativeEnd_, _len_).
          1. Let _count_ be max(_final_ - _k_, 0).
          1. Let _A_ be ? ArraySpeciesCreate(_O_, _count_).
          1. Let _n_ be 0.
          1. Repeat, while _k_ &lt; _final_
            1. Let _Pk_ be ! ToString(_k_).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(_n_), _kValue_).
            1. Increase _k_ by 1.
            1. Increase _n_ by 1.
          1. Perform ? Set(_A_, `"length"`, _n_, *true*).
          1. Return _A_.
        </emu-alg>
        <emu-note>
          <p>The explicit setting of the `"length"` property of the result Array in step 11 was necessary in previous editions of ECMAScript to ensure that its length was correct in situations where the trailing elements of the result Array were not present. Setting `"length"` became unnecessary starting in ES2015 when the result Array was initialized to its proper length rather than an empty Array but is carried forward to preserve backward compatibility.</p>
        </emu-note>
        <emu-note>
          <p>The `slice` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.some">
        <h1>Array.prototype.some ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callbackfn_ should be a function that accepts three arguments and returns a value that is coercible to the Boolean value *true* or *false*. `some` calls _callbackfn_ once for each element present in the array, in ascending order, until it finds one where _callbackfn_ returns *true*. If such an element is found, `some` immediately returns *true*. Otherwise, `some` returns *false*. _callbackfn_ is called only for elements of the array which actually exist; it is not called for missing elements of the array.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _callbackfn_. If it is not provided, *undefined* is used instead.</p>
          <p>_callbackfn_ is called with three arguments: the value of the element, the index of the element, and the object being traversed.</p>
          <p>`some` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callbackfn_.</p>
          <p>The range of elements processed by `some` is set before the first call to _callbackfn_. Elements that are appended to the array after the call to `some` begins will not be visited by _callbackfn_. If existing elements of the array are changed, their value as passed to _callbackfn_ will be the value at the time that `some` visits them; elements that are deleted after the call to `some` begins and before being visited are not visited. `some` acts like the "exists" quantifier in mathematics. In particular, for an empty array, it returns *false*.</p>
        </emu-note>
        <p>When the `some` method is called with one or two arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_O_, `"length"`)).
          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.
          1. If _thisArg_ is present, let _T_ be _thisArg_; else let _T_ be *undefined*.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_
            1. Let _Pk_ be ! ToString(_k_).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Let _testResult_ be ToBoolean(? Call(_callbackfn_, _T_, &laquo; _kValue_, _k_, _O_ &raquo;)).
              1. If _testResult_ is *true*, return *true*.
            1. Increase _k_ by 1.
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>The `some` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.sort">
        <h1>Array.prototype.sort ( _comparefn_ )</h1>
        <p>The elements of this array are sorted. The sort must be stable (that is, elements that compare equal must remain in their original order). If _comparefn_ is not *undefined*, it should be a function that accepts two arguments _x_ and _y_ and returns a negative value if _x_ &lt; _y_, zero if _x_ = _y_, or a positive value if _x_ &gt; _y_.</p>
        <p>Upon entry, the following steps are performed to initialize evaluation of the `sort` function:</p>
        <emu-alg>
          1. If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.
          1. Let _obj_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_obj_, `"length"`)).
        </emu-alg>
        <p>Within this specification of the `sort` method, an object, _obj_, is said to be <em>sparse</em> if the following algorithm returns *true*:</p>
        <emu-alg>
          1. For each integer _i_ in the range 0 &le; _i_ &lt; _len_, do
            1. Let _elem_ be _obj_.[[GetOwnProperty]](! ToString(_i_)).
            1. If _elem_ is *undefined*, return *true*.
          1. Return *false*.
        </emu-alg>
        <p>The <em>sort order</em> is the ordering, after completion of this function, of the <emu-xref href="#integer-index">integer-indexed</emu-xref> property values of _obj_ whose integer indexes are less than _len_. The result of the `sort` function is then determined as follows:</p>
        <p>If _comparefn_ is not *undefined* and is not a consistent comparison function for the elements of this array (see below), the sort order is implementation-defined. The sort order is also implementation-defined if _comparefn_ is *undefined* and SortCompare does not act as a consistent comparison function.</p>
        <p>Let _proto_ be _obj_.[[GetPrototypeOf]](). If _proto_ is not *null* and there exists an integer _j_ such that all of the conditions below are satisfied then the sort order is implementation-defined:</p>
        <ul>
          <li>
            _obj_ is sparse
          </li>
          <li>
            0 &le; _j_ &lt; _len_
          </li>
          <li>
            HasProperty(_proto_, ToString(_j_)) is *true*.
          </li>
        </ul>
        <p>The sort order is also implementation-defined if _obj_ is sparse and any of the following conditions are true:</p>
        <ul>
          <li>
            IsExtensible(_obj_) is *false*.
          </li>
          <li>
            Any integer index property of _obj_ whose name is a nonnegative integer less than _len_ is a data property whose [[Configurable]] attribute is *false*.
          </li>
        </ul>
        <p>The sort order is also implementation-defined if any of the following conditions are true:</p>
        <ul>
          <li>
            If _obj_ is an exotic object (including Proxy exotic objects) whose behaviour for [[Get]], [[Set]], [[Delete]], and [[GetOwnProperty]] is not the ordinary object implementation of these internal methods.
          </li>
          <li>
            If any index property of _obj_ whose name is a nonnegative integer less than _len_ is an accessor property or is a data property whose [[Writable]] attribute is *false*.
          </li>
          <li>
            If _comparefn_ is *undefined* and the application of ToString to any value passed as an argument to SortCompare modifies _obj_ or any object on _obj_'s prototype chain.
          </li>
          <li>
            If _comparefn_ is *undefined* and all applications of ToString, to any specific value passed as an argument to SortCompare, do not produce the same result.
          </li>
        </ul>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Perform an implementation-dependent sequence of calls to the [[Get]] and [[Set]] internal methods of _obj_, to the DeletePropertyOrThrow and HasOwnProperty abstract operation with _obj_ as the first argument, and to SortCompare (described below), such that:
            * The property key argument for each call to [[Get]], [[Set]], HasOwnProperty, or DeletePropertyOrThrow is the string representation of a nonnegative integer less than _len_.
            * The arguments for calls to SortCompare are values returned by a previous call to the [[Get]] internal method, unless the properties accessed by those previous calls did not exist according to HasOwnProperty. If both prospective arguments to SortCompare correspond to non-existent properties, use *+0* instead of calling SortCompare. If only the first prospective argument is non-existent use +1. If only the second prospective argument is non-existent use -1.
            * If _obj_ is not sparse then DeletePropertyOrThrow must not be called.
            * If any [[Set]] call returns *false* a *TypeError* exception is thrown.
            * If an abrupt completion is returned from any of these operations, it is immediately returned as the value of this function.
          1. Return _obj_.
        </emu-alg>
        <p>Unless the sort order is specified above to be implementation-defined, the returned object must have the following two characteristics:</p>
        <ul>
          <li>
            There must be some mathematical permutation &pi; of the nonnegative integers less than _len_, such that for every nonnegative integer _j_ less than _len_, if property <emu-eqn>old[_j_]</emu-eqn> existed, then <emu-eqn>new[&pi;(_j_)]</emu-eqn> is exactly the same value as <emu-eqn>old[_j_]</emu-eqn>. But if property <emu-eqn>old[_j_]</emu-eqn> did not exist, then <emu-eqn>new[&pi;(_j_)]</emu-eqn> does not exist.
          </li>
          <li>
            Then for all nonnegative integers _j_ and _k_, each less than _len_, if <emu-eqn>SortCompare(old[_j_], old[_k_]) &lt; 0</emu-eqn> (see SortCompare below), then <emu-eqn>new[&pi;(_j_)] &lt; new[&pi;(_k_)]</emu-eqn>.
          </li>
        </ul>
        <p>Here the notation <emu-eqn>old[_j_]</emu-eqn> is used to refer to the hypothetical result of calling _obj_.[[Get]](_j_) before this function is executed, and the notation <emu-eqn>new[_j_]</emu-eqn> to refer to the hypothetical result of calling _obj_.[[Get]](_j_) after this function has been executed.</p>
        <p>A function _comparefn_ is a consistent comparison function for a set of values _S_ if all of the requirements below are met for all values _a_, _b_, and _c_ (possibly the same value) in the set _S_: The notation <emu-eqn>_a_ &lt;<sub>CF</sub> _b_</emu-eqn> means <emu-eqn>_comparefn_(_a_, _b_) &lt; 0</emu-eqn>; <emu-eqn>_a_ =<sub>CF</sub> _b_</emu-eqn> means <emu-eqn>_comparefn_(_a_, _b_) = 0</emu-eqn> (of either sign); and <emu-eqn>_a_ &gt;<sub>CF</sub> _b_</emu-eqn> means <emu-eqn>_comparefn_(_a_, _b_) &gt; 0</emu-eqn>.</p>
        <ul>
          <li>
            Calling _comparefn_(_a_, _b_) always returns the same value _v_ when given a specific pair of values _a_ and _b_ as its two arguments. Furthermore, Type(_v_) is Number, and _v_ is not *NaN*. Note that this implies that exactly one of _a_ &lt;<sub>CF</sub> _b_, _a_ =<sub>CF</sub> _b_, and _a_ &gt;<sub>CF</sub> _b_ will be true for a given pair of _a_ and _b_.
          </li>
          <li>
            Calling _comparefn_(_a_, _b_) does not modify _obj_ or any object on _obj_'s prototype chain.
          </li>
          <li>
            _a_ =<sub>CF</sub> _a_ (reflexivity)
          </li>
          <li>
            If _a_ =<sub>CF</sub> _b_, then _b_ =<sub>CF</sub> _a_ (symmetry)
          </li>
          <li>
            If _a_ =<sub>CF</sub> _b_ and _b_ =<sub>CF</sub> _c_, then _a_ =<sub>CF</sub> _c_ (transitivity of =<sub>CF</sub>)
          </li>
          <li>
            If _a_ &lt;<sub>CF</sub> _b_ and _b_ &lt;<sub>CF</sub> _c_, then _a_ &lt;<sub>CF</sub> _c_ (transitivity of &lt;<sub>CF</sub>)
          </li>
          <li>
            If _a_ &gt;<sub>CF</sub> _b_ and _b_ &gt;<sub>CF</sub> _c_, then _a_ &gt;<sub>CF</sub> _c_ (transitivity of &gt;<sub>CF</sub>)
          </li>
        </ul>
        <emu-note>
          <p>The above conditions are necessary and sufficient to ensure that _comparefn_ divides the set _S_ into equivalence classes and that these equivalence classes are totally ordered.</p>
        </emu-note>
        <emu-note>
          <p>The `sort` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>

        <emu-clause id="sec-sortcompare" aoid="SortCompare">
          <h1>Runtime Semantics: SortCompare ( _x_, _y_ )</h1>
          <p>The SortCompare abstract operation is called with two arguments _x_ and _y_. It also has access to the _comparefn_ argument passed to the current invocation of the `sort` method. The following steps are taken:</p>
          <emu-alg>
            1. If _x_ and _y_ are both *undefined*, return *+0*.
            1. If _x_ is *undefined*, return 1.
            1. If _y_ is *undefined*, return -1.
            1. If _comparefn_ is not *undefined*, then
              1. Let _v_ be ? ToNumber(? Call(_comparefn_, *undefined*, &laquo; _x_, _y_ &raquo;)).
              1. If _v_ is *NaN*, return *+0*.
              1. Return _v_.
            1. Let _xString_ be ? ToString(_x_).
            1. Let _yString_ be ? ToString(_y_).
            1. Let _xSmaller_ be the result of performing Abstract Relational Comparison _xString_ &lt; _yString_.
            1. If _xSmaller_ is *true*, return -1.
            1. Let _ySmaller_ be the result of performing Abstract Relational Comparison _yString_ &lt; _xString_.
            1. If _ySmaller_ is *true*, return 1.
            1. Return *+0*.
          </emu-alg>
          <emu-note>
            <p>Because non-existent property values always compare greater than *undefined* property values, and *undefined* always compares greater than any other value, *undefined* property values always sort to the end of the result, followed by non-existent property values.</p>
          </emu-note>
          <emu-note>
            <p>Method calls performed by the ToString abstract operations in steps 5 and 7 have the potential to cause SortCompare to not behave as a consistent comparison function.</p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-array.prototype.splice">
        <h1>Array.prototype.splice ( _start_, _deleteCount_, ..._items_ )</h1>
        <emu-note>
          <p>When the `splice` method is called with two or more arguments _start_, _deleteCount_ and zero or more _items_, the _deleteCount_ elements of the array starting at integer index _start_ are replaced by the arguments _items_. An Array object containing the deleted elements (if any) is returned.</p>
        </emu-note>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_O_, `"length"`)).
          1. Let _relativeStart_ be ? ToInteger(_start_).
          1. If _relativeStart_ &lt; 0, let _actualStart_ be max((_len_ + _relativeStart_), 0); else let _actualStart_ be min(_relativeStart_, _len_).
          1. If the number of actual arguments is 0, then
            1. Let _insertCount_ be 0.
            1. Let _actualDeleteCount_ be 0.
          1. Else if the number of actual arguments is 1, then
            1. Let _insertCount_ be 0.
            1. Let _actualDeleteCount_ be _len_ - _actualStart_.
          1. Else,
            1. Let _insertCount_ be the number of actual arguments minus 2.
            1. Let _dc_ be ? ToInteger(_deleteCount_).
            1. Let _actualDeleteCount_ be min(max(_dc_, 0), _len_ - _actualStart_).
          1. If _len_ + _insertCount_ - _actualDeleteCount_ &gt; 2<sup>53</sup> - 1, throw a *TypeError* exception.
          1. Let _A_ be ? ArraySpeciesCreate(_O_, _actualDeleteCount_).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _actualDeleteCount_
            1. Let _from_ be ! ToString(_actualStart_ + _k_).
            1. Let _fromPresent_ be ? HasProperty(_O_, _from_).
            1. If _fromPresent_ is *true*, then
              1. Let _fromValue_ be ? Get(_O_, _from_).
              1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(_k_), _fromValue_).
            1. Increment _k_ by 1.
          1. Perform ? Set(_A_, `"length"`, _actualDeleteCount_, *true*).
          1. Let _items_ be a List whose elements are, in left to right order, the portion of the actual argument list starting with the third argument. The list is empty if fewer than three arguments were passed.
          1. Let _itemCount_ be the number of elements in _items_.
          1. If _itemCount_ &lt; _actualDeleteCount_, then
            1. Set _k_ to _actualStart_.
            1. Repeat, while _k_ &lt; (_len_ - _actualDeleteCount_)
              1. Let _from_ be ! ToString(_k_ + _actualDeleteCount_).
              1. Let _to_ be ! ToString(_k_ + _itemCount_).
              1. Let _fromPresent_ be ? HasProperty(_O_, _from_).
              1. If _fromPresent_ is *true*, then
                1. Let _fromValue_ be ? Get(_O_, _from_).
                1. Perform ? Set(_O_, _to_, _fromValue_, *true*).
              1. Else _fromPresent_ is *false*,
                1. Perform ? DeletePropertyOrThrow(_O_, _to_).
              1. Increase _k_ by 1.
            1. Set _k_ to _len_.
            1. Repeat, while _k_ &gt; (_len_ - _actualDeleteCount_ + _itemCount_)
              1. Perform ? DeletePropertyOrThrow(_O_, ! ToString(_k_ - 1)).
              1. Decrease _k_ by 1.
          1. Else if _itemCount_ &gt; _actualDeleteCount_, then
            1. Set _k_ to (_len_ - _actualDeleteCount_).
            1. Repeat, while _k_ &gt; _actualStart_
              1. Let _from_ be ! ToString(_k_ + _actualDeleteCount_ - 1).
              1. Let _to_ be ! ToString(_k_ + _itemCount_ - 1).
              1. Let _fromPresent_ be ? HasProperty(_O_, _from_).
              1. If _fromPresent_ is *true*, then
                1. Let _fromValue_ be ? Get(_O_, _from_).
                1. Perform ? Set(_O_, _to_, _fromValue_, *true*).
              1. Else _fromPresent_ is *false*,
                1. Perform ? DeletePropertyOrThrow(_O_, _to_).
              1. Decrease _k_ by 1.
          1. Set _k_ to _actualStart_.
          1. Repeat, while _items_ is not empty
            1. Remove the first element from _items_ and let _E_ be the value of that element.
            1. Perform ? Set(_O_, ! ToString(_k_), _E_, *true*).
            1. Increase _k_ by 1.
          1. Perform ? Set(_O_, `"length"`, _len_ - _actualDeleteCount_ + _itemCount_, *true*).
          1. Return _A_.
        </emu-alg>
        <emu-note>
          <p>The explicit setting of the `"length"` property of the result Array in step 19 was necessary in previous editions of ECMAScript to ensure that its length was correct in situations where the trailing elements of the result Array were not present. Setting `"length"` became unnecessary starting in ES2015 when the result Array was initialized to its proper length rather than an empty Array but is carried forward to preserve backward compatibility.</p>
        </emu-note>
        <emu-note>
          <p>The `splice` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.tolocalestring">
        <h1>Array.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Array.prototype.toLocaleString` method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `toLocaleString` method is used.</p>
        <emu-note>
          <p>The first edition of ECMA-402 did not include a replacement specification for the `Array.prototype.toLocaleString` method.</p>
        </emu-note>
        <p>The meanings of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _array_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_array_, `"length"`)).
          1. Let _separator_ be the String value for the list-separator String appropriate for the host environment's current locale (this is derived in an implementation-defined way).
          1. Let _R_ be the empty String.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_
            1. If _k_ &gt; 0, then
              1. Set _R_ to the string-concatenation of _R_ and _separator_.
            1. Let _nextElement_ be ? Get(_array_, ! ToString(_k_)).
            1. If _nextElement_ is not *undefined* or *null*, then
              1. Let _S_ be ? ToString(? Invoke(_nextElement_, `"toLocaleString"`)).
              1. Set _R_ to the string-concatenation of _R_ and _S_.
            1. Increase _k_ by 1.
          1. Return _R_.
        </emu-alg>
        <emu-note>
          <p>The elements of the array are converted to Strings using their `toLocaleString` methods, and these Strings are then concatenated, separated by occurrences of a separator String that has been derived in an implementation-defined locale-specific way. The result of calling this function is intended to be analogous to the result of `toString`, except that the result of this function is intended to be locale-specific.</p>
        </emu-note>
        <emu-note>
          <p>The `toLocaleString` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.tostring">
        <h1>Array.prototype.toString ( )</h1>
        <p>When the `toString` method is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _array_ be ? ToObject(*this* value).
          1. Let _func_ be ? Get(_array_, `"join"`).
          1. If IsCallable(_func_) is *false*, set _func_ to the intrinsic function %ObjProto_toString%.
          1. Return ? Call(_func_, _array_).
        </emu-alg>
        <emu-note>
          <p>The `toString` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.unshift">
        <h1>Array.prototype.unshift ( ..._items_ )</h1>
        <emu-note>
          <p>The arguments are prepended to the start of the array, such that their order within the array is the same as the order in which they appear in the argument list.</p>
        </emu-note>
        <p>When the `unshift` method is called with zero or more arguments _item1_, _item2_, etc., the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? ToLength(? Get(_O_, `"length"`)).
          1. Let _argCount_ be the number of actual arguments.
          1. If _argCount_ &gt; 0, then
            1. If _len_ + _argCount_ &gt; 2<sup>53</sup> - 1, throw a *TypeError* exception.
            1. Let _k_ be _len_.
            1. Repeat, while _k_ &gt; 0,
              1. Let _from_ be ! ToString(_k_ - 1).
              1. Let _to_ be ! ToString(_k_ + _argCount_ - 1).
              1. Let _fromPresent_ be ? HasProperty(_O_, _from_).
              1. If _fromPresent_ is *true*, then
                1. Let _fromValue_ be ? Get(_O_, _from_).
                1. Perform ? Set(_O_, _to_, _fromValue_, *true*).
              1. Else _fromPresent_ is *false*,
                1. Perform ? DeletePropertyOrThrow(_O_, _to_).
              1. Decrease _k_ by 1.
            1. Let _j_ be 0.
            1. Let _items_ be a List whose elements are, in left to right order, the arguments that were passed to this function invocation.
            1. Repeat, while _items_ is not empty
              1. Remove the first element from _items_ and let _E_ be the value of that element.
              1. Perform ? Set(_O_, ! ToString(_j_), _E_, *true*).
              1. Increase _j_ by 1.
          1. Perform ? Set(_O_, `"length"`, _len_ + _argCount_, *true*).
          1. Return _len_ + _argCount_.
        </emu-alg>
        <p>The `"length"` property of the `unshift` method is 1.</p>
        <emu-note>
          <p>The `unshift` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.values">
        <h1>Array.prototype.values ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Return CreateArrayIterator(_O_, `"value"`).
        </emu-alg>
        <p>This function is the <dfn>%ArrayProto_values%</dfn> intrinsic object.</p>
      </emu-clause>

      <emu-clause id="sec-array.prototype-@@iterator">
        <h1>Array.prototype [ @@iterator ] ( )</h1>
        <p>The initial value of the @@iterator property is the same function object as the initial value of the `Array.prototype.values` property.</p>
      </emu-clause>

      <emu-clause id="sec-array.prototype-@@unscopables">
        <h1>Array.prototype [ @@unscopables ]</h1>
        <p>The initial value of the @@unscopables data property is an object created by the following steps:</p>
        <emu-alg>
          1. Let _unscopableList_ be ObjectCreate(*null*).
          1. Perform CreateDataProperty(_unscopableList_, `"copyWithin"`, *true*).
          1. Perform CreateDataProperty(_unscopableList_, `"entries"`, *true*).
          1. Perform CreateDataProperty(_unscopableList_, `"fill"`, *true*).
          1. Perform CreateDataProperty(_unscopableList_, `"find"`, *true*).
          1. Perform CreateDataProperty(_unscopableList_, `"findIndex"`, *true*).
          1. Perform CreateDataProperty(_unscopableList_, `"flat"`, *true*).
          1. Perform CreateDataProperty(_unscopableList_, `"flatMap"`, *true*).
          1. Perform CreateDataProperty(_unscopableList_, `"includes"`, *true*).
          1. Perform CreateDataProperty(_unscopableList_, `"keys"`, *true*).
          1. Perform CreateDataProperty(_unscopableList_, `"values"`, *true*).
          1. Assert: Each of the above calls returns *true*.
          1. Return _unscopableList_.
        </emu-alg>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        <emu-note>
          <p>The own property names of this object are property names that were not included as standard properties of `Array.prototype` prior to the ECMAScript 2015 specification. These names are ignored for `with` statement binding purposes in order to preserve the behaviour of existing code that might use one of these names as a binding in an outer scope that is shadowed by a `with` statement whose binding object is an Array object.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-array-instances">
      <h1>Properties of Array Instances</h1>
      <p>Array instances are Array exotic objects and have the internal methods specified for such objects. Array instances inherit properties from the Array prototype object.</p>
      <p>Array instances have a `"length"` property, and a set of enumerable properties with array index names.</p>

      <emu-clause id="sec-properties-of-array-instances-length">
        <h1>length</h1>
        <p>The `"length"` property of an Array instance is a data property whose value is always numerically greater than the name of every configurable own property whose name is an array index.</p>
        <p>The `"length"` property initially has the attributes { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        <emu-note>
          <p>Reducing the value of the `"length"` property has the side-effect of deleting own array elements whose array index is between the old and new length values. However, non-configurable properties can not be deleted. Attempting to set the `"length"` property of an Array object to a value that is numerically less than or equal to the largest numeric own property name of an existing non-configurable <emu-xref href="#array-index">array-indexed</emu-xref> property of the array will result in the length being set to a numeric value that is one greater than that non-configurable numeric own property name. See <emu-xref href="#sec-array-exotic-objects-defineownproperty-p-desc"></emu-xref>.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-array-iterator-objects">
      <h1>Array Iterator Objects</h1>
      <p>An Array Iterator is an object, that represents a specific iteration over some specific Array instance object. There is not a named constructor for Array Iterator objects. Instead, Array iterator objects are created by calling certain methods of Array instance objects.</p>

      <emu-clause id="sec-createarrayiterator" aoid="CreateArrayIterator">
        <h1>CreateArrayIterator ( _array_, _kind_ )</h1>
        <p>Several methods of Array objects return Iterator objects. The abstract operation CreateArrayIterator with arguments _array_ and _kind_ is used to create such iterator objects. It performs the following steps:</p>
        <emu-alg>
          1. Assert: Type(_array_) is Object.
          1. Let _iterator_ be ObjectCreate(%ArrayIteratorPrototype%, &laquo; [[IteratedObject]], [[ArrayIteratorNextIndex]], [[ArrayIterationKind]] &raquo;).
          1. Set _iterator_.[[IteratedObject]] to _array_.
          1. Set _iterator_.[[ArrayIteratorNextIndex]] to 0.
          1. Set _iterator_.[[ArrayIterationKind]] to _kind_.
          1. Return _iterator_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%arrayiteratorprototype%-object">
        <h1>The %ArrayIteratorPrototype% Object</h1>
        <p>The <dfn>%ArrayIteratorPrototype%</dfn> object:</p>
        <ul>
          <li>has properties that are inherited by all Array Iterator Objects.</li>
          <li>is an ordinary object.</li>
          <li>has a [[Prototype]] internal slot whose value is the intrinsic object %IteratorPrototype%.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-%arrayiteratorprototype%.next">
          <h1>%ArrayIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. Let _O_ be the *this* value.
            1. If Type(_O_) is not Object, throw a *TypeError* exception.
            1. If _O_ does not have all of the internal slots of an Array Iterator Instance (<emu-xref href="#sec-properties-of-array-iterator-instances"></emu-xref>), throw a *TypeError* exception.
            1. Let _a_ be _O_.[[IteratedObject]].
            1. If _a_ is *undefined*, return CreateIterResultObject(*undefined*, *true*).
            1. Let _index_ be _O_.[[ArrayIteratorNextIndex]].
            1. Let _itemKind_ be _O_.[[ArrayIterationKind]].
            1. If _a_ has a [[TypedArrayName]] internal slot, then
              1. If IsDetachedBuffer(_a_.[[ViewedArrayBuffer]]) is *true*, throw a *TypeError* exception.
              1. Let _len_ be _a_.[[ArrayLength]].
            1. Else,
              1. Let _len_ be ? ToLength(? Get(_a_, `"length"`)).
            1. If _index_ &ge; _len_, then
              1. Set _O_.[[IteratedObject]] to *undefined*.
              1. Return CreateIterResultObject(*undefined*, *true*).
            1. Set _O_.[[ArrayIteratorNextIndex]] to _index_ + 1.
            1. If _itemKind_ is `"key"`, return CreateIterResultObject(_index_, *false*).
            1. Let _elementKey_ be ! ToString(_index_).
            1. Let _elementValue_ be ? Get(_a_, _elementKey_).
            1. If _itemKind_ is `"value"`, let _result_ be _elementValue_.
            1. Else,
              1. Assert: _itemKind_ is `"key+value"`.
              1. Let _result_ be CreateArrayFromList(&laquo; _index_, _elementValue_ &raquo;).
            1. Return CreateIterResultObject(_result_, *false*).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%arrayiteratorprototype%-@@tostringtag">
          <h1>%ArrayIteratorPrototype% [ @@toStringTag ]</h1>
          <p>The initial value of the @@toStringTag property is the String value `"Array Iterator"`.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-array-iterator-instances">
        <h1>Properties of Array Iterator Instances</h1>
        <p>Array Iterator instances are ordinary objects that inherit properties from the %ArrayIteratorPrototype% intrinsic object. Array Iterator instances are initially created with the internal slots listed in <emu-xref href="#table-48"></emu-xref>.</p>
        <emu-table id="table-48" caption="Internal Slots of Array Iterator Instances">
          <table>
            <tbody>
            <tr>
              <th>
                Internal Slot
              </th>
              <th>
                Description
              </th>
            </tr>
            <tr>
              <td>
                [[IteratedObject]]
              </td>
              <td>
                The object whose array elements are being iterated.
              </td>
            </tr>
            <tr>
              <td>
                [[ArrayIteratorNextIndex]]
              </td>
              <td>
                The integer index of the next integer index to be examined by this iteration.
              </td>
            </tr>
            <tr>
              <td>
                [[ArrayIterationKind]]
              </td>
              <td>
                A String value that identifies what is returned for each element of the iteration. The possible values are: `"key"`, `"value"`, `"key+value"`.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-typedarray-objects">
    <h1>TypedArray Objects</h1>
    <p>_TypedArray_ objects present an array-like view of an underlying binary data buffer (<emu-xref href="#sec-arraybuffer-objects"></emu-xref>). Each element of a _TypedArray_ instance has the same underlying binary scalar data type. There is a distinct _TypedArray_ constructor, listed in <emu-xref href="#table-49"></emu-xref>, for each of the nine supported element types. Each constructor in <emu-xref href="#table-49"></emu-xref> has a corresponding distinct prototype object.</p>
    <emu-table id="table-49" caption="The TypedArray Constructors">
      <table>
        <tbody>
        <tr>
          <th>
            Constructor Name and Intrinsic
          </th>
          <th>
            Element Type
          </th>
          <th>
            Element Size
          </th>
          <th>
            Conversion Operation
          </th>
          <th>
            Description
          </th>
          <th>
            Equivalent C Type
          </th>
        </tr>
        <tr>
          <td>
            Int8Array
            <br>
            %Int8Array%
          </td>
          <td>
            Int8
          </td>
          <td>
            1
          </td>
          <td>
            ToInt8
          </td>
          <td>
            8-bit 2's complement signed integer
          </td>
          <td>
            signed char
          </td>
        </tr>
        <tr>
          <td>
            Uint8Array
            <br>
            %Uint8Array%
          </td>
          <td>
            Uint8
          </td>
          <td>
            1
          </td>
          <td>
            ToUint8
          </td>
          <td>
            8-bit unsigned integer
          </td>
          <td>
            unsigned char
          </td>
        </tr>
        <tr>
          <td>
            Uint8ClampedArray
            <br>
            %Uint8ClampedArray%
          </td>
          <td>
            Uint8C
          </td>
          <td>
            1
          </td>
          <td>
            ToUint8Clamp
          </td>
          <td>
            8-bit unsigned integer (clamped conversion)
          </td>
          <td>
            unsigned char
          </td>
        </tr>
        <tr>
          <td>
            Int16Array
            <br>
            %Int16Array%
          </td>
          <td>
            Int16
          </td>
          <td>
            2
          </td>
          <td>
            ToInt16
          </td>
          <td>
            16-bit 2's complement signed integer
          </td>
          <td>
            short
          </td>
        </tr>
        <tr>
          <td>
            Uint16Array
            <br>
            %Uint16Array%
          </td>
          <td>
            Uint16
          </td>
          <td>
            2
          </td>
          <td>
            ToUint16
          </td>
          <td>
            16-bit unsigned integer
          </td>
          <td>
            unsigned short
          </td>
        </tr>
        <tr>
          <td>
            Int32Array
            <br>
            %Int32Array%
          </td>
          <td>
            Int32
          </td>
          <td>
            4
          </td>
          <td>
            ToInt32
          </td>
          <td>
            32-bit 2's complement signed integer
          </td>
          <td>
            int
          </td>
        </tr>
        <tr>
          <td>
            Uint32Array
            <br>
            %Uint32Array%
          </td>
          <td>
            Uint32
          </td>
          <td>
            4
          </td>
          <td>
            ToUint32
          </td>
          <td>
            32-bit unsigned integer
          </td>
          <td>
            unsigned int
          </td>
        </tr>
        <tr>
          <td>
            Float32Array
            <br>
            %Float32Array%
          </td>
          <td>
            Float32
          </td>
          <td>
            4
          </td>
          <td>
          </td>
          <td>
            32-bit IEEE floating point
          </td>
          <td>
            float
          </td>
        </tr>
        <tr>
          <td>
            Float64Array
            <br>
            %Float64Array%
          </td>
          <td>
            Float64
          </td>
          <td>
            8
          </td>
          <td>
          </td>
          <td>
            64-bit IEEE floating point
          </td>
          <td>
            double
          </td>
        </tr>
        </tbody>
      </table>
    </emu-table>
    <p>In the definitions below, references to _TypedArray_ should be replaced with the appropriate constructor name from the above table. The phrase &ldquo;the element size in bytes&rdquo; refers to the value in the Element Size column of the table in the row corresponding to the constructor. The phrase &ldquo;element Type&rdquo; refers to the value in the Element Type column for that row.</p>

    <emu-clause id="sec-%typedarray%-intrinsic-object">
      <h1>The %TypedArray% Intrinsic Object</h1>
      <p>The <dfn>%TypedArray%</dfn> intrinsic object:</p>
      <ul>
        <li>is a constructor function object that all of the _TypedArray_ constructor objects inherit from.</li>
        <li>along with its corresponding prototype object, provides common properties that are inherited by all _TypedArray_ constructors and their instances.</li>
        <li>does not have a global name or appear as a property of the global object.</li>
        <li>acts as the abstract superclass of the various _TypedArray_ constructors.</li>
        <li>will throw an error when invoked, because it is an abstract class constructor. The _TypedArray_ constructors do not perform a `super` call to it.</li>
      </ul>

      <emu-clause id="sec-%typedarray%">
        <h1>%TypedArray% ( )</h1>
        <p>The %TypedArray% constructor performs the following steps:</p>
        <emu-alg>
          1. Throw a *TypeError* exception.
        </emu-alg>
        <p>The `"length"` property of the %TypedArray% constructor function is 0.</p>
      </emu-clause>
    </emu-clause>


    <emu-clause id="sec-properties-of-the-%typedarray%-intrinsic-object">
      <h1>Properties of the %TypedArray% Intrinsic Object</h1>
      <p>The %TypedArray% intrinsic object:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.</li>
        <li>has a `name` property whose value is `"TypedArray"`.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-%typedarray%.from">
        <h1>%TypedArray%.from ( _source_ [ , _mapfn_ [ , _thisArg_ ] ] )</h1>
        <p>When the `from` method is called with argument _source_, and optional arguments _mapfn_ and _thisArg_, the following steps are taken:</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.
          1. If _mapfn_ is present and _mapfn_ is not *undefined*, then
            1. If IsCallable(_mapfn_) is *false*, throw a *TypeError* exception.
            1. Let _mapping_ be *true*.
          1. Else, let _mapping_ be *false*.
          1. If _thisArg_ is present, let _T_ be _thisArg_; else let _T_ be *undefined*.
          1. Let _usingIterator_ be ? GetMethod(_source_, @@iterator).
          1. If _usingIterator_ is not *undefined*, then
            1. Let _values_ be ? IterableToList(_source_, _usingIterator_).
            1. Let _len_ be the number of elements in _values_.
            1. Let _targetObj_ be ? TypedArrayCreate(_C_, &laquo; _len_ &raquo;).
            1. Let _k_ be 0.
            1. Repeat, while _k_ &lt; _len_
              1. Let _Pk_ be ! ToString(_k_).
              1. Let _kValue_ be the first element of _values_ and remove that element from _values_.
              1. If _mapping_ is *true*, then
                1. Let _mappedValue_ be ? Call(_mapfn_, _T_, &laquo; _kValue_, _k_ &raquo;).
              1. Else, let _mappedValue_ be _kValue_.
              1. Perform ? Set(_targetObj_, _Pk_, _mappedValue_, *true*).
              1. Increase _k_ by 1.
            1. Assert: _values_ is now an empty List.
            1. Return _targetObj_.
          1. NOTE: _source_ is not an Iterable so assume it is already an array-like object.
          1. Let _arrayLike_ be ! ToObject(_source_).
          1. Let _len_ be ? ToLength(? Get(_arrayLike_, `"length"`)).
          1. Let _targetObj_ be ? TypedArrayCreate(_C_, &laquo; _len_ &raquo;).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_
            1. Let _Pk_ be ! ToString(_k_).
            1. Let _kValue_ be ? Get(_arrayLike_, _Pk_).
            1. If _mapping_ is *true*, then
              1. Let _mappedValue_ be ? Call(_mapfn_, _T_, &laquo; _kValue_, _k_ &raquo;).
            1. Else, let _mappedValue_ be _kValue_.
            1. Perform ? Set(_targetObj_, _Pk_, _mappedValue_, *true*).
            1. Increase _k_ by 1.
          1. Return _targetObj_.
        </emu-alg>

        <emu-clause id="sec-iterabletolist" aoid="IterableToList">
          <h1>Runtime Semantics: IterableToList ( _items_, _method_ )</h1>
          <p>The abstract operation IterableToList performs the following steps:</p>
          <emu-alg>
            1. Let _iteratorRecord_ be ? GetIterator(_items_, ~sync~, _method_).
            1. Let _values_ be a new empty List.
            1. Let _next_ be *true*.
            1. Repeat, while _next_ is not *false*
              1. Set _next_ to ? IteratorStep(_iteratorRecord_).
              1. If _next_ is not *false*, then
                1. Let _nextValue_ be ? IteratorValue(_next_).
                1. Append _nextValue_ to the end of the List _values_.
            1. Return _values_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.of">
        <h1>%TypedArray%.of ( ..._items_ )</h1>
        <p>When the `of` method is called with any number of arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _len_ be the actual number of arguments passed to this function.
          1. Let _items_ be the List of arguments passed to this function.
          1. Let _C_ be the *this* value.
          1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.
          1. Let _newObj_ be ? TypedArrayCreate(_C_, &laquo; _len_ &raquo;).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_
            1. Let _kValue_ be _items_[_k_].
            1. Let _Pk_ be ! ToString(_k_).
            1. Perform ? Set(_newObj_, _Pk_, _kValue_, *true*).
            1. Increase _k_ by 1.
          1. Return _newObj_.
        </emu-alg>
        <emu-note>
          <p>The _items_ argument is assumed to be a well-formed rest argument value.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype">
        <h1>%TypedArray%.prototype</h1>
        <p>The initial value of %TypedArray%`.prototype` is the %TypedArrayPrototype% intrinsic object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%-@@species">
        <h1>get %TypedArray% [ @@species ]</h1>
        <p>%TypedArray%`[@@species]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the `name` property of this function is `"get [Symbol.species]"`.</p>
        <emu-note>
          <p>%TypedArrayPrototype% methods normally use their `this` object's constructor to create a derived object. However, a subclass constructor may over-ride that default behaviour by redefining its @@species property.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-%typedarrayprototype%-object">
      <h1>Properties of the %TypedArrayPrototype% Object</h1>
      <p>The <dfn>%TypedArrayPrototype%</dfn> object:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[ViewedArrayBuffer]] or any other of the internal slots that are specific to _TypedArray_ instance objects.</li>
      </ul>

      <emu-clause id="sec-get-%typedarray%.prototype.buffer">
        <h1>get %TypedArray%.prototype.buffer</h1>
        <p>%TypedArray%`.prototype.buffer` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
          1. Return _buffer_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype.bytelength">
        <h1>get %TypedArray%.prototype.byteLength</h1>
        <p>%TypedArray%`.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
          1. If IsDetachedBuffer(_buffer_) is *true*, return 0.
          1. Let _size_ be _O_.[[ByteLength]].
          1. Return _size_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype.byteoffset">
        <h1>get %TypedArray%.prototype.byteOffset</h1>
        <p>%TypedArray%`.prototype.byteOffset` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
          1. If IsDetachedBuffer(_buffer_) is *true*, return 0.
          1. Let _offset_ be _O_.[[ByteOffset]].
          1. Return _offset_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.constructor">
        <h1>%TypedArray%.prototype.constructor</h1>
        <p>The initial value of %TypedArray%`.prototype.constructor` is the %TypedArray% intrinsic object.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.copywithin">
        <h1>%TypedArray%.prototype.copyWithin ( _target_, _start_ [ , _end_ ] )</h1>
        <p>The interpretation and use of the arguments of %TypedArray%`.prototype.copyWithin` are the same as for `Array.prototype.copyWithin` as defined in <emu-xref href="#sec-array.prototype.copywithin"></emu-xref>.</p>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be *this* value.
          1. Perform ? ValidateTypedArray(_O_).
          1. Let _len_ be _O_.[[ArrayLength]].
          1. Let _relativeTarget_ be ? ToInteger(_target_).
          1. If _relativeTarget_ &lt; 0, let _to_ be max((_len_ + _relativeTarget_), 0); else let _to_ be min(_relativeTarget_, _len_).
          1. Let _relativeStart_ be ? ToInteger(_start_).
          1. If _relativeStart_ &lt; 0, let _from_ be max((_len_ + _relativeStart_), 0); else let _from_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToInteger(_end_).
          1. If _relativeEnd_ &lt; 0, let _final_ be max((_len_ + _relativeEnd_), 0); else let _final_ be min(_relativeEnd_, _len_).
          1. Let _count_ be min(_final_ - _from_, _len_ - _to_).
          1. If _count_ &gt; 0, then
            1. NOTE: The copying must be performed in a manner that preserves the bit-level encoding of the source data.
            1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
            1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
            1. Let _typedArrayName_ be the String value of _O_.[[TypedArrayName]].
            1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _typedArrayName_.
            1. Let _byteOffset_ be _O_.[[ByteOffset]].
            1. Let _toByteIndex_ be _to_ &times; _elementSize_ + _byteOffset_.
            1. Let _fromByteIndex_ be _from_ &times; _elementSize_ + _byteOffset_.
            1. Let _countBytes_ be _count_ &times; _elementSize_.
            1. If _fromByteIndex_ &lt; _toByteIndex_ and _toByteIndex_ &lt; _fromByteIndex_ + _countBytes_, then
              1. Let _direction_ be -1.
              1. Set _fromByteIndex_ to _fromByteIndex_ + _countBytes_ - 1.
              1. Set _toByteIndex_ to _toByteIndex_ + _countBytes_ - 1.
            1. Else,
              1. Let _direction_ be 1.
            1. Repeat, while _countBytes_ &gt; 0
              1. Let _value_ be GetValueFromBuffer(_buffer_, _fromByteIndex_, `"Uint8"`, *true*, `"Unordered"`).
              1. Perform SetValueInBuffer(_buffer_, _toByteIndex_, `"Uint8"`, _value_, *true*, `"Unordered"`).
              1. Set _fromByteIndex_ to _fromByteIndex_ + _direction_.
              1. Set _toByteIndex_ to _toByteIndex_ + _direction_.
              1. Decrease _countBytes_ by 1.
          1. Return _O_.
        </emu-alg>

        <emu-clause id="sec-validatetypedarray" aoid="ValidateTypedArray">
          <h1>Runtime Semantics: ValidateTypedArray ( _O_ )</h1>
          <p>When called with argument _O_, the following steps are taken:</p>
          <emu-alg>
            1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
            1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
            1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
            1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
            1. Return _buffer_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.entries">
        <h1>%TypedArray%.prototype.entries ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? ValidateTypedArray(_O_).
          1. Return CreateArrayIterator(_O_, `"key+value"`).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.every">
        <h1>%TypedArray%.prototype.every ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <p>%TypedArray%`.prototype.every` is a distinct function that implements the same algorithm as `Array.prototype.every` as defined in <emu-xref href="#sec-array.prototype.every"></emu-xref> except that the *this* object's [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of `"length"`. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose integer-indexed properties are not sparse. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm and must take into account the possibility that calls to _callbackfn_ may cause the *this* value to become detached.</p>
        <p>This function is not generic. ValidateTypedArray is applied to the *this* value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.fill">
        <h1>%TypedArray%.prototype.fill ( _value_ [ , _start_ [ , _end_ ] ] )</h1>
        <p>The interpretation and use of the arguments of %TypedArray%`.prototype.fill` are the same as for `Array.prototype.fill` as defined in <emu-xref href="#sec-array.prototype.fill"></emu-xref>.</p>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? ValidateTypedArray(_O_).
          1. Let _len_ be _O_.[[ArrayLength]].
          1. Set _value_ to ? ToNumber(_value_).
          1. Let _relativeStart_ be ? ToInteger(_start_).
          1. If _relativeStart_ &lt; 0, let _k_ be max((_len_ + _relativeStart_), 0); else let _k_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToInteger(_end_).
          1. If _relativeEnd_ &lt; 0, let _final_ be max((_len_ + _relativeEnd_), 0); else let _final_ be min(_relativeEnd_, _len_).
          1. If IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) is *true*, throw a *TypeError* exception.
          1. Repeat, while _k_ &lt; _final_
            1. Let _Pk_ be ! ToString(_k_).
            1. Perform ! Set(_O_, _Pk_, _value_, *true*).
            1. Increase _k_ by 1.
          1. Return _O_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.filter">
        <h1>%TypedArray%.prototype.filter ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of %TypedArray%`.prototype.filter` are the same as for `Array.prototype.filter` as defined in <emu-xref href="#sec-array.prototype.filter"></emu-xref>.</p>
        <p>When the `filter` method is called with one or two arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? ValidateTypedArray(_O_).
          1. Let _len_ be _O_.[[ArrayLength]].
          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.
          1. If _thisArg_ is present, let _T_ be _thisArg_; else let _T_ be *undefined*.
          1. Let _kept_ be a new empty List.
          1. Let _k_ be 0.
          1. Let _captured_ be 0.
          1. Repeat, while _k_ &lt; _len_
            1. Let _Pk_ be ! ToString(_k_).
            1. Let _kValue_ be ? Get(_O_, _Pk_).
            1. Let _selected_ be ToBoolean(? Call(_callbackfn_, _T_, &laquo; _kValue_, _k_, _O_ &raquo;)).
            1. If _selected_ is *true*, then
              1. Append _kValue_ to the end of _kept_.
              1. Increase _captured_ by 1.
            1. Increase _k_ by 1.
          1. Let _A_ be ? TypedArraySpeciesCreate(_O_, &laquo; _captured_ &raquo;).
          1. Let _n_ be 0.
          1. For each element _e_ of _kept_, do
            1. Perform ! Set(_A_, ! ToString(_n_), _e_, *true*).
            1. Increment _n_ by 1.
          1. Return _A_.
        </emu-alg>
        <p>This function is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.find">
        <h1>%TypedArray%.prototype.find ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>%TypedArray%`.prototype.find` is a distinct function that implements the same algorithm as `Array.prototype.find` as defined in <emu-xref href="#sec-array.prototype.find"></emu-xref> except that the *this* object's [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of `"length"`. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm and must take into account the possibility that calls to _predicate_ may cause the *this* value to become detached.</p>
        <p>This function is not generic. ValidateTypedArray is applied to the *this* value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.findindex">
        <h1>%TypedArray%.prototype.findIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>%TypedArray%`.prototype.findIndex` is a distinct function that implements the same algorithm as `Array.prototype.findIndex` as defined in <emu-xref href="#sec-array.prototype.findindex"></emu-xref> except that the *this* object's [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of `"length"`. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm and must take into account the possibility that calls to _predicate_ may cause the *this* value to become detached.</p>
        <p>This function is not generic. ValidateTypedArray is applied to the *this* value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.foreach">
        <h1>%TypedArray%.prototype.forEach ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <p>%TypedArray%`.prototype.forEach` is a distinct function that implements the same algorithm as `Array.prototype.forEach` as defined in <emu-xref href="#sec-array.prototype.foreach"></emu-xref> except that the *this* object's [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of `"length"`. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm and must take into account the possibility that calls to _callbackfn_ may cause the *this* value to become detached.</p>
        <p>This function is not generic. ValidateTypedArray is applied to the *this* value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.includes">
        <h1>%TypedArray%.prototype.includes ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>%TypedArray%`.prototype.includes` is a distinct function that implements the same algorithm as `Array.prototype.includes` as defined in <emu-xref href="#sec-array.prototype.includes"></emu-xref> except that the *this* object's [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of `"length"`. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.</p>
        <p>This function is not generic. ValidateTypedArray is applied to the *this* value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.indexof">
        <h1>%TypedArray%.prototype.indexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>%TypedArray%`.prototype.indexOf` is a distinct function that implements the same algorithm as `Array.prototype.indexOf` as defined in <emu-xref href="#sec-array.prototype.indexof"></emu-xref> except that the *this* object's [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of `"length"`. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.</p>
        <p>This function is not generic. ValidateTypedArray is applied to the *this* value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.join">
        <h1>%TypedArray%.prototype.join ( _separator_ )</h1>
        <p>%TypedArray%`.prototype.join` is a distinct function that implements the same algorithm as `Array.prototype.join` as defined in <emu-xref href="#sec-array.prototype.join"></emu-xref> except that the *this* object's [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of `"length"`. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.</p>
        <p>This function is not generic. ValidateTypedArray is applied to the *this* value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.keys">
        <h1>%TypedArray%.prototype.keys ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? ValidateTypedArray(_O_).
          1. Return CreateArrayIterator(_O_, `"key"`).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.lastindexof">
        <h1>%TypedArray%.prototype.lastIndexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>%TypedArray%`.prototype.lastIndexOf` is a distinct function that implements the same algorithm as `Array.prototype.lastIndexOf` as defined in <emu-xref href="#sec-array.prototype.lastindexof"></emu-xref> except that the *this* object's [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of `"length"`. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.</p>
        <p>This function is not generic. ValidateTypedArray is applied to the *this* value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype.length">
        <h1>get %TypedArray%.prototype.length</h1>
        <p>%TypedArray%`.prototype.length` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
          1. Assert: _O_ has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.
          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
          1. If IsDetachedBuffer(_buffer_) is *true*, return 0.
          1. Let _length_ be _O_.[[ArrayLength]].
          1. Return _length_.
        </emu-alg>
        <p>This function is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.map">
        <h1>%TypedArray%.prototype.map ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of %TypedArray%`.prototype.map` are the same as for `Array.prototype.map` as defined in <emu-xref href="#sec-array.prototype.map"></emu-xref>.</p>
        <p>When the `map` method is called with one or two arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? ValidateTypedArray(_O_).
          1. Let _len_ be _O_.[[ArrayLength]].
          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.
          1. If _thisArg_ is present, let _T_ be _thisArg_; else let _T_ be *undefined*.
          1. Let _A_ be ? TypedArraySpeciesCreate(_O_, &laquo; _len_ &raquo;).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_
            1. Let _Pk_ be ! ToString(_k_).
            1. Let _kValue_ be ? Get(_O_, _Pk_).
            1. Let _mappedValue_ be ? Call(_callbackfn_, _T_, &laquo; _kValue_, _k_, _O_ &raquo;).
            1. Perform ? Set(_A_, _Pk_, _mappedValue_, *true*).
            1. Increase _k_ by 1.
          1. Return _A_.
        </emu-alg>
        <p>This function is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.reduce">
        <h1>%TypedArray%.prototype.reduce ( _callbackfn_ [ , _initialValue_ ] )</h1>
        <p>%TypedArray%`.prototype.reduce` is a distinct function that implements the same algorithm as `Array.prototype.reduce` as defined in <emu-xref href="#sec-array.prototype.reduce"></emu-xref> except that the *this* object's [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of `"length"`. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm and must take into account the possibility that calls to _callbackfn_ may cause the *this* value to become detached.</p>
        <p>This function is not generic. ValidateTypedArray is applied to the *this* value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.reduceright">
        <h1>%TypedArray%.prototype.reduceRight ( _callbackfn_ [ , _initialValue_ ] )</h1>
        <p>%TypedArray%`.prototype.reduceRight` is a distinct function that implements the same algorithm as `Array.prototype.reduceRight` as defined in <emu-xref href="#sec-array.prototype.reduceright"></emu-xref> except that the *this* object's [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of `"length"`. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm and must take into account the possibility that calls to _callbackfn_ may cause the *this* value to become detached.</p>
        <p>This function is not generic. ValidateTypedArray is applied to the *this* value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.reverse">
        <h1>%TypedArray%.prototype.reverse ( )</h1>
        <p>%TypedArray%`.prototype.reverse` is a distinct function that implements the same algorithm as `Array.prototype.reverse` as defined in <emu-xref href="#sec-array.prototype.reverse"></emu-xref> except that the *this* object's [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of `"length"`. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.</p>
        <p>This function is not generic. ValidateTypedArray is applied to the *this* value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.set-overloaded-offset">
        <h1>%TypedArray%.prototype.set ( _overloaded_ [ , _offset_ ] )</h1>
        <p>%TypedArray%`.prototype.set` is a single function whose behaviour is overloaded based upon the type of its first argument.</p>
        <p>This function is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>

        <emu-clause id="sec-%typedarray%.prototype.set-array-offset">
          <h1>%TypedArray%.prototype.set ( _array_ [ , _offset_ ] )</h1>
          <p>Sets multiple values in this _TypedArray_, reading the values from the object _array_. The optional _offset_ value indicates the first element index in this _TypedArray_ where values are written. If omitted, it is assumed to be 0.</p>
          <emu-alg>
            1. Assert: _array_ is any ECMAScript language value other than an Object with a [[TypedArrayName]] internal slot. If it is such an Object, the definition in <emu-xref href="#sec-%typedarray%.prototype.set-typedarray-offset"></emu-xref> applies.
            1. Let _target_ be the *this* value.
            1. Perform ? RequireInternalSlot(_target_, [[TypedArrayName]]).
            1. Assert: _target_ has a [[ViewedArrayBuffer]] internal slot.
            1. Let _targetOffset_ be ? ToInteger(_offset_).
            1. If _targetOffset_ &lt; 0, throw a *RangeError* exception.
            1. Let _targetBuffer_ be _target_.[[ViewedArrayBuffer]].
            1. If IsDetachedBuffer(_targetBuffer_) is *true*, throw a *TypeError* exception.
            1. Let _targetLength_ be _target_.[[ArrayLength]].
            1. Let _targetName_ be the String value of _target_.[[TypedArrayName]].
            1. Let _targetElementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _targetName_.
            1. Let _targetType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _targetName_.
            1. Let _targetByteOffset_ be _target_.[[ByteOffset]].
            1. Let _src_ be ? ToObject(_array_).
            1. Let _srcLength_ be ? ToLength(? Get(_src_, `"length"`)).
            1. If _srcLength_ + _targetOffset_ &gt; _targetLength_, throw a *RangeError* exception.
            1. Let _targetByteIndex_ be _targetOffset_ &times; _targetElementSize_ + _targetByteOffset_.
            1. Let _k_ be 0.
            1. Let _limit_ be _targetByteIndex_ + _targetElementSize_ &times; _srcLength_.
            1. Repeat, while _targetByteIndex_ &lt; _limit_
              1. Let _Pk_ be ! ToString(_k_).
              1. Let _kNumber_ be ? ToNumber(? Get(_src_, _Pk_)).
              1. If IsDetachedBuffer(_targetBuffer_) is *true*, throw a *TypeError* exception.
              1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, _targetType_, _kNumber_, *true*, `"Unordered"`).
              1. Increase _k_ by 1.
              1. Set _targetByteIndex_ to _targetByteIndex_ + _targetElementSize_.
            1. Return *undefined*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%typedarray%.prototype.set-typedarray-offset">
          <h1>%TypedArray%.prototype.set ( _typedArray_ [ , _offset_ ] )</h1>
          <p>Sets multiple values in this _TypedArray_, reading the values from the _typedArray_ argument object. The optional _offset_ value indicates the first element index in this _TypedArray_ where values are written. If omitted, it is assumed to be 0.</p>
          <emu-alg>
            1. Assert: _typedArray_ has a [[TypedArrayName]] internal slot. If it does not, the definition in <emu-xref href="#sec-%typedarray%.prototype.set-array-offset"></emu-xref> applies.
            1. Let _target_ be the *this* value.
            1. Perform ? RequireInternalSlot(_target_, [[TypedArrayName]]).
            1. Assert: _target_ has a [[ViewedArrayBuffer]] internal slot.
            1. Let _targetOffset_ be ? ToInteger(_offset_).
            1. If _targetOffset_ &lt; 0, throw a *RangeError* exception.
            1. Let _targetBuffer_ be _target_.[[ViewedArrayBuffer]].
            1. If IsDetachedBuffer(_targetBuffer_) is *true*, throw a *TypeError* exception.
            1. Let _targetLength_ be _target_.[[ArrayLength]].
            1. Let _srcBuffer_ be _typedArray_.[[ViewedArrayBuffer]].
            1. If IsDetachedBuffer(_srcBuffer_) is *true*, throw a *TypeError* exception.
            1. Let _targetName_ be the String value of _target_.[[TypedArrayName]].
            1. Let _targetType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _targetName_.
            1. Let _targetElementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _targetName_.
            1. Let _targetByteOffset_ be _target_.[[ByteOffset]].
            1. Let _srcName_ be the String value of _typedArray_.[[TypedArrayName]].
            1. Let _srcType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _srcName_.
            1. Let _srcElementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _srcName_.
            1. Let _srcLength_ be _typedArray_.[[ArrayLength]].
            1. Let _srcByteOffset_ be _typedArray_.[[ByteOffset]].
            1. If _srcLength_ + _targetOffset_ &gt; _targetLength_, throw a *RangeError* exception.
            1. If both IsSharedArrayBuffer(_srcBuffer_) and IsSharedArrayBuffer(_targetBuffer_) are *true*, then
              1. If _srcBuffer_.[[ArrayBufferData]] and _targetBuffer_.[[ArrayBufferData]] are the same Shared Data Block values, let _same_ be *true*; else let _same_ be *false*.
            1. Else, let _same_ be SameValue(_srcBuffer_, _targetBuffer_).
            1. If _same_ is *true*, then
              1. Let _srcByteLength_ be _typedArray_.[[ByteLength]].
              1. Set _srcBuffer_ to ? CloneArrayBuffer(_srcBuffer_, _srcByteOffset_, _srcByteLength_, %ArrayBuffer%).
              1. NOTE: %ArrayBuffer% is used to clone _srcBuffer_ because is it known to not have any observable side-effects.
              1. Let _srcByteIndex_ be 0.
            1. Else, let _srcByteIndex_ be _srcByteOffset_.
            1. Let _targetByteIndex_ be _targetOffset_ &times; _targetElementSize_ + _targetByteOffset_.
            1. Let _limit_ be _targetByteIndex_ + _targetElementSize_ &times; _srcLength_.
            1. If SameValue(_srcType_, _targetType_) is *true*, then
              1. NOTE: If _srcType_ and _targetType_ are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.
              1. Repeat, while _targetByteIndex_ &lt; _limit_
                1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, `"Uint8"`, *true*, `"Unordered"`).
                1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, `"Uint8"`, _value_, *true*, `"Unordered"`).
                1. Increase _srcByteIndex_ by 1.
                1. Increase _targetByteIndex_ by 1.
            1. Else,
              1. Repeat, while _targetByteIndex_ &lt; _limit_
                1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, _srcType_, *true*, `"Unordered"`).
                1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, _targetType_, _value_, *true*, `"Unordered"`).
                1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.
                1. Set _targetByteIndex_ to _targetByteIndex_ + _targetElementSize_.
            1. Return *undefined*.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.slice">
        <h1>%TypedArray%.prototype.slice ( _start_, _end_ )</h1>
        <p>The interpretation and use of the arguments of %TypedArray%`.prototype.slice` are the same as for `Array.prototype.slice` as defined in <emu-xref href="#sec-array.prototype.slice"></emu-xref>. The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? ValidateTypedArray(_O_).
          1. Let _len_ be _O_.[[ArrayLength]].
          1. Let _relativeStart_ be ? ToInteger(_start_).
          1. If _relativeStart_ &lt; 0, let _k_ be max((_len_ + _relativeStart_), 0); else let _k_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToInteger(_end_).
          1. If _relativeEnd_ &lt; 0, let _final_ be max((_len_ + _relativeEnd_), 0); else let _final_ be min(_relativeEnd_, _len_).
          1. Let _count_ be max(_final_ - _k_, 0).
          1. Let _A_ be ? TypedArraySpeciesCreate(_O_, &laquo; _count_ &raquo;).
          1. Let _srcName_ be the String value of _O_.[[TypedArrayName]].
          1. Let _srcType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _srcName_.
          1. Let _targetName_ be the String value of _A_.[[TypedArrayName]].
          1. Let _targetType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _targetName_.
          1. If SameValue(_srcType_, _targetType_) is *false*, then
            1. Let _n_ be 0.
            1. Repeat, while _k_ &lt; _final_
              1. Let _Pk_ be ! ToString(_k_).
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Perform ! Set(_A_, ! ToString(_n_), _kValue_, *true*).
              1. Increase _k_ by 1.
              1. Increase _n_ by 1.
          1. Else if _count_ &gt; 0, then
            1. Let _srcBuffer_ be _O_.[[ViewedArrayBuffer]].
            1. If IsDetachedBuffer(_srcBuffer_) is *true*, throw a *TypeError* exception.
            1. Let _targetBuffer_ be _A_.[[ViewedArrayBuffer]].
            1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _srcType_.
            1. NOTE: If _srcType_ and _targetType_ are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.
            1. Let _srcByteOffet_ be _O_.[[ByteOffset]].
            1. Let _targetByteIndex_ be _A_.[[ByteOffset]].
            1. Let _srcByteIndex_ be (_k_ &times; _elementSize_) + _srcByteOffet_.
            1. Let _limit_ be _targetByteIndex_ + _count_ &times; _elementSize_.
            1. Repeat, while _targetByteIndex_ &lt; _limit_
              1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, `"Uint8"`, *true*, `"Unordered"`).
              1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, `"Uint8"`, _value_, *true*, `"Unordered"`).
              1. Increase _srcByteIndex_ by 1.
              1. Increase _targetByteIndex_ by 1.
          1. Return _A_.
        </emu-alg>
        <p>This function is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.some">
        <h1>%TypedArray%.prototype.some ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <p>%TypedArray%`.prototype.some` is a distinct function that implements the same algorithm as `Array.prototype.some` as defined in <emu-xref href="#sec-array.prototype.some"></emu-xref> except that the *this* object's [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of `"length"`. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm and must take into account the possibility that calls to _callbackfn_ may cause the *this* value to become detached.</p>
        <p>This function is not generic. ValidateTypedArray is applied to the *this* value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.sort">
        <h1>%TypedArray%.prototype.sort ( _comparefn_ )</h1>
        <p>%TypedArray%`.prototype.sort` is a distinct function that, except as described below, implements the same requirements as those of `Array.prototype.sort` as defined in <emu-xref href="#sec-array.prototype.sort"></emu-xref>. The implementation of the %TypedArray%`.prototype.sort` specification may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse. The only internal methods of the *this* object that the algorithm may call are [[Get]] and [[Set]].</p>
        <p>This function is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
        <p>Upon entry, the following steps are performed to initialize evaluation of the `sort` function. These steps are used instead of the entry steps in <emu-xref href="#sec-array.prototype.sort"></emu-xref>:</p>
        <emu-alg>
          1. If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.
          1. Let _obj_ be the *this* value.
          1. Let _buffer_ be ? ValidateTypedArray(_obj_).
          1. Let _len_ be _obj_.[[ArrayLength]].
        </emu-alg>
        <p>The implementation-defined sort order condition for exotic objects is not applied by %TypedArray%`.prototype.sort`.</p>
        <p>The following version of SortCompare is used by %TypedArray%`.prototype.sort`. It performs a numeric comparison rather than the string comparison used in <emu-xref href="#sec-array.prototype.sort"></emu-xref>. SortCompare has access to the _comparefn_ and _buffer_ values of the current invocation of the `sort` method.</p>
        <p>When the TypedArray SortCompare abstract operation is called with two arguments _x_ and _y_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: Both Type(_x_) and Type(_y_) is Number.
          1. If _comparefn_ is not *undefined*, then
            1. Let _v_ be ? ToNumber(? Call(_comparefn_, *undefined*, &laquo; _x_, _y_ &raquo;)).
            1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
            1. If _v_ is *NaN*, return *+0*.
            1. Return _v_.
          1. If _x_ and _y_ are both *NaN*, return *+0*.
          1. If _x_ is *NaN*, return 1.
          1. If _y_ is *NaN*, return -1.
          1. If _x_ &lt; _y_, return -1.
          1. If _x_ &gt; _y_, return 1.
          1. If _x_ is *-0* and _y_ is *+0*, return -1.
          1. If _x_ is *+0* and _y_ is *-0*, return 1.
          1. Return *+0*.
        </emu-alg>
        <emu-note>
          <p>Because *NaN* always compares greater than any other value, *NaN* property values always sort to the end of the result when _comparefn_ is not provided.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.subarray">
        <h1>%TypedArray%.prototype.subarray ( _begin_, _end_ )</h1>
        <p>Returns a new _TypedArray_ object whose element type is the same as this _TypedArray_ and whose ArrayBuffer is the same as the ArrayBuffer of this _TypedArray_, referencing the elements at _begin_, inclusive, up to _end_, exclusive. If either _begin_ or _end_ is negative, it refers to an index from the end of the array, as opposed to from the beginning.</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
          1. Let _srcLength_ be _O_.[[ArrayLength]].
          1. Let _relativeBegin_ be ? ToInteger(_begin_).
          1. If _relativeBegin_ &lt; 0, let _beginIndex_ be max((_srcLength_ + _relativeBegin_), 0); else let _beginIndex_ be min(_relativeBegin_, _srcLength_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _srcLength_; else, let _relativeEnd_ be ? ToInteger(_end_).
          1. If _relativeEnd_ &lt; 0, let _endIndex_ be max((_srcLength_ + _relativeEnd_), 0); else let _endIndex_ be min(_relativeEnd_, _srcLength_).
          1. Let _newLength_ be max(_endIndex_ - _beginIndex_, 0).
          1. Let _constructorName_ be the String value of _O_.[[TypedArrayName]].
          1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _constructorName_.
          1. Let _srcByteOffset_ be _O_.[[ByteOffset]].
          1. Let _beginByteOffset_ be _srcByteOffset_ + _beginIndex_ &times; _elementSize_.
          1. Let _argumentsList_ be &laquo; _buffer_, _beginByteOffset_, _newLength_ &raquo;.
          1. Return ? TypedArraySpeciesCreate(_O_, _argumentsList_).
        </emu-alg>
        <p>This function is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.tolocalestring">
        <h1>%TypedArray%.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>%TypedArray%`.prototype.toLocaleString` is a distinct function that implements the same algorithm as `Array.prototype.toLocaleString` as defined in <emu-xref href="#sec-array.prototype.tolocalestring"></emu-xref> except that the *this* object's [[ArrayLength]] internal slot is accessed in place of performing a [[Get]] of `"length"`. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.</p>
        <p>This function is not generic. ValidateTypedArray is applied to the *this* value prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</p>
        <emu-note>
          <p>If the ECMAScript implementation includes the ECMA-402 Internationalization API this function is based upon the algorithm for `Array.prototype.toLocaleString` that is in the ECMA-402 specification.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.tostring">
        <h1>%TypedArray%.prototype.toString ( )</h1>
        <p>The initial value of the %TypedArray%`.prototype.toString` data property is the same built-in function object as the `Array.prototype.toString` method defined in <emu-xref href="#sec-array.prototype.tostring"></emu-xref>.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.values">
        <h1>%TypedArray%.prototype.values ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? ValidateTypedArray(_O_).
          1. Return CreateArrayIterator(_O_, `"value"`).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype-@@iterator">
        <h1>%TypedArray%.prototype [ @@iterator ] ( )</h1>
        <p>The initial value of the @@iterator property is the same function object as the initial value of the %TypedArray%`.prototype.values` property.</p>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype-@@tostringtag">
        <h1>get %TypedArray%.prototype [ @@toStringTag ]</h1>
        <p>%TypedArray%`.prototype[@@toStringTag]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If Type(_O_) is not Object, return *undefined*.
          1. If _O_ does not have a [[TypedArrayName]] internal slot, return *undefined*.
          1. Let _name_ be _O_.[[TypedArrayName]].
          1. Assert: Type(_name_) is String.
          1. Return _name_.
        </emu-alg>
        <p>This property has the attributes { [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        <p>The initial value of the `name` property of this function is `"get [Symbol.toStringTag]"`.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-typedarray-constructors">
      <h1>The _TypedArray_ Constructors</h1>
      <p>Each _TypedArray_ constructor:</p>
      <ul>
        <li>is an intrinsic object that has the structure described below, differing only in the name used as the constructor name instead of _TypedArray_, in <emu-xref href="#table-49"></emu-xref>.</li>
        <li>is a single function whose behaviour is overloaded based upon the number and types of its arguments. The actual behaviour of a call of _TypedArray_ depends upon the number and kind of arguments that are passed to it.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified _TypedArray_ behaviour must include a `super` call to the _TypedArray_ constructor to create and initialize the subclass instance with the internal state necessary to support the %TypedArray%`.prototype` built-in methods.</li>
        <li>has a `"length"` property whose value is 3.</li>
      </ul>

      <emu-clause id="sec-typedarray">
        <h1>_TypedArray_ ( )</h1>
        <p>This description applies only if the _TypedArray_ function is called with no arguments.</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _constructorName_ be the String value of the Constructor Name value specified in <emu-xref href="#table-49"></emu-xref> for this <var>TypedArray</var> constructor.
          1. Return ? AllocateTypedArray(_constructorName_, NewTarget, <code>"%<var>TypedArray</var>Prototype%"</code>, 0).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-length">
        <h1>_TypedArray_ ( _length_ )</h1>
        <p>This description applies only if the _TypedArray_ function is called with at least one argument and the Type of the first argument is not Object.</p>
        <p>_TypedArray_ called with argument _length_ performs the following steps:</p>
        <emu-alg>
          1. Assert: Type(_length_) is not Object.
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _elementLength_ be ? ToIndex(_length_).
          1. Let _constructorName_ be the String value of the Constructor Name value specified in <emu-xref href="#table-49"></emu-xref> for this <var>TypedArray</var> constructor.
          1. Return ? AllocateTypedArray(_constructorName_, NewTarget, <code>"%<var>TypedArray</var>Prototype%"</code>, _elementLength_).
        </emu-alg>

        <emu-clause id="sec-allocatetypedarray" aoid="AllocateTypedArray">
          <h1>Runtime Semantics: AllocateTypedArray ( _constructorName_, _newTarget_, _defaultProto_ [ , _length_ ] )</h1>
          <p>The abstract operation AllocateTypedArray with arguments _constructorName_, _newTarget_, _defaultProto_ and optional argument _length_ is used to validate and create an instance of a TypedArray constructor. _constructorName_ is required to be the name of a TypedArray constructor in <emu-xref href="#table-49"></emu-xref>. If the _length_ argument is passed, an ArrayBuffer of that length is also allocated and associated with the new TypedArray instance. AllocateTypedArray provides common semantics that is used by all of the _TypedArray_ overloads. AllocateTypedArray performs the following steps:</p>
          <emu-alg>
            1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, _defaultProto_).
            1. Let _obj_ be IntegerIndexedObjectCreate(_proto_, &laquo; [[ViewedArrayBuffer]], [[TypedArrayName]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] &raquo;).
            1. Assert: _obj_.[[ViewedArrayBuffer]] is *undefined*.
            1. Set _obj_.[[TypedArrayName]] to _constructorName_.
            1. If _length_ is not present, then
              1. Set _obj_.[[ByteLength]] to 0.
              1. Set _obj_.[[ByteOffset]] to 0.
              1. Set _obj_.[[ArrayLength]] to 0.
            1. Else,
              1. Perform ? AllocateTypedArrayBuffer(_obj_, _length_).
            1. Return _obj_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-allocatetypedarraybuffer" aoid="AllocateTypedArrayBuffer">
          <h1>Runtime Semantics: AllocateTypedArrayBuffer ( _O_, _length_ )</h1>
          <p>The abstract operation AllocateTypedArrayBuffer with arguments _O_ and _length_ allocates and associates an ArrayBuffer with the TypedArray instance _O_. It performs the following steps:</p>
          <emu-alg>
            1. Assert: _O_ is an Object that has a [[ViewedArrayBuffer]] internal slot.
            1. Assert: _O_.[[ViewedArrayBuffer]] is *undefined*.
            1. Assert: _length_ &ge; 0.
            1. Let _constructorName_ be the String value of _O_.[[TypedArrayName]].
            1. Let _elementSize_ be the Element Size value in <emu-xref href="#table-49"></emu-xref> for _constructorName_.
            1. Let _byteLength_ be _elementSize_ &times; _length_.
            1. Let _data_ be ? AllocateArrayBuffer(%ArrayBuffer%, _byteLength_).
            1. Set _O_.[[ViewedArrayBuffer]] to _data_.
            1. Set _O_.[[ByteLength]] to _byteLength_.
            1. Set _O_.[[ByteOffset]] to 0.
            1. Set _O_.[[ArrayLength]] to _length_.
            1. Return _O_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-typedarray-typedarray">
        <h1>_TypedArray_ ( _typedArray_ )</h1>
        <p>This description applies only if the _TypedArray_ function is called with at least one argument and the Type of the first argument is Object and that object has a [[TypedArrayName]] internal slot.</p>
        <p>_TypedArray_ called with argument _typedArray_ performs the following steps:</p>
        <emu-alg>
          1. Assert: Type(_typedArray_) is Object and _typedArray_ has a [[TypedArrayName]] internal slot.
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _constructorName_ be the String value of the Constructor Name value specified in <emu-xref href="#table-49"></emu-xref> for this <var>TypedArray</var> constructor.
          1. Let _O_ be ? AllocateTypedArray(_constructorName_, NewTarget, <code>"%<var>TypedArray</var>Prototype%"</code>).
          1. Let _srcArray_ be _typedArray_.
          1. Let _srcData_ be _srcArray_.[[ViewedArrayBuffer]].
          1. If IsDetachedBuffer(_srcData_) is *true*, throw a *TypeError* exception.
          1. Let _elementType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _constructorName_.
          1. Let _elementLength_ be _srcArray_.[[ArrayLength]].
          1. Let _srcName_ be the String value of _srcArray_.[[TypedArrayName]].
          1. Let _srcType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _srcName_.
          1. Let _srcElementSize_ be the Element Size value in <emu-xref href="#table-49"></emu-xref> for _srcName_.
          1. Let _srcByteOffset_ be _srcArray_.[[ByteOffset]].
          1. Let _elementSize_ be the Element Size value in <emu-xref href="#table-49"></emu-xref> for _constructorName_.
          1. Let _byteLength_ be _elementSize_ &times; _elementLength_.
          1. If IsSharedArrayBuffer(_srcData_) is *false*, then
            1. Let _bufferConstructor_ be ? SpeciesConstructor(_srcData_, %ArrayBuffer%).
          1. Else,
            1. Let _bufferConstructor_ be %ArrayBuffer%.
          1. If SameValue(_elementType_, _srcType_) is *true*, then
            1. Let _data_ be ? CloneArrayBuffer(_srcData_, _srcByteOffset_, _byteLength_, _bufferConstructor_).
          1. Else,
            1. Let _data_ be ? AllocateArrayBuffer(_bufferConstructor_, _byteLength_).
            1. If IsDetachedBuffer(_srcData_) is *true*, throw a *TypeError* exception.
            1. Let _srcByteIndex_ be _srcByteOffset_.
            1. Let _targetByteIndex_ be 0.
            1. Let _count_ be _elementLength_.
            1. Repeat, while _count_ &gt; 0
              1. Let _value_ be GetValueFromBuffer(_srcData_, _srcByteIndex_, _srcType_, *true*, `"Unordered"`).
              1. Perform SetValueInBuffer(_data_, _targetByteIndex_, _elementType_, _value_, *true*, `"Unordered"`).
              1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.
              1. Set _targetByteIndex_ to _targetByteIndex_ + _elementSize_.
              1. Decrement _count_ by 1.
          1. Set _O_.[[ViewedArrayBuffer]] to _data_.
          1. Set _O_.[[ByteLength]] to _byteLength_.
          1. Set _O_.[[ByteOffset]] to 0.
          1. Set _O_.[[ArrayLength]] to _elementLength_.
          1. Return _O_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-object">
        <h1>_TypedArray_ ( _object_ )</h1>
        <p>This description applies only if the _TypedArray_ function is called with at least one argument and the Type of the first argument is Object and that object does not have either a [[TypedArrayName]] or an [[ArrayBufferData]] internal slot.</p>
        <p>_TypedArray_ called with argument _object_ performs the following steps:</p>
        <emu-alg>
          1. Assert: Type(_object_) is Object and _object_ does not have either a [[TypedArrayName]] or an [[ArrayBufferData]] internal slot.
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _constructorName_ be the String value of the Constructor Name value specified in <emu-xref href="#table-49"></emu-xref> for this <var>TypedArray</var> constructor.
          1. Let _O_ be ? AllocateTypedArray(_constructorName_, NewTarget, <code>"%<var>TypedArray</var>Prototype%"</code>).
          1. Let _usingIterator_ be ? GetMethod(_object_, @@iterator).
          1. If _usingIterator_ is not *undefined*, then
            1. Let _values_ be ? IterableToList(_object_, _usingIterator_).
            1. Let _len_ be the number of elements in _values_.
            1. Perform ? AllocateTypedArrayBuffer(_O_, _len_).
            1. Let _k_ be 0.
            1. Repeat, while _k_ &lt; _len_
              1. Let _Pk_ be ! ToString(_k_).
              1. Let _kValue_ be the first element of _values_ and remove that element from _values_.
              1. Perform ? Set(_O_, _Pk_, _kValue_, *true*).
              1. Increase _k_ by 1.
            1. Assert: _values_ is now an empty List.
            1. Return _O_.
          1. NOTE: _object_ is not an Iterable so assume it is already an array-like object.
          1. Let _arrayLike_ be _object_.
          1. Let _len_ be ? ToLength(? Get(_arrayLike_, `"length"`)).
          1. Perform ? AllocateTypedArrayBuffer(_O_, _len_).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_
            1. Let _Pk_ be ! ToString(_k_).
            1. Let _kValue_ be ? Get(_arrayLike_, _Pk_).
            1. Perform ? Set(_O_, _Pk_, _kValue_, *true*).
            1. Increase _k_ by 1.
          1. Return _O_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-buffer-byteoffset-length">
        <h1>_TypedArray_ ( _buffer_ [ , _byteOffset_ [ , _length_ ] ] )</h1>
        <p>This description applies only if the _TypedArray_ function is called with at least one argument and the Type of the first argument is Object and that object has an [[ArrayBufferData]] internal slot.</p>
        <p>_TypedArray_ called with at least one argument _buffer_ performs the following steps:</p>
        <emu-alg>
          1. Assert: Type(_buffer_) is Object and _buffer_ has an [[ArrayBufferData]] internal slot.
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _constructorName_ be the String value of the Constructor Name value specified in <emu-xref href="#table-49"></emu-xref> for this <var>TypedArray</var> constructor.
          1. Let _O_ be ? AllocateTypedArray(_constructorName_, NewTarget, <code>"%<var>TypedArray</var>Prototype%"</code>).
          1. Let _elementSize_ be the Number value of the Element Size value in <emu-xref href="#table-49"></emu-xref> for _constructorName_.
          1. Let _offset_ be ? ToIndex(_byteOffset_).
          1. If _offset_ modulo _elementSize_ &ne; 0, throw a *RangeError* exception.
          1. If _length_ is present and _length_ is not *undefined*, then
            1. Let _newLength_ be ? ToIndex(_length_).
          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
          1. Let _bufferByteLength_ be _buffer_.[[ArrayBufferByteLength]].
          1. If _length_ is either not present or *undefined*, then
            1. If _bufferByteLength_ modulo _elementSize_ &ne; 0, throw a *RangeError* exception.
            1. Let _newByteLength_ be _bufferByteLength_ - _offset_.
            1. If _newByteLength_ &lt; 0, throw a *RangeError* exception.
          1. Else,
            1. Let _newByteLength_ be _newLength_ &times; _elementSize_.
            1. If _offset_ + _newByteLength_ &gt; _bufferByteLength_, throw a *RangeError* exception.
          1. Set _O_.[[ViewedArrayBuffer]] to _buffer_.
          1. Set _O_.[[ByteLength]] to _newByteLength_.
          1. Set _O_.[[ByteOffset]] to _offset_.
          1. Set _O_.[[ArrayLength]] to _newByteLength_ / _elementSize_.
          1. Return _O_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="typedarray-create" aoid="TypedArrayCreate">
        <h1>TypedArrayCreate ( _constructor_, _argumentList_ )</h1>
        <p>The abstract operation TypedArrayCreate with arguments _constructor_ and _argumentList_ is used to specify the creation of a new TypedArray object using a constructor function. It performs the following steps:</p>
        <emu-alg>
          1. Let _newTypedArray_ be ? Construct(_constructor_, _argumentList_).
          1. Perform ? ValidateTypedArray(_newTypedArray_).
          1. If _argumentList_ is a List of a single Number, then
            1. If _newTypedArray_.[[ArrayLength]] &lt; _argumentList_[0], throw a *TypeError* exception.
          1. Return _newTypedArray_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="typedarray-species-create" aoid="TypedArraySpeciesCreate">
        <h1>TypedArraySpeciesCreate ( _exemplar_, _argumentList_ )</h1>
        <p>The abstract operation TypedArraySpeciesCreate with arguments _exemplar_ and _argumentList_ is used to specify the creation of a new TypedArray object using a constructor function that is derived from _exemplar_. It performs the following steps:</p>
        <emu-alg>
          1. Assert: _exemplar_ is an Object that has a [[TypedArrayName]] internal slot.
          1. Let _defaultConstructor_ be the intrinsic object listed in column one of <emu-xref href="#table-49"></emu-xref> for _exemplar_.[[TypedArrayName]].
          1. Let _constructor_ be ? SpeciesConstructor(_exemplar_, _defaultConstructor_).
          1. Return ? TypedArrayCreate(_constructor_, _argumentList_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-typedarray-constructors">
      <h1>Properties of the _TypedArray_ Constructors</h1>
      <p>Each _TypedArray_ constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %TypedArray%.</li>
        <li>has a `name` property whose value is the String value of the constructor name specified for it in <emu-xref href="#table-49"></emu-xref>.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-typedarray.bytes_per_element">
        <h1>_TypedArray_.BYTES_PER_ELEMENT</h1>
        <p>The value of _TypedArray_.BYTES_PER_ELEMENT is the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _TypedArray_.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-typedarray.prototype">
        <h1>_TypedArray_.prototype</h1>
        <p>The initial value of _TypedArray_`.prototype` is the corresponding _TypedArray_ prototype intrinsic object (<emu-xref href="#sec-properties-of-typedarray-prototype-objects"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-typedarray-prototype-objects">
      <h1>Properties of the _TypedArray_ Prototype Objects</h1>
      <p>Each _TypedArray_ prototype object:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %TypedArrayPrototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[ViewedArrayBuffer]] or any other of the internal slots that are specific to _TypedArray_ instance objects.</li>
      </ul>

      <emu-clause id="sec-typedarray.prototype.bytes_per_element">
        <h1>_TypedArray_.prototype.BYTES_PER_ELEMENT</h1>
        <p>The value of <code><var>TypedArray</var>.prototype.BYTES_PER_ELEMENT</code> is the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _TypedArray_.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-typedarray.prototype.constructor">
        <h1>_TypedArray_.prototype.constructor</h1>
        <p>The initial value of a <code><var>TypedArray</var>.prototype.constructor</code> is the corresponding %_TypedArray_% intrinsic object.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-typedarray-instances">
      <h1>Properties of _TypedArray_ Instances</h1>
      <p>_TypedArray_ instances are <emu-xref href="#integer-indexed-exotic-object">Integer-Indexed exotic objects</emu-xref>. Each _TypedArray_ instance inherits properties from the corresponding _TypedArray_ prototype object. Each _TypedArray_ instance has the following internal slots: [[TypedArrayName]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]], and [[ArrayLength]].</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-keyed-collections" oldids="sec-keyed-collection">
  <h1>Keyed Collections</h1>

  <emu-clause id="sec-map-objects">
    <h1>Map Objects</h1>
    <p>Map objects are collections of key/value pairs where both the keys and values may be arbitrary ECMAScript language values. A distinct key value may only occur in one key/value pair within the Map's collection. Distinct key values are discriminated using the SameValueZero comparison algorithm.</p>
    <p>Map object must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of elements in the collection. The data structures used in this Map objects specification is only intended to describe the required observable semantics of Map objects. It is not intended to be a viable implementation model.</p>

    <emu-clause id="sec-map-constructor">
      <h1>The Map Constructor</h1>
      <p>The Map constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%Map%</dfn>.</li>
        <li>is the initial value of the `Map` property of the global object.</li>
        <li>creates and initializes a new Map object when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>is designed to be subclassable. It may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `Map` behaviour must include a `super` call to the `Map` constructor to create and initialize the subclass instance with the internal state necessary to support the `Map.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-map-iterable">
        <h1>Map ( [ _iterable_ ] )</h1>
        <p>When the `Map` function is called with optional argument _iterable_, the following steps are taken:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _map_ be ? OrdinaryCreateFromConstructor(NewTarget, `"%MapPrototype%"`, &laquo; [[MapData]] &raquo;).
          1. Set _map_.[[MapData]] to a new empty List.
          1. If _iterable_ is not present, or is either *undefined* or *null*, return _map_.
          1. Let _adder_ be ? Get(_map_, `"set"`).
          1. Return ? AddEntriesFromIterable(_map_, _iterable_, _adder_).
        </emu-alg>
        <emu-note>
          <p>If the parameter _iterable_ is present, it is expected to be an object that implements an @@iterator method that returns an iterator object that produces a two element array-like object whose first element is a value that will be used as a Map key and whose second element is the value to associate with that key.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-add-entries-from-iterable" aoid="AddEntriesFromIterable">
        <h1>AddEntriesFromIterable ( _target_, _iterable_, _adder_ )</h1>
        <p>The abstract operation AddEntriesFromIterable accepts a _target_ object, an _iterable_ of entries, and an _adder_ function to be invoked, with _target_ as the receiver.</p>
        <emu-alg>
          1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.
          1. Assert: _iterable_ is present, and is neither *undefined* nor *null*.
          1. Let _iteratorRecord_ be ? GetIterator(_iterable_).
          1. Repeat,
            1. Let _next_ be ? IteratorStep(_iteratorRecord_).
            1. If _next_ is *false*, return _target_.
            1. Let _nextItem_ be ? IteratorValue(_next_).
            1. If Type(_nextItem_) is not Object, then
              1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
              1. Return ? IteratorClose(_iteratorRecord_, _error_).
            1. Let _k_ be Get(_nextItem_, `"0"`).
            1. If _k_ is an abrupt completion, return ? IteratorClose(_iteratorRecord_, _k_).
            1. Let _v_ be Get(_nextItem_, `"1"`).
            1. If _v_ is an abrupt completion, return ? IteratorClose(_iteratorRecord_, _v_).
            1. Let _status_ be Call(_adder_, _target_, &laquo; _k_.[[Value]], _v_.[[Value]] &raquo;).
            1. If _status_ is an abrupt completion, return ? IteratorClose(_iteratorRecord_, _status_).
        </emu-alg>
        <emu-note>
          <p>The parameter _iterable_ is expected to be an object that implements an @@iterator method that returns an iterator object that produces a two element array-like object whose first element is a value that will be used as a Map key and whose second element is the value to associate with that key.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-map-constructor">
      <h1>Properties of the Map Constructor</h1>
      <p>The Map constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-map.prototype">
        <h1>Map.prototype</h1>
        <p>The initial value of `Map.prototype` is the intrinsic object %MapPrototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-get-map-@@species">
        <h1>get Map [ @@species ]</h1>
        <p>`Map[@@species]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the `name` property of this function is `"get [Symbol.species]"`.</p>
        <emu-note>
          <p>Methods that create derived collection objects should call @@species to determine the constructor to use to create the derived objects. Subclass constructor may over-ride @@species to change the default constructor assignment.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-map-prototype-object">
      <h1>Properties of the Map Prototype Object</h1>
      <p>The Map prototype object:</p>
      <ul>
        <li>is the intrinsic object <dfn>%MapPrototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[MapData]] internal slot.</li>
      </ul>

      <emu-clause id="sec-map.prototype.clear">
        <h1>Map.prototype.clear ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).
          1. Let _entries_ be the List that is _M_.[[MapData]].
          1. For each Record { [[Key]], [[Value]] } _p_ that is an element of _entries_, do
            1. Set _p_.[[Key]] to ~empty~.
            1. Set _p_.[[Value]] to ~empty~.
          1. Return *undefined*.
        </emu-alg>
        <emu-note>
          <p>The existing [[MapData]] List is preserved because there may be existing Map Iterator objects that are suspended midway through iterating over that List.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-map.prototype.constructor">
        <h1>Map.prototype.constructor</h1>
        <p>The initial value of `Map.prototype.constructor` is the intrinsic object %Map%.</p>
      </emu-clause>

      <emu-clause id="sec-map.prototype.delete">
        <h1>Map.prototype.delete ( _key_ )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).
          1. Let _entries_ be the List that is _M_.[[MapData]].
          1. For each Record { [[Key]], [[Value]] } _p_ that is an element of _entries_, do
            1. If _p_.[[Key]] is not ~empty~ and SameValueZero(_p_.[[Key]], _key_) is *true*, then
              1. Set _p_.[[Key]] to ~empty~.
              1. Set _p_.[[Value]] to ~empty~.
              1. Return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>The value ~empty~ is used as a specification device to indicate that an entry has been deleted. Actual implementations may take other actions such as physically removing the entry from internal data structures.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-map.prototype.entries">
        <h1>Map.prototype.entries ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Return ? CreateMapIterator(_M_, `"key+value"`).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.foreach">
        <h1>Map.prototype.forEach ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <p>When the `forEach` method is called with one or two arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).
          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.
          1. If _thisArg_ is present, let _T_ be _thisArg_; else let _T_ be *undefined*.
          1. Let _entries_ be the List that is _M_.[[MapData]].
          1. For each Record { [[Key]], [[Value]] } _e_ that is an element of _entries_, in original key insertion order, do
            1. If _e_.[[Key]] is not ~empty~, then
              1. Perform ? Call(_callbackfn_, _T_, &laquo; _e_.[[Value]], _e_.[[Key]], _M_ &raquo;).
          1. Return *undefined*.
        </emu-alg>
        <emu-note>
          <p>_callbackfn_ should be a function that accepts three arguments. `forEach` calls _callbackfn_ once for each key/value pair present in the map object, in key insertion order. _callbackfn_ is called only for keys of the map which actually exist; it is not called for keys that have been deleted from the map.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _callbackfn_. If it is not provided, *undefined* is used instead.</p>
          <p>_callbackfn_ is called with three arguments: the value of the item, the key of the item, and the Map object being traversed.</p>
          <p>`forEach` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callbackfn_. Each entry of a map's [[MapData]] is only visited once. New keys added after the call to `forEach` begins are visited. A key will be revisited if it is deleted after it has been visited and then re-added before the `forEach` call completes. Keys that are deleted after the call to `forEach` begins and before being visited are not visited unless the key is added again before the `forEach` call completes.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-map.prototype.get">
        <h1>Map.prototype.get ( _key_ )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).
          1. Let _entries_ be the List that is _M_.[[MapData]].
          1. For each Record { [[Key]], [[Value]] } _p_ that is an element of _entries_, do
            1. If _p_.[[Key]] is not ~empty~ and SameValueZero(_p_.[[Key]], _key_) is *true*, return _p_.[[Value]].
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.has">
        <h1>Map.prototype.has ( _key_ )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).
          1. Let _entries_ be the List that is _M_.[[MapData]].
          1. For each Record { [[Key]], [[Value]] } _p_ that is an element of _entries_, do
            1. If _p_.[[Key]] is not ~empty~ and SameValueZero(_p_.[[Key]], _key_) is *true*, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.keys">
        <h1>Map.prototype.keys ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Return ? CreateMapIterator(_M_, `"key"`).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.set">
        <h1>Map.prototype.set ( _key_, _value_ )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).
          1. Let _entries_ be the List that is _M_.[[MapData]].
          1. For each Record { [[Key]], [[Value]] } _p_ that is an element of _entries_, do
            1. If _p_.[[Key]] is not ~empty~ and SameValueZero(_p_.[[Key]], _key_) is *true*, then
              1. Set _p_.[[Value]] to _value_.
              1. Return _M_.
          1. If _key_ is *-0*, set _key_ to *+0*.
          1. Let _p_ be the Record { [[Key]]: _key_, [[Value]]: _value_ }.
          1. Append _p_ as the last element of _entries_.
          1. Return _M_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-map.prototype.size">
        <h1>get Map.prototype.size</h1>
        <p>`Map.prototype.size` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).
          1. Let _entries_ be the List that is _M_.[[MapData]].
          1. Let _count_ be 0.
          1. For each Record { [[Key]], [[Value]] } _p_ that is an element of _entries_, do
            1. If _p_.[[Key]] is not ~empty~, increase _count_ by 1.
          1. Return _count_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.values">
        <h1>Map.prototype.values ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Return ? CreateMapIterator(_M_, `"value"`).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype-@@iterator">
        <h1>Map.prototype [ @@iterator ] ( )</h1>
        <p>The initial value of the @@iterator property is the same function object as the initial value of the `entries` property.</p>
      </emu-clause>

      <emu-clause id="sec-map.prototype-@@tostringtag">
        <h1>Map.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value `"Map"`.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-map-instances">
      <h1>Properties of Map Instances</h1>
      <p>Map instances are ordinary objects that inherit properties from the Map prototype. Map instances also have a [[MapData]] internal slot.</p>
    </emu-clause>

    <emu-clause id="sec-map-iterator-objects">
      <h1>Map Iterator Objects</h1>
      <p>A Map Iterator is an object, that represents a specific iteration over some specific Map instance object. There is not a named constructor for Map Iterator objects. Instead, map iterator objects are created by calling certain methods of Map instance objects.</p>

      <emu-clause id="sec-createmapiterator" aoid="CreateMapIterator">
        <h1>CreateMapIterator ( _map_, _kind_ )</h1>
        <p>Several methods of Map objects return Iterator objects. The abstract operation CreateMapIterator with arguments _map_ and _kind_ is used to create such iterator objects. It performs the following steps:</p>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_map_, [[MapData]]).
          1. Let _iterator_ be ObjectCreate(%MapIteratorPrototype%, &laquo; [[Map]], [[MapNextIndex]], [[MapIterationKind]] &raquo;).
          1. Set _iterator_.[[Map]] to _map_.
          1. Set _iterator_.[[MapNextIndex]] to 0.
          1. Set _iterator_.[[MapIterationKind]] to _kind_.
          1. Return _iterator_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%mapiteratorprototype%-object">
        <h1>The %MapIteratorPrototype% Object</h1>
        <p>The <dfn>%MapIteratorPrototype%</dfn> object:</p>
        <ul>
          <li>has properties that are inherited by all Map Iterator Objects.</li>
          <li>is an ordinary object.</li>
          <li>has a [[Prototype]] internal slot whose value is the intrinsic object %IteratorPrototype%.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-%mapiteratorprototype%.next">
          <h1>%MapIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. Let _O_ be the *this* value.
            1. If Type(_O_) is not Object, throw a *TypeError* exception.
            1. If _O_ does not have all of the internal slots of a Map Iterator Instance (<emu-xref href="#sec-properties-of-map-iterator-instances"></emu-xref>), throw a *TypeError* exception.
            1. Let _m_ be _O_.[[Map]].
            1. Let _index_ be _O_.[[MapNextIndex]].
            1. Let _itemKind_ be _O_.[[MapIterationKind]].
            1. If _m_ is *undefined*, return CreateIterResultObject(*undefined*, *true*).
            1. Assert: _m_ has a [[MapData]] internal slot.
            1. Let _entries_ be the List that is _m_.[[MapData]].
            1. Let _numEntries_ be the number of elements of _entries_.
            1. NOTE: _numEntries_ must be redetermined each time this method is evaluated.
            1. Repeat, while _index_ is less than _numEntries_,
              1. Let _e_ be the Record { [[Key]], [[Value]] } that is the value of _entries_[_index_].
              1. Increase _index_ by 1.
              1. Set _O_.[[MapNextIndex]] to _index_.
              1. If _e_.[[Key]] is not ~empty~, then
                1. If _itemKind_ is `"key"`, let _result_ be _e_.[[Key]].
                1. Else if _itemKind_ is `"value"`, let _result_ be _e_.[[Value]].
                1. Else,
                  1. Assert: _itemKind_ is `"key+value"`.
                  1. Let _result_ be CreateArrayFromList(&laquo; _e_.[[Key]], _e_.[[Value]] &raquo;).
                1. Return CreateIterResultObject(_result_, *false*).
            1. Set _O_.[[Map]] to *undefined*.
            1. Return CreateIterResultObject(*undefined*, *true*).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%mapiteratorprototype%-@@tostringtag">
          <h1>%MapIteratorPrototype% [ @@toStringTag ]</h1>
          <p>The initial value of the @@toStringTag property is the String value `"Map Iterator"`.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-map-iterator-instances">
        <h1>Properties of Map Iterator Instances</h1>
        <p>Map Iterator instances are ordinary objects that inherit properties from the %MapIteratorPrototype% intrinsic object. Map Iterator instances are initially created with the internal slots described in <emu-xref href="#table-50"></emu-xref>.</p>
        <emu-table id="table-50" caption="Internal Slots of Map Iterator Instances">
          <table>
            <tbody>
            <tr>
              <th>
                Internal Slot
              </th>
              <th>
                Description
              </th>
            </tr>
            <tr>
              <td>
                [[Map]]
              </td>
              <td>
                The Map object that is being iterated.
              </td>
            </tr>
            <tr>
              <td>
                [[MapNextIndex]]
              </td>
              <td>
                The integer index of the next Map data element to be examined by this iterator.
              </td>
            </tr>
            <tr>
              <td>
                [[MapIterationKind]]
              </td>
              <td>
                A String value that identifies what is to be returned for each element of the iteration. The possible values are: `"key"`, `"value"`, `"key+value"`.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-set-objects">
    <h1>Set Objects</h1>
    <p>Set objects are collections of ECMAScript language values. A distinct value may only occur once as an element of a Set's collection. Distinct values are discriminated using the SameValueZero comparison algorithm.</p>
    <p>Set objects must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of elements in the collection. The data structures used in this Set objects specification is only intended to describe the required observable semantics of Set objects. It is not intended to be a viable implementation model.</p>

    <emu-clause id="sec-set-constructor">
      <h1>The Set Constructor</h1>
      <p>The Set constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%Set%</dfn>.</li>
        <li>is the initial value of the `Set` property of the global object.</li>
        <li>creates and initializes a new Set object when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>is designed to be subclassable. It may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `Set` behaviour must include a `super` call to the `Set` constructor to create and initialize the subclass instance with the internal state necessary to support the `Set.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-set-iterable">
        <h1>Set ( [ _iterable_ ] )</h1>
        <p>When the `Set` function is called with optional argument _iterable_, the following steps are taken:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _set_ be ? OrdinaryCreateFromConstructor(NewTarget, `"%SetPrototype%"`, &laquo; [[SetData]] &raquo;).
          1. Set _set_.[[SetData]] to a new empty List.
          1. If _iterable_ is not present, set _iterable_ to *undefined*.
          1. If _iterable_ is either *undefined* or *null*, return _set_.
          1. Let _adder_ be ? Get(_set_, `"add"`).
          1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.
          1. Let _iteratorRecord_ be ? GetIterator(_iterable_).
          1. Repeat,
            1. Let _next_ be ? IteratorStep(_iteratorRecord_).
            1. If _next_ is *false*, return _set_.
            1. Let _nextValue_ be ? IteratorValue(_next_).
            1. Let _status_ be Call(_adder_, _set_, &laquo; _nextValue_ &raquo;).
            1. If _status_ is an abrupt completion, return ? IteratorClose(_iteratorRecord_, _status_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-set-constructor">
      <h1>Properties of the Set Constructor</h1>
      <p>The Set constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-set.prototype">
        <h1>Set.prototype</h1>
        <p>The initial value of `Set.prototype` is the intrinsic %SetPrototype% object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-get-set-@@species">
        <h1>get Set [ @@species ]</h1>
        <p>`Set[@@species]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the `name` property of this function is `"get [Symbol.species]"`.</p>
        <emu-note>
          <p>Methods that create derived collection objects should call @@species to determine the constructor to use to create the derived objects. Subclass constructor may over-ride @@species to change the default constructor assignment.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-set-prototype-object">
      <h1>Properties of the Set Prototype Object</h1>
      <p>The Set prototype object:</p>
      <ul>
        <li>is the intrinsic object <dfn>%SetPrototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[SetData]] internal slot.</li>
      </ul>

      <emu-clause id="sec-set.prototype.add">
        <h1>Set.prototype.add ( _value_ )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).
          1. Let _entries_ be the List that is _S_.[[SetData]].
          1. For each _e_ that is an element of _entries_, do
            1. If _e_ is not ~empty~ and SameValueZero(_e_, _value_) is *true*, then
              1. Return _S_.
          1. If _value_ is *-0*, set _value_ to *+0*.
          1. Append _value_ as the last element of _entries_.
          1. Return _S_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.clear">
        <h1>Set.prototype.clear ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).
          1. Let _entries_ be the List that is _S_.[[SetData]].
          1. For each _e_ that is an element of _entries_, do
            1. Replace the element of _entries_ whose value is _e_ with an element whose value is ~empty~.
          1. Return *undefined*.
        </emu-alg>
        <emu-note>
          <p>The existing [[SetData]] List is preserved because there may be existing Set Iterator objects that are suspended midway through iterating over that List.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.constructor">
        <h1>Set.prototype.constructor</h1>
        <p>The initial value of `Set.prototype.constructor` is the intrinsic object %Set%.</p>
      </emu-clause>

      <emu-clause id="sec-set.prototype.delete">
        <h1>Set.prototype.delete ( _value_ )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).
          1. Let _entries_ be the List that is _S_.[[SetData]].
          1. For each _e_ that is an element of _entries_, do
            1. If _e_ is not ~empty~ and SameValueZero(_e_, _value_) is *true*, then
              1. Replace the element of _entries_ whose value is _e_ with an element whose value is ~empty~.
              1. Return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>The value ~empty~ is used as a specification device to indicate that an entry has been deleted. Actual implementations may take other actions such as physically removing the entry from internal data structures.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.entries">
        <h1>Set.prototype.entries ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateSetIterator(_S_, `"key+value"`).
        </emu-alg>
        <emu-note>
          <p>For iteration purposes, a Set appears similar to a Map where each entry has the same value for its key and value.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.foreach">
        <h1>Set.prototype.forEach ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <p>When the `forEach` method is called with one or two arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).
          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.
          1. If _thisArg_ is present, let _T_ be _thisArg_; else let _T_ be *undefined*.
          1. Let _entries_ be the List that is _S_.[[SetData]].
          1. For each _e_ that is an element of _entries_, in original insertion order, do
            1. If _e_ is not ~empty~, then
              1. Perform ? Call(_callbackfn_, _T_, &laquo; _e_, _e_, _S_ &raquo;).
          1. Return *undefined*.
        </emu-alg>
        <emu-note>
          <p>_callbackfn_ should be a function that accepts three arguments. `forEach` calls _callbackfn_ once for each value present in the set object, in value insertion order. _callbackfn_ is called only for values of the Set which actually exist; it is not called for keys that have been deleted from the set.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _callbackfn_. If it is not provided, *undefined* is used instead.</p>
          <p>_callbackfn_ is called with three arguments: the first two arguments are a value contained in the Set. The same value is passed for both arguments. The Set object being traversed is passed as the third argument.</p>
          <p>The _callbackfn_ is called with three arguments to be consistent with the call back functions used by `forEach` methods for Map and Array. For Sets, each item value is considered to be both the key and the value.</p>
          <p>`forEach` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callbackfn_.</p>
          <p>Each value is normally visited only once. However, a value will be revisited if it is deleted after it has been visited and then re-added before the `forEach` call completes. Values that are deleted after the call to `forEach` begins and before being visited are not visited unless the value is added again before the `forEach` call completes. New values added after the call to `forEach` begins are visited.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.has">
        <h1>Set.prototype.has ( _value_ )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).
          1. Let _entries_ be the List that is _S_.[[SetData]].
          1. For each _e_ that is an element of _entries_, do
            1. If _e_ is not ~empty~ and SameValueZero(_e_, _value_) is *true*, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.keys">
        <h1>Set.prototype.keys ( )</h1>
        <p>The initial value of the `keys` property is the same function object as the initial value of the `values` property.</p>
        <emu-note>
          <p>For iteration purposes, a Set appears similar to a Map where each entry has the same value for its key and value.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-set.prototype.size">
        <h1>get Set.prototype.size</h1>
        <p>`Set.prototype.size` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).
          1. Let _entries_ be the List that is _S_.[[SetData]].
          1. Let _count_ be 0.
          1. For each _e_ that is an element of _entries_, do
            1. If _e_ is not ~empty~, increase _count_ by 1.
          1. Return _count_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.values">
        <h1>Set.prototype.values ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateSetIterator(_S_, `"value"`).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype-@@iterator">
        <h1>Set.prototype [ @@iterator ] ( )</h1>
        <p>The initial value of the @@iterator property is the same function object as the initial value of the `values` property.</p>
      </emu-clause>

      <emu-clause id="sec-set.prototype-@@tostringtag">
        <h1>Set.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value `"Set"`.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-set-instances">
      <h1>Properties of Set Instances</h1>
      <p>Set instances are ordinary objects that inherit properties from the Set prototype. Set instances also have a [[SetData]] internal slot.</p>
    </emu-clause>

    <emu-clause id="sec-set-iterator-objects">
      <h1>Set Iterator Objects</h1>
      <p>A Set Iterator is an ordinary object, with the structure defined below, that represents a specific iteration over some specific Set instance object. There is not a named constructor for Set Iterator objects. Instead, set iterator objects are created by calling certain methods of Set instance objects.</p>

      <emu-clause id="sec-createsetiterator" aoid="CreateSetIterator">
        <h1>CreateSetIterator ( _set_, _kind_ )</h1>
        <p>Several methods of Set objects return Iterator objects. The abstract operation CreateSetIterator with arguments _set_ and _kind_ is used to create such iterator objects. It performs the following steps:</p>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_set_, [[SetData]]).
          1. Let _iterator_ be ObjectCreate(%SetIteratorPrototype%, &laquo; [[IteratedSet]], [[SetNextIndex]], [[SetIterationKind]] &raquo;).
          1. Set _iterator_.[[IteratedSet]] to _set_.
          1. Set _iterator_.[[SetNextIndex]] to 0.
          1. Set _iterator_.[[SetIterationKind]] to _kind_.
          1. Return _iterator_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%setiteratorprototype%-object">
        <h1>The %SetIteratorPrototype% Object</h1>
        <p>The <dfn>%SetIteratorPrototype%</dfn> object:</p>
        <ul>
          <li>has properties that are inherited by all Set Iterator Objects.</li>
          <li>is an ordinary object.</li>
          <li>has a [[Prototype]] internal slot whose value is the intrinsic object %IteratorPrototype%.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-%setiteratorprototype%.next">
          <h1>%SetIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. Let _O_ be the *this* value.
            1. If Type(_O_) is not Object, throw a *TypeError* exception.
            1. If _O_ does not have all of the internal slots of a Set Iterator Instance (<emu-xref href="#sec-properties-of-set-iterator-instances"></emu-xref>), throw a *TypeError* exception.
            1. Let _s_ be _O_.[[IteratedSet]].
            1. Let _index_ be _O_.[[SetNextIndex]].
            1. Let _itemKind_ be _O_.[[SetIterationKind]].
            1. If _s_ is *undefined*, return CreateIterResultObject(*undefined*, *true*).
            1. Assert: _s_ has a [[SetData]] internal slot.
            1. Let _entries_ be the List that is _s_.[[SetData]].
            1. Let _numEntries_ be the number of elements of _entries_.
            1. NOTE: _numEntries_ must be redetermined each time this method is evaluated.
            1. Repeat, while _index_ is less than _numEntries_,
              1. Let _e_ be _entries_[_index_].
              1. Increase _index_ by 1.
              1. Set _O_.[[SetNextIndex]] to _index_.
              1. If _e_ is not ~empty~, then
                1. If _itemKind_ is `"key+value"`, then
                  1. Return CreateIterResultObject(CreateArrayFromList(&laquo; _e_, _e_ &raquo;), *false*).
                1. Return CreateIterResultObject(_e_, *false*).
            1. Set _O_.[[IteratedSet]] to *undefined*.
            1. Return CreateIterResultObject(*undefined*, *true*).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%setiteratorprototype%-@@tostringtag">
          <h1>%SetIteratorPrototype% [ @@toStringTag ]</h1>
          <p>The initial value of the @@toStringTag property is the String value `"Set Iterator"`.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-set-iterator-instances">
        <h1>Properties of Set Iterator Instances</h1>
        <p>Set Iterator instances are ordinary objects that inherit properties from the %SetIteratorPrototype% intrinsic object. Set Iterator instances are initially created with the internal slots specified in <emu-xref href="#table-51"></emu-xref>.</p>
        <emu-table id="table-51" caption="Internal Slots of Set Iterator Instances">
          <table>
            <tbody>
            <tr>
              <th>
                Internal Slot
              </th>
              <th>
                Description
              </th>
            </tr>
            <tr>
              <td>
                [[IteratedSet]]
              </td>
              <td>
                The Set object that is being iterated.
              </td>
            </tr>
            <tr>
              <td>
                [[SetNextIndex]]
              </td>
              <td>
                The integer index of the next Set data element to be examined by this iterator
              </td>
            </tr>
            <tr>
              <td>
                [[SetIterationKind]]
              </td>
              <td>
                A String value that identifies what is to be returned for each element of the iteration. The possible values are: `"key"`, `"value"`, `"key+value"`. `"key"` and `"value"` have the same meaning.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-weakmap-objects">
    <h1>WeakMap Objects</h1>
    <p>WeakMap objects are collections of key/value pairs where the keys are objects and values may be arbitrary ECMAScript language values. A WeakMap may be queried to see if it contains a key/value pair with a specific key, but no mechanism is provided for enumerating the objects it holds as keys. If an object that is being used as the key of a WeakMap key/value pair is only reachable by following a chain of references that start within that WeakMap, then that key/value pair is inaccessible and is automatically removed from the WeakMap. WeakMap implementations must detect and remove such key/value pairs and any associated resources.</p>
    <p>An implementation may impose an arbitrarily determined latency between the time a key/value pair of a WeakMap becomes inaccessible and the time when the key/value pair is removed from the WeakMap. If this latency was observable to ECMAScript program, it would be a source of indeterminacy that could impact program execution. For that reason, an ECMAScript implementation must not provide any means to observe a key of a WeakMap that does not require the observer to present the observed key.</p>
    <p>WeakMap objects must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of key/value pairs in the collection. The data structure used in this WeakMap objects specification are only intended to describe the required observable semantics of WeakMap objects. It is not intended to be a viable implementation model.</p>
    <emu-note>
      <p>WeakMap and WeakSets are intended to provide mechanisms for dynamically associating state with an object in a manner that does not &ldquo;leak&rdquo; memory resources if, in the absence of the WeakMap or WeakSet, the object otherwise became inaccessible and subject to resource reclamation by the implementation's garbage collection mechanisms. This characteristic can be achieved by using an inverted per-object mapping of weak map instances to keys. Alternatively each weak map may internally store its key to value mappings but this approach requires coordination between the WeakMap or WeakSet implementation and the garbage collector. The following references describe mechanism that may be useful to implementations of WeakMap and WeakSets:</p>
      <p>Barry Hayes. 1997. Ephemerons: a new finalization mechanism. In <i>Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications (OOPSLA '97)</i>, A. Michael Berman (Ed.). ACM, New York, NY, USA, 176-183, <a href="http://doi.acm.org/10.1145/263698.263733">http://doi.acm.org/10.1145/263698.263733</a>.</p>
      <p>Alexandra Barros, Roberto Ierusalimschy, Eliminating Cycles in Weak Tables. Journal of Universal Computer Science - J.UCS, vol. 14, no. 21, pp. 3481-3497, 2008, <a href="http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak">http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak</a></p>
    </emu-note>

    <emu-clause id="sec-weakmap-constructor">
      <h1>The WeakMap Constructor</h1>
      <p>The WeakMap constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%WeakMap%</dfn>.</li>
        <li>is the initial value of the `WeakMap` property of the global object.</li>
        <li>creates and initializes a new WeakMap object when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>is designed to be subclassable. It may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `WeakMap` behaviour must include a `super` call to the `WeakMap` constructor to create and initialize the subclass instance with the internal state necessary to support the `WeakMap.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-weakmap-iterable">
        <h1>WeakMap ( [ _iterable_ ] )</h1>
        <p>When the `WeakMap` function is called with optional argument _iterable_, the following steps are taken:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _map_ be ? OrdinaryCreateFromConstructor(NewTarget, `"%WeakMapPrototype%"`, &laquo; [[WeakMapData]] &raquo;).
          1. Set _map_.[[WeakMapData]] to a new empty List.
          1. If _iterable_ is not present, or is either *undefined* or *null*, return _map_.
          1. Let _adder_ be ? Get(_map_, `"set"`).
          1. Return ? AddEntriesFromIterable(_map_, _iterable_, _adder_).
        </emu-alg>
        <emu-note>
          <p>If the parameter _iterable_ is present, it is expected to be an object that implements an @@iterator method that returns an iterator object that produces a two element array-like object whose first element is a value that will be used as a WeakMap key and whose second element is the value to associate with that key.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakmap-constructor">
      <h1>Properties of the WeakMap Constructor</h1>
      <p>The WeakMap constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-weakmap.prototype">
        <h1>WeakMap.prototype</h1>
        <p>The initial value of `WeakMap.prototype` is the intrinsic object %WeakMapPrototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakmap-prototype-object">
      <h1>Properties of the WeakMap Prototype Object</h1>
      <p>The WeakMap prototype object:</p>
      <ul>
        <li>is the intrinsic object <dfn>%WeakMapPrototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[WeakMapData]] internal slot.</li>
      </ul>

      <emu-clause id="sec-weakmap.prototype.constructor">
        <h1>WeakMap.prototype.constructor</h1>
        <p>The initial value of `WeakMap.prototype.constructor` is the intrinsic object %WeakMap%.</p>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.delete">
        <h1>WeakMap.prototype.delete ( _key_ )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).
          1. Let _entries_ be the List that is _M_.[[WeakMapData]].
          1. If Type(_key_) is not Object, return *false*.
          1. For each Record { [[Key]], [[Value]] } _p_ that is an element of _entries_, do
            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, then
              1. Set _p_.[[Key]] to ~empty~.
              1. Set _p_.[[Value]] to ~empty~.
              1. Return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>The value ~empty~ is used as a specification device to indicate that an entry has been deleted. Actual implementations may take other actions such as physically removing the entry from internal data structures.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.get">
        <h1>WeakMap.prototype.get ( _key_ )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).
          1. Let _entries_ be the List that is _M_.[[WeakMapData]].
          1. If Type(_key_) is not Object, return *undefined*.
          1. For each Record { [[Key]], [[Value]] } _p_ that is an element of _entries_, do
            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, return _p_.[[Value]].
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.has">
        <h1>WeakMap.prototype.has ( _key_ )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).
          1. Let _entries_ be the List that is _M_.[[WeakMapData]].
          1. If Type(_key_) is not Object, return *false*.
          1. For each Record { [[Key]], [[Value]] } _p_ that is an element of _entries_, do
            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.set">
        <h1>WeakMap.prototype.set ( _key_, _value_ )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).
          1. Let _entries_ be the List that is _M_.[[WeakMapData]].
          1. If Type(_key_) is not Object, throw a *TypeError* exception.
          1. For each Record { [[Key]], [[Value]] } _p_ that is an element of _entries_, do
            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, then
              1. Set _p_.[[Value]] to _value_.
              1. Return _M_.
          1. Let _p_ be the Record { [[Key]]: _key_, [[Value]]: _value_ }.
          1. Append _p_ as the last element of _entries_.
          1. Return _M_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype-@@tostringtag">
        <h1>WeakMap.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value `"WeakMap"`.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-weakmap-instances">
      <h1>Properties of WeakMap Instances</h1>
      <p>WeakMap instances are ordinary objects that inherit properties from the WeakMap prototype. WeakMap instances also have a [[WeakMapData]] internal slot.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-weakset-objects">
    <h1>WeakSet Objects</h1>
    <p>WeakSet objects are collections of objects. A distinct object may only occur once as an element of a WeakSet's collection. A WeakSet may be queried to see if it contains a specific object, but no mechanism is provided for enumerating the objects it holds. If an object that is contained by a WeakSet is only reachable by following a chain of references that start within that WeakSet, then that object is inaccessible and is automatically removed from the WeakSet. WeakSet implementations must detect and remove such objects and any associated resources.</p>
    <p>An implementation may impose an arbitrarily determined latency between the time an object contained in a WeakSet becomes inaccessible and the time when the object is removed from the WeakSet. If this latency was observable to ECMAScript program, it would be a source of indeterminacy that could impact program execution. For that reason, an ECMAScript implementation must not provide any means to determine if a WeakSet contains a particular object that does not require the observer to present the observed object.</p>
    <p>WeakSet objects must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of elements in the collection. The data structure used in this WeakSet objects specification is only intended to describe the required observable semantics of WeakSet objects. It is not intended to be a viable implementation model.</p>
    <emu-note>
      <p>See the NOTE in <emu-xref href="#sec-weakmap-objects"></emu-xref>.</p>
    </emu-note>

    <emu-clause id="sec-weakset-constructor">
      <h1>The WeakSet Constructor</h1>
      <p>The WeakSet constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%WeakSet%</dfn>.</li>
        <li>is the initial value of the `WeakSet` property of the global object.</li>
        <li>creates and initializes a new WeakSet object when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>is designed to be subclassable. It may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `WeakSet` behaviour must include a `super` call to the `WeakSet` constructor to create and initialize the subclass instance with the internal state necessary to support the `WeakSet.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-weakset-iterable">
        <h1>WeakSet ( [ _iterable_ ] )</h1>
        <p>When the `WeakSet` function is called with optional argument _iterable_, the following steps are taken:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _set_ be ? OrdinaryCreateFromConstructor(NewTarget, `"%WeakSetPrototype%"`, &laquo; [[WeakSetData]] &raquo;).
          1. Set _set_.[[WeakSetData]] to a new empty List.
          1. If _iterable_ is not present, set _iterable_ to *undefined*.
          1. If _iterable_ is either *undefined* or *null*, return _set_.
          1. Let _adder_ be ? Get(_set_, `"add"`).
          1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.
          1. Let _iteratorRecord_ be ? GetIterator(_iterable_).
          1. Repeat,
            1. Let _next_ be ? IteratorStep(_iteratorRecord_).
            1. If _next_ is *false*, return _set_.
            1. Let _nextValue_ be ? IteratorValue(_next_).
            1. Let _status_ be Call(_adder_, _set_, &laquo; _nextValue_ &raquo;).
            1. If _status_ is an abrupt completion, return ? IteratorClose(_iteratorRecord_, _status_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakset-constructor">
      <h1>Properties of the WeakSet Constructor</h1>
      <p>The WeakSet constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-weakset.prototype">
        <h1>WeakSet.prototype</h1>
        <p>The initial value of `WeakSet.prototype` is the intrinsic %WeakSetPrototype% object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakset-prototype-object">
      <h1>Properties of the WeakSet Prototype Object</h1>
      <p>The WeakSet prototype object:</p>
      <ul>
        <li>is the intrinsic object <dfn>%WeakSetPrototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[WeakSetData]] internal slot.</li>
      </ul>

      <emu-clause id="sec-weakset.prototype.add">
        <h1>WeakSet.prototype.add ( _value_ )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[WeakSetData]]).
          1. If Type(_value_) is not Object, throw a *TypeError* exception.
          1. Let _entries_ be the List that is _S_.[[WeakSetData]].
          1. For each _e_ that is an element of _entries_, do
            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, then
              1. Return _S_.
          1. Append _value_ as the last element of _entries_.
          1. Return _S_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weakset.prototype.constructor">
        <h1>WeakSet.prototype.constructor</h1>
        <p>The initial value of `WeakSet.prototype.constructor` is the %WeakSet% intrinsic object.</p>
      </emu-clause>

      <emu-clause id="sec-weakset.prototype.delete">
        <h1>WeakSet.prototype.delete ( _value_ )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[WeakSetData]]).
          1. If Type(_value_) is not Object, return *false*.
          1. Let _entries_ be the List that is _S_.[[WeakSetData]].
          1. For each _e_ that is an element of _entries_, do
            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, then
              1. Replace the element of _entries_ whose value is _e_ with an element whose value is ~empty~.
              1. Return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>The value ~empty~ is used as a specification device to indicate that an entry has been deleted. Actual implementations may take other actions such as physically removing the entry from internal data structures.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-weakset.prototype.has">
        <h1>WeakSet.prototype.has ( _value_ )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[WeakSetData]]).
          1. Let _entries_ be the List that is _S_.[[WeakSetData]].
          1. If Type(_value_) is not Object, return *false*.
          1. For each _e_ that is an element of _entries_, do
            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weakset.prototype-@@tostringtag">
        <h1>WeakSet.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value `"WeakSet"`.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-weakset-instances">
      <h1>Properties of WeakSet Instances</h1>
      <p>WeakSet instances are ordinary objects that inherit properties from the WeakSet prototype. WeakSet instances also have a [[WeakSetData]] internal slot.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-structured-data">
  <h1>Structured Data</h1>

  <emu-clause id="sec-arraybuffer-objects">
    <h1>ArrayBuffer Objects</h1>

    <emu-clause id="sec-abstract-operations-for-arraybuffer-objects">
      <h1>Abstract Operations For ArrayBuffer Objects</h1>

      <emu-clause id="sec-allocatearraybuffer" aoid="AllocateArrayBuffer">
        <h1>AllocateArrayBuffer ( _constructor_, _byteLength_ )</h1>
        <p>The abstract operation AllocateArrayBuffer with arguments _constructor_ and _byteLength_ is used to create an ArrayBuffer object. It performs the following steps:</p>
        <emu-alg>
          1. Let _obj_ be ? OrdinaryCreateFromConstructor(_constructor_, `"%ArrayBufferPrototype%"`, &laquo; [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] &raquo;).
          1. Assert: _byteLength_ is an integer value &ge; 0.
          1. Let _block_ be ? CreateByteDataBlock(_byteLength_).
          1. Set _obj_.[[ArrayBufferData]] to _block_.
          1. Set _obj_.[[ArrayBufferByteLength]] to _byteLength_.
          1. Return _obj_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isdetachedbuffer" aoid="IsDetachedBuffer">
        <h1>IsDetachedBuffer ( _arrayBuffer_ )</h1>
        <p>The abstract operation IsDetachedBuffer with argument _arrayBuffer_ performs the following steps:</p>
        <emu-alg>
          1. Assert: Type(_arrayBuffer_) is Object and it has an [[ArrayBufferData]] internal slot.
          1. If _arrayBuffer_.[[ArrayBufferData]] is *null*, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-detacharraybuffer" aoid="DetachArrayBuffer">
        <h1>DetachArrayBuffer ( _arrayBuffer_ [ , _key_ ] )</h1>
        <p>The abstract operation DetachArrayBuffer with argument _arrayBuffer_ and optional argument _key_ performs the following steps:</p>
        <emu-alg>
          1. Assert: Type(_arrayBuffer_) is Object and it has [[ArrayBufferData]], [[ArrayBufferByteLength]], and [[ArrayBufferDetachKey]] internal slots.
          1. Assert: IsSharedArrayBuffer(_arrayBuffer_) is *false*.
          1. If _key_ is not present, set _key_ to *undefined*.
          1. If SameValue(_arrayBuffer_.[[ArrayBufferDetachKey]], _key_) is *false*, throw a *TypeError* exception.
          1. Set _arrayBuffer_.[[ArrayBufferData]] to *null*.
          1. Set _arrayBuffer_.[[ArrayBufferByteLength]] to 0.
          1. Return NormalCompletion(*null*).
        </emu-alg>
        <emu-note>
          <p>Detaching an ArrayBuffer instance disassociates the Data Block used as its backing store from the instance and sets the byte length of the buffer to 0. No operations defined by this specification use the DetachArrayBuffer abstract operation. However, an ECMAScript implementation or host environment may define such operations.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-clonearraybuffer" aoid="CloneArrayBuffer">
        <h1>CloneArrayBuffer ( _srcBuffer_, _srcByteOffset_, _srcLength_, _cloneConstructor_ )</h1>
        <p>The abstract operation CloneArrayBuffer takes four parameters, an ArrayBuffer _srcBuffer_, an integer offset _srcByteOffset_, an integer length _srcLength_, and a constructor function _cloneConstructor_. It creates a new ArrayBuffer whose data is a copy of _srcBuffer_'s data over the range starting at _srcByteOffset_ and continuing for _srcLength_ bytes. This operation performs the following steps:</p>
        <emu-alg>
          1. Assert: Type(_srcBuffer_) is Object and it has an [[ArrayBufferData]] internal slot.
          1. Assert: IsConstructor(_cloneConstructor_) is *true*.
          1. Let _targetBuffer_ be ? AllocateArrayBuffer(_cloneConstructor_, _srcLength_).
          1. If IsDetachedBuffer(_srcBuffer_) is *true*, throw a *TypeError* exception.
          1. Let _srcBlock_ be _srcBuffer_.[[ArrayBufferData]].
          1. Let _targetBlock_ be _targetBuffer_.[[ArrayBufferData]].
          1. Perform CopyDataBlockBytes(_targetBlock_, 0, _srcBlock_, _srcByteOffset_, _srcLength_).
          1. Return _targetBuffer_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-rawbytestonumber" aoid="RawBytesToNumber">
        <h1>RawBytesToNumber ( _type_, _rawBytes_, _isLittleEndian_ )</h1>
        <p>The abstract operation RawBytesToNumber takes three parameters, a String _type_, a List _rawBytes_, and a Boolean _isLittleEndian_. This operation performs the following steps:</p>
        <emu-alg>
          1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
          1. If _isLittleEndian_ is *false*, reverse the order of the elements of _rawBytes_.
          1. If _type_ is `"Float32"`, then
            1. Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary32 value.
            1. If _value_ is an IEEE 754-2008 binary32 NaN value, return the *NaN* Number value.
            1. Return the Number value that corresponds to _value_.
          1. If _type_ is `"Float64"`, then
            1. Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary64 value.
            1. If _value_ is an IEEE 754-2008 binary64 NaN value, return the *NaN* Number value.
            1. Return the Number value that corresponds to _value_.
          1. If the first code unit of _type_ is the code unit 0x0055 (LATIN CAPITAL LETTER U), then
            1. Let _intValue_ be the byte elements of _rawBytes_ concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number.
          1. Else,
            1. Let _intValue_ be the byte elements of _rawBytes_ concatenated and interpreted as a bit string encoding of a binary little-endian 2's complement number of bit length _elementSize_ &times; 8.
          1. Return the Number value that corresponds to _intValue_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getvaluefrombuffer" aoid="GetValueFromBuffer">
        <h1>GetValueFromBuffer ( _arrayBuffer_, _byteIndex_, _type_, _isTypedArray_, _order_ [ , _isLittleEndian_ ] )</h1>
        <p>The abstract operation GetValueFromBuffer takes six parameters, an ArrayBuffer or SharedArrayBuffer _arrayBuffer_, an integer _byteIndex_, a String _type_, a Boolean _isTypedArray_, a String _order_, and optionally a Boolean _isLittleEndian_. This operation performs the following steps:</p>
        <emu-alg>
          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.
          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.
          1. Assert: _byteIndex_ is an integer value &ge; 0.
          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].
          1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then
            1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
            1. Let _eventList_ be the [[EventList]] field of the element in _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
            1. If _isTypedArray_ is *true* and _type_ is `"Int8"`, `"Uint8"`, `"Int16"`, `"Uint16"`, `"Int32"`, or `"Uint32"`, let _noTear_ be *true*; otherwise let _noTear_ be *false*.
            1. Let _rawValue_ be a List of length _elementSize_ of nondeterministically chosen byte values.
            1. NOTE: In implementations, _rawValue_ is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
            1. Let _readEvent_ be ReadSharedMemory { [[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_ }.
            1. Append _readEvent_ to _eventList_.
            1. Append Chosen Value Record { [[Event]]: _readEvent_, [[ChosenValue]]: _rawValue_ } to _execution_.[[ChosenValues]].
          1. Else, let _rawValue_ be a List of _elementSize_ containing, in order, the _elementSize_ sequence of bytes starting with _block_[_byteIndex_].
          1. If _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
          1. Return RawBytesToNumber(_type_, _rawValue_, _isLittleEndian_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-numbertorawbytes" aoid="NumberToRawBytes">
        <h1>NumberToRawBytes ( _type_, _value_, _isLittleEndian_ )</h1>
        <p>The abstract operation NumberToRawBytes takes three parameters, a String _type_, a Number _value_, and a Boolean _isLittleEndian_. This operation performs the following steps:</p>
        <emu-alg>
          1. If _type_ is `"Float32"`, then
            1. Let _rawBytes_ be a List containing the 4 bytes that are the result of converting _value_ to IEEE 754-2008 binary32 format using roundTiesToEven mode. If _isLittleEndian_ is *false*, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If _value_ is *NaN*, _rawBytes_ may be set to any implementation chosen IEEE 754-2008 binary32 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.
          1. Else if _type_ is `"Float64"`, then
            1. Let _rawBytes_ be a List containing the 8 bytes that are the IEEE 754-2008 binary64 format encoding of _value_. If _isLittleEndian_ is *false*, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If _value_ is *NaN*, _rawBytes_ may be set to any implementation chosen IEEE 754-2008 binary64 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.
          1. Else,
            1. Let _n_ be the Number value of the Element Size specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
            1. Let _convOp_ be the abstract operation named in the Conversion Operation column in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
            1. Let _intValue_ be _convOp_(_value_).
            1. If _intValue_ &ge; 0, then
              1. Let _rawBytes_ be a List containing the _n_-byte binary encoding of _intValue_. If _isLittleEndian_ is *false*, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.
            1. Else,
              1. Let _rawBytes_ be a List containing the _n_-byte binary 2's complement encoding of _intValue_. If _isLittleEndian_ is *false*, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.
          1. Return _rawBytes_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setvalueinbuffer" aoid="SetValueInBuffer">
        <h1>SetValueInBuffer ( _arrayBuffer_, _byteIndex_, _type_, _value_, _isTypedArray_, _order_ [ , _isLittleEndian_ ] )</h1>
        <p>The abstract operation SetValueInBuffer takes seven parameters, an ArrayBuffer or SharedArrayBuffer _arrayBuffer_, an integer _byteIndex_, a String _type_, a Number _value_, a Boolean _isTypedArray_, a String _order_, and optionally a Boolean _isLittleEndian_. This operation performs the following steps:</p>
        <emu-alg>
          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.
          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.
          1. Assert: _byteIndex_ is an integer value &ge; 0.
          1. Assert: Type(_value_) is Number.
          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].
          1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
          1. If _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
          1. Let _rawBytes_ be NumberToRawBytes(_type_, _value_, _isLittleEndian_).
          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then
            1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
            1. Let _eventList_ be the [[EventList]] field of the element in _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
            1. If _isTypedArray_ is *true* and _type_ is `"Int8"`, `"Uint8"`, `"Int16"`, `"Uint16"`, `"Int32"`, or `"Uint32"`, let _noTear_ be *true*; otherwise let _noTear_ be *false*.
            1. Append WriteSharedMemory { [[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_ } to _eventList_.
          1. Else, store the individual bytes of _rawBytes_ into _block_, in order, starting at _block_[_byteIndex_].
          1. Return NormalCompletion(*undefined*).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getmodifysetvalueinbuffer" aoid="GetModifySetValueInBuffer">
        <h1>GetModifySetValueInBuffer ( _arrayBuffer_, _byteIndex_, _type_, _value_, _op_ [ , _isLittleEndian_ ] )</h1>
        <p>The abstract operation GetModifySetValueInBuffer takes six parameters, a SharedArrayBuffer _arrayBuffer_, a nonnegative integer _byteIndex_, a String _type_, a Number _value_, a semantic function _op_, and optionally a Boolean _isLittleEndian_. This operation performs the following steps:</p>
        <emu-alg>
          1. Assert: IsSharedArrayBuffer(_arrayBuffer_) is *true*.
          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.
          1. Assert: _byteIndex_ is an integer value &ge; 0.
          1. Assert: Type(_value_) is Number.
          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].
          1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
          1. If _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
          1. Let _rawBytes_ be NumberToRawBytes(_type_, _value_, _isLittleEndian_).
          1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
          1. Let _eventList_ be the [[EventList]] field of the element in _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
          1. Let _rawBytesRead_ be a List of length _elementSize_ of nondeterministically chosen byte values.
          1. NOTE: In implementations, _rawBytesRead_ is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
          1. Let _rmwEvent_ be ReadModifyWriteSharedMemory { [[Order]]: `"SeqCst"`, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_, [[ModifyOp]]: _op_ }.
          1. Append _rmwEvent_ to _eventList_.
          1. Append Chosen Value Record { [[Event]]: _rmwEvent_, [[ChosenValue]]: _rawBytesRead_ } to _execution_.[[ChosenValues]].
          1. Return RawBytesToNumber(_type_, _rawBytesRead_, _isLittleEndian_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-arraybuffer-constructor">
      <h1>The ArrayBuffer Constructor</h1>
      <p>The ArrayBuffer constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%ArrayBuffer%</dfn>.</li>
        <li>is the initial value of the `ArrayBuffer` property of the global object.</li>
        <li>creates and initializes a new ArrayBuffer object when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `ArrayBuffer` behaviour must include a `super` call to the `ArrayBuffer` constructor to create and initialize subclass instances with the internal state necessary to support the `ArrayBuffer.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-arraybuffer-length">
        <h1>ArrayBuffer ( _length_ )</h1>
        <p>When the `ArrayBuffer` function is called with argument _length_, the following steps are taken:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _byteLength_ be ? ToIndex(_length_).
          1. Return ? AllocateArrayBuffer(NewTarget, _byteLength_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-arraybuffer-constructor">
      <h1>Properties of the ArrayBuffer Constructor</h1>
      <p>The ArrayBuffer constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-arraybuffer.isview">
        <h1>ArrayBuffer.isView ( _arg_ )</h1>
        <p>The `isView` function takes one argument _arg_, and performs the following steps:</p>
        <emu-alg>
          1. If Type(_arg_) is not Object, return *false*.
          1. If _arg_ has a [[ViewedArrayBuffer]] internal slot, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype">
        <h1>ArrayBuffer.prototype</h1>
        <p>The initial value of `ArrayBuffer.prototype` is the intrinsic object %ArrayBufferPrototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-get-arraybuffer-@@species">
        <h1>get ArrayBuffer [ @@species ]</h1>
        <p>`ArrayBuffer[@@species]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the `name` property of this function is `"get [Symbol.species]"`.</p>
        <emu-note>
          <p>ArrayBuffer prototype methods normally use their `this` object's constructor to create a derived object. However, a subclass constructor may over-ride that default behaviour by redefining its @@species property.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-arraybuffer-prototype-object">
      <h1>Properties of the ArrayBuffer Prototype Object</h1>
      <p>The ArrayBuffer prototype object:</p>
      <ul>
        <li>is the intrinsic object <dfn>%ArrayBufferPrototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have an [[ArrayBufferData]] or [[ArrayBufferByteLength]] internal slot.</li>
      </ul>

      <emu-clause id="sec-get-arraybuffer.prototype.bytelength">
        <h1>get ArrayBuffer.prototype.byteLength</h1>
        <p>`ArrayBuffer.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
          1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.
          1. Let _length_ be _O_.[[ArrayBufferByteLength]].
          1. Return _length_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.constructor">
        <h1>ArrayBuffer.prototype.constructor</h1>
        <p>The initial value of `ArrayBuffer.prototype.constructor` is the intrinsic object %ArrayBuffer%.</p>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.slice">
        <h1>ArrayBuffer.prototype.slice ( _start_, _end_ )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
          1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.
          1. Let _len_ be _O_.[[ArrayBufferByteLength]].
          1. Let _relativeStart_ be ? ToInteger(_start_).
          1. If _relativeStart_ &lt; 0, let _first_ be max((_len_ + _relativeStart_), 0); else let _first_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToInteger(_end_).
          1. If _relativeEnd_ &lt; 0, let _final_ be max((_len_ + _relativeEnd_), 0); else let _final_ be min(_relativeEnd_, _len_).
          1. Let _newLen_ be max(_final_ - _first_, 0).
          1. Let _ctor_ be ? SpeciesConstructor(_O_, %ArrayBuffer%).
          1. Let _new_ be ? Construct(_ctor_, &laquo; _newLen_ &raquo;).
          1. Perform ? RequireInternalSlot(_new_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_new_) is *true*, throw a *TypeError* exception.
          1. If IsDetachedBuffer(_new_) is *true*, throw a *TypeError* exception.
          1. If SameValue(_new_, _O_) is *true*, throw a *TypeError* exception.
          1. If _new_.[[ArrayBufferByteLength]] &lt; _newLen_, throw a *TypeError* exception.
          1. NOTE: Side-effects of the above steps may have detached _O_.
          1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.
          1. Let _fromBuf_ be _O_.[[ArrayBufferData]].
          1. Let _toBuf_ be _new_.[[ArrayBufferData]].
          1. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _newLen_).
          1. Return _new_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype-@@tostringtag">
        <h1>ArrayBuffer.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value `"ArrayBuffer"`.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-arraybuffer-instances">
      <h1>Properties of ArrayBuffer Instances</h1>
      <p>ArrayBuffer instances inherit properties from the ArrayBuffer prototype object. ArrayBuffer instances each have an [[ArrayBufferData]] internal slot, an [[ArrayBufferByteLength]] internal slot, and an [[ArrayBufferDetachKey]] internal slot.</p>
      <p>ArrayBuffer instances whose [[ArrayBufferData]] is *null* are considered to be detached and all operators to access or modify data contained in the ArrayBuffer instance will fail.</p>
      <p>ArrayBuffer instances whose [[ArrayBufferDetachKey]] is set to a value other than *undefined* need to have all DetachArrayBuffer calls passing that same "detach key" as an argument, otherwise a TypeError will result. This internal slot is only ever set by certain embedding environments, not by algorithms in this specification.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-sharedarraybuffer-objects">
    <h1>SharedArrayBuffer Objects</h1>

    <emu-clause id="sec-abstract-operations-for-sharedarraybuffer-objects">
      <h1>Abstract Operations for SharedArrayBuffer Objects</h1>

      <emu-clause id="sec-allocatesharedarraybuffer" aoid="AllocateSharedArrayBuffer">
        <h1>AllocateSharedArrayBuffer ( _constructor_, _byteLength_ )</h1>
        <p>The abstract operation AllocateSharedArrayBuffer with arguments _constructor_ and _byteLength_ is used to create a SharedArrayBuffer object. It performs the following steps:</p>
        <emu-alg>
          1. Let _obj_ be ? OrdinaryCreateFromConstructor(_constructor_, `"%SharedArrayBufferPrototype%"`, &laquo; [[ArrayBufferData]], [[ArrayBufferByteLength]] &raquo;).
          1. Assert: _byteLength_ is a nonnegative integer.
          1. Let _block_ be ? CreateSharedByteDataBlock(_byteLength_).
          1. Set _obj_.[[ArrayBufferData]] to _block_.
          1. Set _obj_.[[ArrayBufferByteLength]] to _byteLength_.
          1. Return _obj_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-issharedarraybuffer" aoid="IsSharedArrayBuffer">
        <h1>IsSharedArrayBuffer ( _obj_ )</h1>
        <p>IsSharedArrayBuffer tests whether an object is an ArrayBuffer, a SharedArrayBuffer, or a subtype of either. It performs the following steps:</p>
        <emu-alg>
          1. Assert: Type(_obj_) is Object and it has an [[ArrayBufferData]] internal slot.
          1. Let _bufferData_ be _obj_.[[ArrayBufferData]].
          1. If _bufferData_ is *null*, return *false*.
          1. If _bufferData_ is a Data Block, return *false*.
          1. Assert: _bufferData_ is a Shared Data Block.
          1. Return *true*.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-sharedarraybuffer-constructor">
      <h1>The SharedArrayBuffer Constructor</h1>
      <p>The SharedArrayBuffer constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%SharedArrayBuffer%</dfn>.</li>
        <li>is the initial value of the `SharedArrayBuffer` property of the global object.</li>
        <li>creates and initializes a new SharedArrayBuffer object when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `SharedArrayBuffer` behaviour must include a `super` call to the `SharedArrayBuffer` constructor to create and initialize subclass instances with the internal state necessary to support the `SharedArrayBuffer.prototype` built-in methods.</li>
      </ul>

      <emu-note>
        <p>Unlike an `ArrayBuffer`, a `SharedArrayBuffer` cannot become detached, and its internal [[ArrayBufferData]] slot is never *null*.</p>
      </emu-note>

      <emu-clause id="sec-sharedarraybuffer-length">
        <h1>SharedArrayBuffer ( [ _length_ ] )</h1>
        <p>When the `SharedArrayBuffer` function is called with optional argument _length_, the following steps are taken:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _byteLength_ be ? ToIndex(_length_).
          1. Return ? AllocateSharedArrayBuffer(NewTarget, _byteLength_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-sharedarraybuffer-constructor">
      <h1>Properties of the SharedArrayBuffer Constructor</h1>
      <p>The SharedArrayBuffer constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-sharedarraybuffer.prototype">
        <h1>SharedArrayBuffer.prototype</h1>
        <p>The initial value of `SharedArrayBuffer.prototype` is the intrinsic object %SharedArrayBufferPrototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-sharedarraybuffer-@@species">
        <h1>get SharedArrayBuffer [ @@species ]</h1>
        <p>`SharedArrayBuffer[@@species]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the `name` property of this function is `"get [Symbol.species]"`.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-sharedarraybuffer-prototype-object">
      <h1>Properties of the SharedArrayBuffer Prototype Object</h1>
      <p>The SharedArrayBuffer prototype object:</p>
      <ul>
        <li>is the intrinsic object <dfn>%SharedArrayBufferPrototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have an [[ArrayBufferData]] or [[ArrayBufferByteLength]] internal slot.</li>
      </ul>

      <emu-clause id="sec-get-sharedarraybuffer.prototype.bytelength">
        <h1>get SharedArrayBuffer.prototype.byteLength</h1>
        <p>`SharedArrayBuffer.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
          1. Let _length_ be _O_.[[ArrayBufferByteLength]].
          1. Return _length_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-sharedarraybuffer.prototype.constructor">
        <h1>SharedArrayBuffer.prototype.constructor</h1>
        <p>The initial value of `SharedArrayBuffer.prototype.constructor` is the intrinsic object %SharedArrayBuffer%.</p>
      </emu-clause>

      <emu-clause id="sec-sharedarraybuffer.prototype.slice">
        <h1>SharedArrayBuffer.prototype.slice ( _start_, _end_ )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
          1. Let _len_ be _O_.[[ArrayBufferByteLength]].
          1. Let _relativeStart_ be ? ToInteger(_start_).
          1. If _relativeStart_ &lt; 0, let _first_ be max((_len_ + _relativeStart_), 0); else let _first_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToInteger(_end_).
          1. If _relativeEnd_ &lt; 0, let _final_ be max((_len_ + _relativeEnd_), 0); else let _final_ be min(_relativeEnd_, _len_).
          1. Let _newLen_ be max(_final_ - _first_, 0).
          1. Let _ctor_ be ? SpeciesConstructor(_O_, %SharedArrayBuffer%).
          1. Let _new_ be ? Construct(_ctor_, &laquo; _newLen_ &raquo;).
          1. Perform ? RequireInternalSlot(_new_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_new_) is *false*, throw a *TypeError* exception.
          1. If _new_.[[ArrayBufferData]] and _O_.[[ArrayBufferData]] are the same Shared Data Block values, throw a *TypeError* exception.
          1. If _new_.[[ArrayBufferByteLength]] &lt; _newLen_, throw a *TypeError* exception.
          1. Let _fromBuf_ be _O_.[[ArrayBufferData]].
          1. Let _toBuf_ be _new_.[[ArrayBufferData]].
          1. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _newLen_).
          1. Return _new_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-sharedarraybuffer.prototype.toString">
        <h1>SharedArrayBuffer.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value `"SharedArrayBuffer"`.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-sharedarraybuffer-instances">
      <h1>Properties of SharedArrayBuffer Instances</h1>
      <p>SharedArrayBuffer instances inherit properties from the SharedArrayBuffer prototype object. SharedArrayBuffer instances each have an [[ArrayBufferData]] internal slot and an [[ArrayBufferByteLength]] internal slot.</p>

      <emu-note>
        <p>SharedArrayBuffer instances, unlike ArrayBuffer instances, are never detached.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-dataview-objects">
    <h1>DataView Objects</h1>

    <emu-clause id="sec-abstract-operations-for-dataview-objects">
      <h1>Abstract Operations For DataView Objects</h1>

      <emu-clause id="sec-getviewvalue" aoid="GetViewValue">
        <h1>GetViewValue ( _view_, _requestIndex_, _isLittleEndian_, _type_ )</h1>
        <p>The abstract operation GetViewValue with arguments _view_, _requestIndex_, _isLittleEndian_, and _type_ is used by functions on DataView instances to retrieve values from the view's buffer. It performs the following steps:</p>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_view_, [[DataView]]).
          1. Assert: _view_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _getIndex_ be ? ToIndex(_requestIndex_).
          1. Set _isLittleEndian_ to ToBoolean(_isLittleEndian_).
          1. Let _buffer_ be _view_.[[ViewedArrayBuffer]].
          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
          1. Let _viewOffset_ be _view_.[[ByteOffset]].
          1. Let _viewSize_ be _view_.[[ByteLength]].
          1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
          1. If _getIndex_ + _elementSize_ &gt; _viewSize_, throw a *RangeError* exception.
          1. Let _bufferIndex_ be _getIndex_ + _viewOffset_.
          1. Return GetValueFromBuffer(_buffer_, _bufferIndex_, _type_, *false*, `"Unordered"`, _isLittleEndian_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setviewvalue" aoid="SetViewValue">
        <h1>SetViewValue ( _view_, _requestIndex_, _isLittleEndian_, _type_, _value_ )</h1>
        <p>The abstract operation SetViewValue with arguments _view_, _requestIndex_, _isLittleEndian_, _type_, and _value_ is used by functions on DataView instances to store values into the view's buffer. It performs the following steps:</p>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_view_, [[DataView]]).
          1. Assert: _view_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _getIndex_ be ? ToIndex(_requestIndex_).
          1. Let _numberValue_ be ? ToNumber(_value_).
          1. Set _isLittleEndian_ to ToBoolean(_isLittleEndian_).
          1. Let _buffer_ be _view_.[[ViewedArrayBuffer]].
          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
          1. Let _viewOffset_ be _view_.[[ByteOffset]].
          1. Let _viewSize_ be _view_.[[ByteLength]].
          1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
          1. If _getIndex_ + _elementSize_ &gt; _viewSize_, throw a *RangeError* exception.
          1. Let _bufferIndex_ be _getIndex_ + _viewOffset_.
          1. Return SetValueInBuffer(_buffer_, _bufferIndex_, _type_, _numberValue_, *false*, `"Unordered"`, _isLittleEndian_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-dataview-constructor">
      <h1>The DataView Constructor</h1>
      <p>The DataView constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%DataView%</dfn>.</li>
        <li>is the initial value of the `DataView` property of the global object.</li>
        <li>creates and initializes a new DataView object when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `DataView` behaviour must include a `super` call to the `DataView` constructor to create and initialize subclass instances with the internal state necessary to support the `DataView.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-dataview-buffer-byteoffset-bytelength">
        <h1>DataView ( _buffer_ [ , _byteOffset_ [ , _byteLength_ ] ] )</h1>
        <p>When the `DataView` function is called with at least one argument _buffer_, the following steps are taken:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Perform ? RequireInternalSlot(_buffer_, [[ArrayBufferData]]).
          1. Let _offset_ be ? ToIndex(_byteOffset_).
          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
          1. Let _bufferByteLength_ be _buffer_.[[ArrayBufferByteLength]].
          1. If _offset_ &gt; _bufferByteLength_, throw a *RangeError* exception.
          1. If _byteLength_ is either not present or *undefined*, then
            1. Let _viewByteLength_ be _bufferByteLength_ - _offset_.
          1. Else,
            1. Let _viewByteLength_ be ? ToIndex(_byteLength_).
            1. If _offset_ + _viewByteLength_ &gt; _bufferByteLength_, throw a *RangeError* exception.
          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, `"%DataViewPrototype%"`, &laquo; [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] &raquo;).
          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
          1. Set _O_.[[ViewedArrayBuffer]] to _buffer_.
          1. Set _O_.[[ByteLength]] to _viewByteLength_.
          1. Set _O_.[[ByteOffset]] to _offset_.
          1. Return _O_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-dataview-constructor">
      <h1>Properties of the DataView Constructor</h1>
      <p>The DataView constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-dataview.prototype">
        <h1>DataView.prototype</h1>
        <p>The initial value of `DataView.prototype` is the intrinsic object %DataViewPrototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-dataview-prototype-object">
      <h1>Properties of the DataView Prototype Object</h1>
      <p>The DataView prototype object:</p>
      <ul>
        <li>is the intrinsic object <dfn>%DataViewPrototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], or [[ByteOffset]] internal slot.</li>
      </ul>

      <emu-clause id="sec-get-dataview.prototype.buffer">
        <h1>get DataView.prototype.buffer</h1>
        <p>`DataView.prototype.buffer` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[DataView]]).
          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
          1. Return _buffer_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-dataview.prototype.bytelength">
        <h1>get DataView.prototype.byteLength</h1>
        <p>`DataView.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[DataView]]).
          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
          1. Let _size_ be _O_.[[ByteLength]].
          1. Return _size_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-dataview.prototype.byteoffset">
        <h1>get DataView.prototype.byteOffset</h1>
        <p>`DataView.prototype.byteOffset` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[DataView]]).
          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
          1. Let _offset_ be _O_.[[ByteOffset]].
          1. Return _offset_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.constructor">
        <h1>DataView.prototype.constructor</h1>
        <p>The initial value of `DataView.prototype.constructor` is the intrinsic object %DataView%.</p>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getfloat32">
        <h1>DataView.prototype.getFloat32 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>When the `getFloat32` method is called with argument _byteOffset_ and optional argument _littleEndian_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, `"Float32"`).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getfloat64">
        <h1>DataView.prototype.getFloat64 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>When the `getFloat64` method is called with argument _byteOffset_ and optional argument _littleEndian_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, `"Float64"`).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getint8">
        <h1>DataView.prototype.getInt8 ( _byteOffset_ )</h1>
        <p>When the `getInt8` method is called with argument _byteOffset_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. Return ? GetViewValue(_v_, _byteOffset_, *true*, `"Int8"`).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getint16">
        <h1>DataView.prototype.getInt16 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>When the `getInt16` method is called with argument _byteOffset_ and optional argument _littleEndian_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, `"Int16"`).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getint32">
        <h1>DataView.prototype.getInt32 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>When the `getInt32` method is called with argument _byteOffset_ and optional argument _littleEndian_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, `"Int32"`).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getuint8">
        <h1>DataView.prototype.getUint8 ( _byteOffset_ )</h1>
        <p>When the `getUint8` method is called with argument _byteOffset_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. Return ? GetViewValue(_v_, _byteOffset_, *true*, `"Uint8"`).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getuint16">
        <h1>DataView.prototype.getUint16 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>When the `getUint16` method is called with argument _byteOffset_ and optional argument _littleEndian_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, `"Uint16"`).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getuint32">
        <h1>DataView.prototype.getUint32 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>When the `getUint32` method is called with argument _byteOffset_ and optional argument _littleEndian_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, `"Uint32"`).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setfloat32">
        <h1>DataView.prototype.setFloat32 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>When the `setFloat32` method is called with arguments _byteOffset_ and _value_ and optional argument _littleEndian_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, `"Float32"`, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setfloat64">
        <h1>DataView.prototype.setFloat64 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>When the `setFloat64` method is called with arguments _byteOffset_ and _value_ and optional argument _littleEndian_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, `"Float64"`, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setint8">
        <h1>DataView.prototype.setInt8 ( _byteOffset_, _value_ )</h1>
        <p>When the `setInt8` method is called with arguments _byteOffset_ and _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. Return ? SetViewValue(_v_, _byteOffset_, *true*, `"Int8"`, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setint16">
        <h1>DataView.prototype.setInt16 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>When the `setInt16` method is called with arguments _byteOffset_ and _value_ and optional argument _littleEndian_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, `"Int16"`, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setint32">
        <h1>DataView.prototype.setInt32 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>When the `setInt32` method is called with arguments _byteOffset_ and _value_ and optional argument _littleEndian_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, `"Int32"`, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setuint8">
        <h1>DataView.prototype.setUint8 ( _byteOffset_, _value_ )</h1>
        <p>When the `setUint8` method is called with arguments _byteOffset_ and _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. Return ? SetViewValue(_v_, _byteOffset_, *true*, `"Uint8"`, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setuint16">
        <h1>DataView.prototype.setUint16 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>When the `setUint16` method is called with arguments _byteOffset_ and _value_ and optional argument _littleEndian_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, `"Uint16"`, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setuint32">
        <h1>DataView.prototype.setUint32 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>When the `setUint32` method is called with arguments _byteOffset_ and _value_ and optional argument _littleEndian_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, `"Uint32"`, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype-@@tostringtag">
        <h1>DataView.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value `"DataView"`.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-dataview-instances">
      <h1>Properties of DataView Instances</h1>
      <p>DataView instances are ordinary objects that inherit properties from the DataView prototype object. DataView instances each have [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], and [[ByteOffset]] internal slots.</p>
      <emu-note>
        <p>The value of the [[DataView]] internal slot is not used within this specification. The simple presence of that internal slot is used within the specification to identify objects created using the `DataView` constructor.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-atomics-object">
    <h1>The Atomics Object</h1>
    <p>The Atomics object:</p>
    <ul>
      <li>is the intrinsic object <dfn>%Atomics%</dfn>.</li>
      <li>is the initial value of the `Atomics` property of the global object.</li>
      <li>is an ordinary object.</li>
      <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
      <li>does not have a [[Construct]] internal method; it cannot be used as a constructor with the `new` operator.</li>
      <li>does not have a [[Call]] internal method; it cannot be invoked as a function.</li>
    </ul>
    <p>The Atomics object provides functions that operate indivisibly (atomically) on shared memory array cells as well as functions that let agents wait for and dispatch primitive events.  When used with discipline, the Atomics functions allow multi-agent programs that communicate through shared memory to execute in a well-understood order even on parallel CPUs. The rules that govern shared-memory communication are provided by the memory model, defined below.</p>
    <emu-note>
      <p>For informative guidelines for programming and implementing shared memory in ECMAScript, please see the notes at the end of the memory model section.</p>
    </emu-note>

    <emu-clause id="sec-abstract-operations-for-atomics">
      <h1>Abstract Operations for Atomics</h1>

      <emu-clause id="sec-validatesharedintegertypedarray" aoid="ValidateSharedIntegerTypedArray">
        <h1>ValidateSharedIntegerTypedArray ( _typedArray_ [ , _onlyInt32_ ] )</h1>
        <p>The abstract operation ValidateSharedIntegerTypedArray takes one argument _typedArray_ and an optional Boolean _onlyInt32_. It performs the following steps:</p>
        <emu-alg>
          1. If _onlyInt32_ is not present, set _onlyInt32_ to *false*.
          1. Perform ? RequireInternalSlot(_typedArray_, [[TypedArrayName]]).
          1. Let _typeName_ be _typedArray_.[[TypedArrayName]].
          1. If _onlyInt32_ is *true*, then
            1. If _typeName_ is not `"Int32Array"`, throw a *TypeError* exception.
          1. Else,
            1. If _typeName_ is not `"Int8Array"`, `"Uint8Array"`, `"Int16Array"`, `"Uint16Array"`, `"Int32Array"`, or `"Uint32Array"`, throw a *TypeError* exception.
          1. Assert: _typedArray_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].
          1. If IsSharedArrayBuffer(_buffer_) is *false*, throw a *TypeError* exception.
          1. Return _buffer_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-validateatomicaccess" aoid="ValidateAtomicAccess">
        <h1>ValidateAtomicAccess ( _typedArray_, _requestIndex_ )</h1>
        <p>The abstract operation ValidateAtomicAccess takes two arguments, _typedArray_ and _requestIndex_. It performs the following steps:</p>
        <emu-alg>
          1. Assert: _typedArray_ is an Object that has a [[ViewedArrayBuffer]] internal slot.
          1. Let _accessIndex_ be ? ToIndex(_requestIndex_).
          1. Let _length_ be _typedArray_.[[ArrayLength]].
          1. Assert: _accessIndex_ &ge; 0.
          1. If _accessIndex_ &ge; _length_, throw a *RangeError* exception.
          1. Return _accessIndex_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getwaiterlist" aoid="GetWaiterList">
        <h1>GetWaiterList ( _block_, _i_ )</h1>
        <p>A <dfn>WaiterList</dfn> is a semantic object that contains an ordered list of those agents that are waiting on a location (_block_, _i_) in shared memory; _block_ is a Shared Data Block and _i_ a byte offset into the memory of _block_.</p>
        <p>The agent cluster has a store of WaiterList objects; the store is indexed by (_block_, _i_). WaiterLists are agent-independent: a lookup in the store of WaiterLists by (_block_, _i_) will result in the same WaiterList object in any agent in the agent cluster.</p>
        <p>Operations on a WaiterList -- adding and removing waiting agents, traversing the list of agents, suspending and notifying agents on the list -- may only be performed by agents that have entered the WaiterList's critical section.</p>
        <p>The abstract operation GetWaiterList takes two arguments, a Shared Data Block _block_ and a nonnegative integer _i_. It performs the following steps:</p>
        <emu-alg>
          1. Assert: _block_ is a Shared Data Block.
          1. Assert: _i_ and _i_ + 3 are valid byte offsets within the memory of _block_.
          1. Assert: _i_ is divisible by 4.
          1. Return the WaiterList that is referenced by the pair (_block_, _i_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-entercriticalsection" aoid="EnterCriticalSection">
        <h1>EnterCriticalSection ( _WL_ )</h1>
        <p>The abstract operation EnterCriticalSection takes one argument, a WaiterList _WL_. It performs the following steps:</p>
        <emu-alg>
          1. Assert: The calling agent is not in the critical section for any WaiterList.
          1. Wait until no agent is in the critical section for _WL_, then enter the critical section for _WL_ (without allowing any other agent to enter).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-leavecriticalsection" aoid="LeaveCriticalSection">
        <h1>LeaveCriticalSection ( _WL_ )</h1>
        <p>The abstract operation LeaveCriticalSection takes one argument, a WaiterList _WL_. It performs the following steps:</p>
        <emu-alg>
          1. Assert: The calling agent is in the critical section for _WL_.
          1. Leave the critical section for _WL_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-addwaiter" aoid="AddWaiter">
        <h1>AddWaiter ( _WL_, _W_ )</h1>
        <p>The abstract operation AddWaiter takes two arguments, a WaiterList _WL_ and an agent signifier _W_. It performs the following steps:</p>
        <emu-alg>
          1. Assert: The calling agent is in the critical section for _WL_.
          1. Assert: _W_ is not on the list of waiters in any WaiterList.
          1. Add _W_ to the end of the list of waiters in _WL_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-removewaiter" aoid="RemoveWaiter">
        <h1>RemoveWaiter ( _WL_, _W_ )</h1>
        <p>The abstract operation RemoveWaiter takes two arguments, a WaiterList _WL_ and an agent signifier _W_. It performs the following steps:</p>
        <emu-alg>
          1. Assert: The calling agent is in the critical section for _WL_.
          1. Assert: _W_ is on the list of waiters in _WL_.
          1. Remove _W_ from the list of waiters in _WL_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-removewaiters" aoid="RemoveWaiters">
        <h1>RemoveWaiters ( _WL_, _c_ )</h1>
        <p>The abstract operation RemoveWaiters takes two arguments, a WaiterList _WL_ and nonnegative integer _c_. It performs the following steps:</p>
        <emu-alg>
          1. Assert: The calling agent is in the critical section for _WL_.
          1. Let _L_ be a new empty List.
          1. Let _S_ be a reference to the list of waiters in _WL_.
          1. Repeat, while _c_ &gt; 0 and _S_ is not an empty List,
            1. Let _W_ be the first waiter in _S_.
            1. Add _W_ to the end of _L_.
            1. Remove _W_ from _S_.
            1. Subtract 1 from _c_.
          1. Return _L_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-suspend" aoid="Suspend">
        <h1>Suspend ( _WL_, _W_, _timeout_ )</h1>
        <p>The abstract operation Suspend takes three arguments, a WaiterList _WL_, an agent signifier _W_, and a nonnegative, non-*NaN* Number _timeout_. It performs the following steps:</p>
        <emu-alg>
          1. Assert: The calling agent is in the critical section for _WL_.
          1. Assert: _W_ is equal to AgentSignifier().
          1. Assert: _W_ is on the list of waiters in _WL_.
          1. Assert: AgentCanSuspend() is *true*.
          1. Perform LeaveCriticalSection(_WL_) and suspend _W_ for up to _timeout_ milliseconds, performing the combined operation in such a way that a notification that arrives after the critical section is exited but before the suspension takes effect is not lost.  _W_ can notify either because the timeout expired or because it was notified explicitly by another agent calling NotifyWaiter(_WL_, _W_), and not for any other reasons at all.
          1. Perform EnterCriticalSection(_WL_).
          1. If _W_ was notified explicitly by another agent calling NotifyWaiter(_WL_, _W_), return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-notifywaiter" aoid="NotifyWaiter">
        <h1>NotifyWaiter ( _WL_, _W_ )</h1>
        <p>The abstract operation NotifyWaiter takes two arguments, a WaiterList _WL_ and an agent signifier _W_. It performs the following steps:</p>
        <emu-alg>
          1. Assert: The calling agent is in the critical section for _WL_.
          1. Assert: _W_ is on the list of waiters in _WL_.
          1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
          1. Let _eventsRecord_ be the Agent Events Record in _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
          1. Let _agentSynchronizesWith_ be _eventsRecord_.[[AgentSynchronizesWith]].
          1. Let _notifierEventList_ be _eventsRecord_.[[EventList]].
          1. Let _waiterEventList_ be the [[EventList]] field of the element in _execution_.[[EventsRecords]] whose [[AgentSignifier]] is _W_.
          1. Let _notifyEvent_ and _waitEvent_ be new Synchronize events.
          1. Append _notifyEvent_ to _notifierEventList_.
          1. Append _waitEvent_ to _waiterEventList_.
          1. Append (_notifyEvent_, _waitEvent_) to _agentSynchronizesWith_.
          1. Notify the agent _W_.
        </emu-alg>
        <emu-note>
          <p>The embedding may delay notifying _W_, e.g. for resource management reasons, but _W_ must eventually be notified in order to guarantee forward progress.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-atomicreadmodifywrite" aoid="AtomicReadModifyWrite">
        <h1>AtomicReadModifyWrite ( _typedArray_, _index_, _value_, _op_ )</h1>
        <p>The abstract operation AtomicReadModifyWrite takes four arguments, _typedArray_, _index_, _value_, and a pure combining operation _op_. The pure combining operation _op_ takes two List of byte values arguments and returns a List of byte values. The operation atomically loads a value, combines it with another value, and stores the result of the combination. It returns the loaded value. It performs the following steps:</p>
        <emu-alg>
          1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_).
          1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
          1. Let _v_ be ? ToInteger(_value_).
          1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
          1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.
          1. Let _elementType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.
          1. Let _offset_ be _typedArray_.[[ByteOffset]].
          1. Let _indexedPosition_ be (_i_ &times; _elementSize_) + _offset_.
          1. Return GetModifySetValueInBuffer(_buffer_, _indexedPosition_, _elementType_, _v_, _op_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-atomicload" aoid="AtomicLoad">
        <h1>AtomicLoad ( _typedArray_, _index_ )</h1>
        <p>The abstract operation AtomicLoad takes two arguments, _typedArray_, _index_. The operation atomically loads a value and returns the loaded value. It performs the following steps:</p>
        <emu-alg>
          1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_).
          1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
          1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
          1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.
          1. Let _elementType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.
          1. Let _offset_ be _typedArray_.[[ByteOffset]].
          1. Let _indexedPosition_ be (_i_ &times; _elementSize_) + _offset_.
          1. Return GetValueFromBuffer(_buffer_, _indexedPosition_, _elementType_, *true*, `"SeqCst"`).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-atomics.add">
      <h1>Atomics.add ( _typedArray_, _index_, _value_ )</h1>
      <p>Let `add` denote a semantic function of two List of byte values arguments that applies the addition operation to the Number values corresponding to the List of byte values arguments and returns a List of byte values corresponding to the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, `add`).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.and">
      <h1>Atomics.and ( _typedArray_, _index_, _value_ )</h1>
      <p>Let `and` denote a semantic function of two List of byte values arguments that applies the bitwise-and operation element-wise to the two arguments and returns a List of byte values corresponding to the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, `and`).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.compareexchange">
      <h1>Atomics.compareExchange ( _typedArray_, _index_, _expectedValue_, _replacementValue_ )</h1>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_).
        1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
        1. Let _expected_ be ? ToInteger(_expectedValue_).
        1. Let _replacement_ be ? ToInteger(_replacementValue_).
        1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
        1. Let _elementType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.
        1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
        1. Let _expectedBytes_ be NumberToRawBytes(_elementType_, _expected_, _isLittleEndian_).
        1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.
        1. Let _offset_ be _typedArray_.[[ByteOffset]].
        1. Let _indexedPosition_ be (_i_ &times; _elementSize_) + _offset_.
        1. Let `compareExchange` denote a semantic function of two List of byte values arguments that returns the second argument if the first argument is element-wise equal to _expectedBytes_.
        1. Return GetModifySetValueInBuffer(_buffer_, _indexedPosition_, _elementType_, _replacement_, `compareExchange`).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.exchange">
      <h1>Atomics.exchange ( _typedArray_, _index_, _value_ )</h1>
      <p>Let `second` denote a semantic function of two List of byte values arguments that returns its second argument.</p>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, `second`).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.islockfree">
      <h1>Atomics.isLockFree ( _size_ )</h1>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Let _n_ be ? ToInteger(_size_).
        1. Let _AR_ be the Agent Record of the surrounding agent.
        1. If _n_ equals 1, return _AR_.[[IsLockFree1]].
        1. If _n_ equals 2, return _AR_.[[IsLockFree2]].
        1. If _n_ equals 4, return *true*.
        1. Return *false*.
      </emu-alg>
      <emu-note>
        <p>`Atomics.isLockFree`() is an optimization primitive. The intuition is that if the atomic step of an atomic primitive (`compareExchange`, `load`, `store`, `add`, `sub`, `and`, `or`, `xor`, or `exchange`) on a datum of size _n_ bytes will be performed without the calling agent acquiring a lock outside the _n_ bytes comprising the datum, then `Atomics.isLockFree`(_n_) will return *true*. High-performance algorithms will use Atomics.isLockFree to determine whether to use locks or atomic operations in critical sections. If an atomic primitive is not lock-free then it is often more efficient for an algorithm to provide its own locking.</p>
        <p>`Atomics.isLockFree`(4) always returns *true* as that can be supported on all known relevant hardware. Being able to assume this will generally simplify programs.</p>
      </emu-note>
    </emu-clause>
    <emu-clause id="sec-atomics.load">
      <h1>Atomics.load ( _typedArray_, _index_ )</h1>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Return ? AtomicLoad(_typedArray_, _index_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.or">
      <h1>Atomics.or ( _typedArray_, _index_, _value_ )</h1>
      <p>Let `or` denote a semantic function of two List of byte values arguments that applies the bitwise-or operation element-wise to the two arguments and returns a List of byte values corresponding to the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, `or`).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.store">
      <h1>Atomics.store ( _typedArray_, _index_, _value_ )</h1>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_).
        1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
        1. Let _v_ be ? ToInteger(_value_).
        1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
        1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.
        1. Let _elementType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.
        1. Let _offset_ be _typedArray_.[[ByteOffset]].
        1. Let _indexedPosition_ be (_i_ &times; _elementSize_) + _offset_.
        1. Perform SetValueInBuffer(_buffer_, _indexedPosition_, _elementType_, _v_, *true*, `"SeqCst"`).
        1. Return _v_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.sub">
      <h1>Atomics.sub ( _typedArray_, _index_, _value_ )</h1>
      <p>Let `subtract` denote a semantic function of two List of byte values arguments that applies the subtraction operation to the Number values corresponding to the List of byte values arguments and returns a List of byte values corresponding to the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, `subtract`).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.wait">
      <h1>Atomics.wait ( _typedArray_, _index_, _value_, _timeout_ )</h1>
      <p>`Atomics.wait` puts the calling agent in a wait queue and puts it to sleep until it is notified or the sleep times out. The following steps are taken:</p>
      <emu-alg>
        1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_, *true*).
        1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
        1. Let _v_ be ? ToInt32(_value_).
        1. Let _q_ be ? ToNumber(_timeout_).
        1. If _q_ is *NaN*, let _t_ be *+&infin;*, else let _t_ be max(_q_, 0).
        1. Let _B_ be AgentCanSuspend().
        1. If _B_ is *false*, throw a *TypeError* exception.
        1. Let _block_ be _buffer_.[[ArrayBufferData]].
        1. Let _offset_ be _typedArray_.[[ByteOffset]].
        1. Let _indexedPosition_ be (_i_ &times; 4) + _offset_.
        1. Let _WL_ be GetWaiterList(_block_, _indexedPosition_).
        1. Perform EnterCriticalSection(_WL_).
        1. Let _w_ be ! AtomicLoad(_typedArray_, _i_).
        1. If _v_ is not equal to _w_, then
          1. Perform LeaveCriticalSection(_WL_).
          1. Return the String `"not-equal"`.
        1. Let _W_ be AgentSignifier().
        1. Perform AddWaiter(_WL_, _W_).
        1. Let _notified_ be Suspend(_WL_, _W_, _t_).
        1. If _notified_ is *true*, then
          1. Assert: _W_ is not on the list of waiters in _WL_.
        1. Else,
          1. Perform RemoveWaiter(_WL_, _W_).
        1. Perform LeaveCriticalSection(_WL_).
        1. If _notified_ is *true*, return the String `"ok"`.
        1. Return the String `"timed-out"`.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.notify">
      <h1>Atomics.notify ( _typedArray_, _index_, _count_ )</h1>
      <p>`Atomics.notify` notifies some agents that are sleeping in the wait queue.  The following steps are taken:</p>
      <emu-alg>
        1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_, *true*).
        1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
        1. If _count_ is *undefined*, let _c_ be *+&infin;*.
        1. Else,
          1. Let _intCount_ be ? ToInteger(_count_).
          1. Let _c_ be max(_intCount_, 0).
        1. Let _block_ be _buffer_.[[ArrayBufferData]].
        1. Let _offset_ be _typedArray_.[[ByteOffset]].
        1. Let _indexedPosition_ be (_i_ &times; 4) + _offset_.
        1. Let _WL_ be GetWaiterList(_block_, _indexedPosition_).
        1. Let _n_ be 0.
        1. Perform EnterCriticalSection(_WL_).
        1. Let _S_ be RemoveWaiters(_WL_, _c_).
        1. Repeat, while _S_ is not an empty List,
          1. Let _W_ be the first agent in _S_.
          1. Remove _W_ from the front of _S_.
          1. Perform NotifyWaiter(_WL_, _W_).
          1. Add 1 to _n_.
        1. Perform LeaveCriticalSection(_WL_).
        1. Return _n_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.xor">
      <h1>Atomics.xor ( _typedArray_, _index_, _value_ )</h1>
      <p>Let `xor` denote a semantic function of two List of byte values arguments that applies the bitwise-xor operation element-wise to the two arguments and returns a List of byte values corresponding to the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, `xor`).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics-@@tostringtag">
      <h1>Atomics [ @@toStringTag ]</h1>
      <p>The initial value of the @@toStringTag property is the String value `"Atomics"`.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-json-object">
    <h1>The JSON Object</h1>
    <p>The JSON object:</p>
    <ul>
      <li>is the intrinsic object <dfn>%JSON%</dfn>.</li>
      <li>is the initial value of the `JSON` property of the global object.</li>
      <li>is an ordinary object.</li>
      <li>contains two functions, `parse` and `stringify`, that are used to parse and construct JSON texts.</li>
      <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
      <li>does not have a [[Construct]] internal method; it cannot be used as a constructor with the `new` operator.</li>
      <li>does not have a [[Call]] internal method; it cannot be invoked as a function.</li>
    </ul>
    <p>The JSON Data Interchange Format is defined in ECMA-404. The JSON interchange format used in this specification is exactly that described by ECMA-404. Conforming implementations of `JSON.parse` and `JSON.stringify` must support the exact interchange format described in the ECMA-404 specification without any deletions or extensions to the format.</p>

    <emu-clause id="sec-json.parse">
      <h1>JSON.parse ( _text_ [ , _reviver_ ] )</h1>
      <p>The `parse` function parses a JSON text (a JSON-formatted String) and produces an ECMAScript value. The JSON format represents literals, arrays, and objects with a syntax similar to the syntax for ECMAScript literals, Array Initializers, and Object Initializers. After parsing, JSON objects are realized as ECMAScript objects. JSON arrays are realized as ECMAScript Array instances. JSON strings, numbers, booleans, and null are realized as ECMAScript Strings, Numbers, Booleans, and *null*.</p>
      <p>The optional _reviver_ parameter is a function that takes two parameters, _key_ and _value_. It can filter and transform the results. It is called with each of the _key_/_value_ pairs produced by the parse, and its return value is used instead of the original value. If it returns what it received, the structure is not modified. If it returns *undefined* then the property is deleted from the result.</p>
      <emu-alg>
        1. Let _JText_ be ? ToString(_text_).
        1. Parse _JText_ interpreted as UTF-16 encoded Unicode points (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>) as a JSON text as specified in ECMA-404. Throw a *SyntaxError* exception if _JText_ is not a valid JSON text as defined in that specification.
        1. Let _scriptText_ be the string-concatenation of `"("`, _JText_, and `");"`.
        1. Let _completion_ be the result of parsing and evaluating _scriptText_ as if it was the source text of an ECMAScript |Script|. The extended PropertyDefinitionEvaluation semantics defined in <emu-xref href="#sec-__proto__-property-names-in-object-initializers"></emu-xref> must not be used during the evaluation.
        1. Let _unfiltered_ be _completion_.[[Value]].
        1. Assert: _unfiltered_ is either a String, Number, Boolean, Null, or an Object that is defined by either an |ArrayLiteral| or an |ObjectLiteral|.
        1. If IsCallable(_reviver_) is *true*, then
          1. Let _root_ be ObjectCreate(%ObjectPrototype%).
          1. Let _rootName_ be the empty String.
          1. Let _status_ be CreateDataProperty(_root_, _rootName_, _unfiltered_).
          1. Assert: _status_ is *true*.
          1. Return ? InternalizeJSONProperty(_root_, _rootName_).
        1. Else,
          1. Return _unfiltered_.
      </emu-alg>
      <p>This function is the <dfn>%JSONParse%</dfn> intrinsic object.</p>
      <p>The `"length"` property of the `parse` function is 2.</p>
      <emu-note>
        <p>Valid JSON text is a subset of the ECMAScript |PrimaryExpression| syntax as modified by Step 4 above. Step 2 verifies that _JText_ conforms to that subset, and step 6 verifies that that parsing and evaluation returns a value of an appropriate type.</p>
      </emu-note>

      <emu-clause id="sec-internalizejsonproperty" aoid="InternalizeJSONProperty">
        <h1>Runtime Semantics: InternalizeJSONProperty ( _holder_, _name_ )</h1>
        <p>The abstract operation InternalizeJSONProperty is a recursive abstract operation that takes two parameters: a _holder_ object and the String _name_ of a property in that object. InternalizeJSONProperty uses the value of _reviver_ that was originally passed to the above parse function.</p>
        <emu-alg>
          1. Let _val_ be ? Get(_holder_, _name_).
          1. If Type(_val_) is Object, then
            1. Let _isArray_ be ? IsArray(_val_).
            1. If _isArray_ is *true*, then
              1. Let _I_ be 0.
              1. Let _len_ be ? ToLength(? Get(_val_, `"length"`)).
              1. Repeat, while _I_ &lt; _len_,
                1. Let _newElement_ be ? InternalizeJSONProperty(_val_, ! ToString(_I_)).
                1. If _newElement_ is *undefined*, then
                  1. Perform ? _val_.[[Delete]](! ToString(_I_)).
                1. Else,
                  1. Perform ? CreateDataProperty(_val_, ! ToString(_I_), _newElement_).
                  1. NOTE: This algorithm intentionally does not throw an exception if CreateDataProperty returns *false*.
                1. Add 1 to _I_.
            1. Else,
              1. Let _keys_ be ? EnumerableOwnPropertyNames(_val_, *"key"*).
              1. For each String _P_ in _keys_, do
                1. Let _newElement_ be ? InternalizeJSONProperty(_val_, _P_).
                1. If _newElement_ is *undefined*, then
                  1. Perform ? _val_.[[Delete]](_P_).
                1. Else,
                  1. Perform ? CreateDataProperty(_val_, _P_, _newElement_).
                  1. NOTE: This algorithm intentionally does not throw an exception if CreateDataProperty returns *false*.
          1. Return ? Call(_reviver_, _holder_, &laquo; _name_, _val_ &raquo;).
        </emu-alg>
        <p>It is not permitted for a conforming implementation of `JSON.parse` to extend the JSON grammars. If an implementation wishes to support a modified or extended JSON interchange format it must do so by defining a different parse function.</p>
        <emu-note>
          <p>In the case where there are duplicate name Strings within an object, lexically preceding values for the same key shall be overwritten.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-json.stringify">
      <h1>JSON.stringify ( _value_ [ , _replacer_ [ , _space_ ] ] )</h1>
      <p>The `stringify` function returns a String in UTF-16 encoded JSON format representing an ECMAScript value, or *undefined*. It can take three parameters. The _value_ parameter is an ECMAScript value, which is usually an object or array, although it can also be a String, Boolean, Number or *null*. The optional _replacer_ parameter is either a function that alters the way objects and arrays are stringified, or an array of Strings and Numbers that acts as an inclusion list for selecting the object properties that will be stringified. The optional _space_ parameter is a String or Number that allows the result to have white space injected into it to improve human readability.</p>
      <p>These are the steps in stringifying an object:</p>
      <emu-alg>
        1. Let _stack_ be a new empty List.
        1. Let _indent_ be the empty String.
        1. Let _PropertyList_ and _ReplacerFunction_ be *undefined*.
        1. If Type(_replacer_) is Object, then
          1. If IsCallable(_replacer_) is *true*, then
            1. Set _ReplacerFunction_ to _replacer_.
          1. Else,
            1. Let _isArray_ be ? IsArray(_replacer_).
            1. If _isArray_ is *true*, then
              1. Set _PropertyList_ to a new empty List.
              1. Let _len_ be ? ToLength(? Get(_replacer_, `"length"`)).
              1. Let _k_ be 0.
              1. Repeat, while _k_ &lt; _len_,
                1. Let _v_ be ? Get(_replacer_, ! ToString(_k_)).
                1. Let _item_ be *undefined*.
                1. If Type(_v_) is String, set _item_ to _v_.
                1. Else if Type(_v_) is Number, set _item_ to ! ToString(_v_).
                1. Else if Type(_v_) is Object, then
                  1. If _v_ has a [[StringData]] or [[NumberData]] internal slot, set _item_ to ? ToString(_v_).
                1. If _item_ is not *undefined* and _item_ is not currently an element of _PropertyList_, then
                  1. Append _item_ to the end of _PropertyList_.
                1. Increase _k_ by 1.
        1. If Type(_space_) is Object, then
          1. If _space_ has a [[NumberData]] internal slot, then
            1. Set _space_ to ? ToNumber(_space_).
          1. Else if _space_ has a [[StringData]] internal slot, then
            1. Set _space_ to ? ToString(_space_).
        1. If Type(_space_) is Number, then
          1. Set _space_ to min(10, ! ToInteger(_space_)).
          1. Let _gap_ be the String value containing _space_ occurrences of the code unit 0x0020 (SPACE). This will be the empty String if _space_ is less than 1.
        1. Else if Type(_space_) is String, then
          1. If the length of _space_ is 10 or less, let _gap_ be _space_; otherwise let _gap_ be the String value consisting of the first 10 code units of _space_.
        1. Else,
          1. Let _gap_ be the empty String.
        1. Let _wrapper_ be ObjectCreate(%ObjectPrototype%).
        1. Let _status_ be CreateDataProperty(_wrapper_, the empty String, _value_).
        1. Assert: _status_ is *true*.
        1. Return ? SerializeJSONProperty(the empty String, _wrapper_).
      </emu-alg>
      <p>The `"length"` property of the `stringify` function is 3.</p>
      <emu-note>
        <p>JSON structures are allowed to be nested to any depth, but they must be acyclic. If _value_ is or contains a cyclic structure, then the stringify function must throw a *TypeError* exception. This is an example of a value that cannot be stringified:</p>
        <pre><code class="javascript">
          a = [];
          a[0] = a;
          my_text = JSON.stringify(a); // This must throw a TypeError.
        </code></pre>
      </emu-note>
      <emu-note>
        <p>Symbolic primitive values are rendered as follows:</p>
        <ul>
          <li>
            The *null* value is rendered in JSON text as the String `null`.
          </li>
          <li>
            The *undefined* value is not rendered.
          </li>
          <li>
            The *true* value is rendered in JSON text as the String `true`.
          </li>
          <li>
            The *false* value is rendered in JSON text as the String `false`.
          </li>
        </ul>
      </emu-note>
      <emu-note>
        <p>String values are wrapped in QUOTATION MARK (`"`) code units. The code units `"` and `\\` are escaped with `\\` prefixes. Control characters code units are replaced with escape sequences `\\u`HHHH, or with the shorter forms, `\\b` (BACKSPACE), `\\f` (FORM FEED), `\\n` (LINE FEED), `\\r` (CARRIAGE RETURN), `\\t` (CHARACTER TABULATION).</p>
      </emu-note>
      <emu-note>
        <p>Finite numbers are stringified as if by calling ToString(_number_). *NaN* and Infinity regardless of sign are represented as the String `null`.</p>
      </emu-note>
      <emu-note>
        <p>Values that do not have a JSON representation (such as *undefined* and functions) do not produce a String. Instead they produce the *undefined* value. In arrays these values are represented as the String `null`. In objects an unrepresentable value causes the property to be excluded from stringification.</p>
      </emu-note>
      <emu-note>
        <p>An object is rendered as U+007B (LEFT CURLY BRACKET) followed by zero or more properties, separated with a U+002C (COMMA), closed with a U+007D (RIGHT CURLY BRACKET). A property is a quoted String representing the key or property name, a U+003A (COLON), and then the stringified property value. An array is rendered as an opening U+005B (LEFT SQUARE BRACKET followed by zero or more values, separated with a U+002C (COMMA), closed with a U+005D (RIGHT SQUARE BRACKET).</p>
      </emu-note>

      <emu-clause id="sec-serializejsonproperty" aoid="SerializeJSONProperty">
        <h1>Runtime Semantics: SerializeJSONProperty ( _key_, _holder_ )</h1>
        <p>The abstract operation SerializeJSONProperty with arguments _key_, and _holder_ has access to _ReplacerFunction_ from the invocation of the `stringify` method. Its algorithm is as follows:</p>
        <emu-alg>
          1. Let _value_ be ? Get(_holder_, _key_).
          1. If Type(_value_) is Object, then
            1. Let _toJSON_ be ? Get(_value_, `"toJSON"`).
            1. If IsCallable(_toJSON_) is *true*, then
              1. Set _value_ to ? Call(_toJSON_, _value_, &laquo; _key_ &raquo;).
          1. If _ReplacerFunction_ is not *undefined*, then
            1. Set _value_ to ? Call(_ReplacerFunction_, _holder_, &laquo; _key_, _value_ &raquo;).
          1. If Type(_value_) is Object, then
            1. If _value_ has a [[NumberData]] internal slot, then
              1. Set _value_ to ? ToNumber(_value_).
            1. Else if _value_ has a [[StringData]] internal slot, then
              1. Set _value_ to ? ToString(_value_).
            1. Else if _value_ has a [[BooleanData]] internal slot, then
              1. Set _value_ to _value_.[[BooleanData]].
          1. If _value_ is *null*, return `"null"`.
          1. If _value_ is *true*, return `"true"`.
          1. If _value_ is *false*, return `"false"`.
          1. If Type(_value_) is String, return QuoteJSONString(_value_).
          1. If Type(_value_) is Number, then
            1. If _value_ is finite, return ! ToString(_value_).
            1. Return `"null"`.
          1. If Type(_value_) is Object and IsCallable(_value_) is *false*, then
            1. Let _isArray_ be ? IsArray(_value_).
            1. If _isArray_ is *true*, return ? SerializeJSONArray(_value_).
            1. Return ? SerializeJSONObject(_value_).
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-quotejsonstring" aoid="QuoteJSONString">
        <h1>Runtime Semantics: QuoteJSONString ( _value_ )</h1>
        <p>The abstract operation QuoteJSONString with argument _value_ wraps a String value in QUOTATION MARK code units and escapes certain other code units within it.</p>
        <p>This operation interprets a String value as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        <emu-alg>
          1. Let _product_ be the String value consisting solely of the code unit 0x0022 (QUOTATION MARK).
          1. Let _cpList_ be a List containing in order the code points of _value_ when interpreted as a sequence of UTF-16 encoded code points as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.
          1. For each code point _C_ in _cpList_, do
            1. If _C_ is listed in the Code Point column of <emu-xref href="#table-json-single-character-escapes"></emu-xref>, then
              1. Set _product_ to the string-concatenation of _product_ and the Escape Sequence for _C_ as specified in <emu-xref href="#table-json-single-character-escapes"></emu-xref>.
            1. Else if _C_ has a numeric value less than 0x0020 (SPACE), or if _C_ has the same numeric value as a <emu-xref href="#leading-surrogate"></emu-xref> or <emu-xref href="#trailing-surrogate"></emu-xref>, then
              1. Let _unit_ be the code unit whose numeric value is that of _C_.
              1. Set _product_ to the string-concatenation of _product_ and UnicodeEscape(_unit_).
            1. Else,
              1. Set _product_ to the string-concatenation of _product_ and the UTF16Encoding of _C_.
          1. Set _product_ to the string-concatenation of _product_ and the code unit 0x0022 (QUOTATION MARK).
          1. Return _product_.
        </emu-alg>
        <emu-table id="table-json-single-character-escapes" caption="JSON Single Character Escape Sequences">
          <table>
            <tbody>
            <tr>
              <th>
                Code Point
              </th>
              <th>
                Unicode Character Name
              </th>
              <th>
                Escape Sequence
              </th>
            </tr>
            <tr>
              <td>
                U+0008
              </td>
              <td>
                BACKSPACE
              </td>
              <td>
                `\\b`
              </td>
            </tr>
            <tr>
              <td>
                U+0009
              </td>
              <td>
                CHARACTER TABULATION
              </td>
              <td>
                `\\t`
              </td>
            </tr>
            <tr>
              <td>
                U+000A
              </td>
              <td>
                LINE FEED (LF)
              </td>
              <td>
                `\\n`
              </td>
            </tr>
            <tr>
              <td>
                U+000C
              </td>
              <td>
                FORM FEED (FF)
              </td>
              <td>
                `\\f`
              </td>
            </tr>
            <tr>
              <td>
                U+000D
              </td>
              <td>
                CARRIAGE RETURN (CR)
              </td>
              <td>
                `\\r`
              </td>
            </tr>
            <tr>
              <td>
                U+0022
              </td>
              <td>
                QUOTATION MARK
              </td>
              <td>
                `\\"`
              </td>
            </tr>
            <tr>
              <td>
                U+005C
              </td>
              <td>
                REVERSE SOLIDUS
              </td>
              <td>
                `\\\\`
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-unicodeescape" aoid="UnicodeEscape">
        <h1>Runtime Semantics: UnicodeEscape ( _C_ )</h1>
        <p>The abstract operation UnicodeEscape takes a code unit argument _C_ and represents it as a Unicode escape sequence.</p>
        <emu-alg>
          1. Let _n_ be the numeric value of _C_.
          1. Assert: _n_ &le; 0xFFFF.
          1. Return the string-concatenation of:
            * the code unit 0x005C (REVERSE SOLIDUS)
            * `"u"`
            * the String representation of _n_, formatted as a four-digit lowercase hexadecimal number, padded to the left with zeroes if necessary
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-serializejsonobject" aoid="SerializeJSONObject">
        <h1>Runtime Semantics: SerializeJSONObject ( _value_ )</h1>
        <p>The abstract operation SerializeJSONObject with argument _value_ serializes an object. It has access to the _stack_, _indent_, _gap_, and _PropertyList_ values of the current invocation of the `stringify` method.</p>
        <emu-alg>
          1. If _stack_ contains _value_, throw a *TypeError* exception because the structure is cyclical.
          1. Append _value_ to _stack_.
          1. Let _stepback_ be _indent_.
          1. Set _indent_ to the string-concatenation of _indent_ and _gap_.
          1. If _PropertyList_ is not *undefined*, then
            1. Let _K_ be _PropertyList_.
          1. Else,
            1. Let _K_ be ? EnumerableOwnPropertyNames(_value_, *"key"*).
          1. Let _partial_ be a new empty List.
          1. For each element _P_ of _K_, do
            1. Let _strP_ be ? SerializeJSONProperty(_P_, _value_).
            1. If _strP_ is not *undefined*, then
              1. Let _member_ be QuoteJSONString(_P_).
              1. Set _member_ to the string-concatenation of _member_ and `":"`.
              1. If _gap_ is not the empty String, then
                1. Set _member_ to the string-concatenation of _member_ and the code unit 0x0020 (SPACE).
              1. Set _member_ to the string-concatenation of _member_ and _strP_.
              1. Append _member_ to _partial_.
          1. If _partial_ is empty, then
            1. Let _final_ be `"{}"`.
          1. Else,
            1. If _gap_ is the empty String, then
              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with the code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.
              1. Let _final_ be the string-concatenation of `"{"`, _properties_, and `"}"`.
            1. Else _gap_ is not the empty String,
              1. Let _separator_ be the string-concatenation of the code unit 0x002C (COMMA), the code unit 0x000A (LINE FEED), and _indent_.
              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with _separator_. The _separator_ String is not inserted either before the first String or after the last String.
              1. Let _final_ be the string-concatenation of `"{"`, the code unit 0x000A (LINE FEED), _indent_, _properties_, the code unit 0x000A (LINE FEED), _stepback_, and `"}"`.
          1. Remove the last element of _stack_.
          1. Set _indent_ to _stepback_.
          1. Return _final_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-serializejsonarray" aoid="SerializeJSONArray">
        <h1>Runtime Semantics: SerializeJSONArray ( _value_ )</h1>
        <p>The abstract operation SerializeJSONArray with argument _value_ serializes an array. It has access to the _stack_, _indent_, and _gap_ values of the current invocation of the `stringify` method.</p>
        <emu-alg>
          1. If _stack_ contains _value_, throw a *TypeError* exception because the structure is cyclical.
          1. Append _value_ to _stack_.
          1. Let _stepback_ be _indent_.
          1. Set _indent_ to the string-concatenation of _indent_ and _gap_.
          1. Let _partial_ be a new empty List.
          1. Let _len_ be ? ToLength(? Get(_value_, `"length"`)).
          1. Let _index_ be 0.
          1. Repeat, while _index_ &lt; _len_
            1. Let _strP_ be ? SerializeJSONProperty(! ToString(_index_), _value_).
            1. If _strP_ is *undefined*, then
              1. Append `"null"` to _partial_.
            1. Else,
              1. Append _strP_ to _partial_.
            1. Increment _index_ by 1.
          1. If _partial_ is empty, then
            1. Let _final_ be `"[]"`.
          1. Else,
            1. If _gap_ is the empty String, then
              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with the code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.
              1. Let _final_ be the string-concatenation of `"["`, _properties_, and `"]"`.
            1. Else,
              1. Let _separator_ be the string-concatenation of the code unit 0x002C (COMMA), the code unit 0x000A (LINE FEED), and _indent_.
              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with _separator_. The _separator_ String is not inserted either before the first String or after the last String.
              1. Let _final_ be the string-concatenation of `"["`, the code unit 0x000A (LINE FEED), _indent_, _properties_, the code unit 0x000A (LINE FEED), _stepback_, and `"]"`.
          1. Remove the last element of _stack_.
          1. Set _indent_ to _stepback_.
          1. Return _final_.
        </emu-alg>
        <emu-note>
          <p>The representation of arrays includes only the elements between zero and <emu-eqn>`array.length` - 1</emu-eqn> inclusive. Properties whose keys are not <emu-xref href="#array-index">array indexes</emu-xref> are excluded from the stringification. An array is stringified as an opening LEFT SQUARE BRACKET, elements separated by COMMA, and a closing RIGHT SQUARE BRACKET.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-json-@@tostringtag">
      <h1>JSON [ @@toStringTag ]</h1>
      <p>The initial value of the @@toStringTag property is the String value `"JSON"`.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-control-abstraction-objects">
  <h1>Control Abstraction Objects</h1>

  <emu-clause id="sec-iteration">
    <h1>Iteration</h1>

    <emu-clause id="sec-common-iteration-interfaces">
      <h1>Common Iteration Interfaces</h1>
      <p>An interface is a set of property keys whose associated values match a specific specification. Any object that provides all the properties as described by an interface's specification <em>conforms</em> to that interface. An interface is not represented by a distinct object. There may be many separately implemented objects that conform to any interface. An individual object may conform to multiple interfaces.</p>

      <emu-clause id="sec-iterable-interface">
        <h1>The <i>Iterable</i> Interface</h1>
        <p>The <i>Iterable</i> interface includes the property described in <emu-xref href="#table-52"></emu-xref>:</p>
        <emu-table id="table-52" caption="<i>Iterable</i> Interface Required Properties">
          <table>
            <tbody>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Requirements
              </th>
            </tr>
            <tr>
              <td>
                `@@iterator`
              </td>
              <td>
                A function that returns an <i>Iterator</i> object.
              </td>
              <td>
                The returned object must conform to the <i>Iterator</i> interface.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-iterator-interface">
        <h1>The <i>Iterator</i> Interface</h1>
        <p>An object that implements the <i>Iterator</i> interface must include the property in <emu-xref href="#table-53"></emu-xref>. Such objects may also implement the properties in <emu-xref href="#table-54"></emu-xref>.</p>
        <emu-table id="table-53" caption="<i>Iterator</i> Interface Required Properties">
          <table>
            <tbody>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Requirements
              </th>
            </tr>
            <tr>
              <td>
                `next`
              </td>
              <td>
                A function that returns an <i>IteratorResult</i> object.
              </td>
              <td>
                The returned object must conform to the <i>IteratorResult</i> interface. If a previous call to the `next` method of an <i>Iterator</i> has returned an <i>IteratorResult</i> object whose `done` property is *true*, then all subsequent calls to the `next` method of that object should also return an <i>IteratorResult</i> object whose `done` property is *true*. However, this requirement is not enforced.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
        <emu-note>
          <p>Arguments may be passed to the next function but their interpretation and validity is dependent upon the target <i>Iterator</i>. The for-of statement and other common users of <em>Iterators</em> do not pass any arguments, so <i>Iterator</i> objects that expect to be used in such a manner must be prepared to deal with being called with no arguments.</p>
        </emu-note>
        <emu-table id="table-54" caption="<i>Iterator</i> Interface Optional Properties">
          <table>
            <tbody>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Requirements
              </th>
            </tr>
            <tr>
              <td>
                `return`
              </td>
              <td>
                A function that returns an <i>IteratorResult</i> object.
              </td>
              <td>
                The returned object must conform to the <i>IteratorResult</i> interface. Invoking this method notifies the <i>Iterator</i> object that the caller does not intend to make any more `next` method calls to the <i>Iterator</i>. The returned <i>IteratorResult</i> object will typically have a `done` property whose value is *true*, and a `value` property with the value passed as the argument of the `return` method. However, this requirement is not enforced.
              </td>
            </tr>
            <tr>
              <td>
                `throw`
              </td>
              <td>
                A function that returns an <i>IteratorResult</i> object.
              </td>
              <td>
                The returned object must conform to the <i>IteratorResult</i> interface. Invoking this method notifies the <i>Iterator</i> object that the caller has detected an error condition. The argument may be used to identify the error condition and typically will be an exception object. A typical response is to `throw` the value passed as the argument. If the method does not `throw`, the returned <i>IteratorResult</i> object will typically have a `done` property whose value is *true*.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
        <emu-note>
          <p>Typically callers of these methods should check for their existence before invoking them. Certain ECMAScript language features including `for`-`of`, `yield*`, and array destructuring call these methods after performing an existence check. Most ECMAScript library functions that accept <i>Iterable</i> objects as arguments also conditionally call them.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-asynciterable-interface">
        <h1>The <i>AsyncIterable</i> Interface</h1>
        <p>The <i>AsyncIterable</i> interface includes the properties described in <emu-xref href="#table-async-iterable"></emu-xref>:</p>
        <emu-table id="table-async-iterable" caption="<i>AsyncIterable</i> Interface Required Properties">
          <table>
            <tbody>
            <tr>
              <th>Property</th>
              <th>Value</th>
              <th>Requirements</th>
            </tr>
            <tr>
              <td>`@@asyncIterator`</td>
              <td>A function that returns an <i>AsyncIterator</i> object.</td>
              <td>The returned object must conform to the <i>AsyncIterator</i> interface.</td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-asynciterator-interface">
        <h1>The <i>AsyncIterator</i> Interface</h1>
        <p>An object that implements the <i>AsyncIterator</i> interface must include the properties in <emu-xref href="#table-async-iterator-required"></emu-xref>. Such objects may also implement the properties in <emu-xref href="#table-async-iterator-optional"></emu-xref>.</p>
        <emu-table id="table-async-iterator-required" caption="<i>AsyncIterator</i> Interface Required Properties">
          <table>
            <tbody>
            <tr>
              <th>Property</th>
              <th>Value</th>
              <th>Requirements</th>
            </tr>
            <tr>
              <td>`next`</td>
              <td>A function that returns a promise for an <i>IteratorResult</i> object.</td>
              <td>
                <p>The returned promise, when fulfilled, must fulfill with an object which conforms to the <i>IteratorResult</i> interface. If a previous call to the `next` method of an <i>AsyncIterator</i> has returned a promise for an <i>IteratorResult</i> object whose `done` property is *true*, then all subsequent calls to the `next` method of that object should also return a promise for an <i>IteratorResult</i> object whose `done` property is *true*. However, this requirement is not enforced.</p>

                <p>Additionally, the <i>IteratorResult</i> object that serves as a fulfillment value should have a `value` property whose value is not a promise (or "thenable"). However, this requirement is also not enforced.</p>
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
        <emu-note>
          <p>Arguments may be passed to the next function but their interpretation and validity is dependent upon the target <i>AsyncIterator</i>. The `for`-`await`-`of` statement and other common users of <em>AsyncIterators</em> do not pass any arguments, so <i>AsyncIterator</i> objects that expect to be used in such a manner must be prepared to deal with being called with no arguments.</p>
        </emu-note>
        <emu-table id="table-async-iterator-optional" caption="<i>AsyncIterator</i> Interface Optional Properties">
          <table>
            <tbody>
            <tr>
              <th>Property</th>
              <th>Value</th>
              <th>Requirements</th>
            </tr>
            <tr>
              <td>`return`</td>
              <td>A function that returns a promise for an <i>IteratorResult</i> object.</td>
              <td>
                <p>The returned promise, when fulfilled, must fulfill with an object which conforms to the <i>IteratorResult</i> interface. Invoking this method notifies the <i>AsyncIterator</i> object that the caller does not intend to make any more `next` method calls to the <i>AsyncIterator</i>. The returned promise will fulfill with an <i>IteratorResult</i> object which will typically have a `done` property whose value is *true*, and a `value` property with the value passed as the argument of the `return` method. However, this requirement is not enforced.</p>

                <p>Additionally, the <i>IteratorResult</i> object that serves as a fulfillment value should have a `value` property whose value is not a promise (or "thenable"). If the argument value is used in the typical manner, then if it is a rejected promise, a promise rejected with the same reason should be returned; if it is a fulfilled promise, then its fulfillment value should be used as the `value` property of the returned promise's <i>IteratorResult</i> object fulfillment value. However, these requirements are also not enforced.</p>
              </td>
            </tr>
            <tr>
              <td>`throw`</td>
              <td>A function that returns a promise for an <i>IteratorResult</i> object.</td>
              <td>
                <p>The returned promise, when fulfilled, must fulfill with an object which conforms to the <i>IteratorResult</i> interface. Invoking this method notifies the <i>AsyncIterator</i> object that the caller has detected an error condition. The argument may be used to identify the error condition and typically will be an exception object. A typical response is to return a rejected promise which rejects with the value passed as the argument.</p>

                <p>If the returned promise is fulfilled, the <i>IteratorResult</i> fulfillment value will typically have a `done` property whose value is *true*. Additionally, it should have a `value` property whose value is not a promise (or "thenable"), but this requirement is not enforced.</p>
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
        <emu-note>
          <p>Typically callers of these methods should check for their existence before invoking them. Certain ECMAScript language features including `for`-`await`-`of` and `yield*` call these methods after performing an existence check.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-iteratorresult-interface">
        <h1>The <i>IteratorResult</i> Interface</h1>
        <p>The <i>IteratorResult</i> interface includes the properties listed in <emu-xref href="#table-55"></emu-xref>:</p>
        <emu-table id="table-55" caption="<i>IteratorResult</i> Interface Properties">
          <table>
            <tbody>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Requirements
              </th>
            </tr>
            <tr>
              <td>
                `done`
              </td>
              <td>
                Either *true* or *false*.
              </td>
              <td>
                This is the result status of an <em>iterator</em> `next` method call. If the end of the iterator was reached `done` is *true*. If the end was not reached `done` is *false* and a value is available. If a `done` property (either own or inherited) does not exist, it is consider to have the value *false*.
              </td>
            </tr>
            <tr>
              <td>
                `value`
              </td>
              <td>
                Any ECMAScript language value.
              </td>
              <td>
                If done is *false*, this is the current iteration element value. If done is *true*, this is the return value of the iterator, if it supplied one. If the iterator does not have a return value, `value` is *undefined*. In that case, the `value` property may be absent from the conforming object if it does not inherit an explicit `value` property.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-%iteratorprototype%-object">
      <h1>The %IteratorPrototype% Object</h1>
      <p>The <dfn>%IteratorPrototype%</dfn> object:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
        <li>is an ordinary object.</li>
      </ul>
      <emu-note>
        <p>All objects defined in this specification that implement the Iterator interface also inherit from %IteratorPrototype%. ECMAScript code may also define objects that inherit from %IteratorPrototype%.The %IteratorPrototype% object provides a place where additional methods that are applicable to all iterator objects may be added.</p>
        <p>The following expression is one way that ECMAScript code can access the %IteratorPrototype% object:</p>
        <pre><code class="javascript">Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))</code></pre>
      </emu-note>

      <emu-clause id="sec-%iteratorprototype%-@@iterator">
        <h1>%IteratorPrototype% [ @@iterator ] ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the `name` property of this function is `"[Symbol.iterator]"`.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-asynciteratorprototype">
      <h1>The %AsyncIteratorPrototype% Object</h1>
      <p>The <dfn>%AsyncIteratorPrototype%</dfn> object:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
        <li>is an ordinary object.</li>
      </ul>
      <emu-note>
        <p>All objects defined in this specification that implement the AsyncIterator interface also inherit from %AsyncIteratorPrototype%. ECMAScript code may also define objects that inherit from %AsyncIteratorPrototype%.The %AsyncIteratorPrototype% object provides a place where additional methods that are applicable to all async iterator objects may be added.</p>
      </emu-note>

      <emu-clause id="sec-asynciteratorprototype-asynciterator">
        <h1>%AsyncIteratorPrototype% [ @@asyncIterator ] ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the `name` property of this function is `"[Symbol.asyncIterator]"`.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-from-sync-iterator-objects">
      <h1>Async-from-Sync Iterator Objects</h1>
      <p>An Async-from-Sync Iterator object is an async iterator that adapts a specific synchronous iterator. There is not a named constructor for Async-from-Sync Iterator objects. Instead, Async-from-Sync iterator objects are created by the CreateAsyncFromSyncIterator abstract operation as needed.</p>

      <emu-clause id="sec-createasyncfromsynciterator" aoid="CreateAsyncFromSyncIterator">
        <h1>CreateAsyncFromSyncIterator ( _syncIteratorRecord_ )</h1>
        <p>The abstract operation CreateAsyncFromSyncIterator is used to create an async iterator Record from a synchronous iterator Record. It performs the following steps:</p>
        <emu-alg>
          1. Let _asyncIterator_ be ! ObjectCreate(%AsyncFromSyncIteratorPrototype%, &laquo; [[SyncIteratorRecord]] &raquo;).
          1. Set _asyncIterator_.[[SyncIteratorRecord]] to _syncIteratorRecord_.
          1. Return ? GetIterator(_asyncIterator_, ~async~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%asyncfromsynciteratorprototype%-object">
        <h1>The %AsyncFromSyncIteratorPrototype% Object</h1>
        <p>The <dfn>%AsyncFromSyncIteratorPrototype%</dfn> object:</p>
        <ul>
          <li>has properties that are inherited by all Async-from-Sync Iterator Objects.</li>
          <li>is an ordinary object.</li>
          <li>has a [[Prototype]] internal slot whose value is the intrinsic object %AsyncIteratorPrototype%.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-%asyncfromsynciteratorprototype%.next">
          <h1>%AsyncFromSyncIteratorPrototype%.next ( _value_ )</h1>
          <emu-alg>
            1. Let _O_ be the *this* value.
            1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
            1. If Type(_O_) is not Object, or if _O_ does not have a [[SyncIteratorRecord]] internal slot, then
              1. Let _invalidIteratorError_ be a newly created *TypeError* object.
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _invalidIteratorError_ &raquo;).
              1. Return _promiseCapability_.[[Promise]].
            1. Let _syncIteratorRecord_ be _O_.[[SyncIteratorRecord]].
            1. Let _result_ be IteratorNext(_syncIteratorRecord_, _value_).
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
            1. Return ! AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%asyncfromsynciteratorprototype%.return">
          <h1>%AsyncFromSyncIteratorPrototype%.return ( _value_ )</h1>

          <emu-alg>
            1. Let _O_ be the *this* value.
            1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
            1. If Type(_O_) is not Object, or if _O_ does not have a [[SyncIteratorRecord]] internal slot, then
              1. Let _invalidIteratorError_ be a newly created *TypeError* object.
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _invalidIteratorError_ &raquo;).
              1. Return _promiseCapability_.[[Promise]].
            1. Let _syncIterator_ be _O_.[[SyncIteratorRecord]].[[Iterator]].
            1. Let _return_ be GetMethod(_syncIterator_, `"return"`).
            1. IfAbruptRejectPromise(_return_, _promiseCapability_).
            1. If _return_ is *undefined*, then
              1. Let _iterResult_ be ! CreateIterResultObject(_value_, *true*).
              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _iterResult_ &raquo;).
              1. Return _promiseCapability_.[[Promise]].
            1. Let _result_ be Call(_return_, _syncIterator_, &laquo; _value_ &raquo;).
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
            1. If Type(_result_) is not Object, then
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; a newly created *TypeError* object &raquo;).
              1. Return _promiseCapability_.[[Promise]].
            1. Return ! AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%asyncfromsynciteratorprototype%.throw">
          <h1>%AsyncFromSyncIteratorPrototype%.throw ( _value_ )</h1>

          <emu-alg>
            1. Let _O_ be the *this* value.
            1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
            1. If Type(_O_) is not Object, or if _O_ does not have a [[SyncIteratorRecord]] internal slot, then
              1. Let _invalidIteratorError_ be a newly created *TypeError* object.
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _invalidIteratorError_ &raquo;).
              1. Return _promiseCapability_.[[Promise]].
            1. Let _syncIterator_ be _O_.[[SyncIteratorRecord]].[[Iterator]].
            1. Let _throw_ be GetMethod(_syncIterator_, `"throw"`).
            1. IfAbruptRejectPromise(_throw_, _promiseCapability_).
            1. If _throw_ is *undefined*, then
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _value_ &raquo;).
              1. Return _promiseCapability_.[[Promise]].
            1. Let _result_ be Call(_throw_, _syncIterator_, &laquo; _value_ &raquo;).
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
            1. If Type(_result_) is not Object, then
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; a newly created *TypeError* object &raquo;).
              1. Return _promiseCapability_.[[Promise]].
            1. Return ! AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%asyncfromsynciteratorprototype%-@@tostringtag">
          <h1>%AsyncFromSyncIteratorPrototype% [ @@toStringTag ]</h1>
          <p>The initial value of the @@toStringTag property is the String value `"Async-from-Sync Iterator"`.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        </emu-clause>

        <emu-clause id="sec-async-from-sync-iterator-value-unwrap-functions">
          <h1>Async-from-Sync Iterator Value Unwrap Functions</h1>

          <p>An async-from-sync iterator value unwrap function is an anonymous built-in function that is used by methods of %AsyncFromSyncIteratorPrototype% when processing the `value` field of an <i>IteratorResult</i> object, in order to wait for its value if it is a promise and re-package the result in a new "unwrapped" <i>IteratorResult</i> object. Each async iterator value unwrap function has a [[Done]] internal slot.</p>

          <p>When an async-from-sync iterator value unwrap function is called with argument _value_, the following steps are taken:</p>

          <emu-alg>
            1. Let _F_ be the active function object.
            1. Return ! CreateIterResultObject(_value_, _F_.[[Done]]).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-async-from-sync-iterator-instances">
        <h1>Properties of Async-from-Sync Iterator Instances</h1>
        <p>Async-from-Sync Iterator instances are ordinary objects that inherit properties from the %AsyncFromSyncIteratorPrototype% intrinsic object. Async-from-Sync Iterator instances are initially created with the internal slots listed in <emu-xref href="#table-async-from-sync-iterator-internal-slots"></emu-xref>.</p>
        <emu-table id="table-async-from-sync-iterator-internal-slots" caption="Internal Slots of Async-from-Sync Iterator Instances">
          <table>
            <thead>
            <tr>
              <th>
                Internal Slot
              </th>
              <th>
                Description
              </th>
            </tr>
            </thead>
            <tbody>
            <tr>
              <td>
                [[SyncIteratorRecord]]
              </td>
              <td>
                A Record, of the type returned by GetIterator, representing the original synchronous iterator which is being adapted.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-asyncfromsynciteratorcontinuation" aoid="AsyncFromSyncIteratorContinuation">
        <h1>AsyncFromSyncIteratorContinuation ( _result_, _promiseCapability_ )</h1>

        <emu-alg>
          1. Let _done_ be IteratorComplete(_result_).
          1. IfAbruptRejectPromise(_done_, _promiseCapability_).
          1. Let _value_ be IteratorValue(_result_).
          1. IfAbruptRejectPromise(_value_, _promiseCapability_).
          1. Let _valueWrapper_ be PromiseResolve(%Promise%, _value_).
          1. IfAbruptRejectPromise(_valueWrapper_, _promiseCapability_).
          1. Let _steps_ be the algorithm steps defined in <emu-xref href="#sec-async-from-sync-iterator-value-unwrap-functions" title></emu-xref>.
          1. Let _onFulfilled_ be CreateBuiltinFunction(_steps_, &laquo; [[Done]] &raquo;).
          1. Set _onFulfilled_.[[Done]] to _done_.
          1. Perform ! PerformPromiseThen(_valueWrapper_, _onFulfilled_, *undefined*, _promiseCapability_).
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-generatorfunction-objects">
    <h1>GeneratorFunction Objects</h1>
    <p>GeneratorFunction objects are functions that are usually created by evaluating |GeneratorDeclaration|s, |GeneratorExpression|s, and |GeneratorMethod|s. They may also be created by calling the %GeneratorFunction% intrinsic.</p>
    <emu-figure id="figure-2" caption="Generator Objects Relationships" informative>
      <img alt="A staggering variety of boxes and arrows." src="img/figure-2.png">
    </emu-figure>

    <emu-clause id="sec-generatorfunction-constructor">
      <h1>The GeneratorFunction Constructor</h1>
      <p>The GeneratorFunction constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%GeneratorFunction%</dfn>.</li>
        <li>creates and initializes a new GeneratorFunction object when called as a function rather than as a constructor. Thus the function call `GeneratorFunction (&hellip;)` is equivalent to the object creation expression `new GeneratorFunction (&hellip;)` with the same arguments.</li>
        <li>is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `GeneratorFunction` behaviour must include a `super` call to the `GeneratorFunction` constructor to create and initialize subclass instances with the internal slots necessary for built-in GeneratorFunction behaviour. All ECMAScript syntactic forms for defining generator function objects create direct instances of `GeneratorFunction`. There is no syntactic means to create instances of `GeneratorFunction` subclasses.</li>
      </ul>

      <emu-clause id="sec-generatorfunction">
        <h1>GeneratorFunction ( _p1_, _p2_, &hellip; , _pn_, _body_ )</h1>
        <p>The last argument specifies the body (executable code) of a generator function; any preceding arguments specify formal parameters.</p>
        <p>When the `GeneratorFunction` function is called with some arguments _p1_, _p2_, &hellip; , _pn_, _body_ (where _n_ might be 0, that is, there are no &ldquo;_p_&rdquo; arguments, and where _body_ might also not be provided), the following steps are taken:</p>
        <emu-alg>
          1. Let _C_ be the active function object.
          1. Let _args_ be the _argumentsList_ that was passed to this function by [[Call]] or [[Construct]].
          1. Return ? CreateDynamicFunction(_C_, NewTarget, `"generator"`, _args_).
        </emu-alg>
        <emu-note>
          <p>See NOTE for <emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref>.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-generatorfunction-constructor">
      <h1>Properties of the GeneratorFunction Constructor</h1>
      <p>The GeneratorFunction constructor:</p>
      <ul>
        <li>is a standard built-in function object that inherits from the `Function` constructor.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %Function%.</li>
        <li>has a `name` property whose value is `"GeneratorFunction"`.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-generatorfunction.length">
        <h1>GeneratorFunction.length</h1>
        <p>This is a data property with a value of 1. This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-generatorfunction.prototype">
        <h1>GeneratorFunction.prototype</h1>
        <p>The initial value of `GeneratorFunction.prototype` is the intrinsic object %Generator%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-generatorfunction-prototype-object">
      <h1>Properties of the GeneratorFunction Prototype Object</h1>
      <p>The GeneratorFunction prototype object:</p>
      <ul>
        <li>is an ordinary object.</li>
        <li>is not a function object and does not have an [[ECMAScriptCode]] internal slot or any other of the internal slots listed in <emu-xref href="#table-27"></emu-xref> or <emu-xref href="#table-56"></emu-xref>.</li>
        <li>is the value of the `prototype` property of the intrinsic object %GeneratorFunction%.</li>
        <li>is the intrinsic object <dfn>%Generator%</dfn> (see Figure 2).</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.</li>
      </ul>

      <emu-clause id="sec-generatorfunction.prototype.constructor">
        <h1>GeneratorFunction.prototype.constructor</h1>
        <p>The initial value of `GeneratorFunction.prototype.constructor` is the intrinsic object %GeneratorFunction%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-generatorfunction.prototype.prototype">
        <h1>GeneratorFunction.prototype.prototype</h1>
        <p>The value of `GeneratorFunction.prototype.prototype` is the %GeneratorPrototype% intrinsic object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-generatorfunction.prototype-@@tostringtag">
        <h1>GeneratorFunction.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value `"GeneratorFunction"`.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-generatorfunction-instances">
      <h1>GeneratorFunction Instances</h1>
      <p>Every GeneratorFunction instance is an ECMAScript function object and has the internal slots listed in <emu-xref href="#table-27"></emu-xref>. The value of the [[FunctionKind]] internal slot for all such instances is `"generator"`.</p>
      <p>Each GeneratorFunction instance has the following own properties:</p>

      <emu-clause id="sec-generatorfunction-instances-length">
        <h1>length</h1>
        <p>The specification for the `"length"` property of Function instances given in <emu-xref href="#sec-function-instances-length"></emu-xref> also applies to GeneratorFunction instances.</p>
      </emu-clause>

      <emu-clause id="sec-generatorfunction-instances-name">
        <h1>name</h1>
        <p>The specification for the `name` property of Function instances given in <emu-xref href="#sec-function-instances-name"></emu-xref> also applies to GeneratorFunction instances.</p>
      </emu-clause>

      <emu-clause id="sec-generatorfunction-instances-prototype">
        <h1>prototype</h1>
        <p>Whenever a GeneratorFunction instance is created another ordinary object is also created and is the initial value of the generator function's `prototype` property. The value of the prototype property is used to initialize the [[Prototype]] internal slot of a newly created Generator object when the generator function object is invoked using [[Call]].</p>
        <p>This property has the attributes { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        <emu-note>
          <p>Unlike Function instances, the object that is the value of the a GeneratorFunction's `prototype` property does not have a `constructor` property whose value is the GeneratorFunction instance.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-asyncgeneratorfunction-objects">
    <h1>AsyncGeneratorFunction Objects</h1>
    <p>AsyncGeneratorFunction objects are functions that are usually created by evaluating |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, and |AsyncGeneratorMethod| syntactic productions. They may also be created by calling the %AsyncGeneratorFunction% intrinsic.</p>

    <emu-clause id="sec-asyncgeneratorfunction-constructor">
      <h1>The AsyncGeneratorFunction Constructor</h1>
      <p>The AsyncGeneratorFunction constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%AsyncGeneratorFunction%</dfn>.</li>
        <li>creates and initializes a new AsyncGeneratorFunction object when called as a function rather than as a constructor. Thus the function call `AsyncGeneratorFunction (...)` is equivalent to the object creation expression `new AsyncGeneratorFunction (...)` with the same arguments.</li>
        <li>is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `AsyncGeneratorFunction` behaviour must include a `super` call to the `AsyncGeneratorFunction` constructor to create and initialize subclass instances with the internal slots necessary for built-in AsyncGeneratorFunction behaviour. All ECMAScript syntactic forms for defining async generator function objects create direct instances of `AsyncGeneratorFunction`. There is no syntactic means to create instances of `AsyncGeneratorFunction` subclasses.</li>
      </ul>

      <emu-clause id="sec-asyncgeneratorfunction">
        <h1>AsyncGeneratorFunction ( _p1_, _p2_, ..., _pn_, _body_ )</h1>
        <p>The last argument specifies the body (executable code) of an async generator function; any preceding arguments specify formal parameters.</p>
        <p>When the `AsyncGeneratorFunction` function is called with some arguments _p1_, _p2_, &hellip; , _pn_, _body_ (where _n_ might be 0, that is, there are no "_p_" arguments, and where _body_ might also not be provided), the following steps are taken:</p>
        <emu-alg>
          1. Let _C_ be the active function object.
          1. Let _args_ be the _argumentsList_ that was passed to this function by [[Call]] or [[Construct]].
          1. Return ? CreateDynamicFunction(_C_, NewTarget, `"async generator"`, _args_).
        </emu-alg>
        <emu-note>
          <p>See NOTE for <emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref>.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-asyncgeneratorfunction">
      <h1>Properties of the AsyncGeneratorFunction Constructor</h1>
      <p>The AsyncGeneratorFunction constructor:</p>
      <ul>
        <li>is a standard built-in function object that inherits from the `Function` constructor.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %Function%.</li>
        <li>has a `name` property whose value is `"AsyncGeneratorFunction"`.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-asyncgeneratorfunction-length">
        <h1>AsyncGeneratorFunction.length</h1>
        <p>This is a data property with a value of 1. This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorfunction-prototype">
        <h1>AsyncGeneratorFunction.prototype</h1>
        <p>The initial value of `AsyncGeneratorFunction.prototype` is the intrinsic object <dfn>%AsyncGenerator%</dfn>.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-asyncgeneratorfunction-prototype">
      <h1>Properties of the AsyncGeneratorFunction Prototype Object</h1>
      <p>The AsyncGeneratorFunction prototype object:</p>
      <ul>
        <li>is an ordinary object.</li>
        <li>is not a function object and does not have an [[ECMAScriptCode]] internal slot or any other of the internal slots listed in <emu-xref href="#table-27"></emu-xref> or <emu-xref href="#table-internal-slots-of-asyncgenerator-instances"></emu-xref>.</li>
        <li>is the value of the `prototype` property of the intrinsic object %AsyncGeneratorFunction%.</li>
        <li>is the intrinsic object %AsyncGenerator%.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.</li>
      </ul>

      <emu-clause id="sec-asyncgeneratorfunction-prototype-constructor">
        <h1>AsyncGeneratorFunction.prototype.constructor</h1>
        <p>The initial value of `AsyncGeneratorFunction.prototype.constructor` is the intrinsic object %AsyncGeneratorFunction%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorfunction-prototype-prototype">
        <h1>AsyncGeneratorFunction.prototype.prototype</h1>
        <p>The value of `AsyncGeneratorFunction.prototype.prototype` is the %AsyncGeneratorPrototype% intrinsic object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorfunction-prototype-tostringtag">
        <h1>AsyncGeneratorFunction.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value `"AsyncGeneratorFunction"`.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-asyncgeneratorfunction-instances">
      <h1>AsyncGeneratorFunction Instances</h1>
      <p>Every AsyncGeneratorFunction instance is an ECMAScript function object and has the internal slots listed in <emu-xref href="#table-27"></emu-xref>. The value of the [[FunctionKind]] internal slot for all such instances is `"generator"`.</p>
      <p>Each AsyncGeneratorFunction instance has the following own properties:</p>

      <emu-clause id="sec-asyncgeneratorfunction-instance-length">
        <h1>length</h1>
        <p>The value of the `"length"` property is an integer that indicates the typical number of arguments expected by the AsyncGeneratorFunction. However, the language permits the function to be invoked with some other number of arguments. The behaviour of an AsyncGeneratorFunction when invoked on a number of arguments other than the number specified by its `"length"` property depends on the function.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorfunction-instance-name">
        <h1>name</h1>
        <p>The specification for the `name` property of Function instances given in <emu-xref href="#sec-function-instances-name"></emu-xref> also applies to AsyncGeneratorFunction instances.</p>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorfunction-instance-prototype">
        <h1>prototype</h1>
        <p>Whenever an AsyncGeneratorFunction instance is created another ordinary object is also created and is the initial value of the async generator function's `prototype` property. The value of the prototype property is used to initialize the [[Prototype]] internal slot of a newly created AsyncGenerator object when the generator function object is invoked using [[Call]].</p>
        <p>This property has the attributes { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        <emu-note>
          <p>Unlike function instances, the object that is the value of the an AsyncGeneratorFunction's `prototype` property does not have a `constructor` property whose value is the AsyncGeneratorFunction instance.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-generator-objects">
    <h1>Generator Objects</h1>
    <p>A Generator object is an instance of a generator function and conforms to both the <i>Iterator</i> and <i>Iterable</i> interfaces.</p>
    <p>Generator instances directly inherit properties from the object that is the value of the `prototype` property of the Generator function that created the instance. Generator instances indirectly inherit properties from the Generator Prototype intrinsic, %GeneratorPrototype%.</p>

    <emu-clause id="sec-properties-of-generator-prototype">
      <h1>Properties of the Generator Prototype Object</h1>
      <p>The Generator prototype object:</p>
      <ul>
        <li>is the intrinsic object <dfn>%GeneratorPrototype%</dfn>.</li>
        <li>is the initial value of the `prototype` property of the intrinsic object %Generator% (the GeneratorFunction.prototype).</li>
        <li>is an ordinary object.</li>
        <li>is not a Generator instance and does not have a [[GeneratorState]] internal slot.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %IteratorPrototype%.</li>
        <li>has properties that are indirectly inherited by all Generator instances.</li>
      </ul>

      <emu-clause id="sec-generator.prototype.constructor">
        <h1>Generator.prototype.constructor</h1>
        <p>The initial value of `Generator.prototype.constructor` is the intrinsic object %Generator%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-generator.prototype.next">
        <h1>Generator.prototype.next ( _value_ )</h1>
        <p>The `next` method performs the following steps:</p>
        <emu-alg>
          1. Let _g_ be the *this* value.
          1. Return ? GeneratorResume(_g_, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generator.prototype.return">
        <h1>Generator.prototype.return ( _value_ )</h1>
        <p>The `return` method performs the following steps:</p>
        <emu-alg>
          1. Let _g_ be the *this* value.
          1. Let _C_ be Completion { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }.
          1. Return ? GeneratorResumeAbrupt(_g_, _C_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generator.prototype.throw">
        <h1>Generator.prototype.throw ( _exception_ )</h1>
        <p>The `throw` method performs the following steps:</p>
        <emu-alg>
          1. Let _g_ be the *this* value.
          1. Let _C_ be ThrowCompletion(_exception_).
          1. Return ? GeneratorResumeAbrupt(_g_, _C_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generator.prototype-@@tostringtag">
        <h1>Generator.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value `"Generator"`.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-generator-instances">
      <h1>Properties of Generator Instances</h1>
      <p>Generator instances are initially created with the internal slots described in <emu-xref href="#table-56"></emu-xref>.</p>
      <emu-table id="table-56" caption="Internal Slots of Generator Instances">
        <table>
          <tbody>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[GeneratorState]]
            </td>
            <td>
              The current execution state of the generator. The possible values are: *undefined*, `"suspendedStart"`, `"suspendedYield"`, `"executing"`, and `"completed"`.
            </td>
          </tr>
          <tr>
            <td>
              [[GeneratorContext]]
            </td>
            <td>
              The execution context that is used when executing the code of this generator.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-generator-abstract-operations">
      <h1>Generator Abstract Operations</h1>

      <emu-clause id="sec-generatorstart" aoid="GeneratorStart">
        <h1>GeneratorStart ( _generator_, _generatorBody_ )</h1>
        <p>The abstract operation GeneratorStart with arguments _generator_ and _generatorBody_ performs the following steps:</p>
        <emu-alg>
          1. Assert: The value of _generator_.[[GeneratorState]] is *undefined*.
          1. Let _genContext_ be the running execution context.
          1. Set the Generator component of _genContext_ to _generator_.
          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context the following steps will be performed:
            1. Let _result_ be the result of evaluating _generatorBody_.
            1. Assert: If we return here, the generator either threw an exception or performed either an implicit or explicit return.
            1. Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
            1. Set _generator_.[[GeneratorState]] to `"completed"`.
            1. Once a generator enters the `"completed"` state it never leaves it and its associated execution context is never resumed. Any execution state associated with _generator_ can be discarded at this point.
            1. If _result_.[[Type]] is ~normal~, let _resultValue_ be *undefined*.
            1. Else if _result_.[[Type]] is ~return~, let _resultValue_ be _result_.[[Value]].
            1. Else,
              1. Assert: _result_.[[Type]] is ~throw~.
              1. Return Completion(_result_).
            1. Return CreateIterResultObject(_resultValue_, *true*).
          1. Set _generator_.[[GeneratorContext]] to _genContext_.
          1. Set _generator_.[[GeneratorState]] to `"suspendedStart"`.
          1. Return NormalCompletion(*undefined*).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorvalidate" aoid="GeneratorValidate">
        <h1>GeneratorValidate ( _generator_ )</h1>
        <p>The abstract operation GeneratorValidate with argument _generator_ performs the following steps:</p>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_generator_, [[GeneratorState]]).
          1. Assert: _generator_ also has a [[GeneratorContext]] internal slot.
          1. Let _state_ be _generator_.[[GeneratorState]].
          1. If _state_ is `"executing"`, throw a *TypeError* exception.
          1. Return _state_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorresume" aoid="GeneratorResume">
        <h1>GeneratorResume ( _generator_, _value_ )</h1>
        <p>The abstract operation GeneratorResume with arguments _generator_ and _value_ performs the following steps:</p>
        <emu-alg>
          1. Let _state_ be ? GeneratorValidate(_generator_).
          1. If _state_ is `"completed"`, return CreateIterResultObject(*undefined*, *true*).
          1. Assert: _state_ is either `"suspendedStart"` or `"suspendedYield"`.
          1. Let _genContext_ be _generator_.[[GeneratorContext]].
          1. Let _methodContext_ be the running execution context.
          1. Suspend _methodContext_.
          1. Set _generator_.[[GeneratorState]] to `"executing"`.
          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.
          1. Resume the suspended evaluation of _genContext_ using NormalCompletion(_value_) as the result of the operation that suspended it. Let _result_ be the value returned by the resumed computation.
          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _methodContext_ is the currently running execution context.
          1. Return Completion(_result_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorresumeabrupt" aoid="GeneratorResumeAbrupt">
        <h1>GeneratorResumeAbrupt ( _generator_, _abruptCompletion_ )</h1>
        <p>The abstract operation GeneratorResumeAbrupt with arguments _generator_ and _abruptCompletion_ performs the following steps:</p>
        <emu-alg>
          1. Let _state_ be ? GeneratorValidate(_generator_).
          1. If _state_ is `"suspendedStart"`, then
            1. Set _generator_.[[GeneratorState]] to `"completed"`.
            1. Once a generator enters the `"completed"` state it never leaves it and its associated execution context is never resumed. Any execution state associated with _generator_ can be discarded at this point.
            1. Set _state_ to `"completed"`.
          1. If _state_ is `"completed"`, then
            1. If _abruptCompletion_.[[Type]] is ~return~, then
              1. Return CreateIterResultObject(_abruptCompletion_.[[Value]], *true*).
            1. Return Completion(_abruptCompletion_).
          1. Assert: _state_ is `"suspendedYield"`.
          1. Let _genContext_ be _generator_.[[GeneratorContext]].
          1. Let _methodContext_ be the running execution context.
          1. Suspend _methodContext_.
          1. Set _generator_.[[GeneratorState]] to `"executing"`.
          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.
          1. Resume the suspended evaluation of _genContext_ using _abruptCompletion_ as the result of the operation that suspended it. Let _result_ be the completion record returned by the resumed computation.
          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _methodContext_ is the currently running execution context.
          1. Return Completion(_result_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getgeneratorkind" aoid="GetGeneratorKind">
        <h1>GetGeneratorKind ( )</h1>
        <emu-alg>
          1. Let _genContext_ be the running execution context.
          1. If _genContext_ does not have a Generator component, return ~non-generator~.
          1. Let _generator_ be the Generator component of _genContext_.
          1. If _generator_ has an [[AsyncGeneratorState]] internal slot, return ~async~.
          1. Else, return ~sync~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatoryield" aoid="GeneratorYield">
        <h1>GeneratorYield ( _iterNextObj_ )</h1>
        <p>The abstract operation GeneratorYield with argument _iterNextObj_ performs the following steps:</p>
        <emu-alg>
          1. Assert: _iterNextObj_ is an Object that implements the <i>IteratorResult</i> interface.
          1. Let _genContext_ be the running execution context.
          1. Assert: _genContext_ is the execution context of a generator.
          1. Let _generator_ be the value of the Generator component of _genContext_.
          1. Assert: GetGeneratorKind() is ~sync~.
          1. Set _generator_.[[GeneratorState]] to `"suspendedYield"`.
          1. Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed with a Completion _resumptionValue_ the following steps will be performed:
            1. Return _resumptionValue_.
            1. NOTE: This returns to the evaluation of the |YieldExpression| that originally called this abstract operation.
          1. Return NormalCompletion(_iterNextObj_).
          1. NOTE: This returns to the evaluation of the operation that had most previously resumed evaluation of _genContext_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-asyncgenerator-objects">
    <h1>AsyncGenerator Objects</h1>
    <p>An AsyncGenerator object is an instance of an async generator function and conforms to both the AsyncIterator and AsyncIterable interfaces.</p>

    <p>AsyncGenerator instances directly inherit properties from the object that is the value of the `prototype` property of the AsyncGenerator function that created the instance. AsyncGenerator instances indirectly inherit properties from the AsyncGenerator Prototype intrinsic, %AsyncGeneratorPrototype%.</p>

    <emu-clause id="sec-properties-of-asyncgenerator-prototype">
      <h1>Properties of the AsyncGenerator Prototype Object</h1>
      <p>The AsyncGenerator prototype object:</p>
      <ul>
        <li>is the intrinsic object <dfn>%AsyncGeneratorPrototype%</dfn>.</li>
        <li>is the initial value of the `prototype` property of the intrinsic object %AsyncGenerator% (the AsyncGeneratorFunction.prototype).</li>
        <li>is an ordinary object.</li>
        <li>is not an AsyncGenerator instance and does not have an [[AsyncGeneratorState]] internal slot.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %AsyncIteratorPrototype%.</li>
        <li>has properties that are indirectly inherited by all AsyncGenerator instances.</li>
      </ul>

      <emu-clause id="sec-asyncgenerator-prototype-constructor">
        <h1>AsyncGenerator.prototype.constructor</h1>
        <p>The initial value of `AsyncGenerator.prototype.constructor` is the intrinsic object %AsyncGenerator%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-asyncgenerator-prototype-next">
        <h1>AsyncGenerator.prototype.next ( _value_ )</h1>
        <emu-alg>
          1. Let _generator_ be the *this* value.
          1. Let _completion_ be NormalCompletion(_value_).
          1. Return ! AsyncGeneratorEnqueue(_generator_, _completion_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgenerator-prototype-return">
        <h1>AsyncGenerator.prototype.return ( _value_ )</h1>
        <emu-alg>
          1. Let _generator_ be the *this* value.
          1. Let _completion_ be Completion { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }.
          1. Return ! AsyncGeneratorEnqueue(_generator_, _completion_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgenerator-prototype-throw">
        <h1>AsyncGenerator.prototype.throw ( _exception_ )</h1>
        <emu-alg>
          1. Let _generator_ be the *this* value.
          1. Let _completion_ be ThrowCompletion(_exception_).
          1. Return ! AsyncGeneratorEnqueue(_generator_, _completion_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgenerator-prototype-tostringtag">
        <h1>AsyncGenerator.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value `"AsyncGenerator"`.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

    </emu-clause>

    <emu-clause id="sec-properties-of-asyncgenerator-intances">
      <h1>Properties of AsyncGenerator Instances</h1>
      <p>AsyncGenerator instances are initially created with the internal slots described below:</p>
      <emu-table id="table-internal-slots-of-asyncgenerator-instances" caption="Internal Slots of AsyncGenerator Instances">
        <table>
          <tbody>
          <tr>
            <th>Internal Slot</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>[[AsyncGeneratorState]]</td>
            <td>The current execution state of the async generator. The possible values are: *undefined*, `"suspendedStart"`, `"suspendedYield"`, `"executing"`, `"awaiting-return"`, and `"completed"`.</td>
          </tr>
          <tr>
            <td>[[AsyncGeneratorContext]]</td>
            <td>The execution context that is used when executing the code of this async generator.</td>
          </tr>
          <tr>
            <td>[[AsyncGeneratorQueue]]</td>
            <td>A List of AsyncGeneratorRequest records which represent requests to resume the async generator.</td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-asyncgenerator-abstract-operations">
      <h1>AsyncGenerator Abstract Operations</h1>
      <emu-clause id="sec-asyncgeneratorrequest-records">
        <h1>AsyncGeneratorRequest Records</h1>
        <p>The AsyncGeneratorRequest is a Record value used to store information about how an async generator should be resumed and contains capabilities for fulfilling or rejecting the corresponding promise.</p>
        <p>They have the following fields:</p>
        <emu-table caption="AsyncGeneratorRequest Record Fields">
          <table>
            <tbody>
            <tr>
              <th>Field Name</th>
              <th>Value</th>
              <th>Meaning</th>
            </tr>
            <tr>
              <td>[[Completion]]</td>
              <td>A Completion record</td>
              <td>The completion which should be used to resume the async generator.</td>
            </tr>
            <tr>
              <td>[[Capability]]</td>
              <td>A PromiseCapability record</td>
              <td>The promise capabilities associated with this request.</td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorstart" aoid="AsyncGeneratorStart">
        <h1>AsyncGeneratorStart ( _generator_, _generatorBody_ )</h1>
        <emu-alg>
          1. Assert: _generator_ is an AsyncGenerator instance.
          1. Assert: _generator_.[[AsyncGeneratorState]] is *undefined*.
          1. Let _genContext_ be the running execution context.
          1. Set the Generator component of _genContext_ to _generator_.
          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context the following steps will be performed:
            1. Let _result_ be the result of evaluating _generatorBody_.
            1. Assert: If we return here, the async generator either threw an exception or performed either an implicit or explicit return.
            1. Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
            1. Set _generator_.[[AsyncGeneratorState]] to `"completed"`.
            1. If _result_ is a normal completion, let _resultValue_ be *undefined*.
            1. Else,
              1. Let _resultValue_ be _result_.[[Value]].
              1. If _result_.[[Type]] is not ~return~, then
                1. Return ! AsyncGeneratorReject(_generator_, _resultValue_).
            1. Return ! AsyncGeneratorResolve(_generator_, _resultValue_, *true*).
          1. Set _generator_.[[AsyncGeneratorContext]] to _genContext_.
          1. Set _generator_.[[AsyncGeneratorState]] to `"suspendedStart"`.
          1. Set _generator_.[[AsyncGeneratorQueue]] to a new empty List.
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorresolve" aoid="AsyncGeneratorResolve">
        <h1>AsyncGeneratorResolve ( _generator_, _value_, _done_ )</h1>
        <emu-alg>
          1. Assert: _generator_ is an AsyncGenerator instance.
          1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].
          1. Assert: _queue_ is not an empty List.
          1. Remove the first element from _queue_ and let _next_ be the value of that element.
          1. Let _promiseCapability_ be _next_.[[Capability]].
          1. Let _iteratorResult_ be ! CreateIterResultObject(_value_, _done_).
          1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _iteratorResult_ &raquo;).
          1. Perform ! AsyncGeneratorResumeNext(_generator_).
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorreject" aoid="AsyncGeneratorReject">
        <h1>AsyncGeneratorReject ( _generator_, _exception_ )</h1>
        <emu-alg>
          1. Assert: _generator_ is an AsyncGenerator instance.
          1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].
          1. Assert: _queue_ is not an empty List.
          1. Remove the first element from _queue_ and let _next_ be the value of that element.
          1. Let _promiseCapability_ be _next_.[[Capability]].
          1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _exception_ &raquo;).
          1. Perform ! AsyncGeneratorResumeNext(_generator_).
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorresumenext" aoid="AsyncGeneratorResumeNext">
        <h1>AsyncGeneratorResumeNext ( _generator_ )</h1>
        <emu-alg>
          1. Assert: _generator_ is an AsyncGenerator instance.
          1. Let _state_ be _generator_.[[AsyncGeneratorState]].
          1. Assert: _state_ is not `"executing"`.
          1. If _state_ is `"awaiting-return"`, return *undefined*.
          1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].
          1. If _queue_ is an empty List, return *undefined*.
          1. Let _next_ be the value of the first element of _queue_.
          1. Assert: _next_ is an AsyncGeneratorRequest record.
          1. Let _completion_ be _next_.[[Completion]].
          1. If _completion_ is an abrupt completion, then
            1. If _state_ is `"suspendedStart"`, then
              1. Set _generator_.[[AsyncGeneratorState]] to `"completed"`.
              1. Set _state_ to `"completed"`.
            1. If _state_ is `"completed"`, then
              1. If _completion_.[[Type]] is ~return~, then
                1. Set _generator_.[[AsyncGeneratorState]] to `"awaiting-return"`.
                1. Let _promise_ be ? PromiseResolve(%Promise%, _completion_.[[Value]]).
                1. Let _stepsFulfilled_ be the algorithm steps defined in <emu-xref href="#async-generator-resume-next-return-processor-fulfilled" title></emu-xref>.
                1. Let _onFulfilled_ be CreateBuiltinFunction(_stepsFulfilled_, &laquo; [[Generator]] &raquo;).
                1. Set _onFulfilled_.[[Generator]] to _generator_.
                1. Let _stepsRejected_ be the algorithm steps defined in <emu-xref href="#async-generator-resume-next-return-processor-rejected" title></emu-xref>.
                1. Let _onRejected_ be CreateBuiltinFunction(_stepsRejected_, &laquo; [[Generator]] &raquo;).
                1. Set _onRejected_.[[Generator]] to _generator_.
                1. Perform ! PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_).
                1. Return *undefined*.
              1. Else,
                1. Assert: _completion_.[[Type]] is ~throw~.
                1. Perform ! AsyncGeneratorReject(_generator_, _completion_.[[Value]]).
                1. Return *undefined*.
          1. Else if _state_ is `"completed"`, return ! AsyncGeneratorResolve(_generator_, *undefined*, *true*).
          1. Assert: _state_ is either `"suspendedStart"` or `"suspendedYield"`.
          1. Let _genContext_ be _generator_.[[AsyncGeneratorContext]].
          1. Let _callerContext_ be the running execution context.
          1. Suspend _callerContext_.
          1. Set _generator_.[[AsyncGeneratorState]] to `"executing"`.
          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.
          1. Resume the suspended evaluation of _genContext_ using _completion_ as the result of the operation that suspended it. Let _result_ be the completion record returned by the resumed computation.
          1. Assert: _result_ is never an abrupt completion.
          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _callerContext_ is the currently running execution context.
          1. Return *undefined*.
        </emu-alg>

        <emu-clause id="async-generator-resume-next-return-processor-fulfilled">
          <h1>AsyncGeneratorResumeNext Return Processor Fulfilled Functions</h1>

          <p>An AsyncGeneratorResumeNext return processor fulfilled function is an anonymous built-in function that is used as part of the AsyncGeneratorResumeNext specification device to unwrap promises passed in to the <emu-xref href="#sec-asyncgenerator-prototype-return" title></emu-xref> method. Each AsyncGeneratorResumeNext return processor fulfilled function has a [[Generator]] internal slot.</p>

          <p>When an AsyncGeneratorResumeNext return processor fulfilled function is called with argument _value_, the following steps are taken:</p>

          <emu-alg>
            1. Let _F_ be the active function object.
            1. Set _F_.[[Generator]].[[AsyncGeneratorState]] to `"completed"`.
            1. Return ! AsyncGeneratorResolve(_F_.[[Generator]], _value_, *true*).
          </emu-alg>

          <p>The `"length"` property of an AsyncGeneratorResumeNext return processor fulfilled function is 1.</p>
        </emu-clause>

        <emu-clause id="async-generator-resume-next-return-processor-rejected">
          <h1>AsyncGeneratorResumeNext Return Processor Rejected Functions</h1>

          <p>An AsyncGeneratorResumeNext return processor rejected function is an anonymous built-in function that is used as part of the AsyncGeneratorResumeNext specification device to unwrap promises passed in to the <emu-xref href="#sec-asyncgenerator-prototype-return" title></emu-xref> method. Each AsyncGeneratorResumeNext return processor rejected function has a [[Generator]] internal slot.</p>

          <p>When an AsyncGeneratorResumeNext return processor rejected function is called with argument _reason_, the following steps are taken:</p>

          <emu-alg>
            1. Let _F_ be the active function object.
            1. Set _F_.[[Generator]].[[AsyncGeneratorState]] to `"completed"`.
            1. Return ! AsyncGeneratorReject(_F_.[[Generator]], _reason_).
          </emu-alg>

          <p>The `"length"` property of an AsyncGeneratorResumeNext return processor rejected function is 1.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorenqueue" aoid="AsyncGeneratorEnqueue">
        <h1>AsyncGeneratorEnqueue ( _generator_, _completion_ )</h1>
        <emu-alg>
          1. Assert: _completion_ is a Completion Record.
          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
          1. If Type(_generator_) is not Object, or if _generator_ does not have an [[AsyncGeneratorState]] internal slot, then
            1. Let _badGeneratorError_ be a newly created *TypeError* object.
            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _badGeneratorError_ &raquo;).
            1. Return _promiseCapability_.[[Promise]].
          1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].
          1. Let _request_ be AsyncGeneratorRequest { [[Completion]]: _completion_, [[Capability]]: _promiseCapability_ }.
          1. Append _request_ to the end of _queue_.
          1. Let _state_ be _generator_.[[AsyncGeneratorState]].
          1. If _state_ is not `"executing"`, then
            1. Perform ! AsyncGeneratorResumeNext(_generator_).
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratoryield" aoid="AsyncGeneratorYield">
        <h1>AsyncGeneratorYield ( _value_ )</h1>
        <p>The abstract operation AsyncGeneratorYield with argument _value_ performs the following steps:</p>
        <emu-alg>
          1. Let _genContext_ be the running execution context.
          1. Assert: _genContext_ is the execution context of a generator.
          1. Let _generator_ be the value of the Generator component of _genContext_.
          1. Assert: GetGeneratorKind() is ~async~.
          1. Set _value_ to ? Await(_value_).
          1. Set _generator_.[[AsyncGeneratorState]] to `"suspendedYield"`.
          1. Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed with a Completion _resumptionValue_ the following steps will be performed:
            1. If _resumptionValue_.[[Type]] is not ~return~, return Completion(_resumptionValue_).
            1. Let _awaited_ be Await(_resumptionValue_.[[Value]]).
            1. If _awaited_.[[Type]] is ~throw~, return Completion(_awaited_).
            1. Assert: _awaited_.[[Type]] is ~normal~.
            1. Return Completion { [[Type]]: ~return~, [[Value]]: _awaited_.[[Value]], [[Target]]: ~empty~ }.
            1. NOTE: When one of the above steps returns, it returns to the evaluation of the |YieldExpression| production that originally called this abstract operation.
          1. Return ! AsyncGeneratorResolve(_generator_, _value_, *false*).
          1. NOTE: This returns to the evaluation of the operation that had most previously resumed evaluation of _genContext_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-promise-objects">
    <h1>Promise Objects</h1>
    <p>A Promise is an object that is used as a placeholder for the eventual results of a deferred (and possibly asynchronous) computation.</p>
    <p>Any Promise object is in one of three mutually exclusive states: <em>fulfilled</em>, <em>rejected</em>, and <em>pending</em>:</p>
    <ul>
      <li>
        A promise `p` is fulfilled if `p.then(f, r)` will immediately enqueue a Job to call the function `f`.
      </li>
      <li>
        A promise `p` is rejected if `p.then(f, r)` will immediately enqueue a Job to call the function `r`.
      </li>
      <li>
        A promise is pending if it is neither fulfilled nor rejected.
      </li>
    </ul>
    <p>A promise is said to be <em>settled</em> if it is not pending, i.e. if it is either fulfilled or rejected.</p>
    <p>A promise is <em>resolved</em> if it is settled or if it has been &ldquo;locked in&rdquo; to match the state of another promise. Attempting to resolve or reject a resolved promise has no effect. A promise is <em>unresolved</em> if it is not resolved. An unresolved promise is always in the pending state. A resolved promise may be pending, fulfilled or rejected.</p>

    <emu-clause id="sec-promise-abstract-operations">
      <h1>Promise Abstract Operations</h1>

      <emu-clause id="sec-promisecapability-records">
        <h1>PromiseCapability Records</h1>
        <p>A PromiseCapability is a Record value used to encapsulate a promise object along with the functions that are capable of resolving or rejecting that promise object. PromiseCapability Records are produced by the NewPromiseCapability abstract operation.</p>
        <p>PromiseCapability Records have the fields listed in <emu-xref href="#table-57"></emu-xref>.</p>
        <emu-table id="table-57" caption="PromiseCapability Record Fields">
          <table>
            <tbody>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[Promise]]
              </td>
              <td>
                An object
              </td>
              <td>
                An object that is usable as a promise.
              </td>
            </tr>
            <tr>
              <td>
                [[Resolve]]
              </td>
              <td>
                A function object
              </td>
              <td>
                The function that is used to resolve the given promise object.
              </td>
            </tr>
            <tr>
              <td>
                [[Reject]]
              </td>
              <td>
                A function object
              </td>
              <td>
                The function that is used to reject the given promise object.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>

        <emu-clause id="sec-ifabruptrejectpromise" aoid="IfAbruptRejectPromise">
          <h1>IfAbruptRejectPromise ( _value_, _capability_ )</h1>
          <p>IfAbruptRejectPromise is a shorthand for a sequence of algorithm steps that use a PromiseCapability Record. An algorithm step of the form:</p>
          <emu-alg>
            1. IfAbruptRejectPromise(_value_, _capability_).
          </emu-alg>
          <p>means the same thing as:</p>
          <emu-alg>
            1. If _value_ is an abrupt completion, then
              1. Perform ? Call(_capability_.[[Reject]], *undefined*, &laquo; _value_.[[Value]] &raquo;).
              1. Return _capability_.[[Promise]].
            1. Else if _value_ is a Completion Record, set _value_ to _value_.[[Value]].
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promisereaction-records">
        <h1>PromiseReaction Records</h1>
        <p>The PromiseReaction is a Record value used to store information about how a promise should react when it becomes resolved or rejected with a given value. PromiseReaction records are created by the PerformPromiseThen abstract operation, and are used by a PromiseReactionJob.</p>
        <p>PromiseReaction records have the fields listed in <emu-xref href="#table-58"></emu-xref>.</p>
        <emu-table id="table-58" caption="PromiseReaction Record Fields">
          <table>
            <tbody>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[Capability]]
              </td>
              <td>
                A PromiseCapability Record, or *undefined*
              </td>
              <td>
                The capabilities of the promise for which this record provides a reaction handler.
              </td>
            </tr>
            <tr>
              <td>
                [[Type]]
              </td>
              <td>
                Either `"Fulfill"` or `"Reject"`.
              </td>
              <td>
                The [[Type]] is used when [[Handler]] is *undefined* to allow for behaviour specific to the settlement type.
              </td>
            </tr>
            <tr>
              <td>
                [[Handler]]
              </td>
              <td>
                A function object or *undefined*.
              </td>
              <td>
                The function that should be applied to the incoming value, and whose return value will govern what happens to the derived promise. If [[Handler]] is *undefined*, a function that depends on the value of [[Type]] will be used instead.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-createresolvingfunctions" aoid="CreateResolvingFunctions">
        <h1>CreateResolvingFunctions ( _promise_ )</h1>
        <p>When CreateResolvingFunctions is performed with argument _promise_, the following steps are taken:</p>
        <emu-alg>
          1. Let _alreadyResolved_ be a new Record { [[Value]]: *false* }.
          1. Let _stepsResolve_ be the algorithm steps defined in Promise Resolve Functions (<emu-xref href="#sec-promise-resolve-functions"></emu-xref>).
          1. Let _resolve_ be CreateBuiltinFunction(_stepsResolve_, &laquo; [[Promise]], [[AlreadyResolved]] &raquo;).
          1. Set _resolve_.[[Promise]] to _promise_.
          1. Set _resolve_.[[AlreadyResolved]] to _alreadyResolved_.
          1. Let _stepsReject_ be the algorithm steps defined in Promise Reject Functions (<emu-xref href="#sec-promise-reject-functions"></emu-xref>).
          1. Let _reject_ be CreateBuiltinFunction(_stepsReject_, &laquo; [[Promise]], [[AlreadyResolved]] &raquo;).
          1. Set _reject_.[[Promise]] to _promise_.
          1. Set _reject_.[[AlreadyResolved]] to _alreadyResolved_.
          1. Return a new Record { [[Resolve]]: _resolve_, [[Reject]]: _reject_ }.
        </emu-alg>

        <emu-clause id="sec-promise-reject-functions">
          <h1>Promise Reject Functions</h1>
          <p>A promise reject function is an anonymous built-in function that has [[Promise]] and [[AlreadyResolved]] internal slots.</p>
          <p>When a promise reject function is called with argument _reason_, the following steps are taken:</p>
          <emu-alg>
            1. Let _F_ be the active function object.
            1. Assert: _F_ has a [[Promise]] internal slot whose value is an Object.
            1. Let _promise_ be _F_.[[Promise]].
            1. Let _alreadyResolved_ be _F_.[[AlreadyResolved]].
            1. If _alreadyResolved_.[[Value]] is *true*, return *undefined*.
            1. Set _alreadyResolved_.[[Value]] to *true*.
            1. Return RejectPromise(_promise_, _reason_).
          </emu-alg>
          <p>The `"length"` property of a promise reject function is 1.</p>
        </emu-clause>

        <emu-clause id="sec-promise-resolve-functions">
          <h1>Promise Resolve Functions</h1>
          <p>A promise resolve function is an anonymous built-in function that has [[Promise]] and [[AlreadyResolved]] internal slots.</p>
          <p>When a promise resolve function is called with argument _resolution_, the following steps are taken:</p>
          <emu-alg>
            1. Let _F_ be the active function object.
            1. Assert: _F_ has a [[Promise]] internal slot whose value is an Object.
            1. Let _promise_ be _F_.[[Promise]].
            1. Let _alreadyResolved_ be _F_.[[AlreadyResolved]].
            1. If _alreadyResolved_.[[Value]] is *true*, return *undefined*.
            1. Set _alreadyResolved_.[[Value]] to *true*.
            1. If SameValue(_resolution_, _promise_) is *true*, then
              1. Let _selfResolutionError_ be a newly created *TypeError* object.
              1. Return RejectPromise(_promise_, _selfResolutionError_).
            1. If Type(_resolution_) is not Object, then
              1. Return FulfillPromise(_promise_, _resolution_).
            1. Let _then_ be Get(_resolution_, `"then"`).
            1. If _then_ is an abrupt completion, then
              1. Return RejectPromise(_promise_, _then_.[[Value]]).
            1. Let _thenAction_ be _then_.[[Value]].
            1. If IsCallable(_thenAction_) is *false*, then
              1. Return FulfillPromise(_promise_, _resolution_).
            1. Perform EnqueueJob(`"PromiseJobs"`, PromiseResolveThenableJob, &laquo; _promise_, _resolution_, _thenAction_ &raquo;).
            1. Return *undefined*.
          </emu-alg>
          <p>The `"length"` property of a promise resolve function is 1.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-fulfillpromise" aoid="FulfillPromise">
        <h1>FulfillPromise ( _promise_, _value_ )</h1>
        <p>When the FulfillPromise abstract operation is called with arguments _promise_ and _value_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: The value of _promise_.[[PromiseState]] is `"pending"`.
          1. Let _reactions_ be _promise_.[[PromiseFulfillReactions]].
          1. Set _promise_.[[PromiseResult]] to _value_.
          1. Set _promise_.[[PromiseFulfillReactions]] to *undefined*.
          1. Set _promise_.[[PromiseRejectReactions]] to *undefined*.
          1. Set _promise_.[[PromiseState]] to `"fulfilled"`.
          1. Return TriggerPromiseReactions(_reactions_, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newpromisecapability" aoid="NewPromiseCapability">
        <h1>NewPromiseCapability ( _C_ )</h1>
        <p>The abstract operation NewPromiseCapability takes a constructor function, and attempts to use that constructor function in the fashion of the built-in `Promise` constructor to create a Promise object and extract its resolve and reject functions. The promise plus the resolve and reject functions are used to initialize a new PromiseCapability Record which is returned as the value of this abstract operation.</p>
        <emu-alg>
          1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.
          1. NOTE: _C_ is assumed to be a constructor function that supports the parameter conventions of the `Promise` constructor (see <emu-xref href="#sec-promise-executor"></emu-xref>).
          1. Let _promiseCapability_ be a new PromiseCapability { [[Promise]]: *undefined*, [[Resolve]]: *undefined*, [[Reject]]: *undefined* }.
          1. Let _steps_ be the algorithm steps defined in <emu-xref href="#sec-getcapabilitiesexecutor-functions" title></emu-xref>.
          1. Let _executor_ be CreateBuiltinFunction(_steps_, &laquo; [[Capability]] &raquo;).
          1. Set _executor_.[[Capability]] to _promiseCapability_.
          1. Let _promise_ be ? Construct(_C_, &laquo; _executor_ &raquo;).
          1. If IsCallable(_promiseCapability_.[[Resolve]]) is *false*, throw a *TypeError* exception.
          1. If IsCallable(_promiseCapability_.[[Reject]]) is *false*, throw a *TypeError* exception.
          1. Set _promiseCapability_.[[Promise]] to _promise_.
          1. Return _promiseCapability_.
        </emu-alg>
        <emu-note>
          <p>This abstract operation supports Promise subclassing, as it is generic on any constructor that calls a passed executor function argument in the same way as the Promise constructor. It is used to generalize static methods of the Promise constructor to any subclass.</p>
        </emu-note>

        <emu-clause id="sec-getcapabilitiesexecutor-functions">
          <h1>GetCapabilitiesExecutor Functions</h1>
          <p>A GetCapabilitiesExecutor function is an anonymous built-in function that has a [[Capability]] internal slot.</p>
          <p>When a GetCapabilitiesExecutor function is called with arguments _resolve_ and _reject_, the following steps are taken:</p>
          <emu-alg>
            1. Let _F_ be the active function object.
            1. Assert: _F_ has a [[Capability]] internal slot whose value is a PromiseCapability Record.
            1. Let _promiseCapability_ be _F_.[[Capability]].
            1. If _promiseCapability_.[[Resolve]] is not *undefined*, throw a *TypeError* exception.
            1. If _promiseCapability_.[[Reject]] is not *undefined*, throw a *TypeError* exception.
            1. Set _promiseCapability_.[[Resolve]] to _resolve_.
            1. Set _promiseCapability_.[[Reject]] to _reject_.
            1. Return *undefined*.
          </emu-alg>
          <p>The `"length"` property of a GetCapabilitiesExecutor function is 2.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-ispromise" aoid="IsPromise">
        <h1>IsPromise ( _x_ )</h1>
        <p>The abstract operation IsPromise checks for the promise brand on an object.</p>
        <emu-alg>
          1. If Type(_x_) is not Object, return *false*.
          1. If _x_ does not have a [[PromiseState]] internal slot, return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-rejectpromise" aoid="RejectPromise">
        <h1>RejectPromise ( _promise_, _reason_ )</h1>
        <p>When the RejectPromise abstract operation is called with arguments _promise_ and _reason_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: The value of _promise_.[[PromiseState]] is `"pending"`.
          1. Let _reactions_ be _promise_.[[PromiseRejectReactions]].
          1. Set _promise_.[[PromiseResult]] to _reason_.
          1. Set _promise_.[[PromiseFulfillReactions]] to *undefined*.
          1. Set _promise_.[[PromiseRejectReactions]] to *undefined*.
          1. Set _promise_.[[PromiseState]] to `"rejected"`.
          1. If _promise_.[[PromiseIsHandled]] is *false*, perform HostPromiseRejectionTracker(_promise_, `"reject"`).
          1. Return TriggerPromiseReactions(_reactions_, _reason_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-triggerpromisereactions" aoid="TriggerPromiseReactions">
        <h1>TriggerPromiseReactions ( _reactions_, _argument_ )</h1>
        <p>The abstract operation TriggerPromiseReactions takes a collection of PromiseReactionRecords and enqueues a new Job for each record. Each such Job processes the [[Type]] and [[Handler]] of the PromiseReactionRecord, and if the [[Handler]] is a function, calls it passing the given argument. If the [[Handler]] is *undefined*, the behaviour is determined by the [[Type]].</p>
        <emu-alg>
          1. For each _reaction_ in _reactions_, in original insertion order, do
            1. Perform EnqueueJob(`"PromiseJobs"`, PromiseReactionJob, &laquo; _reaction_, _argument_ &raquo;).
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-host-promise-rejection-tracker" aoid="HostPromiseRejectionTracker">
        <h1>HostPromiseRejectionTracker ( _promise_, _operation_ )</h1>

        <p>HostPromiseRejectionTracker is an implementation-defined abstract operation that allows host environments to track promise rejections.</p>

        <p>An implementation of HostPromiseRejectionTracker must complete normally in all cases. The default implementation of HostPromiseRejectionTracker is to unconditionally return an empty normal completion.</p>

        <emu-note>
          <p>HostPromiseRejectionTracker is called in two scenarios:</p>

          <ul>
            <li>When a promise is rejected without any handlers, it is called with its _operation_ argument set to `"reject"`.</li>
            <li>When a handler is added to a rejected promise for the first time, it is called with its _operation_ argument set to `"handle"`.</li>
          </ul>

          <p>A typical implementation of HostPromiseRejectionTracker might try to notify developers of unhandled rejections, while also being careful to notify them if such previous notifications are later invalidated by new handlers being attached.</p>
        </emu-note>

        <emu-note>
          <p>If _operation_ is `"handle"`, an implementation should not hold a reference to _promise_ in a way that would interfere with garbage collection. An implementation may hold a reference to _promise_ if _operation_ is `"reject"`, since it is expected that rejections will be rare and not on hot code paths.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-promise-jobs">
      <h1>Promise Jobs</h1>

      <emu-clause id="sec-promisereactionjob" aoid="PromiseReactionJob">
        <h1>PromiseReactionJob ( _reaction_, _argument_ )</h1>
        <p>The job PromiseReactionJob with parameters _reaction_ and _argument_ applies the appropriate handler to the incoming value, and uses the handler's return value to resolve or reject the derived promise associated with that handler.</p>
        <emu-alg>
          1. Assert: _reaction_ is a PromiseReaction Record.
          1. Let _promiseCapability_ be _reaction_.[[Capability]].
          1. Let _type_ be _reaction_.[[Type]].
          1. Let _handler_ be _reaction_.[[Handler]].
          1. If _handler_ is *undefined*, then
            1. If _type_ is `"Fulfill"`, let _handlerResult_ be NormalCompletion(_argument_).
            1. Else,
              1. Assert: _type_ is `"Reject"`.
              1. Let _handlerResult_ be ThrowCompletion(_argument_).
          1. Else, let _handlerResult_ be Call(_handler_, *undefined*, &laquo; _argument_ &raquo;).
          1. If _promiseCapability_ is *undefined*, then
            1. Assert: _handlerResult_ is not an abrupt completion.
            1. Return NormalCompletion(~empty~).
          1. If _handlerResult_ is an abrupt completion, then
            1. Let _status_ be Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _handlerResult_.[[Value]] &raquo;).
          1. Else,
            1. Let _status_ be Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _handlerResult_.[[Value]] &raquo;).
          1. Return Completion(_status_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-promiseresolvethenablejob" aoid="PromiseResolveThenableJob">
        <h1>PromiseResolveThenableJob ( _promiseToResolve_, _thenable_, _then_ )</h1>
        <p>The job PromiseResolveThenableJob with parameters _promiseToResolve_, _thenable_, and _then_ performs the following steps:</p>
        <emu-alg>
          1. Let _resolvingFunctions_ be CreateResolvingFunctions(_promiseToResolve_).
          1. Let _thenCallResult_ be Call(_then_, _thenable_, &laquo; _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]] &raquo;).
          1. If _thenCallResult_ is an abrupt completion, then
            1. Let _status_ be Call(_resolvingFunctions_.[[Reject]], *undefined*, &laquo; _thenCallResult_.[[Value]] &raquo;).
            1. Return Completion(_status_).
          1. Return Completion(_thenCallResult_).
        </emu-alg>
        <emu-note>
          <p>This Job uses the supplied thenable and its `then` method to resolve the given promise. This process must take place as a Job to ensure that the evaluation of the `then` method occurs after evaluation of any surrounding code has completed.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-promise-constructor">
      <h1>The Promise Constructor</h1>
      <p>The Promise constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%Promise%</dfn>.</li>
        <li>is the initial value of the `Promise` property of the global object.</li>
        <li>creates and initializes a new Promise object when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>is designed to be subclassable. It may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `Promise` behaviour must include a `super` call to the `Promise` constructor to create and initialize the subclass instance with the internal state necessary to support the `Promise` and `Promise.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-promise-executor">
        <h1>Promise ( _executor_ )</h1>
        <p>When the `Promise` function is called with argument _executor_, the following steps are taken:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. If IsCallable(_executor_) is *false*, throw a *TypeError* exception.
          1. Let _promise_ be ? OrdinaryCreateFromConstructor(NewTarget, `"%PromisePrototype%"`, &laquo; [[PromiseState]], [[PromiseResult]], [[PromiseFulfillReactions]], [[PromiseRejectReactions]], [[PromiseIsHandled]] &raquo;).
          1. Set _promise_.[[PromiseState]] to `"pending"`.
          1. Set _promise_.[[PromiseFulfillReactions]] to a new empty List.
          1. Set _promise_.[[PromiseRejectReactions]] to a new empty List.
          1. Set _promise_.[[PromiseIsHandled]] to *false*.
          1. Let _resolvingFunctions_ be CreateResolvingFunctions(_promise_).
          1. Let _completion_ be Call(_executor_, *undefined*, &laquo; _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]] &raquo;).
          1. If _completion_ is an abrupt completion, then
            1. Perform ? Call(_resolvingFunctions_.[[Reject]], *undefined*, &laquo; _completion_.[[Value]] &raquo;).
          1. Return _promise_.
        </emu-alg>
        <emu-note>
          <p>The _executor_ argument must be a function object. It is called for initiating and reporting completion of the possibly deferred action represented by this Promise object. The executor is called with two arguments: _resolve_ and _reject_. These are functions that may be used by the _executor_ function to report eventual completion or failure of the deferred computation. Returning from the executor function does not mean that the deferred action has been completed but only that the request to eventually perform the deferred action has been accepted.</p>
          <p>The _resolve_ function that is passed to an _executor_ function accepts a single argument. The _executor_ code may eventually call the _resolve_ function to indicate that it wishes to resolve the associated Promise object. The argument passed to the _resolve_ function represents the eventual value of the deferred action and can be either the actual fulfillment value or another Promise object which will provide the value if it is fulfilled.</p>
          <p>The _reject_ function that is passed to an _executor_ function accepts a single argument. The _executor_ code may eventually call the _reject_ function to indicate that the associated Promise is rejected and will never be fulfilled. The argument passed to the _reject_ function is used as the rejection value of the promise. Typically it will be an `Error` object.</p>
          <p>The resolve and reject functions passed to an _executor_ function by the Promise constructor have the capability to actually resolve and reject the associated promise. Subclasses may have different constructor behaviour that passes in customized values for resolve and reject.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-promise-constructor">
      <h1>Properties of the Promise Constructor</h1>
      <p>The Promise constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-promise.all">
        <h1>Promise.all ( _iterable_ )</h1>
        <p>The `all` function returns a new promise which is fulfilled with an array of fulfillment values for the passed promises, or rejects with the reason of the first passed promise that rejects. It resolves all elements of the passed iterable to promises as it runs this algorithm.</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
          1. Let _iteratorRecord_ be GetIterator(_iterable_).
          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).
          1. Let _result_ be PerformPromiseAll(_iteratorRecord_, _C_, _promiseCapability_).
          1. If _result_ is an abrupt completion, then
            1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to IteratorClose(_iteratorRecord_, _result_).
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. Return Completion(_result_).
        </emu-alg>
        <p>This function is the <dfn>%Promise_all%</dfn> intrinsic object.</p>
        <emu-note>
          <p>The `all` function requires its *this* value to be a constructor function that supports the parameter conventions of the `Promise` constructor.</p>
        </emu-note>

        <emu-clause id="sec-performpromiseall" aoid="PerformPromiseAll">
          <h1>Runtime Semantics: PerformPromiseAll ( _iteratorRecord_, _constructor_, _resultCapability_ )</h1>
          <p>When the PerformPromiseAll abstract operation is called with arguments _iteratorRecord_, _constructor_, and _resultCapability_, the following steps are taken:</p>
          <emu-alg>
            1. Assert: IsConstructor(_constructor_) is *true*.
            1. Assert: _resultCapability_ is a PromiseCapability Record.
            1. Let _values_ be a new empty List.
            1. Let _remainingElementsCount_ be a new Record { [[Value]]: 1 }.
            1. Let _index_ be 0.
            1. Repeat,
              1. Let _next_ be IteratorStep(_iteratorRecord_).
              1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
              1. ReturnIfAbrupt(_next_).
              1. If _next_ is *false*, then
                1. Set _iteratorRecord_.[[Done]] to *true*.
                1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.
                1. If _remainingElementsCount_.[[Value]] is 0, then
                  1. Let _valuesArray_ be CreateArrayFromList(_values_).
                  1. Perform ? Call(_resultCapability_.[[Resolve]], *undefined*, &laquo; _valuesArray_ &raquo;).
                1. Return _resultCapability_.[[Promise]].
              1. Let _nextValue_ be IteratorValue(_next_).
              1. If _nextValue_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
              1. ReturnIfAbrupt(_nextValue_).
              1. Append *undefined* to _values_.
              1. Let _nextPromise_ be ? Invoke(_constructor_, `"resolve"`, &laquo; _nextValue_ &raquo;).
              1. Let _steps_ be the algorithm steps defined in <emu-xref href="#sec-promise.all-resolve-element-functions" title></emu-xref>.
              1. Let _resolveElement_ be CreateBuiltinFunction(_steps_, &laquo; [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] &raquo;).
              1. Set _resolveElement_.[[AlreadyCalled]] to a new Record { [[Value]]: *false* }.
              1. Set _resolveElement_.[[Index]] to _index_.
              1. Set _resolveElement_.[[Values]] to _values_.
              1. Set _resolveElement_.[[Capability]] to _resultCapability_.
              1. Set _resolveElement_.[[RemainingElements]] to _remainingElementsCount_.
              1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] + 1.
              1. Perform ? Invoke(_nextPromise_, `"then"`, &laquo; _resolveElement_, _resultCapability_.[[Reject]] &raquo;).
              1. Increase _index_ by 1.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-promise.all-resolve-element-functions">
          <h1>`Promise.all` Resolve Element Functions</h1>
          <p>A `Promise.all` resolve element function is an anonymous built-in function that is used to resolve a specific `Promise.all` element. Each `Promise.all` resolve element function has [[Index]], [[Values]], [[Capability]], [[RemainingElements]], and [[AlreadyCalled]] internal slots.</p>
          <p>When a `Promise.all` resolve element function is called with argument _x_, the following steps are taken:</p>
          <emu-alg>
            1. Let _F_ be the active function object.
            1. Let _alreadyCalled_ be _F_.[[AlreadyCalled]].
            1. If _alreadyCalled_.[[Value]] is *true*, return *undefined*.
            1. Set _alreadyCalled_.[[Value]] to *true*.
            1. Let _index_ be _F_.[[Index]].
            1. Let _values_ be _F_.[[Values]].
            1. Let _promiseCapability_ be _F_.[[Capability]].
            1. Let _remainingElementsCount_ be _F_.[[RemainingElements]].
            1. Set _values_[_index_] to _x_.
            1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.
            1. If _remainingElementsCount_.[[Value]] is 0, then
              1. Let _valuesArray_ be CreateArrayFromList(_values_).
              1. Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _valuesArray_ &raquo;).
            1. Return *undefined*.
          </emu-alg>
          <p>The `"length"` property of a `Promise.all` resolve element function is 1.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.prototype">
        <h1>Promise.prototype</h1>
        <p>The initial value of `Promise.prototype` is the intrinsic object %PromisePrototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-promise.race">
        <h1>Promise.race ( _iterable_ )</h1>
        <p>The `race` function returns a new promise which is settled in the same way as the first passed promise to settle. It resolves all elements of the passed _iterable_ to promises as it runs this algorithm.</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
          1. Let _iteratorRecord_ be GetIterator(_iterable_).
          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).
          1. Let _result_ be PerformPromiseRace(_iteratorRecord_, _C_, _promiseCapability_).
          1. If _result_ is an abrupt completion, then
            1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to IteratorClose(_iteratorRecord_, _result_).
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. Return Completion(_result_).
        </emu-alg>
        <emu-note>
          <p>If the _iterable_ argument is empty or if none of the promises in _iterable_ ever settle then the pending promise returned by this method will never be settled.</p>
        </emu-note>
        <emu-note>
          <p>The `race` function expects its *this* value to be a constructor function that supports the parameter conventions of the `Promise` constructor. It also expects that its *this* value provides a `resolve` method.</p>
        </emu-note>

        <emu-clause id="sec-performpromiserace" aoid="PerformPromiseRace">
          <h1>Runtime Semantics: PerformPromiseRace ( _iteratorRecord_, _constructor_, _resultCapability_ )</h1>
          <p>When the PerformPromiseRace abstract operation is called with arguments _iteratorRecord_, _constructor_, and _resultCapability_, the following steps are taken:</p>
          <emu-alg>
            1. Assert: IsConstructor(_constructor_) is *true*.
            1. Assert: _resultCapability_ is a PromiseCapability Record.
            1. Repeat,
              1. Let _next_ be IteratorStep(_iteratorRecord_).
              1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
              1. ReturnIfAbrupt(_next_).
              1. If _next_ is *false*, then
                1. Set _iteratorRecord_.[[Done]] to *true*.
                1. Return _resultCapability_.[[Promise]].
              1. Let _nextValue_ be IteratorValue(_next_).
              1. If _nextValue_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
              1. ReturnIfAbrupt(_nextValue_).
              1. Let _nextPromise_ be ? Invoke(_constructor_, `"resolve"`, &laquo; _nextValue_ &raquo;).
              1. Perform ? Invoke(_nextPromise_, `"then"`, &laquo; _resultCapability_.[[Resolve]], _resultCapability_.[[Reject]] &raquo;).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.reject">
        <h1>Promise.reject ( _r_ )</h1>
        <p>The `reject` function returns a new promise rejected with the passed argument.</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
          1. Perform ? Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _r_ &raquo;).
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
        <p>This function is the <dfn>%Promise_reject%</dfn> intrinsic object.</p>
        <emu-note>
          <p>The `reject` function expects its *this* value to be a constructor function that supports the parameter conventions of the `Promise` constructor.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-promise.resolve">
        <h1>Promise.resolve ( _x_ )</h1>
        <p>The `resolve` function returns either a new promise resolved with the passed argument, or the argument itself if the argument is a promise produced by this constructor.</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. If Type(_C_) is not Object, throw a *TypeError* exception.
          1. Return ? PromiseResolve(_C_, _x_).
        </emu-alg>
        <p>This function is the <dfn>%Promise_resolve%</dfn> intrinsic object.</p>
        <emu-note>
          <p>The `resolve` function expects its *this* value to be a constructor function that supports the parameter conventions of the `Promise` constructor.</p>
        </emu-note>

        <emu-clause id="sec-promise-resolve" aoid="PromiseResolve">
          <h1>PromiseResolve ( _C_, _x_ )</h1>
          <p>The abstract operation PromiseResolve, given a constructor and a value, returns a new promise resolved with that value.</p>
          <emu-alg>
            1. Assert: Type(_C_) is Object.
            1. If IsPromise(_x_) is *true*, then
              1. Let _xConstructor_ be ? Get(_x_, `"constructor"`).
              1. If SameValue(_xConstructor_, _C_) is *true*, return _x_.
            1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
            1. Perform ? Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _x_ &raquo;).
            1. Return _promiseCapability_.[[Promise]].
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-get-promise-@@species">
        <h1>get Promise [ @@species ]</h1>
        <p>`Promise[@@species]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the `name` property of this function is `"get [Symbol.species]"`.</p>
        <emu-note>
          <p>Promise prototype methods normally use their `this` object's constructor to create a derived object. However, a subclass constructor may over-ride that default behaviour by redefining its @@species property.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-promise-prototype-object">
      <h1>Properties of the Promise Prototype Object</h1>
      <p>The Promise prototype object:</p>
      <ul>
        <li>is the intrinsic object <dfn>%PromisePrototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[PromiseState]] internal slot or any of the other internal slots of Promise instances.</li>
      </ul>

      <emu-clause id="sec-promise.prototype.catch">
        <h1>Promise.prototype.catch ( _onRejected_ )</h1>
        <p>When the `catch` method is called with argument _onRejected_, the following steps are taken:</p>
        <emu-alg>
          1. Let _promise_ be the *this* value.
          1. Return ? Invoke(_promise_, `"then"`, &laquo; *undefined*, _onRejected_ &raquo;).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-promise.prototype.constructor">
        <h1>Promise.prototype.constructor</h1>
        <p>The initial value of `Promise.prototype.constructor` is the intrinsic object %Promise%.</p>
      </emu-clause>

      <emu-clause id="sec-promise.prototype.finally">
        <h1>Promise.prototype.finally ( _onFinally_ )</h1>
        <p>When the `finally` method is called with argument _onFinally_, the following steps are taken:</p>
        <emu-alg>
          1. Let _promise_ be the *this* value.
          1. If Type(_promise_) is not Object, throw a *TypeError* exception.
          1. Let _C_ be ? SpeciesConstructor(_promise_, %Promise%).
          1. Assert: IsConstructor(_C_) is *true*.
          1. If IsCallable(_onFinally_) is *false*, then
            1. Let _thenFinally_ be _onFinally_.
            1. Let _catchFinally_ be _onFinally_.
          1. Else,
            1. Let _stepsThenFinally_ be the algorithm steps defined in <emu-xref href="#sec-thenfinallyfunctions" title></emu-xref>.
            1. Let _thenFinally_ be CreateBuiltinFunction(_stepsThenFinally_, &laquo; [[Constructor]], [[OnFinally]] &raquo;).
            1. Set _thenFinally_.[[Constructor]] to _C_.
            1. Set _thenFinally_.[[OnFinally]] to _onFinally_.
            1. Let _stepsCatchFinally_ be the algorithm steps defined in <emu-xref href="#sec-catchfinallyfunctions" title></emu-xref>.
            1. Let _catchFinally_ be CreateBuiltinFunction(_stepsCatchFinally_, &laquo; [[Constructor]], [[OnFinally]] &raquo;).
            1. Set _catchFinally_.[[Constructor]] to _C_.
            1. Set _catchFinally_.[[OnFinally]] to _onFinally_.
          1. Return ? Invoke(_promise_, `"then"`, &laquo; _thenFinally_, _catchFinally_ &raquo;).
        </emu-alg>

        <emu-clause id="sec-thenfinallyfunctions">
          <h1>Then Finally Functions</h1>
          <p>A Then Finally function is an anonymous built-in function that has a [[Constructor]] and an [[OnFinally]] internal slot. The value of the [[Constructor]] internal slot is a `Promise`-like constructor function object, and the value of the [[OnFinally]] internal slot is a function object.</p>
          <p>When a Then Finally function is called with argument _value_, the following steps are taken:</p>
          <emu-alg>
            1. Let _F_ be the active function object.
            1. Let _onFinally_ be _F_.[[OnFinally]].
            1. Assert: IsCallable(_onFinally_) is *true*.
            1. Let _result_ be ? Call(_onFinally_, *undefined*).
            1. Let _C_ be _F_.[[Constructor]].
            1. Assert: IsConstructor(_C_) is *true*.
            1. Let _promise_ be ? PromiseResolve(_C_, _result_).
            1. Let _valueThunk_ be equivalent to a function that returns _value_.
            1. Return ? Invoke(_promise_, `"then"`, &laquo; _valueThunk_ &raquo;).
          </emu-alg>
          <p>The `"length"` property of a Then Finally function is *1*.</p>
        </emu-clause>

        <emu-clause id="sec-catchfinallyfunctions">
          <h1>Catch Finally Functions</h1>
          <p>A Catch Finally function is an anonymous built-in function that has a [[Constructor]] and an [[OnFinally]] internal slot. The value of the [[Constructor]] internal slot is a `Promise`-like constructor function object, and the value of the [[OnFinally]] internal slot is a function object.</p>
          <p>When a Catch Finally function is called with argument _reason_, the following steps are taken:</p>
          <emu-alg>
            1. Let _F_ be the active function object.
            1. Let _onFinally_ be _F_.[[OnFinally]].
            1. Assert: IsCallable(_onFinally_) is *true*.
            1. Let _result_ be ? Call(_onFinally_, *undefined*).
            1. Let _C_ be _F_.[[Constructor]].
            1. Assert: IsConstructor(_C_) is *true*.
            1. Let _promise_ be ? PromiseResolve(_C_, _result_).
            1. Let _thrower_ be equivalent to a function that throws _reason_.
            1. Return ? Invoke(_promise_, `"then"`, &laquo; _thrower_ &raquo;).
          </emu-alg>
          <p>The `"length"` property of a Catch Finally function is *1*.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.prototype.then">
        <h1>Promise.prototype.then ( _onFulfilled_, _onRejected_ )</h1>
        <p>When the `then` method is called with arguments _onFulfilled_ and _onRejected_, the following steps are taken:</p>
        <emu-alg>
          1. Let _promise_ be the *this* value.
          1. If IsPromise(_promise_) is *false*, throw a *TypeError* exception.
          1. Let _C_ be ? SpeciesConstructor(_promise_, %Promise%).
          1. Let _resultCapability_ be ? NewPromiseCapability(_C_).
          1. Return PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_, _resultCapability_).
        </emu-alg>
        <p>This function is the <dfn>%PromiseProto_then%</dfn> intrinsic object.</p>

        <emu-clause id="sec-performpromisethen" aoid="PerformPromiseThen">
          <h1>PerformPromiseThen ( _promise_, _onFulfilled_, _onRejected_ [ , _resultCapability_ ] )</h1>
          <p>The abstract operation PerformPromiseThen performs the &ldquo;then&rdquo; operation on _promise_ using _onFulfilled_ and _onRejected_ as its settlement actions. If _resultCapability_ is passed, the result is stored by updating _resultCapability_'s promise. (If it is not passed, then PerformPromiseThen is being called by a specification-internal operation where the result does not matter.)</p>
          <emu-alg>
            1. Assert: IsPromise(_promise_) is *true*.
            1. If _resultCapability_ is present, then
              1. Assert: _resultCapability_ is a PromiseCapability Record.
            1. Else,
              1. Set _resultCapability_ to *undefined*.
            1. If IsCallable(_onFulfilled_) is *false*, then
              1. Set _onFulfilled_ to *undefined*.
            1. If IsCallable(_onRejected_) is *false*, then
              1. Set _onRejected_ to *undefined*.
            1. Let _fulfillReaction_ be the PromiseReaction { [[Capability]]: _resultCapability_, [[Type]]: `"Fulfill"`, [[Handler]]: _onFulfilled_ }.
            1. Let _rejectReaction_ be the PromiseReaction { [[Capability]]: _resultCapability_, [[Type]]: `"Reject"`, [[Handler]]: _onRejected_ }.
            1. If _promise_.[[PromiseState]] is `"pending"`, then
              1. Append _fulfillReaction_ as the last element of the List that is _promise_.[[PromiseFulfillReactions]].
              1. Append _rejectReaction_ as the last element of the List that is _promise_.[[PromiseRejectReactions]].
            1. Else if _promise_.[[PromiseState]] is `"fulfilled"`, then
              1. Let _value_ be _promise_.[[PromiseResult]].
              1. Perform EnqueueJob(`"PromiseJobs"`, PromiseReactionJob, &laquo; _fulfillReaction_, _value_ &raquo;).
            1. Else,
              1. Assert: The value of _promise_.[[PromiseState]] is `"rejected"`.
              1. Let _reason_ be _promise_.[[PromiseResult]].
              1. If _promise_.[[PromiseIsHandled]] is *false*, perform HostPromiseRejectionTracker(_promise_, `"handle"`).
              1. Perform EnqueueJob(`"PromiseJobs"`, PromiseReactionJob, &laquo; _rejectReaction_, _reason_ &raquo;).
            1. Set _promise_.[[PromiseIsHandled]] to *true*.
            1. If _resultCapability_ is *undefined*, then
              1. Return *undefined*.
            1. Else,
              1. Return _resultCapability_.[[Promise]].
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.prototype-@@tostringtag">
        <h1>Promise.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value `"Promise"`.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-promise-instances">
      <h1>Properties of Promise Instances</h1>
      <p>Promise instances are ordinary objects that inherit properties from the Promise prototype object (the intrinsic, %PromisePrototype%). Promise instances are initially created with the internal slots described in <emu-xref href="#table-59"></emu-xref>.</p>
      <emu-table id="table-59" caption="Internal Slots of Promise Instances">
        <table>
          <tbody>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[PromiseState]]
            </td>
            <td>
              A String value that governs how a promise will react to incoming calls to its `then` method. The possible values are: `"pending"`, `"fulfilled"`, and `"rejected"`.
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseResult]]
            </td>
            <td>
              The value with which the promise has been fulfilled or rejected, if any. Only meaningful if [[PromiseState]] is not `"pending"`.
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseFulfillReactions]]
            </td>
            <td>
              A List of PromiseReaction records to be processed when/if the promise transitions from the `"pending"` state to the `"fulfilled"` state.
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseRejectReactions]]
            </td>
            <td>
              A List of PromiseReaction records to be processed when/if the promise transitions from the `"pending"` state to the `"rejected"` state.
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseIsHandled]]
            </td>
            <td>
              A boolean indicating whether the promise has ever had a fulfillment or rejection handler; used in unhandled rejection tracking.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-function-objects">
    <h1>AsyncFunction Objects</h1>
    <p>AsyncFunction objects are functions that are usually created by evaluating |AsyncFunctionDeclaration|s, |AsyncFunctionExpression|s, |AsyncMethod|s, and |AsyncArrowFunction|s. They may also be created by calling the %AsyncFunction% intrinsic.</p>

    <emu-clause id="sec-async-function-constructor">
      <h1>The AsyncFunction Constructor</h1>

      <p>The AsyncFunction constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%AsyncFunction%</dfn>.</li>
        <li>is a subclass of `Function`.</li>
        <li>creates and initializes a new AsyncFunction object when called as a function rather than as a constructor. Thus the function call `AsyncFunction(&hellip;)` is equivalent to the object creation expression `new AsyncFunction(&hellip;)` with the same arguments.</li>
        <li>is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified AsyncFunction behaviour must include a `super` call to the `AsyncFunction` constructor to create and initialize a subclass instance with the internal slots necessary for built-in async function behaviour.</li>
      </ul>

      <emu-clause id="sec-async-function-constructor-arguments">
        <h1>AsyncFunction ( _p1_, _p2_, &hellip; , _pn_, _body_ )</h1>

        <p>The last argument specifies the body (executable code) of an async function. Any preceding arguments specify formal parameters.</p>

        <p>When the `AsyncFunction` function is called with some arguments _p1_, _p2_, &hellip;, _pn_, _body_ (where _n_ might be 0, that is, there are no _p_ arguments, and where _body_ might also not be provided), the following steps are taken:</p>

        <emu-alg>
          1. Let _C_ be the active function object.
          2. Let _args_ be the _argumentsList_ that was passed to this function by [[Call]] or [[Construct]].
          3. Return CreateDynamicFunction(_C_, NewTarget, `"async"`, _args_).
        </emu-alg>

        <emu-note>See NOTE for <emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref>.</emu-note>
      </emu-clause>
    </emu-clause>
    <emu-clause id="sec-async-function-constructor-properties">
      <h1>Properties of the AsyncFunction Constructor</h1>

      <p>The AsyncFunction constructor:</p>
      <ul>
        <li>is a standard built-in function object that inherits from the `Function` constructor.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %Function%.</li>
        <li>has a `name` property whose value is `"AsyncFunction"`.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-async-function-constructor-length">
        <h1>AsyncFunction.length</h1>
        <p>This is a data property with a value of 1. This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-async-function-constructor-prototype">
        <h1>AsyncFunction.prototype</h1>
        <p>The initial value of `AsyncFunction.prototype` is the intrinsic object %AsyncFunctionPrototype%.</p>

        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>
    <emu-clause id="sec-async-function-prototype-properties">
      <h1>Properties of the AsyncFunction Prototype Object</h1>
      <p>The AsyncFunction prototype object:</p>
      <ul>
        <li>is an ordinary object.</li>
        <li>is not a function object and does not have an [[ECMAScriptCode]] internal slot or any other of the internal slots listed in <emu-xref href="#table-27"></emu-xref>.</li>
        <li>is the value of the `prototype` property of the intrinsic object %AsyncFunction%.</li>
        <li>is the intrinsic object <dfn>%AsyncFunctionPrototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.</li>
      </ul>

      <emu-clause id="sec-async-function-prototype-properties-constructor">
        <h1>AsyncFunction.prototype.constructor</h1>

        <p>The initial value of `AsyncFunction.prototype.constructor` is the intrinsic object %AsyncFunction%</p>

        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-async-function-prototype-properties-toStringTag">
        <h1>AsyncFunction.prototype [ @@toStringTag ]</h1>

        <p>The initial value of the @@toStringTag property is the string value `"AsyncFunction"`.</p>

        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-function-instances">
      <h1>AsyncFunction Instances</h1>

      <p>Every AsyncFunction instance is an ECMAScript function object and has the internal slots listed in <emu-xref href="#table-27"></emu-xref>. The value of the [[FunctionKind]] internal slot for all such instances is `"async"`. AsyncFunction instances are not constructors and do not have a [[Construct]] internal method. AsyncFunction instances do not have a prototype property as they are not constructable.</p>
      <p>Each AsyncFunction instance has the following own properties:</p>
      <emu-clause id="sec-async-function-instances-length">
        <h1>length</h1>
        <p>The specification for the `"length"` property of Function instances given in <emu-xref href="#sec-function-instances-length"></emu-xref> also applies to AsyncFunction instances.</p>
      </emu-clause>

      <emu-clause id="sec-async-function-instances-name">
        <h1>name</h1>
        <p>The specification for the `name` property of Function instances given in <emu-xref href="#sec-function-instances-name"></emu-xref> also applies to AsyncFunction instances.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-functions-abstract-operations">
      <h1>Async Functions Abstract Operations</h1>

      <emu-clause id="sec-async-functions-abstract-operations-async-function-start" aoid="AsyncFunctionStart">
        <h1>AsyncFunctionStart ( _promiseCapability_, _asyncFunctionBody_ )</h1>
        <emu-alg>
          1. Let _runningContext_ be the running execution context.
          1. Let _asyncContext_ be a copy of _runningContext_.
          1. Set the code evaluation state of _asyncContext_ such that when evaluation is resumed for that execution context the following steps will be performed:
            1. Let _result_ be the result of evaluating _asyncFunctionBody_.
            1. Assert: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.
            1. Remove _asyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
            1. If _result_.[[Type]] is ~normal~, then
              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; *undefined* &raquo;).
            1. Else if _result_.[[Type]] is ~return~, then
              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _result_.[[Value]] &raquo;).
            1. Else,
              1. Assert: _result_.[[Type]] is ~throw~.
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _result_.[[Value]] &raquo;).
            1. Return.
          1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.
          1. Resume the suspended evaluation of _asyncContext_. Let _result_ be the value returned by the resumed computation.
          1. Assert: When we return here, _asyncContext_ has already been removed from the execution context stack and _runningContext_ is the currently running execution context.
          1. Assert: _result_ is a normal completion with a value of *undefined*. The possible sources of completion values are Await or, if the async function doesn't await anything, the step 3.g above.
          1. Return.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-reflection">
  <h1>Reflection</h1>

  <emu-clause id="sec-reflect-object">
    <h1>The Reflect Object</h1>
    <p>The Reflect object:</p>
    <ul>
      <li>is the intrinsic object <dfn>%Reflect%</dfn>.</li>
      <li>is the initial value of the `Reflect` property of the global object.</li>
      <li>is an ordinary object.</li>
      <li>has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.</li>
      <li>is not a function object.</li>
      <li>does not have a [[Construct]] internal method; it cannot be used as a constructor with the `new` operator.</li>
      <li>does not have a [[Call]] internal method; it cannot be invoked as a function.</li>
    </ul>

    <emu-clause id="sec-reflect.apply">
      <h1>Reflect.apply ( _target_, _thisArgument_, _argumentsList_ )</h1>
      <p>When the `apply` function is called with arguments _target_, _thisArgument_, and _argumentsList_, the following steps are taken:</p>
      <emu-alg>
        1. If IsCallable(_target_) is *false*, throw a *TypeError* exception.
        1. Let _args_ be ? CreateListFromArrayLike(_argumentsList_).
        1. Perform PrepareForTailCall().
        1. Return ? Call(_target_, _thisArgument_, _args_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.construct">
      <h1>Reflect.construct ( _target_, _argumentsList_ [ , _newTarget_ ] )</h1>
      <p>When the `construct` function is called with arguments _target_, _argumentsList_, and _newTarget_, the following steps are taken:</p>
      <emu-alg>
        1. If IsConstructor(_target_) is *false*, throw a *TypeError* exception.
        1. If _newTarget_ is not present, set _newTarget_ to _target_.
        1. Else if IsConstructor(_newTarget_) is *false*, throw a *TypeError* exception.
        1. Let _args_ be ? CreateListFromArrayLike(_argumentsList_).
        1. Return ? Construct(_target_, _args_, _newTarget_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.defineproperty">
      <h1>Reflect.defineProperty ( _target_, _propertyKey_, _attributes_ )</h1>
      <p>When the `defineProperty` function is called with arguments _target_, _propertyKey_, and _attributes_, the following steps are taken:</p>
      <emu-alg>
        1. If Type(_target_) is not Object, throw a *TypeError* exception.
        1. Let _key_ be ? ToPropertyKey(_propertyKey_).
        1. Let _desc_ be ? ToPropertyDescriptor(_attributes_).
        1. Return ? _target_.[[DefineOwnProperty]](_key_, _desc_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.deleteproperty">
      <h1>Reflect.deleteProperty ( _target_, _propertyKey_ )</h1>
      <p>When the `deleteProperty` function is called with arguments _target_ and _propertyKey_, the following steps are taken:</p>
      <emu-alg>
        1. If Type(_target_) is not Object, throw a *TypeError* exception.
        1. Let _key_ be ? ToPropertyKey(_propertyKey_).
        1. Return ? _target_.[[Delete]](_key_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.get">
      <h1>Reflect.get ( _target_, _propertyKey_ [ , _receiver_ ] )</h1>
      <p>When the `get` function is called with arguments _target_, _propertyKey_, and _receiver_, the following steps are taken:</p>
      <emu-alg>
        1. If Type(_target_) is not Object, throw a *TypeError* exception.
        1. Let _key_ be ? ToPropertyKey(_propertyKey_).
        1. If _receiver_ is not present, then
          1. Set _receiver_ to _target_.
        1. Return ? _target_.[[Get]](_key_, _receiver_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.getownpropertydescriptor">
      <h1>Reflect.getOwnPropertyDescriptor ( _target_, _propertyKey_ )</h1>
      <p>When the `getOwnPropertyDescriptor` function is called with arguments _target_ and _propertyKey_, the following steps are taken:</p>
      <emu-alg>
        1. If Type(_target_) is not Object, throw a *TypeError* exception.
        1. Let _key_ be ? ToPropertyKey(_propertyKey_).
        1. Let _desc_ be ? _target_.[[GetOwnProperty]](_key_).
        1. Return FromPropertyDescriptor(_desc_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.getprototypeof">
      <h1>Reflect.getPrototypeOf ( _target_ )</h1>
      <p>When the `getPrototypeOf` function is called with argument _target_, the following steps are taken:</p>
      <emu-alg>
        1. If Type(_target_) is not Object, throw a *TypeError* exception.
        1. Return ? _target_.[[GetPrototypeOf]]().
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.has">
      <h1>Reflect.has ( _target_, _propertyKey_ )</h1>
      <p>When the `has` function is called with arguments _target_ and _propertyKey_, the following steps are taken:</p>
      <emu-alg>
        1. If Type(_target_) is not Object, throw a *TypeError* exception.
        1. Let _key_ be ? ToPropertyKey(_propertyKey_).
        1. Return ? _target_.[[HasProperty]](_key_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.isextensible">
      <h1>Reflect.isExtensible ( _target_ )</h1>
      <p>When the `isExtensible` function is called with argument _target_, the following steps are taken:</p>
      <emu-alg>
        1. If Type(_target_) is not Object, throw a *TypeError* exception.
        1. Return ? _target_.[[IsExtensible]]().
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.ownkeys">
      <h1>Reflect.ownKeys ( _target_ )</h1>
      <p>When the `ownKeys` function is called with argument _target_, the following steps are taken:</p>
      <emu-alg>
        1. If Type(_target_) is not Object, throw a *TypeError* exception.
        1. Let _keys_ be ? _target_.[[OwnPropertyKeys]]().
        1. Return CreateArrayFromList(_keys_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.preventextensions">
      <h1>Reflect.preventExtensions ( _target_ )</h1>
      <p>When the `preventExtensions` function is called with argument _target_, the following steps are taken:</p>
      <emu-alg>
        1. If Type(_target_) is not Object, throw a *TypeError* exception.
        1. Return ? _target_.[[PreventExtensions]]().
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.set">
      <h1>Reflect.set ( _target_, _propertyKey_, _V_ [ , _receiver_ ] )</h1>
      <p>When the `set` function is called with arguments _target_, _V_, _propertyKey_, and _receiver_, the following steps are taken:</p>
      <emu-alg>
        1. If Type(_target_) is not Object, throw a *TypeError* exception.
        1. Let _key_ be ? ToPropertyKey(_propertyKey_).
        1. If _receiver_ is not present, then
          1. Set _receiver_ to _target_.
        1. Return ? _target_.[[Set]](_key_, _V_, _receiver_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.setprototypeof">
      <h1>Reflect.setPrototypeOf ( _target_, _proto_ )</h1>
      <p>When the `setPrototypeOf` function is called with arguments _target_ and _proto_, the following steps are taken:</p>
      <emu-alg>
        1. If Type(_target_) is not Object, throw a *TypeError* exception.
        1. If Type(_proto_) is not Object and _proto_ is not *null*, throw a *TypeError* exception.
        1. Return ? _target_.[[SetPrototypeOf]](_proto_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-proxy-objects">
    <h1>Proxy Objects</h1>

    <emu-clause id="sec-proxy-constructor">
      <h1>The Proxy Constructor</h1>
      <p>The Proxy constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%Proxy%</dfn>.</li>
        <li>is the initial value of the `Proxy` property of the global object.</li>
        <li>creates and initializes a new proxy exotic object when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
      </ul>

      <emu-clause id="sec-proxy-target-handler">
        <h1>Proxy ( _target_, _handler_ )</h1>
        <p>When `Proxy` is called with arguments _target_ and _handler_, it performs the following steps:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Return ? ProxyCreate(_target_, _handler_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-proxy-constructor">
      <h1>Properties of the Proxy Constructor</h1>
      <p>The Proxy constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.</li>
        <li>does not have a `prototype` property because proxy exotic objects do not have a [[Prototype]] internal slot that requires initialization.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-proxy.revocable">
        <h1>Proxy.revocable ( _target_, _handler_ )</h1>
        <p>The `Proxy.revocable` function is used to create a revocable Proxy object. When `Proxy.revocable` is called with arguments _target_ and _handler_, the following steps are taken:</p>
        <emu-alg>
          1. Let _p_ be ? ProxyCreate(_target_, _handler_).
          1. Let _steps_ be the algorithm steps defined in <emu-xref href="#sec-proxy-revocation-functions" title></emu-xref>.
          1. Let _revoker_ be CreateBuiltinFunction(_steps_, &laquo; [[RevocableProxy]] &raquo;).
          1. Set _revoker_.[[RevocableProxy]] to _p_.
          1. Let _result_ be ObjectCreate(%ObjectPrototype%).
          1. Perform CreateDataProperty(_result_, `"proxy"`, _p_).
          1. Perform CreateDataProperty(_result_, `"revoke"`, _revoker_).
          1. Return _result_.
        </emu-alg>

        <emu-clause id="sec-proxy-revocation-functions">
          <h1>Proxy Revocation Functions</h1>
          <p>A Proxy revocation function is an anonymous function that has the ability to invalidate a specific Proxy object.</p>
          <p>Each Proxy revocation function has a [[RevocableProxy]] internal slot.</p>
          <p>When a Proxy revocation function is called, the following steps are taken:</p>
          <emu-alg>
            1. Let _F_ be the active function object.
            1. Let _p_ be _F_.[[RevocableProxy]].
            1. If _p_ is *null*, return *undefined*.
            1. Set _F_.[[RevocableProxy]] to *null*.
            1. Assert: _p_ is a Proxy object.
            1. Set _p_.[[ProxyTarget]] to *null*.
            1. Set _p_.[[ProxyHandler]] to *null*.
            1. Return *undefined*.
          </emu-alg>
          <p>The `"length"` property of a Proxy revocation function is 0.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-module-namespace-objects">
    <h1>Module Namespace Objects</h1>
    <p>A Module Namespace Object is a module namespace exotic object that provides runtime property-based access to a module's exported bindings. There is no constructor function for Module Namespace Objects. Instead, such an object is created for each module that is imported by an |ImportDeclaration| that includes a |NameSpaceImport|.</p>
    <p>In addition to the properties specified in <emu-xref href="#sec-module-namespace-exotic-objects"></emu-xref> each Module Namespace Object has the following own property:</p>

    <emu-clause id="sec-@@tostringtag">
      <h1>@@toStringTag</h1>
      <p>The initial value of the @@toStringTag property is the String value `"Module"`.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>


<emu-clause id="sec-memory-model">
  <h1>Memory Model</h1>
  <p>The memory consistency model, or <dfn>memory model</dfn>, specifies the possible orderings of Shared Data Block events, arising via accessing TypedArray instances backed by a SharedArrayBuffer and via methods on the Atomics object. When the program has no data races (defined below), the ordering of events appears as sequentially consistent, i.e., as an interleaving of actions from each agent. When the program has data races, shared memory operations may appear sequentially inconsistent. For example, programs may exhibit causality-violating behaviour and other astonishments. These astonishments arise from compiler transforms and the design of CPUs (e.g., out-of-order execution and speculation). The memory model defines both the precise conditions under which a program exhibits sequentially consistent behaviour as well as the possible values read from data races. To wit, there is no undefined behaviour.</p>
  <p>The memory model is defined as relational constraints on events introduced by abstract operations on SharedArrayBuffer or by methods on the Atomics object during an evaluation.</p>
  <emu-note>
    <p>This section provides an axiomatic model on events introduced by the abstract operations on SharedArrayBuffers. It bears stressing that the model is not expressible algorithmically, unlike the rest of this specification. The nondeterministic introduction of events by abstract operations is the interface between the operational semantics of ECMAScript evaluation and the axiomatic semantics of the memory model. The semantics of these events is defined by considering graphs of all events in an evaluation. These are neither Static Semantics nor Runtime Semantics. There is no demonstrated algorithmic implementation, but instead a set of constraints that determine if a particular event graph is allowed or disallowed.</p>
  </emu-note>

  <emu-clause id="sec-memory-model-fundamentals">
    <h1>Memory Model Fundamentals</h1>
    <p>Shared memory accesses (reads and writes) are divided into two groups, atomic accesses and data accesses, defined below. Atomic accesses are sequentially consistent, i.e., there is a strict total ordering of events agreed upon by all agents in an agent cluster. Non-atomic accesses do not have a strict total ordering agreed upon by all agents, i.e., unordered.</p>
    <emu-note>
      <p>No orderings weaker than sequentially consistent and stronger than unordered, such as release-acquire, are supported.</p>
    </emu-note>
    <p>A <dfn>Shared Data Block event</dfn> is either a <dfn>ReadSharedMemory</dfn>, <dfn>WriteSharedMemory</dfn>, or <dfn>ReadModifyWriteSharedMemory</dfn> Record.</p>

    <emu-table id="table-readsharedmemory-fields" caption="ReadSharedMemory Event Fields">
      <table>
        <tbody>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[Order]]</td>
            <td>`"SeqCst"` or `"Unordered"`</td>
            <td>The weakest ordering guaranteed by the memory model for the event.</td>
          </tr>
          <tr>
            <td>[[NoTear]]</td>
            <td>A Boolean</td>
            <td>Whether this event is allowed to read from multiple write events on equal range as this event.</td>
          </tr>
          <tr>
            <td>[[Block]]</td>
            <td>A Shared Data Block</td>
            <td>The block the event operates on.</td>
          </tr>
          <tr>
            <td>[[ByteIndex]]</td>
            <td>A nonnegative integer</td>
            <td>The byte address of the read in [[Block]].</td>
          </tr>
          <tr>
            <td>[[ElementSize]]</td>
            <td>A nonnegative integer</td>
            <td>The size of the read.</td>
          </tr>
        </tbody>
      </table>
    </emu-table>

    <emu-table id="table-writesharedmemory-fields" caption="WriteSharedMemory Event Fields">
      <table>
        <tbody>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[Order]]</td>
            <td>`"SeqCst"`, `"Unordered"`, or `"Init"`</td>
            <td>The weakest ordering guaranteed by the memory model for the event.</td>
          </tr>
          <tr>
            <td>[[NoTear]]</td>
            <td>A Boolean</td>
            <td>Whether this event is allowed to be read from multiple read events with equal range as this event.</td>
          </tr>
          <tr>
            <td>[[Block]]</td>
            <td>A Shared Data Block</td>
            <td>The block the event operates on.</td>
          </tr>
          <tr>
            <td>[[ByteIndex]]</td>
            <td>A nonnegative integer</td>
            <td>The byte address of the write in [[Block]].</td>
          </tr>
          <tr>
            <td>[[ElementSize]]</td>
            <td>A nonnegative integer</td>
            <td>The size of the write.</td>
          </tr>
          <tr>
            <td>[[Payload]]</td>
            <td>A List</td>
            <td>The List of byte values to be read by other events.</td>
          </tr>
        </tbody>
      </table>
    </emu-table>

    <emu-table id="table-rmwsharedmemory-fields" caption="ReadModifyWriteSharedMemory Event Fields">
      <table>
        <tbody>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[Order]]</td>
            <td>`"SeqCst"`</td>
            <td>Read-modify-write events are always sequentially consistent.</td>
          </tr>
          <tr>
            <td>[[NoTear]]</td>
            <td>*true*</td>
            <td>Read-modify-write events cannot tear.</td>
          </tr>
          <tr>
            <td>[[Block]]</td>
            <td>A Shared Data Block</td>
            <td>The block the event operates on.</td>
          </tr>
          <tr>
            <td>[[ByteIndex]]</td>
            <td>A nonnegative integer</td>
            <td>The byte address of the read-modify-write in [[Block]].</td>
          </tr>
          <tr>
            <td>[[ElementSize]]</td>
            <td>A nonnegative integer</td>
            <td>The size of the read-modify-write.</td>
          </tr>
          <tr>
            <td>[[Payload]]</td>
            <td>A List</td>
            <td>The List of byte values to be passed to [[ModifyOp]].</td>
          </tr>
          <tr>
            <td>[[ModifyOp]]</td>
            <td>A semantic function</td>
            <td>A pure semantic function that returns a modified List of byte values from a read List of byte values and [[Payload]].</td>
          </tr>
        </tbody>
      </table>
    </emu-table>

    <p>These events are introduced by abstract operations or by methods on the Atomics object.</p>
    <p>Some operations may also introduce <dfn>Synchronize</dfn> events. A <dfn>Synchronize event</dfn> has no fields, and exists purely to directly constrain the permitted orderings of other events.</p>
    <p>In addition to Shared Data Block and Synchronize events, there are host-specific events.</p>
    <p>Let the range of a ReadSharedMemory, WriteSharedMemory, or ReadModifyWriteSharedMemory event be the Set of contiguous integers from its [[ByteIndex]] to [[ByteIndex]] + [[ElementSize]] - 1. Two events' ranges are equal when the events have the same [[Block]], and the ranges are element-wise equal. Two events' ranges are overlapping when the events have the same [[Block]], the ranges are not equal and their intersection is non-empty. Two events' ranges are disjoint when the events do not have the same [[Block]] or their ranges are neither equal nor overlapping.</p>
    <emu-note>
      <p>Examples of host-specific synchronizing events that should be accounted for are: sending a SharedArrayBuffer from one agent to another (e.g., by `postMessage` in a browser), starting and stopping agents, and communicating within the agent cluster via channels other than shared memory. It is assumed those events are appended to agent-order during evaluation like the other SharedArrayBuffer events.</p>
    </emu-note>
    <p>Events are ordered within candidate executions by the relations defined below.</p>
  </emu-clause>

  <emu-clause id="sec-agent-event-records">
    <h1>Agent Events Records</h1>
    <p>An <dfn>Agent Events Record</dfn> is a Record with the following fields.</p>
    <emu-table id="table-agent-events-records" caption="Agent Events Record Fields">
      <table>
        <tbody>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[AgentSignifier]]</td>
            <td>A value that admits equality testing</td>
            <td>The agent whose evaluation resulted in this ordering.</td>
          </tr>
          <tr>
            <td>[[EventList]]</td>
            <td>A List of events</td>
            <td>Events are appended to the list during evaluation.</td>
          </tr>
          <tr>
            <td>[[AgentSynchronizesWith]]</td>
            <td>A List of pairs of Synchronize events</td>
            <td>Synchronize relationships introduced by the operational semantics.</td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-chosen-value-records">
    <h1>Chosen Value Records</h1>
    <p>A <dfn>Chosen Value Record</dfn> is a Record with the following fields.</p>
    <emu-table id="table-chosen-value-records" caption="Chosen Value Record Fields">
      <table>
        <tbody>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[Event]]</td>
            <td>A Shared Data Block event</td>
            <td>The ReadSharedMemory or ReadModifyWriteSharedMemory event that was introduced for this chosen value.</td>
          </tr>
          <tr>
            <td>[[ChosenValue]]</td>
            <td>A List of byte values</td>
            <td>The bytes that were nondeterministically chosen during evaluation.</td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-candidate-executions">
    <h1>Candidate Executions</h1>
    <p>A <dfn>candidate execution</dfn> of the evaluation of an agent cluster is a Record with the following fields.</p>
    <emu-table id="table-candidate-execution-records" caption="Candidate Execution Record Fields">
      <table>
        <tbody>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[EventsRecords]]</td>
            <td>A List of Agent Events Records.</td>
            <td>Maps an agent to Lists of events appended during the evaluation.</td>
          </tr>
          <tr>
            <td>[[ChosenValues]]</td>
            <td>A List of Chosen Value Records.</td>
            <td>Maps ReadSharedMemory or ReadModifyWriteSharedMemory events to the List of byte values chosen during the evaluation.</td>
          </tr>
          <tr>
            <td>[[AgentOrder]]</td>
            <td>An agent-order Relation.</td>
            <td>Defined below.</td>
          </tr>
          <tr>
            <td>[[ReadsBytesFrom]]</td>
            <td>A reads-bytes-from semantic function.</td>
            <td>Defined below.</td>
          </tr>
          <tr>
            <td>[[ReadsFrom]]</td>
            <td>A reads-from Relation.</td>
            <td>Defined below.</td>
          </tr>
          <tr>
            <td>[[HostSynchronizesWith]]</td>
            <td>A host-synchronizes-with Relation.</td>
            <td>Defined below.</td>
          </tr>
          <tr>
            <td>[[SynchronizesWith]]</td>
            <td>A synchronizes-with Relation.</td>
            <td>Defined below.</td>
          </tr>
          <tr>
            <td>[[HappensBefore]]</td>
            <td>A happens-before Relation.</td>
            <td>Defined below.</td>
          </tr>
        </tbody>
      </table>
    </emu-table>

    <p>An <dfn>empty candidate execution</dfn> is a candidate execution Record whose fields are empty Lists and Relations.</p>
  </emu-clause>

  <emu-clause id="sec-abstract-operations-for-the-memory-model">
    <h1>Abstract Operations for the Memory Model</h1>
    <emu-clause id="sec-event-set" aoid="EventSet">
      <h1>EventSet ( _execution_ )</h1>
      <p>The abstract operation EventSet takes one argument, a candidate execution _execution_. It performs the following steps:</p>
      <emu-alg>
        1. Let _events_ be an empty Set.
        1. For each Agent Events Record _aer_ in _execution_.[[EventsRecords]], do
          1. For each event _E_ in _aer_.[[EventList]], do
            1. Add _E_ to _events_.
        1. Return _events_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-sharedatablockeventset" aoid="SharedDataBlockEventSet">
      <h1>SharedDataBlockEventSet ( _execution_ )</h1>
      <p>The abstract operation SharedDataBlockEventSet takes one argument, a candidate execution _execution_. It performs the following steps:</p>
      <emu-alg>
        1. Let _events_ be an empty Set.
        1. For each event _E_ in EventSet(_execution_), do
          1. If _E_ is a ReadSharedMemory, WriteSharedMemory, or ReadModifyWriteSharedMemory event, add _E_ to _events_.
        1. Return _events_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-synchronizeeventset" aoid="SynchronizeEventSet">
      <h1>SynchronizeEventSet ( _execution_ )</h1>
      <p>The abstract operation SynchronizeEventSet takes one argument, a candidate execution _execution_. It performs the following steps:</p>
      <emu-alg>
        1. Let _events_ be an empty Set.
        1. For each event _E_ in EventSet(_execution_), do
          1. If _E_ is a Synchronize event, add _E_ to _events_.
        1. Return _events_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-hosteventset" aoid="HostEventSet">
      <h1>HostEventSet ( _execution_ )</h1>
      <p>The abstract operation HostEventSet takes one argument, a candidate execution _execution_. It performs the following steps:</p>
      <emu-alg>
        1. Let _events_ be an empty Set.
        1. For each event _E_ in EventSet(_execution_), do
          1. If _E_ is not in SharedDataBlockEventSet(_execution_), add _E_ to _events_.
        1. Return _events_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-composewriteeventbytes" aoid="ComposeWriteEventBytes">
      <h1>ComposeWriteEventBytes ( _execution_, _byteIndex_, _Ws_ )</h1>
      <p>The abstract operation ComposeWriteEventBytes takes four arguments, a candidate execution _execution_, a nonnegative integer _byteIndex_, and a List _Ws_ of WriteSharedMemory or ReadModifyWriteSharedMemory events. It performs the following steps:</p>
      <emu-alg>
        1. Let _byteLocation_ be _byteIndex_.
        1. Let _bytesRead_ be a new empty List.
        1. For each element _W_ of _Ws_ in List order, do
          1. Assert: _W_ has _byteLocation_ in its range.
          1. Let _payloadIndex_ be _byteLocation_ - _W_.[[ByteIndex]].
          1. If _W_ is a WriteSharedMemory event, then
            1. Let _byte_ be _W_.[[Payload]][_payloadIndex_].
          1. Else,
            1. Assert: _W_ is a ReadModifyWriteSharedMemory event.
            1. Let _bytes_ be ValueOfReadEvent(_execution_, _W_).
            1. Let _bytesModified_ be _W_.[[ModifyOp]](_bytes_, _W_.[[Payload]]).
            1. Let _byte_ be _bytesModified_[_payloadIndex_].
          1. Append _byte_ to _bytesRead_.
          1. Increment _byteLocation_ by 1.
        1. Return _bytesRead_.
      </emu-alg>
      <emu-note>
        <p>The semantic function [[ModifyOp]] is given by the function properties on the Atomics object that introduce ReadModifyWriteSharedMemory events.</p>
      </emu-note>
      <emu-note>
        <p>This abstract operation composes a List of write events into a List of byte values. It is used in the event semantics of ReadSharedMemory and ReadModifyWriteSharedMemory events.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-valueofreadevent" aoid="ValueOfReadEvent">
      <h1>ValueOfReadEvent ( _execution_, _R_ )</h1>
      <p>The abstract operation ValueOfReadEvent takes two arguments, a candidate execution _execution_ and a ReadSharedMemory or ReadModifyWriteSharedMemory event _R_. It performs the following steps:</p>
      <emu-alg>
        1. Assert: _R_ is a ReadSharedMemory or ReadModifyWriteSharedMemory event.
        1. Let _Ws_ be _execution_.[[ReadsBytesFrom]](_R_).
        1. Assert: _Ws_ is a List of WriteSharedMemory or ReadModifyWriteSharedMemory events with length equal to _R_.[[ElementSize]].
        1. Return ComposeWriteEventBytes(_execution_, _R_.[[ByteIndex]], _Ws_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-relations-of-candidate-executions">
    <h1>Relations of Candidate Executions</h1>
    <emu-clause id="sec-agent-order" aoid="agent-order">
      <h1>agent-order</h1>
      <p>For a candidate execution _execution_, _execution_.[[AgentOrder]] is a Relation on events that satisfies the following.</p>
      <ul>
        <li>For each pair (_E_, _D_) in EventSet(_execution_), (_E_, _D_) is in _execution_.[[AgentOrder]] if there is some Agent Events Record _aer_ in _execution_.[[EventsRecords]] such that _E_ and _D_ are in _aer_.[[EventList]] and _E_ is before _D_ in List order of _aer_.[[EventList]].</li>
      </ul>

      <emu-note>
        <p>Each agent introduces events in a per-agent strict total order during the evaluation. This is the union of those strict total orders.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-reads-bytes-from" aoid="reads-bytes-from">
      <h1>reads-bytes-from</h1>
      <p>For a candidate execution _execution_, _execution_.[[ReadsBytesFrom]] is a semantic function from events in SharedDataBlockEventSet(_execution_) to Lists of events in SharedDataBlockEventSet(_execution_) that satisfies the following conditions.</p>
      <ul>
        <li>
          <p>For each ReadSharedMemory or ReadModifyWriteSharedMemory event _R_ in SharedDataBlockEventSet(_execution_), _execution_.[[ReadsBytesFrom]](_R_) is a List of length equal to _R_.[[ElementSize]] of WriteSharedMemory or ReadModifyWriteSharedMemory events _Ws_ such that all of the following are true.</p>
          <ul>
            <li>Each event _W_ with index _i_ in _Ws_ has _R_.[[ByteIndex]] + _i_ in its range.</li>
            <li>_R_ is not in _Ws_.</li>
          </ul>
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-reads-from" aoid="reads-from">
      <h1>reads-from</h1>
      <p>For a candidate execution _execution_, _execution_.[[ReadsFrom]] is the least Relation on events that satisfies the following.</p>
      <ul>
        <li>For each pair (_R_, _W_) in SharedDataBlockEventSet(_execution_), (_R_, _W_) is in _execution_.[[ReadsFrom]] if _W_ is in _execution_.[[ReadsBytesFrom]](_R_).</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-host-synchronizes-with" aoid="host-synchronizes-with">
      <h1>host-synchronizes-with</h1>
      <p>For a candidate execution _execution_, _execution_.[[HostSynchronizesWith]] is a host-provided strict partial order on host-specific events that satisfies at least the following.</p>
      <ul>
        <li>If (_E_, _D_) is in _execution_.[[HostSynchronizesWith]], _E_ and _D_ are in HostEventSet(_execution_).</li>
        <li>There is no cycle in the union of _execution_.[[HostSynchronizesWith]] and _execution_.[[AgentOrder]].</li>
      </ul>

      <emu-note>
        <p>For two host-specific events _E_ and _D_, _E_ host-synchronizes-with _D_ implies _E_ happens-before _D_.</p>
      </emu-note>
      <emu-note>
        <p>The host-synchronizes-with relation allows the host to provide additional synchronization mechanisms, such as `postMessage` between HTML workers.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-synchronizes-with" aoid="synchronizes-with">
      <h1>synchronizes-with</h1>
      <p>For a candidate execution _execution_, _execution_.[[SynchronizesWith]] is the least Relation on events that satisfies the following.</p>
      <ul>
        <li>
          For each pair (_R_, _W_) in _execution_.[[ReadsFrom]], (_W_, _R_) is in _execution_.[[SynchronizesWith]] if all the following are true.
          <ul>
            <li>_R_.[[Order]] is `"SeqCst"`.</li>
            <li>_W_.[[Order]] is `"SeqCst"` or `"Init"`.</li>
            <li>If _W_.[[Order]] is `"SeqCst"`, then _R_ and _W_ have equal ranges.</li>
            <li>If _W_.[[Order]] is `"Init"`, then for each event _V_ such that (_R_, _V_) is in _execution_.[[ReadsFrom]], _V_.[[Order]] is `"Init"`.</li>
          </ul>
        </li>
        <li>
          For each element _eventsRecord_ of _execution_.[[EventsRecords]], the following is true.
          <ul>
            <li>For each pair (_S_, _Sw_) in _eventsRecord_.[[AgentSynchronizesWith]], (_S_, _Sw_) is in _execution_.[[SynchronizesWith]].</li>
          </ul>
        </li>
        <li>For each pair (_E_, _D_) in _execution_.[[HostSynchronizesWith]], (_E_, _D_) is in _execution_.[[SynchronizesWith]].</li>
      </ul>

      <emu-note>
        <p>Owing to convention, write events synchronizes-with read events, instead of read events synchronizes-with write events.</p>
      </emu-note>

      <emu-note>
        <p>Not all `"SeqCst"` events related by reads-from are related by synchronizes-with. Only events that also have equal ranges are related by synchronizes-with.</p>
      </emu-note>

      <emu-note>
        <p>For Shared Data Block events _R_ and _W_ such that _W_ synchronizes-with _R_, _R_ may reads-from other writes than _W_.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-happens-before" aoid="happens-before">
      <h1>happens-before</h1>
      <p>For a candidate execution _execution_, _execution_.[[HappensBefore]] is the least Relation on events that satisfies the following.</p>

      <ul>
        <li>For each pair (_E_, _D_) in _execution_.[[AgentOrder]], (_E_, _D_) is in _execution_.[[HappensBefore]].</li>
        <li>For each pair (_E_, _D_) in _execution_.[[SynchronizesWith]], (_E_, _D_) is in _execution_.[[HappensBefore]].</li>
        <li>For each pair (_E_, _D_) in SharedDataBlockEventSet(_execution_), (_E_, _D_) is in _execution_.[[HappensBefore]] if _E_.[[Order]] is `"Init"` and _E_ and _D_ have overlapping ranges.</li>
        <li>For each pair (_E_, _D_) in EventSet(_execution_), (_E_, _D_) is in _execution_.[[HappensBefore]] if there is an event _F_ such that the pairs (_E_, _F_) and (_F_, _D_) are in _execution_.[[HappensBefore]].</li>
      </ul>

      <emu-note>
        <p>Because happens-before is a superset of agent-order, candidate executions are consistent with the single-thread evaluation semantics of ECMAScript.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-valid-executions">
    <h1>Properties of Valid Executions</h1>
    <emu-clause id="sec-valid-chosen-reads">
      <h1>Valid Chosen Reads</h1>
      <p>A candidate execution _execution_ has valid chosen reads if the following abstract operation returns *true*.</p>
      <emu-alg>
        1. For each ReadSharedMemory or ReadModifyWriteSharedMemory event _R_ in SharedDataBlockEventSet(_execution_), do
          1. Let _chosenValueRecord_ be the element of _execution_.[[ChosenValues]] whose [[Event]] field is _R_.
          1. Let _chosenValue_ be _chosenValueRecord_.[[ChosenValue]].
          1. Let _readValue_ be ValueOfReadEvent(_execution_, _R_).
          1. Let _chosenLen_ be the number of elements of _chosenValue_.
          1. Let _readLen_ be the number of elements of _readValue_.
          1. If _chosenLen_ is not equal to _readLen_, then
            1. Return *false*.
          1. If _chosenValue_[_i_] is not equal to _readValue_[_i_] for any integer value _i_ in the range 0 through _chosenLen_, exclusive, then
            1. Return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-coherent-reads">
      <h1>Coherent Reads</h1>
      <p>A candidate execution _execution_ has coherent reads if the following abstract operation returns *true*.</p>
      <emu-alg>
        1. For each ReadSharedMemory or ReadModifyWriteSharedMemory event _R_ in SharedDataBlockEventSet(_execution_), do
          1. Let _Ws_ be _execution_.[[ReadsBytesFrom]](_R_).
          1. Let _byteLocation_ be _R_.[[ByteIndex]].
          1. For each element _W_ of _Ws_ in List order, do
            1. If (_R_, _W_) is in _execution_.[[HappensBefore]], then
              1. Return *false*.
            1. If there is a WriteSharedMemory or ReadModifyWriteSharedMemory event _V_ that has _byteLocation_ in its range such that the pairs (_W_, _V_) and (_V_, _R_) are in _execution_.[[HappensBefore]], then
              1. Return *false*.
            1. Increment _byteLocation_ by 1.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tear-free-aligned-reads">
      <h1>Tear Free Reads</h1>
      <p>A candidate execution _execution_ has tear free reads if the following abstract operation returns *true*.</p>
      <emu-alg>
        1. For each ReadSharedMemory or ReadModifyWriteSharedMemory event _R_ in SharedDataBlockEventSet(_execution_), do
          1. If _R_.[[NoTear]] is *true*, then
            1. Assert: The remainder of dividing _R_.[[ByteIndex]] by _R_.[[ElementSize]] is 0.
            1. For each event _W_ such that (_R_, _W_) is in _execution_.[[ReadsFrom]] and _W_.[[NoTear]] is *true*, do
              1. If _R_ and _W_ have equal ranges, and there is an event _V_ such that _V_ and _W_ have equal ranges, _V_.[[NoTear]] is *true*, _W_ is not _V_, and (_R_, _V_) is in _execution_.[[ReadsFrom]], then
                1. Return *false*.
        1. Return *true*.
      </emu-alg>

      <emu-note>
        <p>An event's [[NoTear]] field is *true* when that event was introduced via accessing an integer TypedArray, and *false* when introduced via accessing a floating point TypedArray or DataView.</p>
        <p>Intuitively, this requirement says when a memory range is accessed in an aligned fashion via an integer TypedArray, a single write event on that range must "win" when in a data race with other write events with equal ranges. More precisely, this requirement says an aligned read event cannot read a value composed of bytes from multiple, different write events all with equal ranges. It is possible, however, for an aligned read event to read from multiple write events with overlapping ranges.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-memory-order" aoid="memory-order">
      <h1>Sequentially Consistent Atomics</h1>
      <p>For a candidate execution _execution_, memory-order is a strict total order of all events in EventSet(_execution_) that satisfies the following.</p>
      <ul>
        <li>For each pair (_E_, _D_) in _execution_.[[HappensBefore]], (_E_, _D_) is in memory-order.</li>
        <li>
          <p>For each pair (_E_, _D_) in _execution_.[[SynchronizesWith]], (_E_, _D_) is in memory-order if there is no WriteSharedMemory or ReadModifyWriteSharedMemory event _W_ in SharedDataBlockEventSet(_execution_) with equal range as _D_ such that _W_ is not _E_, and the pairs (_E_, _W_) and (_W_, _D_) are in memory-order.</p>
          <emu-note>
            <p>This clause additionally constrains `"SeqCst"` events on equal ranges.</p>
          </emu-note>
        </li>
        <li>
          <p>For each WriteSharedMemory or ReadModifyWriteSharedMemory event _W_ in SharedDataBlockEventSet(_execution_), if _W_.[[Order]] is `"SeqCst"`, then it is not the case that there is an infinite number of ReadSharedMemory or ReadModifyWriteSharedMemory events in SharedDataBlockEventSet(_execution_) with equal range that is memory-order before _W_.</p>
          <emu-note>
            <p>This clause together with the forward progress guarantee on agents ensure the liveness condition that `"SeqCst"` writes become visible to `"SeqCst"` reads with equal range in finite time.</p>
          </emu-note>
        </li>
      </ul>
      <p>A candidate execution has sequentially consistent atomics if a memory-order exists.</p>

      <emu-note>
        <p>While memory-order includes all events in EventSet(_execution_), those that are not constrained by happens-before or synchronizes-with are allowed to occur anywhere in the order.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-valid-executions">
      <h1>Valid Executions</h1>
      <p>A candidate execution _execution_ is a valid execution (or simply an execution) if all of the following are true.</p>
      <ul>
        <li>The host provides a host-synchronizes-with Relation for _execution_.[[HostSynchronizesWith]].</li>
        <li>_execution_.[[HappensBefore]] is a strict partial order.</li>
        <li>_execution_ has valid chosen reads.</li>
        <li>_execution_ has coherent reads.</li>
        <li>_execution_ has tear free reads.</li>
        <li>_execution_ has sequentially consistent atomics.</li>
      </ul>
      <p>All programs have at least one valid execution.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-races">
    <h1>Races</h1>
    <p>For an execution _execution_, two events _E_ and _D_ in SharedDataBlockEventSet(_execution_) are in a race if the following abstract operation returns *true*.</p>
    <emu-alg>
      1. If _E_ is not _D_, then
        1. If the pairs (_E_, _D_) and (_D_, _E_) are not in _execution_.[[HappensBefore]], then
          1. If _E_ and _D_ are both WriteSharedMemory or ReadModifyWriteSharedMemory events and _E_ and _D_ do not have disjoint ranges, then
            1. Return *true*.
          1. If either (_E_, _D_) or (_D_, _E_) is in _execution_.[[ReadsFrom]], then
            1. Return *true*.
      1. Return *false*.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-data-races">
    <h1>Data Races</h1>
    <p>For an execution _execution_, two events _E_ and _D_ in SharedDataBlockEventSet(_execution_) are in a data race if the following abstract operation returns *true*.</p>
    <emu-alg>
      1. If _E_ and _D_ are in a race in _execution_, then
        1. If _E_.[[Order]] is not `"SeqCst"` or _D_.[[Order]] is not `"SeqCst"`, then
          1. Return *true*.
        1. If _E_ and _D_ have overlapping ranges, then
          1. Return *true*.
      1. Return *false*.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-data-race-freedom">
    <h1>Data Race Freedom</h1>
    <p>An execution _execution_ is data race free if there are no two events in SharedDataBlockEventSet(_execution_) that are in a data race.</p>
    <p>A program is data race free if all its executions are data race free.</p>
    <p>The memory model guarantees sequential consistency of all events for data race free programs.</p>
  </emu-clause>

  <emu-clause id="sec-shared-memory-guidelines">
    <h1>Shared Memory Guidelines</h1>
    <emu-note>
      <p>The following are guidelines for ECMAScript programmers working with shared memory.</p>
      <p>We recommend programs be kept data race free, i.e., make it so that it is impossible for there to be concurrent non-atomic operations on the same memory location. Data race free programs have interleaving semantics where each step in the evaluation semantics of each agent are interleaved with each other. For data race free programs, it is not necessary to understand the details of the memory model. The details are unlikely to build intuition that will help one to better write ECMAScript.</p>
      <p>More generally, even if a program is not data race free it may have predictable behaviour, so long as atomic operations are not involved in any data races and the operations that race all have the same access size. The simplest way to arrange for atomics not to be involved in races is to ensure that different memory cells are used by atomic and non-atomic operations and that atomic accesses of different sizes are not used to access the same cells at the same time. Effectively, the program should treat shared memory as strongly typed as much as possible. One still cannot depend on the ordering and timing of non-atomic accesses that race, but if memory is treated as strongly typed the racing accesses will not "tear" (bits of their values will not be mixed).</p>
    </emu-note>

    <emu-note>
      <p>The following are guidelines for ECMAScript implementers writing compiler transformations for programs using shared memory.</p>
      <p>It is desirable to allow most program transformations that are valid in a single-agent setting in a multi-agent setting, to ensure that the performance of each agent in a multi-agent program is as good as it would be in a single-agent setting. Frequently these transformations are hard to judge. We outline some rules about program transformations that are intended to be taken as normative (in that they are implied by the memory model or stronger than what the memory model implies) but which are likely not exhaustive. These rules are intended to apply to program transformations that precede the introductions of the events that make up the agent-order.</p>
      <p>Let an <dfn>agent-order slice</dfn> be the subset of the agent-order pertaining to a single agent.</p>
      <p>Let <dfn>possible read values</dfn> of a read event be the set of all values of ValueOfReadEvent for that event across all valid executions.</p>
      <p>Any transformation of an agent-order slice that is valid in the absence of shared memory is valid in the presence of shared memory, with the following exceptions.</p>
      <ul>
        <li>
          <p><em>Atomics are carved in stone</em>: Program transformations must not cause the <code>"SeqCst"</code> events in an agent-order slice to be reordered with its <code>"Unordered"</code> operations, nor its <code>"SeqCst"</code> operations to be reordered with each other, nor may a program transformation remove a <code>"SeqCst"</code> operation from the agent-order.</p>
          <p>(In practice, the prohibition on reorderings forces a compiler to assume that every <code>"SeqCst"</code> operation is a synchronization and included in the final memory-order, which it would usually have to assume anyway in the absence of inter-agent program analysis. It also forces the compiler to assume that every call where the callee's effects on the memory-order are unknown may contain <code>"SeqCst"</code> operations.)</p>
        </li>
        <li>
          <p><em>Reads must be stable</em>: Any given shared memory read must only observe a single value in an execution.</p>
          <p>(For example, if what is semantically a single read in the program is executed multiple times then the program is subsequently allowed to observe only one of the values read. A transformation known as rematerialization can violate this rule.)</p>
        </li>
        <li>
          <p><em>Writes must be stable</em>: All observable writes to shared memory must follow from program semantics in an execution.</p>
          <p>(For example, a transformation may not introduce certain observable writes, such as by using read-modify-write operations on a larger location to write a smaller datum, writing a value to memory that the program could not have written, or writing a just-read value back to the location it was read from, if that location could have been overwritten by another agent after the read.)</p>
        </li>
        <li>
          <p><em>Possible read values must be nonempty</em>: Program transformations cannot cause the possible read values of a shared memory read to become empty.</p>
          <p>(Counterintuitively, this rule in effect restricts transformations on writes, because writes have force in memory model insofar as to be read by read events. For example, writes may be moved and coalesced and sometimes reordered between two <code>"SeqCst"</code> operations, but the transformation may not remove every write that updates a location; some write must be preserved.)</p>
        </li>
      </ul>
      <p>Examples of transformations that remain valid are: merging multiple non-atomic reads from the same location, reordering non-atomic reads, introducing speculative non-atomic reads, merging multiple non-atomic writes to the same location, reordering non-atomic writes to different locations, and hoisting non-atomic reads out of loops even if that affects termination. Note in general that aliased TypedArrays make it hard to prove that locations are different.</p>
    </emu-note>

    <emu-note>
      <p>The following are guidelines for ECMAScript implementers generating machine code for shared memory accesses.</p>
      <p>For architectures with memory models no weaker than those of ARM or Power, non-atomic stores and loads may be compiled to bare stores and loads on the target architecture. Atomic stores and loads may be compiled down to instructions that guarantee sequential consistency. If no such instructions exist, memory barriers are to be employed, such as placing barriers on both sides of a bare store or load. Read-modify-write operations may be compiled to read-modify-write instructions on the target architectrue, such as <code>LOCK</code>-prefixed instructions on x86, load-exclusive/store-exclusive instructions on ARM, and load-link/store-conditional instructions on Power.</p>
      <p>Specifically, the memory model is intended to allow code generation as follows.</p>
      <ul>
        <li>Every atomic operation in the program is assumed to be necessary.</li>
        <li>Atomic operations are never rearranged with each other or with non-atomic operations.</li>
        <li>Functions are always assumed to perform atomic operations.</li>
        <li>Atomic operations are never implemented as read-modify-write operations on larger data, but as non-lock-free atomics if the platform does not have atomic operations of the appropriate size. (We already assume that every platform has normal memory access operations of every interesting size.)</li>
      </ul>
      <p>Naive code generation uses these patterns:</p>
      <ul>
        <li>Regular loads and stores compile to single load and store instructions.</li>
        <li>Lock-free atomic loads and stores compile to a full (sequentially consistent) fence, a regular load or store, and a full fence.</li>
        <li>Lock-free atomic read-modify-write accesses compile to a full fence, an atomic read-modify-write instruction sequence, and a full fence.</li>
        <li>Non-lock-free atomics compile to a spinlock acquire, a full fence, a series of non-atomic load and store instructions, a full fence, and a spinlock release.</li>
      </ul>
      <p>That mapping is correct so long as an atomic operation on an address range does not race with a non-atomic write or with an atomic operation of different size. However, that is all we need: the memory model effectively demotes the atomic operations involved in a race to non-atomic status. On the other hand, the naive mapping is quite strong: it allows atomic operations to be used as sequentially consistent fences, which the memory model does not actually guarantee.</p>
      <p>A number of local improvements to those basic patterns are also intended to be legal:</p>
      <ul>
        <li>There are obvious platform-dependent improvements that remove redundant fences.  For example, on x86 the fences around lock-free atomic loads and stores can always be omitted except for the fence following a store, and no fence is needed for lock-free read-modify-write instructions, as these all use LOCK-prefixed instructions. On many platforms there are fences of several strengths, and weaker fences can be used in certain contexts without destroying sequential consistency.</li>
        <li>Most modern platforms support lock-free atomics for all the data sizes required by ECMAScript atomics. Should non-lock-free atomics be needed, the fences surrounding the body of the atomic operation can usually be folded into the lock and unlock steps. The simplest solution for non-lock-free atomics is to have a single lock word per SharedArrayBuffer.</li>
        <li>There are also more complicated platform-dependent local improvements, requiring some code analysis. For example, two back-to-back fences often have the same effect as a single fence, so if code is generated for two atomic operations in sequence, only a single fence need separate them.  On x86, even a single fence separating atomic stores can be omitted, as the fence following a store is only needed to separate the store from a subsequent load.</li>
      </ul>
    </emu-note>
  </emu-clause>
</emu-clause>

<emu-annex id="sec-grammar-summary">
  <h1>Grammar Summary</h1>

  <emu-annex id="sec-lexical-grammar">
    <h1>Lexical Grammar</h1>
    <emu-prodref name=SourceCharacter></emu-prodref>
    <emu-prodref name=InputElementDiv></emu-prodref>
    <emu-prodref name=InputElementRegExp></emu-prodref>
    <emu-prodref name=InputElementRegExpOrTemplateTail></emu-prodref>
    <emu-prodref name=InputElementTemplateTail></emu-prodref>
    <emu-prodref name=WhiteSpace></emu-prodref>
    <emu-prodref name=LineTerminator></emu-prodref>
    <emu-prodref name=LineTerminatorSequence></emu-prodref>
    <emu-prodref name=Comment></emu-prodref>
    <emu-prodref name=MultiLineComment></emu-prodref>
    <emu-prodref name=MultiLineCommentChars></emu-prodref>
    <emu-prodref name=PostAsteriskCommentChars></emu-prodref>
    <emu-prodref name=MultiLineNotAsteriskChar></emu-prodref>
    <emu-prodref name=MultiLineNotForwardSlashOrAsteriskChar></emu-prodref>
    <emu-prodref name=SingleLineComment></emu-prodref>
    <emu-prodref name=SingleLineCommentChars></emu-prodref>
    <emu-prodref name=SingleLineCommentChar></emu-prodref>
    <emu-prodref name=CommonToken></emu-prodref>
    <emu-prodref name=IdentifierName></emu-prodref>
    <emu-prodref name=IdentifierStart></emu-prodref>
    <emu-prodref name=IdentifierPart></emu-prodref>
    <emu-prodref name=UnicodeIDStart></emu-prodref>
    <emu-prodref name=UnicodeIDContinue></emu-prodref>
    <emu-prodref name=ReservedWord></emu-prodref>
    <emu-prodref name=Keyword></emu-prodref>
    <emu-prodref name=FutureReservedWord></emu-prodref>
    <p>The following tokens are also considered to be |FutureReservedWord|s when parsing strict mode code:</p>
    <p><emu-t>implements</emu-t> &nbsp;<emu-t>package</emu-t> &nbsp;<emu-t>protected</emu-t><br>
      <emu-t>interface</emu-t> &nbsp;<emu-t>private</emu-t> &nbsp;<emu-t>public</emu-t>
    </p>
    <p>&nbsp;</p>
    <emu-prodref name=Punctuator></emu-prodref>
    <emu-prodref name=DivPunctuator></emu-prodref>
    <emu-prodref name=RightBracePunctuator></emu-prodref>
    <emu-prodref name=NullLiteral></emu-prodref>
    <emu-prodref name=BooleanLiteral></emu-prodref>
    <emu-prodref name=NumericLiteral></emu-prodref>
    <emu-prodref name=DecimalLiteral></emu-prodref>
    <emu-prodref name=DecimalIntegerLiteral></emu-prodref>
    <emu-prodref name=DecimalDigits></emu-prodref>
    <emu-prodref name=DecimalDigit></emu-prodref>
    <emu-prodref name=NonZeroDigit></emu-prodref>
    <emu-prodref name=ExponentPart></emu-prodref>
    <emu-prodref name=ExponentIndicator></emu-prodref>
    <emu-prodref name=SignedInteger></emu-prodref>
    <emu-prodref name=BinaryIntegerLiteral></emu-prodref>
    <emu-prodref name=BinaryDigits></emu-prodref>
    <emu-prodref name=BinaryDigit></emu-prodref>
    <emu-prodref name=OctalIntegerLiteral></emu-prodref>
    <emu-prodref name=OctalDigits></emu-prodref>
    <emu-prodref name=OctalDigit></emu-prodref>
    <emu-prodref name=HexIntegerLiteral></emu-prodref>
    <emu-prodref name=HexDigits></emu-prodref>
    <emu-prodref name=HexDigit></emu-prodref>
    <emu-prodref name=StringLiteral></emu-prodref>
    <emu-prodref name=DoubleStringCharacters></emu-prodref>
    <emu-prodref name=SingleStringCharacters></emu-prodref>
    <emu-prodref name=DoubleStringCharacter></emu-prodref>
    <emu-prodref name=SingleStringCharacter></emu-prodref>
    <emu-prodref name=LineContinuation></emu-prodref>
    <emu-prodref name=EscapeSequence></emu-prodref>
    <emu-prodref name=CharacterEscapeSequence></emu-prodref>
    <emu-prodref name=SingleEscapeCharacter></emu-prodref>
    <emu-prodref name=NonEscapeCharacter></emu-prodref>
    <emu-prodref name=EscapeCharacter></emu-prodref>
    <emu-prodref name=HexEscapeSequence></emu-prodref>
    <emu-prodref name=UnicodeEscapeSequence></emu-prodref>
    <emu-prodref name=Hex4Digits></emu-prodref>
    <emu-prodref name=RegularExpressionLiteral></emu-prodref>
    <emu-prodref name=RegularExpressionBody></emu-prodref>
    <emu-prodref name=RegularExpressionChars></emu-prodref>
    <emu-prodref name=RegularExpressionFirstChar></emu-prodref>
    <emu-prodref name=RegularExpressionChar></emu-prodref>
    <emu-prodref name=RegularExpressionBackslashSequence></emu-prodref>
    <emu-prodref name=RegularExpressionNonTerminator></emu-prodref>
    <emu-prodref name=RegularExpressionClass></emu-prodref>
    <emu-prodref name=RegularExpressionClassChars></emu-prodref>
    <emu-prodref name=RegularExpressionClassChar></emu-prodref>
    <emu-prodref name=RegularExpressionFlags></emu-prodref>
    <emu-prodref name=Template></emu-prodref>
    <emu-prodref name=NoSubstitutionTemplate></emu-prodref>
    <emu-prodref name=TemplateHead></emu-prodref>
    <emu-prodref name=TemplateSubstitutionTail></emu-prodref>
    <emu-prodref name=TemplateMiddle></emu-prodref>
    <emu-prodref name=TemplateTail></emu-prodref>
    <emu-prodref name=TemplateCharacters></emu-prodref>
    <emu-prodref name=TemplateCharacter></emu-prodref>
    <emu-prodref name=NotEscapeSequence></emu-prodref>
    <emu-prodref name=NotCodePoint></emu-prodref>
    <emu-prodref name=CodePoint></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-expressions">
    <h1>Expressions</h1>
    <emu-prodref name=IdentifierReference></emu-prodref>
    <emu-prodref name=BindingIdentifier></emu-prodref>
    <emu-prodref name=Identifier></emu-prodref>
    <emu-prodref name=AsyncArrowBindingIdentifier></emu-prodref>
    <emu-prodref name=LabelIdentifier></emu-prodref>
    <emu-prodref name=PrimaryExpression></emu-prodref>
    <emu-prodref name=CoverParenthesizedExpressionAndArrowParameterList></emu-prodref>
    <p>When processing an instance of the production <emu-prodref name=PrimaryExpression a="parencover"></emu-prodref> the interpretation of |CoverParenthesizedExpressionAndArrowParameterList| is refined using the following grammar:</p>
    <emu-prodref name=ParenthesizedExpression></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name=Literal></emu-prodref>
    <emu-prodref name=ArrayLiteral></emu-prodref>
    <emu-prodref name=ElementList></emu-prodref>
    <emu-prodref name=Elision></emu-prodref>
    <emu-prodref name=SpreadElement></emu-prodref>
    <emu-prodref name=ObjectLiteral></emu-prodref>
    <emu-prodref name=PropertyDefinitionList></emu-prodref>
    <emu-prodref name=PropertyDefinition></emu-prodref>
    <emu-prodref name=PropertyName></emu-prodref>
    <emu-prodref name=LiteralPropertyName></emu-prodref>
    <emu-prodref name=ComputedPropertyName></emu-prodref>
    <emu-prodref name=CoverInitializedName></emu-prodref>
    <emu-prodref name=Initializer></emu-prodref>
    <emu-prodref name=TemplateLiteral></emu-prodref>
    <emu-prodref name=SubstitutionTemplate></emu-prodref>
    <emu-prodref name=TemplateSpans></emu-prodref>
    <emu-prodref name=TemplateMiddleList></emu-prodref>
    <emu-prodref name=MemberExpression></emu-prodref>
    <emu-prodref name=SuperProperty></emu-prodref>
    <emu-prodref name=MetaProperty></emu-prodref>
    <emu-prodref name=NewTarget></emu-prodref>
    <emu-prodref name=NewExpression></emu-prodref>
    <emu-prodref name=CallExpression></emu-prodref>
    <emu-prodref name=CoverCallExpressionAndAsyncArrowHead></emu-prodref>
    <p>When processing an instance of the production <emu-prodref name=CallExpression a=callcover></emu-prodref> the interpretation of |CoverCallExpressionAndAsyncArrowHead| is refined using the following grammar:</p>
    <emu-prodref name=CallMemberExpression></emu-prodref>
    <p>&nbsp;</p>

    <emu-prodref name=SuperCall></emu-prodref>
    <emu-prodref name=Arguments></emu-prodref>
    <emu-prodref name=ArgumentList></emu-prodref>
    <emu-prodref name=LeftHandSideExpression></emu-prodref>
    <emu-prodref name=UpdateExpression></emu-prodref>
    <emu-prodref name=UnaryExpression></emu-prodref>
    <emu-prodref name=ExponentiationExpression></emu-prodref>
    <emu-prodref name=MultiplicativeExpression></emu-prodref>
    <emu-prodref name=MultiplicativeOperator></emu-prodref>
    <emu-prodref name=AdditiveExpression></emu-prodref>
    <emu-prodref name=ShiftExpression></emu-prodref>
    <emu-prodref name=RelationalExpression></emu-prodref>
    <emu-prodref name=EqualityExpression></emu-prodref>
    <emu-prodref name=BitwiseANDExpression></emu-prodref>
    <emu-prodref name=BitwiseXORExpression></emu-prodref>
    <emu-prodref name=BitwiseORExpression></emu-prodref>
    <emu-prodref name=LogicalANDExpression></emu-prodref>
    <emu-prodref name=LogicalORExpression></emu-prodref>
    <emu-prodref name=ConditionalExpression></emu-prodref>
    <emu-prodref name=AssignmentExpression></emu-prodref>
    <p>In certain circumstances when processing an instance of the production <emu-prodref name=AssignmentExpression a=assignment></emu-prodref> the following grammar is used to refine the interpretation of |LeftHandSideExpression|:</p>
    <emu-prodref name="AssignmentPattern"></emu-prodref>
    <emu-prodref name="ObjectAssignmentPattern"></emu-prodref>
    <emu-prodref name="ArrayAssignmentPattern"></emu-prodref>
    <emu-prodref name="AssignmentRestProperty"></emu-prodref>
    <emu-prodref name="AssignmentPropertyList"></emu-prodref>
    <emu-prodref name="AssignmentElementList"></emu-prodref>
    <emu-prodref name="AssignmentElisionElement"></emu-prodref>
    <emu-prodref name="AssignmentProperty"></emu-prodref>
    <emu-prodref name="AssignmentElement"></emu-prodref>
    <emu-prodref name="AssignmentRestElement"></emu-prodref>
    <emu-prodref name="DestructuringAssignmentTarget"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name=AssignmentOperator></emu-prodref>
    <emu-prodref name=Expression></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-statements">
    <h1>Statements</h1>
    <emu-prodref name=Statement></emu-prodref>
    <emu-prodref name=Declaration></emu-prodref>
    <emu-prodref name=HoistableDeclaration></emu-prodref>
    <emu-prodref name=BreakableStatement></emu-prodref>
    <emu-prodref name=BlockStatement></emu-prodref>
    <emu-prodref name=Block></emu-prodref>
    <emu-prodref name=StatementList></emu-prodref>
    <emu-prodref name=StatementListItem></emu-prodref>
    <emu-prodref name=LexicalDeclaration></emu-prodref>
    <emu-prodref name=LetOrConst></emu-prodref>
    <emu-prodref name=BindingList></emu-prodref>
    <emu-prodref name=LexicalBinding></emu-prodref>
    <emu-prodref name=VariableStatement></emu-prodref>
    <emu-prodref name=VariableDeclarationList></emu-prodref>
    <emu-prodref name=VariableDeclaration></emu-prodref>
    <emu-prodref name=BindingPattern></emu-prodref>
    <emu-prodref name=ObjectBindingPattern></emu-prodref>
    <emu-prodref name=ArrayBindingPattern></emu-prodref>
    <emu-prodref name=BindingRestProperty></emu-prodref>
    <emu-prodref name=BindingPropertyList></emu-prodref>
    <emu-prodref name=BindingElementList></emu-prodref>
    <emu-prodref name=BindingElisionElement></emu-prodref>
    <emu-prodref name=BindingProperty></emu-prodref>
    <emu-prodref name=BindingElement></emu-prodref>
    <emu-prodref name=SingleNameBinding></emu-prodref>
    <emu-prodref name=BindingRestElement></emu-prodref>
    <emu-prodref name=EmptyStatement></emu-prodref>
    <emu-prodref name=ExpressionStatement></emu-prodref>
    <emu-prodref name=IfStatement></emu-prodref>
    <emu-prodref name=IterationStatement></emu-prodref>
    <emu-prodref name=ForDeclaration></emu-prodref>
    <emu-prodref name=ForBinding></emu-prodref>
    <emu-prodref name=ContinueStatement></emu-prodref>
    <emu-prodref name=BreakStatement></emu-prodref>
    <emu-prodref name=ReturnStatement></emu-prodref>
    <emu-prodref name=WithStatement></emu-prodref>
    <emu-prodref name=SwitchStatement></emu-prodref>
    <emu-prodref name=CaseBlock></emu-prodref>
    <emu-prodref name=CaseClauses></emu-prodref>
    <emu-prodref name=CaseClause></emu-prodref>
    <emu-prodref name=DefaultClause></emu-prodref>
    <emu-prodref name=LabelledStatement></emu-prodref>
    <emu-prodref name=LabelledItem></emu-prodref>
    <emu-prodref name=ThrowStatement></emu-prodref>
    <emu-prodref name=TryStatement></emu-prodref>
    <emu-prodref name=Catch></emu-prodref>
    <emu-prodref name=Finally></emu-prodref>
    <emu-prodref name=CatchParameter></emu-prodref>
    <emu-prodref name=DebuggerStatement></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-functions-and-classes">
    <h1>Functions and Classes</h1>
    <emu-prodref name=FunctionDeclaration></emu-prodref>
    <emu-prodref name=FunctionExpression></emu-prodref>
    <emu-prodref name=UniqueFormalParameters></emu-prodref>
    <emu-prodref name=FormalParameters></emu-prodref>
    <emu-prodref name=FormalParameterList></emu-prodref>
    <emu-prodref name=FunctionRestParameter></emu-prodref>
    <emu-prodref name=FormalParameter></emu-prodref>
    <emu-prodref name=FunctionBody></emu-prodref>
    <emu-prodref name=FunctionStatementList></emu-prodref>
    <emu-prodref name=ArrowFunction></emu-prodref>
    <emu-prodref name=ArrowParameters></emu-prodref>
    <emu-prodref name=ConciseBody></emu-prodref>
    <p>When the production <emu-prodref name=ArrowParameters a="parencover"></emu-prodref> is recognized the following grammar is used to refine the interpretation of |CoverParenthesizedExpressionAndArrowParameterList|:</p>
    <emu-prodref name=ArrowFormalParameters></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name=AsyncArrowFunction></emu-prodref>
    <emu-prodref name=AsyncConciseBody></emu-prodref>
    <p>When the production <emu-prodref name=AsyncArrowFunction a="callcover"></emu-prodref> is recognized the following grammar is used to refine the interpretation of |CoverParenthesizedExpressionAndArrowParameterList|:</p>
    <emu-prodref name=AsyncArrowHead></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name=MethodDefinition></emu-prodref>
    <emu-prodref name=PropertySetParameterList></emu-prodref>
    <emu-prodref name=GeneratorMethod></emu-prodref>
    <emu-prodref name=GeneratorDeclaration></emu-prodref>
    <emu-prodref name=GeneratorExpression></emu-prodref>
    <emu-prodref name=GeneratorBody></emu-prodref>
    <emu-prodref name=YieldExpression></emu-prodref>
    <emu-prodref name=AsyncGeneratorMethod></emu-prodref>
    <emu-prodref name=AsyncGeneratorDeclaration></emu-prodref>
    <emu-prodref name=AsyncGeneratorExpression></emu-prodref>
    <emu-prodref name=AsyncGeneratorBody></emu-prodref>
    <emu-prodref name=AsyncMethod></emu-prodref>
    <emu-prodref name=AsyncFunctionDeclaration></emu-prodref>
    <emu-prodref name=AsyncFunctionExpression></emu-prodref>
    <emu-prodref name=AsyncFunctionBody></emu-prodref>
    <emu-prodref name=AwaitExpression></emu-prodref>
    <emu-prodref name=ClassDeclaration></emu-prodref>
    <emu-prodref name=ClassExpression></emu-prodref>
    <emu-prodref name=ClassTail></emu-prodref>
    <emu-prodref name=ClassHeritage></emu-prodref>
    <emu-prodref name=ClassBody></emu-prodref>
    <emu-prodref name=ClassElementList></emu-prodref>
    <emu-prodref name=ClassElement></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-scripts-and-modules">
    <h1>Scripts and Modules</h1>
    <emu-prodref name=Script></emu-prodref>
    <emu-prodref name=ScriptBody></emu-prodref>
    <emu-prodref name=Module></emu-prodref>
    <emu-prodref name=ModuleBody></emu-prodref>
    <emu-prodref name=ModuleItemList></emu-prodref>
    <emu-prodref name=ModuleItem></emu-prodref>
    <emu-prodref name=ImportDeclaration></emu-prodref>
    <emu-prodref name=ImportClause></emu-prodref>
    <emu-prodref name=ImportedDefaultBinding></emu-prodref>
    <emu-prodref name=NameSpaceImport></emu-prodref>
    <emu-prodref name=NamedImports></emu-prodref>
    <emu-prodref name=FromClause></emu-prodref>
    <emu-prodref name=ImportsList></emu-prodref>
    <emu-prodref name=ImportSpecifier></emu-prodref>
    <emu-prodref name=ModuleSpecifier></emu-prodref>
    <emu-prodref name=ImportedBinding></emu-prodref>
    <emu-prodref name=ExportDeclaration></emu-prodref>
    <emu-prodref name=ExportClause></emu-prodref>
    <emu-prodref name=ExportsList></emu-prodref>
    <emu-prodref name=ExportSpecifier></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-number-conversions">
    <h1>Number Conversions</h1>
    <emu-prodref name=StringNumericLiteral></emu-prodref>
    <emu-prodref name=StrWhiteSpace></emu-prodref>
    <emu-prodref name=StrWhiteSpaceChar></emu-prodref>
    <emu-prodref name=StrNumericLiteral></emu-prodref>
    <emu-prodref name=StrDecimalLiteral></emu-prodref>
    <emu-prodref name=StrUnsignedDecimalLiteral></emu-prodref>
    <emu-prodref name=DecimalDigits></emu-prodref>
    <emu-prodref name=DecimalDigit></emu-prodref>
    <emu-prodref name=ExponentPart></emu-prodref>
    <emu-prodref name=ExponentIndicator></emu-prodref>
    <emu-prodref name=SignedInteger></emu-prodref>
    <emu-prodref name=HexIntegerLiteral></emu-prodref>
    <emu-prodref name=HexDigit></emu-prodref>
    <p>All grammar symbols not explicitly defined by the |StringNumericLiteral| grammar have the definitions used in the <emu-xref href="#sec-literals-numeric-literals">Lexical Grammar for numeric literals</emu-xref>.</p>
  </emu-annex>

  <emu-annex id="sec-universal-resource-identifier-character-classes">
    <h1>Universal Resource Identifier Character Classes</h1>
    <emu-prodref name=uri></emu-prodref>
    <emu-prodref name=uriCharacters></emu-prodref>
    <emu-prodref name=uriCharacter></emu-prodref>
    <emu-prodref name=uriReserved></emu-prodref>
    <emu-prodref name=uriUnescaped></emu-prodref>
    <emu-prodref name=uriEscaped></emu-prodref>
    <emu-prodref name=uriAlpha></emu-prodref>
    <emu-prodref name=uriMark></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-regular-expressions">
    <h1>Regular Expressions</h1>
    <emu-prodref name=Pattern></emu-prodref>
    <emu-prodref name=Disjunction></emu-prodref>
    <emu-prodref name=Alternative></emu-prodref>
    <emu-prodref name=Term></emu-prodref>
    <emu-prodref name=Assertion></emu-prodref>
    <emu-prodref name=Quantifier></emu-prodref>
    <emu-prodref name=QuantifierPrefix></emu-prodref>
    <emu-prodref name=Atom></emu-prodref>
    <emu-prodref name=SyntaxCharacter></emu-prodref>
    <emu-prodref name=PatternCharacter></emu-prodref>
    <emu-prodref name=AtomEscape></emu-prodref>
    <emu-prodref name=CharacterEscape></emu-prodref>
    <emu-prodref name=ControlEscape></emu-prodref>
    <emu-prodref name=ControlLetter></emu-prodref>
    <emu-prodref name=GroupSpecifier></emu-prodref>
    <emu-prodref name=GroupName></emu-prodref>
    <emu-prodref name=RegExpIdentifierName></emu-prodref>
    <emu-prodref name=RegExpIdentifierStart></emu-prodref>
    <emu-prodref name=RegExpIdentifierPart></emu-prodref>
    <emu-prodref name=RegExpUnicodeEscapeSequence></emu-prodref>
    <p>Each `\\u` |TrailSurrogate| for which the choice of associated `u` |LeadSurrogate| is ambiguous shall be associated with the nearest possible `u` |LeadSurrogate| that would otherwise have no corresponding `\\u` |TrailSurrogate|.</p>
    <p>&nbsp;</p>
    <emu-prodref name=LeadSurrogate></emu-prodref>
    <emu-prodref name=TrailSurrogate></emu-prodref>
    <emu-prodref name=NonSurrogate></emu-prodref>
    <emu-prodref name=IdentityEscape></emu-prodref>
    <emu-prodref name=DecimalEscape></emu-prodref>
    <emu-prodref name=CharacterClassEscape></emu-prodref>
    <emu-prodref name=UnicodePropertyValueExpression></emu-prodref>
    <emu-prodref name=UnicodePropertyName></emu-prodref>
    <emu-prodref name=UnicodePropertyNameCharacters></emu-prodref>
    <emu-prodref name=UnicodePropertyValue></emu-prodref>
    <emu-prodref name=LoneUnicodePropertyNameOrValue></emu-prodref>
    <emu-prodref name=UnicodePropertyValueCharacters></emu-prodref>
    <emu-prodref name=UnicodePropertyValueCharacter></emu-prodref>
    <emu-prodref name=UnicodePropertyNameCharacter></emu-prodref>
    <emu-prodref name=CharacterClass></emu-prodref>
    <emu-prodref name=ClassRanges></emu-prodref>
    <emu-prodref name=NonemptyClassRanges></emu-prodref>
    <emu-prodref name=NonemptyClassRangesNoDash></emu-prodref>
    <emu-prodref name=ClassAtom></emu-prodref>
    <emu-prodref name=ClassAtomNoDash></emu-prodref>
    <emu-prodref name=ClassEscape></emu-prodref>
  </emu-annex>
</emu-annex>

<emu-annex id="sec-additional-ecmascript-features-for-web-browsers" namespace=annexB normative>
  <h1>Additional ECMAScript Features for Web Browsers</h1>
  <p>The ECMAScript language syntax and semantics defined in this annex are required when the ECMAScript host is a web browser. The content of this annex is normative but optional if the ECMAScript host is not a web browser.</p>
  <emu-note>
    <p>This annex describes various legacy features and other characteristics of web browser based ECMAScript implementations. All of the language features and behaviours specified in this annex have one or more undesirable characteristics and in the absence of legacy usage would be removed from this specification. However, the usage of these features by large numbers of existing web pages means that web browsers must continue to support them. The specifications in this annex define the requirements for interoperable implementations of these legacy features.</p>
    <p>These features are not considered part of the core ECMAScript language. Programmers should not use or assume the existence of these features and behaviours when writing new ECMAScript code. ECMAScript implementations are discouraged from implementing these features unless the implementation is part of a web browser or is required to run the same legacy ECMAScript code that web browsers encounter.</p>
  </emu-note>

  <emu-annex id="sec-additional-syntax">
    <h1>Additional Syntax</h1>

    <emu-annex id="sec-additional-syntax-numeric-literals">
      <h1>Numeric Literals</h1>
      <p>The syntax and semantics of <emu-xref href="#sec-literals-numeric-literals"></emu-xref> is extended as follows except that this extension is not allowed for strict mode code:</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        NumericLiteral ::
          DecimalLiteral
          BinaryIntegerLiteral
          OctalIntegerLiteral
          HexIntegerLiteral
          LegacyOctalIntegerLiteral

        LegacyOctalIntegerLiteral ::
          `0` OctalDigit
          LegacyOctalIntegerLiteral OctalDigit

        DecimalIntegerLiteral ::
          `0`
          NonZeroDigit DecimalDigits?
          NonOctalDecimalIntegerLiteral

        NonOctalDecimalIntegerLiteral ::
          `0` NonOctalDigit
          LegacyOctalLikeDecimalIntegerLiteral NonOctalDigit
          NonOctalDecimalIntegerLiteral DecimalDigit

        LegacyOctalLikeDecimalIntegerLiteral ::
          `0` OctalDigit
          LegacyOctalLikeDecimalIntegerLiteral OctalDigit

        NonOctalDigit :: one of
          `8` `9`
      </emu-grammar>

      <emu-annex id="sec-additional-syntax-numeric-literals-status-semantics">
      <h1>Static Semantics</h1>
      <ul>
        <li>
          The MV of <emu-grammar>LegacyOctalIntegerLiteral :: `0` OctalDigit</emu-grammar> is the MV of |OctalDigit|.
        </li>
        <li>
          The MV of <emu-grammar>LegacyOctalIntegerLiteral :: LegacyOctalIntegerLiteral OctalDigit</emu-grammar> is (the MV of |LegacyOctalIntegerLiteral| times 8) plus the MV of |OctalDigit|.
        </li>
        <li>
          The MV of <emu-grammar>DecimalIntegerLiteral :: NonOctalDecimalIntegerLiteral</emu-grammar> is the MV of |NonOctalDecimalIntegerLiteral|.
        </li>
        <li>
          The MV of <emu-grammar>NonOctalDecimalIntegerLiteral :: `0` NonOctalDigit</emu-grammar> is the MV of |NonOctalDigit|.
        </li>
        <li>
          The MV of <emu-grammar>NonOctalDecimalIntegerLiteral :: LegacyOctalLikeDecimalIntegerLiteral NonOctalDigit</emu-grammar> is (the MV of |LegacyOctalLikeDecimalIntegerLiteral| times 10) plus the MV of |NonOctalDigit|.
        </li>
        <li>
          The MV of <emu-grammar>NonOctalDecimalIntegerLiteral :: NonOctalDecimalIntegerLiteral DecimalDigit</emu-grammar> is (the MV of |NonOctalDecimalIntegerLiteral| times 10) plus the MV of |DecimalDigit|.
        </li>
        <li>
          The MV of <emu-grammar>LegacyOctalLikeDecimalIntegerLiteral :: `0` OctalDigit</emu-grammar> is the MV of |OctalDigit|.
        </li>
        <li>
          The MV of <emu-grammar>LegacyOctalLikeDecimalIntegerLiteral :: LegacyOctalLikeDecimalIntegerLiteral OctalDigit</emu-grammar> is (the MV of |LegacyOctalLikeDecimalIntegerLiteral| times 10) plus the MV of |OctalDigit|.
        </li>
        <li>
          The MV of <emu-grammar>NonOctalDigit :: `8`</emu-grammar> is 8.
        </li>
        <li>
          The MV of <emu-grammar>NonOctalDigit :: `9`</emu-grammar> is 9.
        </li>
      </ul>
      </emu-annex>
    </emu-annex>

    <emu-annex id="sec-additional-syntax-string-literals">
      <h1>String Literals</h1>
      <p>The syntax and semantics of <emu-xref href="#sec-literals-string-literals"></emu-xref> is extended as follows except that this extension is not allowed for strict mode code:</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        EscapeSequence ::
          CharacterEscapeSequence
          LegacyOctalEscapeSequence
          HexEscapeSequence
          UnicodeEscapeSequence

        LegacyOctalEscapeSequence ::
          OctalDigit [lookahead &lt;! OctalDigit]
          ZeroToThree OctalDigit [lookahead &lt;! OctalDigit]
          FourToSeven OctalDigit
          ZeroToThree OctalDigit OctalDigit

        ZeroToThree :: one of
          `0` `1` `2` `3`

        FourToSeven :: one of
          `4` `5` `6` `7`
      </emu-grammar>
      <p>This definition of |EscapeSequence| is not used in strict mode or when parsing |TemplateCharacter|.</p>

      <emu-annex id="sec-additional-syntax-string-literals-static-semantics">
        <h1>Static Semantics</h1>
        <ul>
          <li>
            The SV of <emu-grammar>EscapeSequence :: LegacyOctalEscapeSequence</emu-grammar> is the SV of the |LegacyOctalEscapeSequence|.
          </li>
          <li>
            The SV of <emu-grammar>LegacyOctalEscapeSequence :: OctalDigit</emu-grammar> is the code unit whose value is the MV of the |OctalDigit|.
          </li>
          <li>
            The SV of <emu-grammar>LegacyOctalEscapeSequence :: ZeroToThree OctalDigit</emu-grammar> is the code unit whose value is (8 times the MV of the |ZeroToThree|) plus the MV of the |OctalDigit|.
          </li>
          <li>
            The SV of <emu-grammar>LegacyOctalEscapeSequence :: FourToSeven OctalDigit</emu-grammar> is the code unit whose value is (8 times the MV of the |FourToSeven|) plus the MV of the |OctalDigit|.
          </li>
          <li>
            The SV of <emu-grammar>LegacyOctalEscapeSequence :: ZeroToThree OctalDigit OctalDigit</emu-grammar> is the code unit whose value is (64 (that is, 8<sup>2</sup>) times the MV of the |ZeroToThree|) plus (8 times the MV of the first |OctalDigit|) plus the MV of the second |OctalDigit|.
          </li>
          <li>
            The MV of <emu-grammar>ZeroToThree :: `0`</emu-grammar> is 0.
          </li>
          <li>
            The MV of <emu-grammar>ZeroToThree :: `1`</emu-grammar> is 1.
          </li>
          <li>
            The MV of <emu-grammar>ZeroToThree :: `2`</emu-grammar> is 2.
          </li>
          <li>
            The MV of <emu-grammar>ZeroToThree :: `3`</emu-grammar> is 3.
          </li>
          <li>
            The MV of <emu-grammar>FourToSeven :: `4`</emu-grammar> is 4.
          </li>
          <li>
            The MV of <emu-grammar>FourToSeven :: `5`</emu-grammar> is 5.
          </li>
          <li>
            The MV of <emu-grammar>FourToSeven :: `6`</emu-grammar> is 6.
          </li>
          <li>
            The MV of <emu-grammar>FourToSeven :: `7`</emu-grammar> is 7.
          </li>
        </ul>
      </emu-annex>
    </emu-annex>

    <emu-annex id="sec-html-like-comments">
      <h1>HTML-like Comments</h1>
      <p>The syntax and semantics of <emu-xref href="#sec-comments"></emu-xref> is extended as follows except that this extension is not allowed when parsing source code using the goal symbol |Module|:</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        Comment ::
          MultiLineComment
          SingleLineComment
          SingleLineHTMLOpenComment
          SingleLineHTMLCloseComment
          SingleLineDelimitedComment

        MultiLineComment ::
          `/*` FirstCommentLine? LineTerminator MultiLineCommentChars? `*/` HTMLCloseComment?

        FirstCommentLine ::
          SingleLineDelimitedCommentChars

        SingleLineHTMLOpenComment ::
          `&lt;!--` SingleLineCommentChars?

        SingleLineHTMLCloseComment ::
          LineTerminatorSequence HTMLCloseComment

        SingleLineDelimitedComment ::
          `/*` SingleLineDelimitedCommentChars? `*/`

        HTMLCloseComment ::
          WhiteSpaceSequence? SingleLineDelimitedCommentSequence? `--&gt;` SingleLineCommentChars?

        SingleLineDelimitedCommentChars ::
          SingleLineNotAsteriskChar SingleLineDelimitedCommentChars?
          `*` SingleLinePostAsteriskCommentChars?

        SingleLineNotAsteriskChar ::
          SourceCharacter but not one of `*` or LineTerminator

        SingleLinePostAsteriskCommentChars ::
          SingleLineNotForwardSlashOrAsteriskChar SingleLineDelimitedCommentChars?
          `*` SingleLinePostAsteriskCommentChars?

        SingleLineNotForwardSlashOrAsteriskChar ::
          SourceCharacter but not one of `/` or `*` or LineTerminator

        WhiteSpaceSequence ::
          WhiteSpace WhiteSpaceSequence?

        SingleLineDelimitedCommentSequence ::
          SingleLineDelimitedComment WhiteSpaceSequence? SingleLineDelimitedCommentSequence?
      </emu-grammar>
      <p>Similar to a |MultiLineComment| that contains a line terminator code point, a |SingleLineHTMLCloseComment| is considered to be a |LineTerminator| for purposes of parsing by the syntactic grammar.</p>
    </emu-annex>

    <emu-annex id="sec-regular-expressions-patterns">
      <h1>Regular Expressions Patterns</h1>
      <p>The syntax of <emu-xref href="#sec-patterns"></emu-xref> is modified and extended as follows. These changes introduce ambiguities that are broken by the ordering of grammar productions and by contextual information. When parsing using the following grammar, each alternative is considered only if previous production alternatives do not match.</p>
      <p>This alternative pattern grammar and semantics only changes the syntax and semantics of BMP patterns. The following grammar extensions include productions parameterized with the [U] parameter. However, none of these extensions change the syntax of Unicode patterns recognized when parsing with the [U] parameter present on the goal symbol.</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        Term[U, N] ::
          [+U] Assertion[+U, ?N]
          [+U] Atom[+U, ?N]
          [+U] Atom[+U, ?N] Quantifier
          [~U] QuantifiableAssertion[?N] Quantifier
          [~U] Assertion[~U, ?N]
          [~U] ExtendedAtom[?N] Quantifier
          [~U] ExtendedAtom[?N]

        Assertion[U, N] ::
          `^`
          `$`
          `\` `b`
          `\` `B`
          [+U] `(` `?` `=` Disjunction[+U, ?N] `)`
          [+U] `(` `?` `!` Disjunction[+U, ?N] `)`
          [~U] QuantifiableAssertion[?N]
          `(` `?` `&lt;=` Disjunction[?U, ?N] `)`
          `(` `?` `&lt;!` Disjunction[?U, ?N] `)`

        QuantifiableAssertion[N] ::
          `(` `?` `=` Disjunction[~U, ?N] `)`
          `(` `?` `!` Disjunction[~U, ?N] `)`

        ExtendedAtom[N] ::
          `.`
          `\` AtomEscape[~U, ?N]
          `\` [lookahead == `c`]
          CharacterClass[~U]
          `(` Disjunction[~U, ?N] `)`
          `(` `?` `:` Disjunction[~U, ?N] `)`
          InvalidBracedQuantifier
          ExtendedPatternCharacter

        InvalidBracedQuantifier ::
          `{` DecimalDigits `}`
          `{` DecimalDigits `,` `}`
          `{` DecimalDigits `,` DecimalDigits `}`

        ExtendedPatternCharacter ::
          SourceCharacter but not one of `^` `$` `\` `.` `*` `+` `?` `(` `)` `[` `|`

        AtomEscape[U, N] ::
          [+U] DecimalEscape
          [~U] DecimalEscape [> but only if the CapturingGroupNumber of |DecimalEscape| is &lt;= _NcapturingParens_]
          CharacterClassEscape[?U]
          CharacterEscape[~U, ?N]
          [+N] `k` GroupName[?U]

        CharacterEscape[U, N] ::
          ControlEscape
          `c` ControlLetter
          `0` [lookahead &lt;! DecimalDigit]
          HexEscapeSequence
          RegExpUnicodeEscapeSequence[?U]
          [~U] LegacyOctalEscapeSequence
          IdentityEscape[?U, ?N]

        IdentityEscape[U, N] ::
          [+U] SyntaxCharacter
          [+U] `/`
          [~U] SourceCharacterIdentityEscape[?N]

        SourceCharacterIdentityEscape[N] ::
          [~N] SourceCharacter but not `c`
          [+N] SourceCharacter but not one of `c` or `k`

        ClassAtomNoDash[U, N] ::
          SourceCharacter but not one of `\` or `]` or `-`
          `\` ClassEscape[?U, ?N]
          `\` [lookahead == `c`]

        ClassEscape[U, N] ::
          `b`
          [+U] `-`
          [~U] `c` ClassControlLetter
          CharacterClassEscape[?U]
          CharacterEscape[?U, ?N]

        ClassControlLetter ::
          DecimalDigit
          `_`
      </emu-grammar>
      <emu-note>
        <p>When the same left hand sides occurs with both [+U] and [\~U] guards it is to control the disambiguation priority.</p>
      </emu-note>

      <emu-annex id="sec-patterns-static-semantics-early-errors-annexb">
        <h1>Static Semantics: Early Errors</h1>
        <p>The semantics of <emu-xref href="#sec-patterns-static-semantics-early-errors"></emu-xref> is extended as follows:</p>
        <emu-grammar>ExtendedAtom :: InvalidBracedQuantifier</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if any source text matches this rule.
          </li>
        </ul>
        <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassRanges</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if IsCharacterClass of the first |ClassAtom| is *true* or IsCharacterClass of the second |ClassAtom| is *true* <ins>and this production has a <sub>[U]</sub> parameter</ins>.
          </li>
        </ul>
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassRanges</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if IsCharacterClass of |ClassAtomNoDash| is *true* or IsCharacterClass of |ClassAtom| is *true* <ins>and this production has a <sub>[U]</sub> parameter</ins>.
          </li>
        </ul>
      </emu-annex>

      <emu-annex id="sec-patterns-static-semantics-is-character-class-annexb">
        <h1>Static Semantics: IsCharacterClass</h1>
        <p>The semantics of <emu-xref href="#sec-patterns-static-semantics-is-character-class"></emu-xref> is extended as follows:</p>
        <emu-grammar>
          ClassAtomNoDash :: `\` [lookahead == `c`]
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-patterns-static-semantics-character-value-annexb">
        <h1>Static Semantics: CharacterValue</h1>
        <p>The semantics of <emu-xref href="#sec-patterns-static-semantics-character-value"></emu-xref> is extended as follows:</p>
        <emu-grammar>
          ClassAtomNoDash :: `\` [lookahead == `c`]
        </emu-grammar>
        <emu-alg>
          1. Return the code point value of U+005C (REVERSE SOLIDUS).
        </emu-alg>
        <emu-grammar>ClassEscape :: `c` ClassControlLetter</emu-grammar>
        <emu-alg>
          1. Let _ch_ be the code point matched by |ClassControlLetter|.
          1. Let _i_ be _ch_'s code point value.
          1. Return the remainder of dividing _i_ by 32.
        </emu-alg>
        <emu-grammar>CharacterEscape :: LegacyOctalEscapeSequence</emu-grammar>
        <emu-alg>
          1. Evaluate the SV of the |LegacyOctalEscapeSequence| (see <emu-xref href="#sec-additional-syntax-string-literals"></emu-xref>) to obtain a code unit _cu_.
          1. Return the numeric value of _cu_.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-regular-expression-patterns-semantics">
        <h1>Pattern Semantics</h1>
        <p>The semantics of <emu-xref href="#sec-pattern-semantics"></emu-xref> is extended as follows:</p>
        <p>Within <emu-xref href="#sec-term"></emu-xref> reference to &ldquo;<emu-grammar>Atom :: `(` GroupSpecifier Disjunction `)`</emu-grammar> &rdquo; are to be interpreted as meaning &ldquo;<emu-grammar>Atom :: `(` GroupSpecifier Disjunction `)`</emu-grammar> &rdquo; or &ldquo;<emu-grammar>ExtendedAtom :: `(` Disjunction `)`</emu-grammar> &rdquo;.</p>

        <p>Term (<emu-xref href="#sec-term"></emu-xref>) includes the following additional evaluation rules:</p>
        <p>The production <emu-grammar>Term :: QuantifiableAssertion Quantifier</emu-grammar> evaluates the same as the production <emu-grammar>Term :: Atom Quantifier</emu-grammar> but with |QuantifiableAssertion| substituted for |Atom|.</p>
        <p>The production <emu-grammar>Term :: ExtendedAtom Quantifier</emu-grammar> evaluates the same as the production <emu-grammar>Term :: Atom Quantifier</emu-grammar> but with |ExtendedAtom| substituted for |Atom|.</p>
        <p>The production <emu-grammar>Term :: ExtendedAtom</emu-grammar> evaluates the same as the production <emu-grammar>Term :: Atom</emu-grammar> but with |ExtendedAtom| substituted for |Atom|.</p>

        <p>Assertion (<emu-xref href="#sec-assertion"></emu-xref>) includes the following additional evaluation rule:</p>
        <p>The production <emu-grammar>Assertion :: QuantifiableAssertion</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate |QuantifiableAssertion| to obtain a Matcher _m_.
          1. Return _m_.
        </emu-alg>

        <p>Assertion (<emu-xref href="#sec-assertion"></emu-xref>) evaluation rules for the <emu-grammar>Assertion :: `(` `?` `=` Disjunction `)`</emu-grammar> and <emu-grammar>Assertion :: `(` `?` `!` Disjunction `)`</emu-grammar> productions are also used for the |QuantifiableAssertion| productions, but with |QuantifiableAssertion| substituted for |Assertion|.</p>

        <p>Atom (<emu-xref href="#sec-atom"></emu-xref>) evaluation rules for the |Atom| productions except for <emu-grammar>Atom :: PatternCharacter</emu-grammar> are also used for the |ExtendedAtom| productions, but with |ExtendedAtom| substituted for |Atom|. The following evaluation rules are also added:</p>
        <p>The production <emu-grammar>ExtendedAtom :: `\` [lookahead == `c`]</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Let _A_ be the CharSet containing the single character `\\` U+005C (REVERSE SOLIDUS).
          1. Call CharacterSetMatcher(_A_, *false*) and return its Matcher result.
        </emu-alg>
        <p>The production <emu-grammar>ExtendedAtom :: ExtendedPatternCharacter</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Let _ch_ be the character represented by |ExtendedPatternCharacter|.
          1. Let _A_ be a one-element CharSet containing the character _ch_.
          1. Call CharacterSetMatcher(_A_, *false*) and return its Matcher result.
        </emu-alg>

        <p>CharacterEscape (<emu-xref href="#sec-characterescape"></emu-xref>) includes the following additional evaluation rule:</p>
        <p>The production <emu-grammar>CharacterEscape :: LegacyOctalEscapeSequence</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Let _cv_ be the CharacterValue of this |CharacterEscape|.
          1. Return the character whose character value is _cv_.
        </emu-alg>

        <p>NonemptyClassRanges (<emu-xref href="#sec-nonemptyclassranges"></emu-xref>) modifies the following evaluation rule:</p>
        <p>The production <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassRanges</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate the first |ClassAtom| to obtain a CharSet _A_.
          1. Evaluate the second |ClassAtom| to obtain a CharSet _B_.
          1. Evaluate |ClassRanges| to obtain a CharSet _C_.
          1. Call CharacterRangeOrUnion(_A_, _B_) and let _D_ be the resulting CharSet.
          1. Return the union of CharSets _D_ and _C_.
        </emu-alg>

        <p>NonemptyClassRangesNoDash (<emu-xref href="#sec-nonemptyclassrangesnodash"></emu-xref>) modifies the following evaluation rule:</p>
        <p>The production <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassRanges</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Evaluate |ClassAtomNoDash| to obtain a CharSet _A_.
          1. Evaluate |ClassAtom| to obtain a CharSet _B_.
          1. Evaluate |ClassRanges| to obtain a CharSet _C_.
          1. Call CharacterRangeOrUnion(_A_, _B_) and let _D_ be the resulting CharSet.
          1. Return the union of CharSets _D_ and _C_.
        </emu-alg>

        <p>ClassEscape (<emu-xref href="#sec-classescape"></emu-xref>) includes the following additional evaluation rule:</p>
        <p>The production <emu-grammar>ClassEscape :: `c` ClassControlLetter</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Let _cv_ be the CharacterValue of this |ClassEscape|.
          1. Let _c_ be the character whose character value is _cv_.
          1. Return the CharSet containing the single character _c_.
        </emu-alg>

        <p>ClassAtomNoDash (<emu-xref href="#sec-classatomnodash"></emu-xref>) includes the following additional evaluation rule:</p>
        <p>The production <emu-grammar>ClassAtomNoDash :: `\` [lookahead == `c`]</emu-grammar> evaluates as follows:</p>
        <emu-alg>
          1. Return the CharSet containing the single character `\\` U+005C (REVERSE SOLIDUS).
        </emu-alg>

        <emu-note>This production can only be reached from the sequence `\c` within a character class where it is not followed by an acceptable control character.</emu-note>

        <emu-annex id="sec-runtime-semantics-characterrangeorunion-abstract-operation" aoid="CharacterRangeOrUnion">
          <h1>Runtime Semantics: CharacterRangeOrUnion ( _A_, _B_ )</h1>
          <p>The abstract operation CharacterRangeOrUnion takes two CharSet parameters _A_ and _B_ and performs the following steps:</p>
          <emu-alg>
            1. If _Unicode_ is *false*, then
              1. If _A_ does not contain exactly one character or _B_ does not contain exactly one character, then
                1. Let _C_ be the CharSet containing the single character `-` U+002D (HYPHEN-MINUS).
                1. Return the union of CharSets _A_, _B_ and _C_.
            1. Return CharacterRange(_A_, _B_).
          </emu-alg>
        </emu-annex>
      </emu-annex>
    </emu-annex>
  </emu-annex>

  <emu-annex id="sec-additional-built-in-properties">
    <h1>Additional Built-in Properties</h1>
    <p>When the ECMAScript host is a web browser the following additional properties of the standard built-in objects are defined.</p>

    <emu-annex id="sec-additional-properties-of-the-global-object">
      <h1>Additional Properties of the Global Object</h1>
      <p>The entries in <emu-xref href="#table-60"></emu-xref> are added to <emu-xref href="#table-7"></emu-xref>.</p>
      <emu-table id="table-60" caption="Additional Well-known Intrinsic Objects">
        <table>
          <tbody>
          <tr>
            <th>
              Intrinsic Name
            </th>
            <th>
              Global Name
            </th>
            <th>
              ECMAScript Language Association
            </th>
          </tr>
          <tr>
            <td>
              %escape%
            </td>
            <td>
              `escape`
            </td>
            <td>
              The `escape` function (<emu-xref href="#sec-escape-string"></emu-xref>)
            </td>
          </tr>
          <tr>
            <td>
              %unescape%
            </td>
            <td>
              `unescape`
            </td>
            <td>
              The `unescape` function (<emu-xref href="#sec-unescape-string"></emu-xref>)
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>

      <emu-annex id="sec-escape-string">
        <h1>escape ( _string_ )</h1>
        <p>The `escape` function is a property of the global object. It computes a new version of a String value in which certain code units have been replaced by a hexadecimal escape sequence.</p>
        <p>For those code units being replaced whose value is `0x00FF` or less, a two-digit escape sequence of the form <code>%<var>xx</var></code> is used. For those characters being replaced whose code unit value is greater than `0x00FF`, a four-digit escape sequence of the form <code>%u<var>xxxx</var></code> is used.</p>
        <p>The `escape` function is the <dfn>%escape%</dfn> intrinsic object. When the `escape` function is called with one argument _string_, the following steps are taken:</p>
        <emu-alg>
          1. Set _string_ to ? ToString(_string_).
          1. Let _length_ be the number of code units in _string_.
          1. Let _R_ be the empty string.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _length_,
            1. Let _char_ be the code unit (represented as a 16-bit unsigned integer) at index _k_ within _string_.
            1. If _char_ is one of the code units in `"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@*_+-./"`, then
              1. Let _S_ be the String value containing the single code unit _char_.
            1. Else if _char_ &ge; 256, then
              1. Let _n_ be the numeric value of _char_.
              1. Let _S_ be the string-concatenation of:
                * `"%u"`
                * the String representation of _n_, formatted as a four-digit uppercase hexadecimal number, padded to the left with zeroes if necessary
            1. Else _char_ &lt; 256,
              1. Let _n_ be the numeric value of _char_.
              1. Let _S_ be the string-concatenation of:
                * `"%"`
                * the String representation of _n_, formatted as a two-digit uppercase hexadecimal number, padded to the left with a zero if necessary
            1. Set _R_ to the string-concatenation of the previous value of _R_ and _S_.
            1. Increase _k_ by 1.
          1. Return _R_.
        </emu-alg>
        <emu-note>
          <p>The encoding is partly based on the encoding described in RFC 1738, but the entire encoding specified in this standard is described above without regard to the contents of RFC 1738. This encoding does not reflect changes to RFC 1738 made by RFC 3986.</p>
        </emu-note>
      </emu-annex>

      <emu-annex id="sec-unescape-string">
        <h1>unescape ( _string_ )</h1>
        <p>The `unescape` function is a property of the global object. It computes a new version of a String value in which each escape sequence of the sort that might be introduced by the `escape` function is replaced with the code unit that it represents.</p>
        <p>The `unescape` function is the <dfn>%unescape%</dfn> intrinsic object. When the `unescape` function is called with one argument _string_, the following steps are taken:</p>
        <emu-alg>
          1. Set _string_ to ? ToString(_string_).
          1. Let _length_ be the number of code units in _string_.
          1. Let _R_ be the empty String.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &ne; _length_
            1. Let _c_ be the code unit at index _k_ within _string_.
            1. If _c_ is the code unit 0x0025 (PERCENT SIGN), then
              1. If _k_ &le; _length_ - 6 and the code unit at index _k_ + 1 within _string_ is the code unit 0x0075 (LATIN SMALL LETTER U) and the four code units at indices _k_ + 2, _k_ + 3, _k_ + 4, and _k_ + 5 within _string_ are all hexadecimal digits, then
                1. Set _c_ to the code unit whose value is the integer represented by the four hexadecimal digits at indices _k_ + 2, _k_ + 3, _k_ + 4, and _k_ + 5 within _string_.
                1. Increase _k_ by 5.
              1. Else if _k_ &le; _length_ - 3 and the two code units at indices _k_ + 1 and _k_ + 2 within _string_ are both hexadecimal digits, then
                1. Set _c_ to the code unit whose value is the integer represented by two zeroes plus the two hexadecimal digits at indices _k_ + 1 and _k_ + 2 within _string_.
                1. Increase _k_ by 2.
            1. Set _R_ to the string-concatenation of the previous value of _R_ and _c_.
            1. Increase _k_ by 1.
          1. Return _R_.
        </emu-alg>
      </emu-annex>
    </emu-annex>

    <emu-annex id="sec-additional-properties-of-the-object.prototype-object">
      <h1>Additional Properties of the Object.prototype Object</h1>

      <emu-annex id="sec-object.prototype.__proto__">
        <h1>Object.prototype.__proto__</h1>
        <p>Object.prototype.__proto__ is an accessor property with attributes { [[Enumerable]]: *false*, [[Configurable]]: *true* }. The [[Get]] and [[Set]] attributes are defined as follows:</p>

        <emu-annex id="sec-get-object.prototype.__proto__">
          <h1>get Object.prototype.__proto__</h1>
          <p>The value of the [[Get]] attribute is a built-in function that requires no arguments. It performs the following steps:</p>
          <emu-alg>
            1. Let _O_ be ? ToObject(*this* value).
            1. Return ? _O_.[[GetPrototypeOf]]().
          </emu-alg>
        </emu-annex>

        <emu-annex id="sec-set-object.prototype.__proto__">
          <h1>set Object.prototype.__proto__</h1>
          <p>The value of the [[Set]] attribute is a built-in function that takes an argument _proto_. It performs the following steps:</p>
          <emu-alg>
            1. Let _O_ be ? RequireObjectCoercible(*this* value).
            1. If Type(_proto_) is neither Object nor Null, return *undefined*.
            1. If Type(_O_) is not Object, return *undefined*.
            1. Let _status_ be ? _O_.[[SetPrototypeOf]](_proto_).
            1. If _status_ is *false*, throw a *TypeError* exception.
            1. Return *undefined*.
          </emu-alg>
        </emu-annex>
      </emu-annex>

      <emu-annex id="sec-object.prototype.__defineGetter__">
        <h1>Object.prototype.__defineGetter__ ( _P_, _getter_ )</h1>
        <p>When the `__defineGetter__` method is called with arguments _P_ and _getter_, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. If IsCallable(_getter_) is *false*, throw a *TypeError* exception.
          1. Let _desc_ be PropertyDescriptor { [[Get]]: _getter_, [[Enumerable]]: *true*, [[Configurable]]: *true* }.
          1. Let _key_ be ? ToPropertyKey(_P_).
          1. Perform ? DefinePropertyOrThrow(_O_, _key_, _desc_).
          1. Return *undefined*.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-object.prototype.__defineSetter__">
        <h1>Object.prototype.__defineSetter__ ( _P_, _setter_ )</h1>
        <p>When the `__defineSetter__` method is called with arguments _P_ and _setter_, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. If IsCallable(_setter_) is *false*, throw a *TypeError* exception.
          1. Let _desc_ be PropertyDescriptor { [[Set]]: _setter_, [[Enumerable]]: *true*, [[Configurable]]: *true* }.
          1. Let _key_ be ? ToPropertyKey(_P_).
          1. Perform ? DefinePropertyOrThrow(_O_, _key_, _desc_).
          1. Return *undefined*.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-object.prototype.__lookupGetter__">
        <h1>Object.prototype.__lookupGetter__ ( _P_ )</h1>
        <p>When the `__lookupGetter__` method is called with argument _P_, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _key_ be ? ToPropertyKey(_P_).
          1. Repeat,
            1. Let _desc_ be ? _O_.[[GetOwnProperty]](_key_).
            1. If _desc_ is not *undefined*, then
              1. If IsAccessorDescriptor(_desc_) is *true*, return _desc_.[[Get]].
              1. Return *undefined*.
            1. Set _O_ to ? _O_.[[GetPrototypeOf]]().
            1. If _O_ is *null*, return *undefined*.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-object.prototype.__lookupSetter__">
        <h1>Object.prototype.__lookupSetter__ ( _P_ )</h1>
        <p>When the `__lookupSetter__` method is called with argument _P_, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _key_ be ? ToPropertyKey(_P_).
          1. Repeat,
            1. Let _desc_ be ? _O_.[[GetOwnProperty]](_key_).
            1. If _desc_ is not *undefined*, then
              1. If IsAccessorDescriptor(_desc_) is *true*, return _desc_.[[Set]].
              1. Return *undefined*.
            1. Set _O_ to ? _O_.[[GetPrototypeOf]]().
            1. If _O_ is *null*, return *undefined*.
        </emu-alg>
      </emu-annex>
    </emu-annex>

    <emu-annex id="sec-additional-properties-of-the-string.prototype-object">
      <h1>Additional Properties of the String.prototype Object</h1>

      <emu-annex id="sec-string.prototype.substr">
        <h1>String.prototype.substr ( _start_, _length_ )</h1>
        <p>The `substr` method takes two arguments, _start_ and _length_, and returns a substring of the result of converting the *this* object to a String, starting from index _start_ and running for _length_ code units (or through the end of the String if _length_ is *undefined*). If _start_ is negative, it is treated as <emu-eqn>_sourceLength_ + _start_</emu-eqn> where _sourceLength_ is the length of the String. The result is a String value, not a String object. The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? RequireObjectCoercible(*this* value).
          1. Let _S_ be ? ToString(_O_).
          1. Let _intStart_ be ? ToInteger(_start_).
          1. If _length_ is *undefined*, let _end_ be *+&infin;*; otherwise let _end_ be ? ToInteger(_length_).
          1. Let _size_ be the number of code units in _S_.
          1. If _intStart_ &lt; 0, set _intStart_ to max(_size_ + _intStart_, 0).
          1. Let _resultLength_ be min(max(_end_, 0), _size_ - _intStart_).
          1. If _resultLength_ &le; 0, return the empty String `""`.
          1. Return the String value containing _resultLength_ consecutive code units from _S_ beginning with the code unit at index _intStart_.
        </emu-alg>
        <emu-note>
          <p>The `substr` function is intentionally generic; it does not require that its *this* value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-annex>

      <emu-annex id="sec-string.prototype.anchor">
        <h1>String.prototype.anchor ( _name_ )</h1>
        <p>When the `anchor` method is called with argument _name_, the following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, `"a"`, `"name"`, _name_).
        </emu-alg>

        <emu-annex id="sec-createhtml" aoid="CreateHTML">
          <h1>Runtime Semantics: CreateHTML ( _string_, _tag_, _attribute_, _value_ )</h1>
          <p>The abstract operation CreateHTML is called with arguments _string_, _tag_, _attribute_, and _value_. The arguments _tag_ and _attribute_ must be String values. The following steps are taken:</p>
          <emu-alg>
            1. Let _str_ be ? RequireObjectCoercible(_string_).
            1. Let _S_ be ? ToString(_str_).
            1. Let _p1_ be the string-concatenation of `"&lt;"` and _tag_.
            1. If _attribute_ is not the empty String, then
              1. Let _V_ be ? ToString(_value_).
              1. Let _escapedV_ be the String value that is the same as _V_ except that each occurrence of the code unit 0x0022 (QUOTATION MARK) in _V_ has been replaced with the six code unit sequence `"&amp;quot;"`.
              1. Set _p1_ to the string-concatenation of:
                * _p1_
                * the code unit 0x0020 (SPACE)
                * _attribute_
                * the code unit 0x003D (EQUALS SIGN)
                * the code unit 0x0022 (QUOTATION MARK)
                * _escapedV_
                * the code unit 0x0022 (QUOTATION MARK)
            1. Let _p2_ be the string-concatenation of _p1_ and `"&gt;"`.
            1. Let _p3_ be the string-concatenation of _p2_ and _S_.
            1. Let _p4_ be the string-concatenation of _p3_, `"&lt;/"`, _tag_, and `"&gt;"`.
            1. Return _p4_.
          </emu-alg>
        </emu-annex>
      </emu-annex>

      <emu-annex id="sec-string.prototype.big">
        <h1>String.prototype.big ( )</h1>
        <p>When the `big` method is called with no arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, `"big"`, `""`, `""`).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.blink">
        <h1>String.prototype.blink ( )</h1>
        <p>When the `blink` method is called with no arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, `"blink"`, `""`, `""`).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.bold">
        <h1>String.prototype.bold ( )</h1>
        <p>When the `bold` method is called with no arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, `"b"`, `""`, `""`).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.fixed">
        <h1>String.prototype.fixed ( )</h1>
        <p>When the `fixed` method is called with no arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, `"tt"`, `""`, `""`).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.fontcolor">
        <h1>String.prototype.fontcolor ( _color_ )</h1>
        <p>When the `fontcolor` method is called with argument _color_, the following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, `"font"`, `"color"`, _color_).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.fontsize">
        <h1>String.prototype.fontsize ( _size_ )</h1>
        <p>When the `fontsize` method is called with argument _size_, the following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, `"font"`, `"size"`, _size_).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.italics">
        <h1>String.prototype.italics ( )</h1>
        <p>When the `italics` method is called with no arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, `"i"`, `""`, `""`).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.link">
        <h1>String.prototype.link ( _url_ )</h1>
        <p>When the `link` method is called with argument _url_, the following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, `"a"`, `"href"`, _url_).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.small">
        <h1>String.prototype.small ( )</h1>
        <p>When the `small` method is called with no arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, `"small"`, `""`, `""`).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.strike">
        <h1>String.prototype.strike ( )</h1>
        <p>When the `strike` method is called with no arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, `"strike"`, `""`, `""`).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.sub">
        <h1>String.prototype.sub ( )</h1>
        <p>When the `sub` method is called with no arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, `"sub"`, `""`, `""`).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.sup">
        <h1>String.prototype.sup ( )</h1>
        <p>When the `sup` method is called with no arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, `"sup"`, `""`, `""`).
        </emu-alg>
      </emu-annex>

      <emu-annex id="String.prototype.trimleft">
        <h1>String.prototype.trimLeft ( )</h1>
        <emu-note>
          <p>The property `trimStart` is preferred. The `trimLeft` property is provided principally for compatibility with old code. It is recommended that the `trimStart` property be used in new ECMAScript code.</p>
        </emu-note>
        <p>The initial value of the `trimLeft` property is the same function object as the initial value of the `String.prototype.trimStart` property.</p>
      </emu-annex>

      <emu-annex id="String.prototype.trimright">
        <h1>String.prototype.trimRight ( )</h1>
        <emu-note>
          <p>The property `trimEnd` is preferred. The `trimRight` property is provided principally for compatibility with old code. It is recommended that the `trimEnd` property be used in new ECMAScript code.</p>
        </emu-note>
        <p>The initial value of the `trimRight` property is the same function object as the initial value of the `String.prototype.trimEnd` property.</p>
      </emu-annex>
    </emu-annex>

    <emu-annex id="sec-additional-properties-of-the-date.prototype-object">
      <h1>Additional Properties of the Date.prototype Object</h1>

      <emu-annex id="sec-date.prototype.getyear">
        <h1>Date.prototype.getYear ( )</h1>
        <emu-note>
          <p>The `getFullYear` method is preferred for nearly all purposes, because it avoids the &ldquo;year 2000 problem.&rdquo;</p>
        </emu-note>
        <p>When the `getYear` method is called with no arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. If _t_ is *NaN*, return *NaN*.
          1. Return YearFromTime(LocalTime(_t_)) - 1900.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-date.prototype.setyear">
        <h1>Date.prototype.setYear ( _year_ )</h1>
        <emu-note>
          <p>The `setFullYear` method is preferred for nearly all purposes, because it avoids the &ldquo;year 2000 problem.&rdquo;</p>
        </emu-note>
        <p>When the `setYear` method is called with one argument _year_, the following steps are taken:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. If _t_ is *NaN*, set _t_ to *+0*; otherwise, set _t_ to LocalTime(_t_).
          1. Let _y_ be ? ToNumber(_year_).
          1. If _y_ is *NaN*, then
            1. Set the [[DateValue]] internal slot of this Date object to *NaN*.
            1. Return *NaN*.
          1. Let _yi_ be ! ToInteger(_y_).
          1. If 0 &le; _yi_ &le; 99, let _yyyy_ be _yi_ + 1900.
          1. Else, let _yyyy_ be _y_.
          1. Let _d_ be MakeDay(_yyyy_, MonthFromTime(_t_), DateFromTime(_t_)).
          1. Let _date_ be UTC(MakeDate(_d_, TimeWithinDay(_t_))).
          1. Set the [[DateValue]] internal slot of this Date object to TimeClip(_date_).
          1. Return the value of the [[DateValue]] internal slot of this Date object.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-date.prototype.togmtstring">
        <h1>Date.prototype.toGMTString ( )</h1>
        <emu-note>
          <p>The property `toUTCString` is preferred. The `toGMTString` property is provided principally for compatibility with old code. It is recommended that the `toUTCString` property be used in new ECMAScript code.</p>
        </emu-note>
        <p>The function object that is the initial value of `Date.prototype.toGMTString` is the same function object that is the initial value of `Date.prototype.toUTCString`.</p>
      </emu-annex>
    </emu-annex>

    <emu-annex id="sec-additional-properties-of-the-regexp.prototype-object">
      <h1>Additional Properties of the RegExp.prototype Object</h1>

      <emu-annex id="sec-regexp.prototype.compile">
        <h1>RegExp.prototype.compile ( _pattern_, _flags_ )</h1>
        <p>When the `compile` method is called with arguments _pattern_ and _flags_, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If Type(_O_) is not Object or Type(_O_) is Object and _O_ does not have a [[RegExpMatcher]] internal slot, then
            1. Throw a *TypeError* exception.
          1. If Type(_pattern_) is Object and _pattern_ has a [[RegExpMatcher]] internal slot, then
            1. If _flags_ is not *undefined*, throw a *TypeError* exception.
            1. Let _P_ be _pattern_.[[OriginalSource]].
            1. Let _F_ be _pattern_.[[OriginalFlags]].
          1. Else,
            1. Let _P_ be _pattern_.
            1. Let _F_ be _flags_.
          1. Return ? RegExpInitialize(_O_, _P_, _F_).
        </emu-alg>
        <emu-note>
          <p>The `compile` method completely reinitializes the *this* object RegExp with a new pattern and flags. An implementation may interpret use of this method as an assertion that the resulting RegExp object will be used multiple times and hence is a candidate for extra optimization.</p>
        </emu-note>
      </emu-annex>
    </emu-annex>
  </emu-annex>

  <emu-annex id="sec-other-additional-features">
    <h1>Other Additional Features</h1>

    <emu-annex id="sec-__proto__-property-names-in-object-initializers">
      <h1>__proto__ Property Names in Object Initializers</h1>
      <p>The following Early Error rule is added to those in <emu-xref href="#sec-object-initializer-static-semantics-early-errors"></emu-xref>. When |ObjectLiteral| appears in a context where |ObjectAssignmentPattern| is required the Early Error rule is <b>not</b> applied. In addition, it is not applied when initially parsing a |CoverParenthesizedExpressionAndArrowParameterList| or a |CoverCallExpressionAndAsyncArrowHead|.</p>
      <emu-grammar>
        ObjectLiteral : `{` PropertyDefinitionList `}`

        ObjectLiteral : `{` PropertyDefinitionList `,` `}`
      </emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if PropertyNameList of |PropertyDefinitionList| contains any duplicate entries for `"__proto__"` and at least two of those entries were obtained from productions of the form <emu-grammar>PropertyDefinition : PropertyName `:` AssignmentExpression</emu-grammar>.
        </li>
      </ul>
      <emu-note>
        <p>The List returned by PropertyNameList does not include string literal property names defined as using a |ComputedPropertyName|.</p>
      </emu-note>
      <p>In <emu-xref href="#sec-object-initializer-runtime-semantics-propertydefinitionevaluation"></emu-xref> the PropertyDefinitionEvaluation algorithm for the production
        <br>
        <emu-grammar>PropertyDefinition : PropertyName `:` AssignmentExpression</emu-grammar>
        <br>
        is replaced with the following definition:</p>
      <emu-grammar>PropertyDefinition : PropertyName `:` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Let _propKey_ be the result of evaluating |PropertyName|.
        1. ReturnIfAbrupt(_propKey_).
        1. If _propKey_ is the String value `"__proto__"` and if IsComputedPropertyKey(|PropertyName|) is *false*, then
          1. Let _isProtoSetter_ be *true*.
        1. Else,
          1. Let _isProtoSetter_ be *false*.
        1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true* and _isProtoSetter_ is *false*, then
          1. Let _propValue_ be the result of performing NamedEvaluation for |AssignmentExpression| with argument _propKey_.
        1. Else,
          1. Let _exprValueRef_ be the result of evaluating |AssignmentExpression|.
          1. Let _propValue_ be ? GetValue(_exprValueRef_).
        1. If _isProtoSetter_ is *true*, then
          1. If Type(_propValue_) is either Object or Null, then
            1. Return _object_.[[SetPrototypeOf]](_propValue_).
          1. Return NormalCompletion(~empty~).
        1. Assert: _enumerable_ is *true*.
        1. Assert: _object_ is an ordinary, extensible object with no non-configurable properties.
        1. Return ! CreateDataPropertyOrThrow(_object_, _propKey_, _propValue_).
      </emu-alg>
    </emu-annex>

    <emu-annex id="sec-labelled-function-declarations">
      <h1>Labelled Function Declarations</h1>
      <p>Prior to ECMAScript 2015, the specification of |LabelledStatement| did not allow for the association of a statement label with a |FunctionDeclaration|. However, a labelled |FunctionDeclaration| was an allowable extension for non-strict code and most browser-hosted ECMAScript implementations supported that extension. In ECMAScript 2015, the grammar productions for |LabelledStatement| permits use of |FunctionDeclaration| as a |LabelledItem| but <emu-xref href="#sec-labelled-statements-static-semantics-early-errors"></emu-xref> includes an Early Error rule that produces a Syntax Error if that occurs. For web browser compatibility, that rule is modified with the addition of the <ins>highlighted</ins> text:</p>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if any <ins>strict mode</ins> source code matches this rule.
        </li>
      </ul>
      <emu-note>
        <p>The early error rules for |WithStatement|, |IfStatement|, and |IterationStatement| prevent these statements from containing a labelled |FunctionDeclaration| in non-strict code.</p>
      </emu-note>
    </emu-annex>

    <emu-annex id="sec-block-level-function-declarations-web-legacy-compatibility-semantics">
      <h1>Block-Level Function Declarations Web Legacy Compatibility Semantics</h1>
      <p>Prior to ECMAScript 2015, the ECMAScript specification did not define the occurrence of a |FunctionDeclaration| as an element of a |Block| statement's |StatementList|. However, support for that form of |FunctionDeclaration| was an allowable extension and most browser-hosted ECMAScript implementations permitted them. Unfortunately, the semantics of such declarations differ among those implementations. Because of these semantic differences, existing web ECMAScript code that uses |Block| level function declarations is only portable among browser implementation if the usage only depends upon the semantic intersection of all of the browser implementations for such declarations. The following are the use cases that fall within that intersection semantics:</p>
      <ol>
        <li>
          <p>A function is declared and only referenced within a single block</p>
          <ul>
            <li>
              One or more |FunctionDeclaration|s whose |BindingIdentifier| is the name _f_ occur within the function code of an enclosing function _g_ and that declaration is nested within a |Block|.
            </li>
            <li>
              No other declaration of _f_ that is not a `var` declaration occurs within the function code of _g_
            </li>
            <li>
              All occurrences of _f_ as an |IdentifierReference| are within the |StatementList| of the |Block| containing the declaration of _f_.
            </li>
          </ul>
        </li>
        <li>
          <p>A function is declared and possibly used within a single |Block| but also referenced by an inner function definition that is not contained within that same |Block|.</p>
          <ul>
            <li>
              One or more |FunctionDeclaration|s whose |BindingIdentifier| is the name _f_ occur within the function code of an enclosing function _g_ and that declaration is nested within a |Block|.
            </li>
            <li>
              No other declaration of _f_ that is not a `var` declaration occurs within the function code of _g_
            </li>
            <li>
              There may be occurrences of _f_ as an |IdentifierReference| within the |StatementList| of the |Block| containing the declaration of _f_.
            </li>
            <li>
              There is at least one occurrence of _f_ as an |IdentifierReference| within another function _h_ that is nested within _g_ and no other declaration of _f_ shadows the references to _f_ from within _h_.
            </li>
            <li>
              All invocations of _h_ occur after the declaration of _f_ has been evaluated.
            </li>
          </ul>
        </li>
        <li>
          <p>A function is declared and possibly used within a single block but also referenced within subsequent blocks.</p>
          <ul>
            <li>
              One or more |FunctionDeclaration| whose |BindingIdentifier| is the name _f_ occur within the function code of an enclosing function _g_ and that declaration is nested within a |Block|.
            </li>
            <li>
              No other declaration of _f_ that is not a `var` declaration occurs within the function code of _g_
            </li>
            <li>
              There may be occurrences of _f_ as an |IdentifierReference| within the |StatementList| of the |Block| containing the declaration of _f_.
            </li>
            <li>
              There is at least one occurrence of _f_ as an |IdentifierReference| within the function code of _g_ that lexically follows the |Block| containing the declaration of _f_.
            </li>
          </ul>
        </li>
      </ol>
      <p>The first use case is interoperable with the semantics of |Block| level function declarations provided by ECMAScript 2015. Any pre-existing ECMAScript code that employs that use case will operate using the Block level function declarations semantics defined by clauses 9, 13, and 14 of this specification.</p>
      <p>ECMAScript 2015 interoperability for the second and third use cases requires the following extensions to the clause <emu-xref href="#sec-ordinary-and-exotic-objects-behaviours"></emu-xref>, clause <emu-xref href="#sec-ecmascript-language-functions-and-classes"></emu-xref>, clause <emu-xref href="#sec-eval-x"></emu-xref> and clause <emu-xref href="#sec-globaldeclarationinstantiation"></emu-xref> semantics.</p>
      <p>If an ECMAScript implementation has a mechanism for reporting diagnostic warning messages, a warning should be produced when code contains a |FunctionDeclaration| for which these compatibility semantics are applied and introduce observable differences from non-compatibility semantics. For example, if a var binding is not introduced because its introduction would create an early error, a warning message should not be produced.</p>
      <emu-annex id="sec-web-compat-functiondeclarationinstantiation">
        <h1>Changes to FunctionDeclarationInstantiation</h1>
        <p>During FunctionDeclarationInstantiation the following steps are performed in place of step 28:</p>
        <emu-alg>
          1. If _strict_ is *false*, then
            1. For each |FunctionDeclaration| _f_ that is directly contained in the |StatementList| of a |Block|, |CaseClause|, or |DefaultClause|, do
              1. Let _F_ be StringValue of the |BindingIdentifier| of |FunctionDeclaration| _f_.
              1. If replacing the |FunctionDeclaration| _f_ with a |VariableStatement| that has _F_ as a |BindingIdentifier| would not produce any Early Errors for _func_ and _F_ is not an element of _parameterNames_, then
                1. NOTE: A var binding for _F_ is only instantiated here if it is neither a VarDeclaredName, the name of a formal parameter, or another |FunctionDeclaration|.
                1. If _initializedBindings_ does not contain _F_ and _F_ is not `"arguments"`, then
                  1. Perform ! _varEnvRec_.CreateMutableBinding(_F_, *false*).
                  1. Perform _varEnvRec_.InitializeBinding(_F_, *undefined*).
                  1. Append _F_ to _instantiatedVarNames_.
                1. When the |FunctionDeclaration| _f_ is evaluated, perform the following steps in place of the |FunctionDeclaration| Evaluation algorithm provided in <emu-xref href="#sec-function-definitions-runtime-semantics-evaluation"></emu-xref>:
                  1. Let _fenv_ be the running execution context's VariableEnvironment.
                  1. Let _fenvRec_ be _fenv_'s EnvironmentRecord.
                  1. Let _benv_ be the running execution context's LexicalEnvironment.
                  1. Let _benvRec_ be _benv_'s EnvironmentRecord.
                  1. Let _fobj_ be ! _benvRec_.GetBindingValue(_F_, *false*).
                  1. Perform ! _fenvRec_.SetMutableBinding(_F_, _fobj_, *false*).
                  1. Return NormalCompletion(~empty~).
        </emu-alg>
      </emu-annex>
      <emu-annex id="sec-web-compat-globaldeclarationinstantiation">
        <h1>Changes to GlobalDeclarationInstantiation</h1>
        <p>During GlobalDeclarationInstantiation the following steps are performed in place of step 14:</p>
        <emu-alg>
          1. Let _strict_ be IsStrict of _script_.
          1. If _strict_ is *false*, then
            1. Let _declaredFunctionOrVarNames_ be a new empty List.
            1. Append to _declaredFunctionOrVarNames_ the elements of _declaredFunctionNames_.
            1. Append to _declaredFunctionOrVarNames_ the elements of _declaredVarNames_.
            1. For each |FunctionDeclaration| _f_ that is directly contained in the |StatementList| of a |Block|, |CaseClause|, or |DefaultClause| Contained within _script_, do
              1. Let _F_ be StringValue of the |BindingIdentifier| of |FunctionDeclaration| _f_.
              1. If replacing the |FunctionDeclaration| _f_ with a |VariableStatement| that has _F_ as a |BindingIdentifier| would not produce any Early Errors for _script_, then
                1. If _envRec_.HasLexicalDeclaration(_F_) is *false*, then
                  1. Let _fnDefinable_ be ? _envRec_.CanDeclareGlobalVar(_F_).
                  1. If _fnDefinable_ is *true*, then
                    1. NOTE: A var binding for _F_ is only instantiated here if it is neither a VarDeclaredName nor the name of another |FunctionDeclaration|.
                    1. If _declaredFunctionOrVarNames_ does not contain _F_, then
                      1. Perform ? _envRec_.CreateGlobalVarBinding(_F_, *false*).
                      1. Append _F_ to _declaredFunctionOrVarNames_.
                    1. When the |FunctionDeclaration| _f_ is evaluated, perform the following steps in place of the |FunctionDeclaration| Evaluation algorithm provided in <emu-xref href="#sec-function-definitions-runtime-semantics-evaluation"></emu-xref>:
                      1. Let _genv_ be the running execution context's VariableEnvironment.
                      1. Let _genvRec_ be _genv_'s EnvironmentRecord.
                      1. Let _benv_ be the running execution context's LexicalEnvironment.
                      1. Let _benvRec_ be _benv_'s EnvironmentRecord.
                      1. Let _fobj_ be ! _benvRec_.GetBindingValue(_F_, *false*).
                      1. Perform ? _genvRec_.SetMutableBinding(_F_, _fobj_, *false*).
                      1. Return NormalCompletion(~empty~).
        </emu-alg>
      </emu-annex>
      <emu-annex id="sec-web-compat-evaldeclarationinstantiation">
        <h1>Changes to EvalDeclarationInstantiation</h1>
        <p>During EvalDeclarationInstantiation the following steps are performed in place of step 9:</p>
        <emu-alg>
          1. If _strict_ is *false*, then
            1. Let _declaredFunctionOrVarNames_ be a new empty List.
            1. Append to _declaredFunctionOrVarNames_ the elements of _declaredFunctionNames_.
            1. Append to _declaredFunctionOrVarNames_ the elements of _declaredVarNames_.
            1. For each |FunctionDeclaration| _f_ that is directly contained in the |StatementList| of a |Block|, |CaseClause|, or |DefaultClause| Contained within _body_, do
              1. Let _F_ be StringValue of the |BindingIdentifier| of |FunctionDeclaration| _f_.
              1. If replacing the |FunctionDeclaration| _f_ with a |VariableStatement| that has _F_ as a |BindingIdentifier| would not produce any Early Errors for _body_, then
                1. Let _bindingExists_ be *false*.
                1. Let _thisLex_ be _lexEnv_.
                1. Assert: The following loop will terminate.
                1. Repeat, while _thisLex_ is not the same as _varEnv_,
                  1. Let _thisEnvRec_ be _thisLex_'s EnvironmentRecord.
                  1. If _thisEnvRec_ is not an object Environment Record, then
                    1. If _thisEnvRec_.HasBinding(_F_) is *true*, then
                      1. Let _bindingExists_ be *true*.
                  1. Set _thisLex_ to _thisLex_'s outer environment reference.
                1. If _bindingExists_ is *false* and _varEnvRec_ is a global Environment Record, then
                  1. If _varEnvRec_.HasLexicalDeclaration(_F_) is *false*, then
                    1. Let _fnDefinable_ be ? _varEnvRec_.CanDeclareGlobalVar(_F_).
                  1. Else,
                    1. Let _fnDefinable_ be *false*.
                1. Else,
                  1. Let _fnDefinable_ be *true*.
                1. If _bindingExists_ is *false* and _fnDefinable_ is *true*, then
                  1. If _declaredFunctionOrVarNames_ does not contain _F_, then
                    1. If _varEnvRec_ is a global Environment Record, then
                      1. Perform ? _varEnvRec_.CreateGlobalVarBinding(_F_, *true*).
                    1. Else,
                      1. Let _bindingExists_ be _varEnvRec_.HasBinding(_F_).
                      1. If _bindingExists_ is *false*, then
                        1. Perform ! _varEnvRec_.CreateMutableBinding(_F_, *true*).
                        1. Perform ! _varEnvRec_.InitializeBinding(_F_, *undefined*).
                    1. Append _F_ to _declaredFunctionOrVarNames_.
                  1. When the |FunctionDeclaration| _f_ is evaluated, perform the following steps in place of the |FunctionDeclaration| Evaluation algorithm provided in <emu-xref href="#sec-function-definitions-runtime-semantics-evaluation"></emu-xref>:
                    1. Let _genv_ be the running execution context's VariableEnvironment.
                    1. Let _genvRec_ be _genv_'s EnvironmentRecord.
                    1. Let _benv_ be the running execution context's LexicalEnvironment.
                    1. Let _benvRec_ be _benv_'s EnvironmentRecord.
                    1. Let _fobj_ be ! _benvRec_.GetBindingValue(_F_, *false*).
                    1. Perform ? _genvRec_.SetMutableBinding(_F_, _fobj_, *false*).
                    1. Return NormalCompletion(~empty~).
        </emu-alg>
      </emu-annex>
      <emu-annex id="sec-block-duplicates-allowed-static-semantics">
        <h1>Changes to Block Static Semantics: Early Errors</h1>
        <p>For web browser compatibility, that rule is modified with the addition of the <ins>highlighted</ins> text:</p>
        <emu-grammar>Block : `{` StatementList `}`</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the LexicallyDeclaredNames of |StatementList| contains any duplicate entries, <ins>unless the source code matching this production is not strict mode code and the duplicate entries are only bound by FunctionDeclarations.</ins>
          </li>
        </ul>
      </emu-annex>
      <emu-annex id="sec-switch-duplicates-allowed-static-semantics">
        <h1>Changes to `switch` Statement Static Semantics: Early Errors</h1>
        <p>For web browser compatibility, that rule is modified with the addition of the <ins>highlighted</ins> text:</p>
        <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the LexicallyDeclaredNames of |CaseBlock| contains any duplicate entries, <ins>unless the source code matching this production is not strict mode code and the duplicate entries are only bound by FunctionDeclarations.</ins>
          </li>
        </ul>
      </emu-annex>
      <emu-annex id="sec-web-compat-blockdeclarationinstantiation">
        <h1>Changes to BlockDeclarationInstantiation</h1>
        <p>During BlockDeclarationInstantiation the following steps are performed in place of step 4.a.ii.1:</p>
        <emu-alg>
          1. If _envRec_.HasBinding(_dn_) is *false*, then
            1. Perform ! _envRec_.CreateMutableBinding(_dn_, *false*).
        </emu-alg>
        <p>During BlockDeclarationInstantiation the following steps are performed in place of step 4.b.iii:</p>
        <emu-alg>
          1. If _envRec_.HasBinding(_fn_) is *false*, then
            1. Perform _envRec_.InitializeBinding(_fn_, _fo_).
          1. Else,
            1. Assert: _d_ is a |FunctionDeclaration|.
            1. Perform _envRec_.SetMutableBinding(_fn_, _fo_, *false*).
        </emu-alg>
      </emu-annex>
    </emu-annex>

    <emu-annex id="sec-functiondeclarations-in-ifstatement-statement-clauses">
      <h1>FunctionDeclarations in IfStatement Statement Clauses</h1>
      <p>The following augments the |IfStatement| production in <emu-xref href="#sec-if-statement"></emu-xref>:</p>
      <emu-grammar type="definition">
        IfStatement[Yield, Await, Return] :
          `if` `(` Expression[+In, ?Yield, ?Await] `)` FunctionDeclaration[?Yield, ?Await, ~Default] `else` Statement[?Yield, ?Await, ?Return]
          `if` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return] `else` FunctionDeclaration[?Yield, ?Await, ~Default]
          `if` `(` Expression[+In, ?Yield, ?Await] `)` FunctionDeclaration[?Yield, ?Await, ~Default] `else` FunctionDeclaration[?Yield, ?Await, ~Default]
          `if` `(` Expression[+In, ?Yield, ?Await] `)` FunctionDeclaration[?Yield, ?Await, ~Default]
      </emu-grammar>
      <p>This production only applies when parsing non-strict code. Code matching this production is processed as if each matching occurrence of |FunctionDeclaration[?Yield, ?Await, ~Default]| was the sole |StatementListItem| of a |BlockStatement| occupying that position in the source code. The semantics of such a synthetic |BlockStatement| includes the web legacy compatibility semantics specified in <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics"></emu-xref>.</p>
    </emu-annex>

    <emu-annex id="sec-variablestatements-in-catch-blocks">
      <h1>VariableStatements in Catch Blocks</h1>
      <p>The content of subclause <emu-xref href="#sec-try-statement-static-semantics-early-errors"></emu-xref> is replaced with the following:</p>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if BoundNames of |CatchParameter| contains any duplicate elements.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |CatchParameter| also occurs in the LexicallyDeclaredNames of |Block|.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |CatchParameter| also occurs in the VarDeclaredNames of |Block| unless |CatchParameter| is <emu-grammar>CatchParameter : BindingIdentifier</emu-grammar>.
        </li>
      </ul>
      <emu-note>
        <p>The |Block| of a |Catch| clause may contain `var` declarations that bind a name that is also bound by the |CatchParameter|. At runtime, such bindings are instantiated in the VariableDeclarationEnvironment. They do not shadow the same-named bindings introduced by the |CatchParameter| and hence the |Initializer| for such `var` declarations will assign to the corresponding catch parameter rather than the `var` binding.</p>
      </emu-note>
      <p>This modified behaviour also applies to `var` and `function` declarations introduced by direct eval calls contained within the |Block| of a |Catch| clause. This change is accomplished by modifying the algorithm of <emu-xref href="#sec-evaldeclarationinstantiation"></emu-xref> as follows:</p>
      <p>Step 5.d.ii.2.a.i is replaced by:</p>
      <emu-alg type="i">
        1. If _thisEnvRec_ is not the Environment Record for a |Catch| clause, throw a *SyntaxError* exception.
      </emu-alg>
      <p>Step 9.d.ii.4.b.i.i is replaced by:</p>
      <emu-alg type="i">
        1. If _thisEnvRec_ is not the Environment Record for a |Catch| clause, let _bindingExists_ be *true*.
      </emu-alg>
    </emu-annex>

    <emu-annex id="sec-initializers-in-forin-statement-heads">
      <h1>Initializers in ForIn Statement Heads</h1>
      <p>The following augments the |IterationStatement| production in <emu-xref href="#sec-iteration-statements"></emu-xref>:</p>
      <emu-grammar type="definition">
        IterationStatement[Yield, Await, Return] :
          `for` `(` `var` BindingIdentifier[?Yield, ?Await] Initializer[~In, ?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
      </emu-grammar>
      <p>This production only applies when parsing non-strict code.</p>
      <p>The static semantics of ContainsDuplicateLabels in <emu-xref href="#sec-for-in-and-for-of-statements-static-semantics-containsduplicatelabels"></emu-xref> are augmented with the following:</p>
      <emu-grammar>IterationStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.
      </emu-alg>
      <p>The static semantics of ContainsUndefinedBreakTarget in <emu-xref href="#sec-for-in-and-for-of-statements-static-semantics-containsundefinedbreaktarget"></emu-xref> are augmented with the following:</p>
      <emu-grammar>IterationStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.
      </emu-alg>
      <p>The static semantics of ContainsUndefinedContinueTarget in <emu-xref href="#sec-for-in-and-for-of-statements-static-semantics-containsundefinedcontinuetarget"></emu-xref> are augmented with the following:</p>
      <emu-grammar>IterationStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and &laquo; &raquo;.
      </emu-alg>
      <p>The static semantics of IsDestructuring in <emu-xref href="#sec-for-in-and-for-of-statements-static-semantics-isdestructuring"></emu-xref> are augmented with the following:</p>
      <emu-grammar>
        BindingIdentifier :
          Identifier
          `yield`
          `await`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <p>The static semantics of VarDeclaredNames in <emu-xref href="#sec-for-in-and-for-of-statements-static-semantics-vardeclarednames"></emu-xref> are augmented with the following:</p>
      <emu-grammar>IterationStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Let _names_ be the BoundNames of |BindingIdentifier|.
        1. Append to _names_ the elements of the VarDeclaredNames of |Statement|.
        1. Return _names_.
      </emu-alg>
      <p>The static semantics of VarScopedDeclarations in <emu-xref href="#sec-for-in-and-for-of-statements-static-semantics-varscopeddeclarations"></emu-xref> are augmented with the following:</p>
      <emu-grammar>IterationStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Let _declarations_ be a List containing |BindingIdentifier|.
        1. Append to _declarations_ the elements of the VarScopedDeclarations of |Statement|.
        1. Return _declarations_.
      </emu-alg>
      <p>The runtime semantics of LabelledEvaluation in <emu-xref href="#sec-for-in-and-for-of-statements-runtime-semantics-labelledevaluation"></emu-xref> are augmented with the following:</p>
      <emu-grammar>IterationStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Let _bindingId_ be StringValue of |BindingIdentifier|.
        1. Let _lhs_ be ? ResolveBinding(_bindingId_).
        1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then
          1. Let _value_ be the result of performing NamedEvaluation for |Initializer| with argument _bindingId_.
        1. Else,
          1. Let _rhs_ be the result of evaluating |Initializer|.
          1. Let _value_ be ? GetValue(_rhs_).
        1. Perform ? PutValue(_lhs_, _value_).
        1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(&laquo; &raquo;, |Expression|, ~enumerate~).
        1. Return ? ForIn/OfBodyEvaluation(|BindingIdentifier|, |Statement|, _keyResult_, ~enumerate~, ~varBinding~, _labelSet_).
      </emu-alg>
    </emu-annex>

    <emu-annex id="sec-IsHTMLDDA-internal-slot">
      <h1>The [[IsHTMLDDA]] Internal Slot</h1>
      <p>An <dfn>[[IsHTMLDDA]] internal slot</dfn> may exist on implementation-defined objects. Objects with an [[IsHTMLDDA]] internal slot behave like *undefined* in the <emu-xref href="#sec-toboolean">ToBoolean</emu-xref> and <emu-xref href="#sec-abstract-equality-comparison">Abstract Equality Comparison</emu-xref> abstract operations and when used as an operand for the <emu-xref href="#sec-typeof-operator">`typeof` operator</emu-xref>.</p>
      <emu-note>
        <p>Objects with an [[IsHTMLDDA]] internal slot are never created by this specification. However, the <a href="https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-all"><code>document.all</code> object</a> in web browsers is a host-created exotic object with this slot that exists for web compatibility purposes. There are no other known examples of this type of object and implementations should not create any with the exception of `document.all`.</p>
      </emu-note>

      <emu-annex id="sec-IsHTMLDDA-internal-slot-to-boolean">
        <h1>Changes to ToBoolean</h1>
        <p>The result column in <emu-xref href="#table-10"></emu-xref> for an argument type of Object is replaced with the following algorithm:</p>
        <emu-alg>
          1. If _argument_ has an [[IsHTMLDDA]] internal slot, return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-IsHTMLDDA-internal-slot-aec">
        <h1>Changes to Abstract Equality Comparison</h1>
        <p>The following steps are inserted after step 3 of the <emu-xref href="#sec-abstract-equality-comparison">Abstract Equality Comparison</emu-xref> algorithm:</p>
        <emu-alg>
          1. If Type(_x_) is Object and _x_ has an [[IsHTMLDDA]] internal slot and _y_ is either *null* or *undefined*, return *true*.
          1. If _x_ is either *null* or *undefined* and Type(_y_) is Object and _y_ has an [[IsHTMLDDA]] internal slot, return *true*.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-IsHTMLDDA-internal-slot-typeof">
        <h1>Changes to the `typeof` Operator</h1>
        <p>The following table entry is inserted into <emu-xref href="#table-35"></emu-xref> immediately preceeding the entry for "Object (implements [[Call]])":</p>
        <emu-table>
          <emu-caption>
            Additional <emu-xref href="#sec-typeof-operator">`typeof`</emu-xref> Operator Results
          </emu-caption>
          <table>
            <tbody>
              <tr>
                <th>
                  Type of _val_
                </th>
                <th>
                  Result
                </th>
              </tr>
              <tr>
                <td>
                  Object (has an [[IsHTMLDDA]] internal slot)
                </td>
                <td>
                  `"undefined"`
                </td>
              </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-annex>
    </emu-annex>
  </emu-annex>
</emu-annex>

<emu-annex id="sec-strict-mode-of-ecmascript">
  <h1>The Strict Mode of ECMAScript</h1>
  <p><b>The strict mode restriction and exceptions</b></p>
  <ul>
    <li>
      `implements`, `interface`, `let`, `package`, `private`, `protected`, `public`, `static`, and `yield` are reserved words within strict mode code. (<emu-xref href="#sec-reserved-words"></emu-xref>).
    </li>
    <li>
      A conforming implementation, when processing strict mode code, must not extend, as described in <emu-xref href="#sec-additional-syntax-numeric-literals"></emu-xref>, the syntax of |NumericLiteral| to include |LegacyOctalIntegerLiteral|, nor extend the syntax of |DecimalIntegerLiteral| to include |NonOctalDecimalIntegerLiteral|.
    </li>
    <li>
      A conforming implementation, when processing strict mode code, may not extend the syntax of |EscapeSequence| to include |LegacyOctalEscapeSequence| as described in <emu-xref href="#sec-additional-syntax-string-literals"></emu-xref>.
    </li>
    <li>
      Assignment to an undeclared identifier or otherwise unresolvable reference does not create a property in the global object. When a simple assignment occurs within strict mode code, its |LeftHandSideExpression| must not evaluate to an unresolvable Reference. If it does a *ReferenceError* exception is thrown (<emu-xref href="#sec-putvalue"></emu-xref>). The |LeftHandSideExpression| also may not be a reference to a data property with the attribute value { [[Writable]]: *false* }, to an accessor property with the attribute value { [[Set]]: *undefined* }, nor to a non-existent property of an object whose [[Extensible]] internal slot has the value *false*. In these cases a `TypeError` exception is thrown (<emu-xref href="#sec-assignment-operators"></emu-xref>).
    </li>
    <li>
      An |IdentifierReference| with the StringValue `"eval"` or `"arguments"` may not appear as the |LeftHandSideExpression| of an Assignment operator (<emu-xref href="#sec-assignment-operators"></emu-xref>) or of an |UpdateExpression| (<emu-xref href="#sec-update-expressions"></emu-xref>) or as the |UnaryExpression| operated upon by a Prefix Increment (<emu-xref href="#sec-prefix-increment-operator"></emu-xref>) or a Prefix Decrement (<emu-xref href="#sec-prefix-decrement-operator"></emu-xref>) operator.
    </li>
    <li>
      Arguments objects for strict functions define a non-configurable accessor property `"callee"` which throws a *TypeError* exception on access (<emu-xref href="#sec-createunmappedargumentsobject"></emu-xref>).
    </li>
    <li>
      Arguments objects for strict functions do not dynamically share their <emu-xref href="#array-index">array-indexed</emu-xref> property values with the corresponding formal parameter bindings of their functions. (<emu-xref href="#sec-arguments-exotic-objects"></emu-xref>).
    </li>
    <li>
      For strict functions, if an arguments object is created the binding of the local identifier `arguments` to the arguments object is immutable and hence may not be the target of an assignment expression. (<emu-xref href="#sec-functiondeclarationinstantiation"></emu-xref>).
    </li>
    <li>
      It is a *SyntaxError* if the StringValue of a |BindingIdentifier| is `"eval"` or `"arguments"` within strict mode code (<emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref>).
    </li>
    <li>
      Strict mode eval code cannot instantiate variables or functions in the variable environment of the caller to eval. Instead, a new variable environment is created and that environment is used for declaration binding instantiation for the eval code (<emu-xref href="#sec-eval-x"></emu-xref>).
    </li>
    <li>
      If *this* is evaluated within strict mode code, then the *this* value is not coerced to an object. A *this* value of *undefined* or *null* is not converted to the global object and primitive values are not converted to wrapper objects. The *this* value passed via a function call (including calls made using `Function.prototype.apply` and `Function.prototype.call`) do not coerce the passed this value to an object (<emu-xref href="#sec-ordinarycallbindthis"></emu-xref>, <emu-xref href="#sec-function.prototype.apply"></emu-xref>, <emu-xref href="#sec-function.prototype.call"></emu-xref>).
    </li>
    <li>
      When a `delete` operator occurs within strict mode code, a *SyntaxError* is thrown if its |UnaryExpression| is a direct reference to a variable, function argument, or function name (<emu-xref href="#sec-delete-operator-static-semantics-early-errors"></emu-xref>).
    </li>
    <li>
      When a `delete` operator occurs within strict mode code, a *TypeError* is thrown if the property to be deleted has the attribute { [[Configurable]]: *false* } (<emu-xref href="#sec-delete-operator-runtime-semantics-evaluation"></emu-xref>).
    </li>
    <li>
      Strict mode code may not include a |WithStatement|. The occurrence of a |WithStatement| in such a context is a *SyntaxError* (<emu-xref href="#sec-with-statement-static-semantics-early-errors"></emu-xref>).
    </li>
    <li>
      It is a *SyntaxError* if a |CatchParameter| occurs within strict mode code and BoundNames of |CatchParameter| contains either `eval` or `arguments` (<emu-xref href="#sec-try-statement-static-semantics-early-errors"></emu-xref>).
    </li>
    <li>
      It is a *SyntaxError* if the same |BindingIdentifier| appears more than once in the |FormalParameters| of a strict function. An attempt to create such a function using a `Function`, `Generator`, or `AsyncFunction` constructor is a *SyntaxError* (<emu-xref href="#sec-function-definitions-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-createdynamicfunction"></emu-xref>).
    </li>
    <li>
      An implementation may not extend, beyond that defined in this specification, the meanings within strict functions of properties named `caller` or `arguments` of function instances.
    </li>
  </ul>
</emu-annex>

<emu-annex id="sec-corrections-and-clarifications-in-ecmascript-2015-with-possible-compatibility-impact">
  <h1>Corrections and Clarifications in ECMAScript 2015 with Possible Compatibility Impact</h1>
  <p><emu-xref href="#sec-candeclareglobalvar"></emu-xref>-<emu-xref href="#sec-createglobalfunctionbinding"></emu-xref> Edition 5 and 5.1 used a property existence test to determine whether a global object property corresponding to a new global declaration already existed. ECMAScript 2015 uses an own property existence test. This corresponds to what has been most commonly implemented by web browsers.</p>
  <p><emu-xref href="#sec-array-exotic-objects-defineownproperty-p-desc"></emu-xref>: The 5<sup>th</sup> Edition moved the capture of the current array length prior to the integer conversion of the array index or new length value. However, the captured length value could become invalid if the conversion process has the side-effect of changing the array length. ECMAScript 2015 specifies that the current array length must be captured after the possible occurrence of such side-effects.</p>
  <p><emu-xref href="#sec-timeclip"></emu-xref>: Previous editions permitted the TimeClip abstract operation to return either *+0* or *-0* as the representation of a 0 time value. ECMAScript 2015 specifies that *+0* always returned. This means that for ECMAScript 2015 the time value of a Date object is never observably *-0* and methods that return time values never return *-0*.</p>
  <p><emu-xref href="#sec-date-time-string-format"></emu-xref>: If a UTC offset representation is not present, the local time zone is used. Edition 5.1 incorrectly stated that a missing time zone should be interpreted as `"z"`.</p>
  <p><emu-xref href="#sec-date.prototype.toisostring"></emu-xref>: If the year cannot be represented using the Date Time String Format specified in <emu-xref href="#sec-date-time-string-format"></emu-xref> a RangeError exception is thrown. Previous editions did not specify the behaviour for that case.</p>
  <p><emu-xref href="#sec-date.prototype.tostring"></emu-xref>: Previous editions did not specify the value returned by Date.prototype.toString when this time value is *NaN*. ECMAScript 2015 specifies the result to be the String value is `"Invalid Date"`.</p>
  <p><emu-xref href="#sec-regexp-pattern-flags"></emu-xref>, <emu-xref href="#sec-escaperegexppattern"></emu-xref>: Any LineTerminator code points in the value of the `source` property of a RegExp instance must be expressed using an escape sequence. Edition 5.1 only required the escaping of `"/"`.</p>
  <p><emu-xref href="#sec-regexp.prototype-@@match"></emu-xref>, <emu-xref href="#sec-regexp.prototype-@@replace"></emu-xref>: In previous editions, the specifications for `String.prototype.match` and `String.prototype.replace` was incorrect for cases where the pattern argument was a RegExp value whose `global` is flag set. The previous specifications stated that for each attempt to match the pattern, if `lastIndex` did not change it should be incremented by 1. The correct behaviour is that `lastIndex` should be incremented by one only if the pattern matched the empty string.</p>
  <p><emu-xref href="#sec-array.prototype.sort"></emu-xref>, <emu-xref href="#sec-sortcompare"></emu-xref>: Previous editions did not specify how a *NaN* value returned by a _comparefn_ was interpreted by `Array.prototype.sort`. ECMAScript 2015 specifies that such as value is treated as if *+0* was returned from the _comparefn_. ECMAScript 2015 also specifies that ToNumber is applied to the result returned by a _comparefn_. In previous editions, the effect of a _comparefn_ result that is not a Number value was implementation-dependent. In practice, implementations call ToNumber.</p>
</emu-annex>

<emu-annex id="sec-additions-and-changes-that-introduce-incompatibilities-with-prior-editions">
  <h1>Additions and Changes That Introduce Incompatibilities with Prior Editions</h1>
  <p><emu-xref href="#sec-tonumber-applied-to-the-string-type"></emu-xref>: In ECMAScript 2015, ToNumber applied to a String value now recognizes and converts |BinaryIntegerLiteral| and |OctalIntegerLiteral| numeric strings. In previous editions such strings were converted to *NaN*.</p>
  <p><emu-xref href="#sec-reference-specification-type"></emu-xref>: In ECMAScript 2015, Function calls are not allowed to return a Reference value.</p>
  <p><emu-xref href="#sec-names-and-keywords"></emu-xref>: In ECMAScript 2015, the valid code points for an |IdentifierName| are specified in terms of the Unicode properties &ldquo;ID_Start&rdquo; and &ldquo;ID_Continue&rdquo;. In previous editions, the valid |IdentifierName| or |Identifier| code points were specified by enumerating various Unicode code point categories.</p>
  <p><emu-xref href="#sec-rules-of-automatic-semicolon-insertion"></emu-xref>: In ECMAScript 2015, Automatic Semicolon Insertion adds a semicolon at the end of a do-while statement if the semicolon is missing. This change aligns the specification with the actual behaviour of most existing implementations.</p>
  <p><emu-xref href="#sec-object-initializer-static-semantics-early-errors"></emu-xref>: In ECMAScript 2015, it is no longer an early error to have duplicate property names in Object Initializers.</p>
  <p><emu-xref href="#sec-assignment-operators-static-semantics-early-errors"></emu-xref>: In ECMAScript 2015, strict mode code containing an assignment to an immutable binding such as the function name of a |FunctionExpression| does not produce an early error. Instead it produces a runtime error.</p>
  <p><emu-xref href="#sec-block"></emu-xref>: In ECMAScript 2015, a |StatementList| beginning with the token let followed by the input elements |LineTerminator| then |Identifier| is the start of a |LexicalDeclaration|. In previous editions, automatic semicolon insertion would always insert a semicolon before the |Identifier| input element.</p>
  <p><emu-xref href="#sec-expression-statement"></emu-xref>: In ECMAScript 2015, a |StatementListItem| beginning with the token `let` followed by the token `[` is the start of a |LexicalDeclaration|. In previous editions such a sequence would be the start of an |ExpressionStatement|.</p>
  <p><emu-xref href="#sec-if-statement-runtime-semantics-evaluation"></emu-xref>: In ECMAScript 2015, the normal completion value of an |IfStatement| is never the value ~empty~. If no |Statement| part is evaluated or if the evaluated |Statement| part produces a normal completion whose value is ~empty~, the completion value of the |IfStatement| is *undefined*.</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>: In ECMAScript 2015, if the `(` token of a for statement is immediately followed by the token sequence `let [` then the `let` is treated as the start of a |LexicalDeclaration|. In previous editions such a token sequence would be the start of an |Expression|.</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>: In ECMAScript 2015, if the ( token of a for-in statement is immediately followed by the token sequence `let [` then the `let` is treated as the start of a |ForDeclaration|. In previous editions such a token sequence would be the start of an |LeftHandSideExpression|.</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>: Prior to ECMAScript 2015, an initialization expression could appear as part of the |VariableDeclaration| that precedes the `in` keyword. In ECMAScript 2015, the |ForBinding| in that same position does not allow the occurrence of such an initializer. In ECMAScript 2017, such an initializer is permitted only in non-strict code.</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>: In ECMAScript 2015, the completion value of an |IterationStatement| is never the value ~empty~. If the |Statement| part of an |IterationStatement| is not evaluated or if the final evaluation of the |Statement| part produces a completion whose value is ~empty~, the completion value of the |IterationStatement| is *undefined*.</p>
  <p><emu-xref href="#sec-with-statement-runtime-semantics-evaluation"></emu-xref>: In ECMAScript 2015, the normal completion value of a |WithStatement| is never the value ~empty~. If evaluation of the |Statement| part of a |WithStatement| produces a normal completion whose value is ~empty~, the completion value of the |WithStatement| is *undefined*.</p>
  <p><emu-xref href="#sec-switch-statement-runtime-semantics-evaluation"></emu-xref>: In ECMAScript 2015, the completion value of a |SwitchStatement| is never the value ~empty~. If the |CaseBlock| part of a |SwitchStatement| produces a completion whose value is ~empty~, the completion value of the |SwitchStatement| is *undefined*.</p>
  <p><emu-xref href="#sec-try-statement"></emu-xref>: In ECMAScript 2015, it is an early error for a |Catch| clause to contain a `var` declaration for the same |Identifier| that appears as the |Catch| clause parameter. In previous editions, such a variable declaration would be instantiated in the enclosing variable environment but the declaration's |Initializer| value would be assigned to the |Catch| parameter.</p>
  <p><emu-xref href="#sec-try-statement"></emu-xref>, <emu-xref href="#sec-evaldeclarationinstantiation"></emu-xref>: In ECMAScript 2015, a runtime *SyntaxError* is thrown if a |Catch| clause evaluates a non-strict direct `eval` whose eval code includes a `var` or `FunctionDeclaration` declaration that binds the same |Identifier| that appears as the |Catch| clause parameter.</p>
  <p><emu-xref href="#sec-try-statement-runtime-semantics-evaluation"></emu-xref>: In ECMAScript 2015, the completion value of a |TryStatement| is never the value ~empty~. If the |Block| part of a |TryStatement| evaluates to a normal completion whose value is ~empty~, the completion value of the |TryStatement| is *undefined*. If the |Block| part of a |TryStatement| evaluates to a throw completion and it has a |Catch| part that evaluates to a normal completion whose value is ~empty~, the completion value of the |TryStatement| is *undefined* if there is no |Finally| clause or if its |Finally| clause evalulates to an ~empty~ normal completion.</p>
  <p><emu-xref href="#sec-method-definitions-runtime-semantics-propertydefinitionevaluation"></emu-xref> In ECMAScript 2015, the function objects that are created as the values of the [[Get]] or [[Set]] attribute of accessor properties in an |ObjectLiteral| are not constructor functions and they do not have a `prototype` own property. In the previous edition, they were constructors and had a `prototype` property.</p>
  <p><emu-xref href="#sec-object.freeze"></emu-xref>: In ECMAScript 2015, if the argument to `Object.freeze` is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.getownpropertydescriptor"></emu-xref>: In ECMAScript 2015, if the argument to `Object.getOwnPropertyDescriptor` is not an object an attempt is made to coerce the argument using ToObject. If the coercion is successful the result is used in place of the original argument value. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.getownpropertynames"></emu-xref>: In ECMAScript 2015, if the argument to `Object.getOwnPropertyNames` is not an object an attempt is made to coerce the argument using ToObject. If the coercion is successful the result is used in place of the original argument value. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.getprototypeof"></emu-xref>: In ECMAScript 2015, if the argument to `Object.getPrototypeOf` is not an object an attempt is made to coerce the argument using ToObject. If the coercion is successful the result is used in place of the original argument value. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.isextensible"></emu-xref>: In ECMAScript 2015, if the argument to `Object.isExtensible` is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.isfrozen"></emu-xref>: In ECMAScript 2015, if the argument to `Object.isFrozen` is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.issealed"></emu-xref>: In ECMAScript 2015, if the argument to `Object.isSealed` is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.keys"></emu-xref>: In ECMAScript 2015, if the argument to `Object.keys` is not an object an attempt is made to coerce the argument using ToObject. If the coercion is successful the result is used in place of the original argument value. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.preventextensions"></emu-xref>: In ECMAScript 2015, if the argument to `Object.preventExtensions` is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.seal"></emu-xref>: In ECMAScript 2015, if the argument to `Object.seal` is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-function.prototype.bind"></emu-xref>: In ECMAScript 2015, the [[Prototype]] internal slot of a bound function is set to the [[GetPrototypeOf]] value of its target function. In the previous edition, [[Prototype]] was always set to %FunctionPrototype%.</p>
  <p><emu-xref href="#sec-function-instances-length"></emu-xref>: In ECMAScript 2015, the `"length"` property of function instances is configurable. In previous editions it was non-configurable.</p>
  <p><emu-xref href="#sec-properties-of-the-nativeerror-constructors"></emu-xref>: In ECMAScript 2015, the [[Prototype]] internal slot of a _NativeError_ constructor is the Error constructor. In previous editions it was the Function prototype object.</p>
  <p><emu-xref href="#sec-properties-of-the-date-prototype-object"></emu-xref> In ECMAScript 2015, the Date prototype object is not a Date instance. In previous editions it was a Date instance whose TimeValue was *NaN*.</p>
  <p><emu-xref href="#sec-string.prototype.localecompare"></emu-xref> In ECMAScript 2015, the `String.prototype.localeCompare` function must treat Strings that are canonically equivalent according to the Unicode standard as being identical. In previous editions implementations were permitted to ignore canonical equivalence and could instead use a bit-wise comparison.</p>
  <p><emu-xref href="#sec-string.prototype.tolowercase"></emu-xref> and <emu-xref href="#sec-string.prototype.touppercase"></emu-xref> In ECMAScript 2015, lowercase/upper conversion processing operates on code points. In previous editions such the conversion processing was only applied to individual code units. The only affected code points are those in the Deseret block of Unicode.</p>
  <p><emu-xref href="#sec-string.prototype.trim"></emu-xref> In ECMAScript 2015, the `String.prototype.trim` method is defined to recognize white space code points that may exists outside of the Unicode BMP. However, as of Unicode 7 no such code points are defined. In previous editions such code points would not have been recognized as white space.</p>
  <p><emu-xref href="#sec-regexp-pattern-flags"></emu-xref> In ECMAScript 2015, If the _pattern_ argument is a RegExp instance and the _flags_ argument is not *undefined*, a new RegExp instance is created just like _pattern_ except that _pattern_'s flags are replaced by the argument _flags_. In previous editions a *TypeError* exception was thrown when _pattern_ was a RegExp instance and _flags_ was not *undefined*.</p>
  <p><emu-xref href="#sec-properties-of-the-regexp-prototype-object"></emu-xref> In ECMAScript 2015, the RegExp prototype object is not a RegExp instance. In previous editions it was a RegExp instance whose pattern is the empty string.</p>
  <p><emu-xref href="#sec-properties-of-the-regexp-prototype-object"></emu-xref> In ECMAScript 2015, `source`, `global`, `ignoreCase`, and `multiline` are accessor properties defined on the RegExp prototype object. In previous editions they were data properties defined on RegExp instances.</p>
</emu-annex>
<emu-annex id="sec-colophon">
  <h1>Colophon</h1>
  <p>This specification is authored on <a href="https://github.com/tc39/ecma262">GitHub</a> in a plaintext source format called <a href="https://github.com/bterlson/ecmarkup">Ecmarkup</a>. Ecmarkup is an HTML and Markdown dialect that provides a framework and toolset for authoring ECMAScript specifications in plaintext and processing the specification into a full-featured HTML rendering that follows the editorial conventions for this document. Ecmarkup builds on and integrates a number of other formats and technologies including <a href="https://github.com/rbuckton/grammarkdown">Grammarkdown</a> for defining syntax and <a href="https://github.com/domenic/ecmarkdown">Ecmarkdown</a> for authoring algorithm steps. PDF renderings of this specification are produced by printing the HTML rendering to a PDF.</p>
  <p>Prior editions of this specification were authored using Word&mdash;the Ecmarkup source text that formed the basis of this edition was produced by converting the ECMAScript 2015 Word document to Ecmarkup using an automated conversion tool.</p>
</emu-annex>
<emu-annex id="sec-bibliography">
  <h1>Bibliography</h1>
  <ol>
    <li>
      IEEE Std 754-2008: <i>IEEE Standard for Floating-Point Arithmetic</i>. Institute of Electrical and Electronic Engineers, New York (2008)
    </li>
    <li>
      <i>The Unicode Standard</i>, available at &lt;<a href="https://unicode.org/versions/latest">https://unicode.org/versions/latest</a>&gt;
    </li>
    <li>
      <i>Unicode Technical Note #5: Canonical Equivalence in Applications</i>, available at &lt;<a href="https://unicode.org/notes/tn5/">https://unicode.org/notes/tn5/</a>&gt;
    </li>
    <li>
      <i>Unicode Technical Standard #10: Unicode Collation Algorithm</i>, available at &lt;<a href="https://unicode.org/reports/tr10/">https://unicode.org/reports/tr10/</a>&gt;
    </li>
    <li>
      <i>Unicode Standard Annex #15, Unicode Normalization Forms</i>, available at &lt;<a href="https://unicode.org/reports/tr15/">https://unicode.org/reports/tr15/</a>&gt;
    </li>
    <li>
      <i>Unicode Standard Annex #18: Unicode Regular Expressions</i>, available at &lt;<a href="https://unicode.org/reports/tr18/">https://unicode.org/reports/tr18/</a>&gt;
    </li>
    <li>
      <i>Unicode Standard Annex #24: Unicode `Script` Property</i>, available at &lt;<a href="https://unicode.org/reports/tr24/">https://unicode.org/reports/tr24/</a>&gt;
    </li>
    <li>
      <i>Unicode Standard Annex #31, Unicode Identifiers and Pattern Syntax</i>, available at &lt;<a href="https://unicode.org/reports/tr31/">https://unicode.org/reports/tr31/</a>&gt;
    </li>
    <li>
      <i>Unicode Standard Annex #44: Unicode Character Database</i>, available at &lt;<a href="https://unicode.org/reports/tr44/">https://unicode.org/reports/tr44/</a>&gt;
    </li>
    <li>
      <i>Unicode Technical Standard #51: Unicode Emoji</i>, available at &lt;<a href="https://unicode.org/reports/tr51/">https://unicode.org/reports/tr51/</a>&gt;
    </li>
    <li>
      <i>IANA Time Zone Database</i>, available at &lt;<a href="https://www.iana.org/time-zones">https://www.iana.org/time-zones</a>&gt;
    </li>
    <li>
      ISO 8601:2004(E) <i>Data elements and interchange formats &ndash; Information interchange</i> &mdash; <i>Representation of dates and times</i>
    </li>
    <li>
      <i>RFC 1738 &ldquo;Uniform Resource Locators (URL)&rdquo;</i>, available at &lt;<a href="https://tools.ietf.org/html/rfc1738">https://tools.ietf.org/html/rfc1738</a>&gt;
    </li>
    <li>
      <i>RFC 2396 &ldquo;Uniform Resource Identifiers (URI): Generic Syntax&rdquo;</i>, available at &lt;<a href="https://tools.ietf.org/html/rfc2396">https://tools.ietf.org/html/rfc2396</a>&gt;
    </li>
    <li>
      <i>RFC 3629 &ldquo;UTF-8, a transformation format of ISO 10646&rdquo;</i>, available at &lt;<a href="https://tools.ietf.org/html/rfc3629">https://tools.ietf.org/html/rfc3629</a>&gt;
    </li>
    <li>
      <i>RFC 7231 &ldquo;Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content&rdquo;</i>, available at &lt;<a href="https://tools.ietf.org/html/rfc7231">https://tools.ietf.org/html/rfc7231</a>&gt;
    </li>
  </ol>
</emu-annex>
